<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="《计算机网络自顶向下方法》读书笔记, 大茗茗のblog">
    <meta name="description" content="一、计算机网络和因特网
什么是因特网什么是因特网具体构成描述主机(端系统)通过通信链路和分组交换机连接到一起，遵守一定协议以分组的形式相互传递数据
服务描述各种涉及多台相互交换数据的端系统的应用程序通过因特网提供给每台端系统的应用编程接口(">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>《计算机网络自顶向下方法》读书笔记 | 大茗茗のblog</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="大茗茗のblog" type="application/atom+xml">
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">大茗茗のblog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友链</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">大茗茗のblog</div>
        <div class="logo-desc">
            
            太上有立德，其次有立功，其次有立言，虽久不废，此之谓不朽。
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友链
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/12.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">《计算机网络自顶向下方法》读书笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                                <span class="chip bg-color">计算机网络</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-category">
                                读书笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-10-20
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    63.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    220 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="一、计算机网络和因特网"><a href="#一、计算机网络和因特网" class="headerlink" title="一、计算机网络和因特网"></a>一、计算机网络和因特网</h2><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920160427981.png"></p>
<h2 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h2><h3 id="什么是因特网-1"><a href="#什么是因特网-1" class="headerlink" title="什么是因特网"></a>什么是因特网</h3><h4 id="具体构成描述"><a href="#具体构成描述" class="headerlink" title="具体构成描述"></a>具体构成描述</h4><p>主机(端系统)通过通信链路和分组交换机连接到一起，遵守一定协议以分组的形式相互传递数据</p>
<h4 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h4><p>各种涉及多台相互交换数据的端系统的应用程序通过因特网提供给每台端系统的应用编程接口(API)完成不同端系统的数据交换，以完成该应用程序的运行。即因特网是为应用程序提供服务的基础设施。</p>
<p><code>主机：</code>主机通过 <code>通信链路</code> 和 <code>分组交换机</code> 连接<br><code>分组交换机</code> 典型的有：<code>路由器</code> （router)、 <code>链路层交换机</code>(link-layer switch)</p>
<p><code>端系统：</code> 通常把与因特网相连的计算机和其他设备称为端系统。端系统是通信链路和分组交换机连接在一起的</p>
<p><code>ISP：</code>因特网服务提供商</p>
<p><code>分组：</code> 发送端系统将数据分段，并为每段加上首部字节</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p><code>TCP：</code> 传输控制协议</p>
<p><code>IP：</code> 网络协议</p>
<p>端系统，分组交换机和其他因特网部件都要运行一系列协议，这些协议控制因特网中信息的接收和发送，IP协议定义了在路由器的端系统之间发送和接受的分组格式，因特网中的协议统称为TCP/IP</p>
<p><code>协议：</code> 定义了在两个或多个通信实体之间交换的报文和顺序，以及报文发送和接收一条报文或其他事件所采取的动作</p>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><p><code>接入网：</code> 接入网是指将端系统物连接到其边缘路由器的网络</p>
<p><code>边缘路由器：</code> 端系统到任何其他远程端系统的路径上的第一台路由器。</p>
<p>1.家庭接入：DSL，电缆，FTTH，拨号和卫星</p>
<p>2.企业接入：以太网和wife</p>
<p>3.广域无限接入：3G和LTE</p>
<h3 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h3><p>物理媒体分为两类：</p>
<p><code>导引型媒体：</code> 电波沿着固体媒体（光缆，双绞铜线或同轴电缆）被导引。</p>
<p><code>非导引型媒体：</code> 电波在空气或外层空间（在无线局域网或数字卫星频道）中传播</p>
<p>1.双绞铜线<br>2.同轴电缆<br>3.光纤<br>4.陆地无线电信道<br>5.卫星无线电信道</p>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><pre class="line-numbers language-none"><code class="language-none">网络核心，即互联了因特网端系统的分组交换机和链路的网状网络<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><h4 id="储存转发运输"><a href="#储存转发运输" class="headerlink" title="储存转发运输"></a>储存转发运输</h4><p><code>存储转发机制：</code> 多数分组交换机在链路的输入端使用储存转发运输，交换机能够开始向输出链路传输该分组的第一个比特之前，必须接受到整个分组。</p>
<p><code>时延：</code> <code>d=NL/R</code> (N为链路数目，R为速率，L是链路长度)</p>
<h4 id="排队时延和分组丢失"><a href="#排队时延和分组丢失" class="headerlink" title="排队时延和分组丢失"></a>排队时延和分组丢失</h4><p>每个分组交换机有多条链路相连，对于每条相连的链路，交换机具有输出缓存。除了存储转发时延，分组还要承受输出缓存的排队时延。当一个到达的分组发现该缓存已经被其他分组充满时，就会出现分组丢包。</p>
<h4 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h4><p>在因特网中，每台端系统具有一个IP地址，每台路由器具有一个转发表(用于将目的地址(或者其一部分)映射为输出链路)。因特网中具有一些特殊的路由选择协议，用于自动设置转发表。</p>
<h3 id="电路交换（创建专用的端到端连接）"><a href="#电路交换（创建专用的端到端连接）" class="headerlink" title="电路交换（创建专用的端到端连接）"></a>电路交换（创建专用的端到端连接）</h3><p>在电路交换网络中，端系统通信会话期间，预留了端系统通信沿电路所需要的资源(缓存，链路传输速率)。在分组交换网络中，这些资源是不被预留的，会话报文按需使用这些资源，可能不得不等待(排队)接入通信线路。传统的电话网络是电路交换。</p>
<p>经过建立连接(占用通信资源)=&gt;通话(一直占用通信资源)=&gt;释放连接(归还通信资源)三个步骤的交换方式成为电路交换。</p>
<p>电路交换的一个重要特点就是在通话的全部时间内，通话的两个用户始终占用端到端的通信资源</p>
<h4 id="电路交换在网络中的复用"><a href="#电路交换在网络中的复用" class="headerlink" title="电路交换在网络中的复用"></a>电路交换在网络中的复用</h4><pre class="line-numbers language-none"><code class="language-none">频分复用` 或 `时分复用<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="分组交换和电路交换的对比"><a href="#分组交换和电路交换的对比" class="headerlink" title="分组交换和电路交换的对比"></a>分组交换和电路交换的对比</h4><p>1.分组交换不适合实时服务，因为端到端时延是不可预测的。</p>
<p>2.分组交换提供了比电路交换更好的带宽共享</p>
<p>3.分组交换比电路交换更简单，更有效，实现成本更低</p>
<h3 id="网络中的网络"><a href="#网络中的网络" class="headerlink" title="网络中的网络"></a>网络中的网络</h3><h4 id="因特网是网络的网络。"><a href="#因特网是网络的网络。" class="headerlink" title="因特网是网络的网络。"></a>因特网是网络的网络。</h4><p>在公共因特网中，坐落在因特网边缘的接入网络通过分层的ISP层次结构和因特网其他部分相连。</p>
<p>因特网由十多个第一层ISP和数十万个较低层ISP组成，不同ISP覆盖不同的区域。较低层的ISP和叫高层的ISP相连，较高层ISP彼此互联。位于相同的等级结构的临近一对ISP能够对等，即直接传输数据不收取费用。同时第三方公司也会提供因特网交换点(IXP)，作为各种ISP的汇集点。用户和内容提供商是较低层ISP的客户，较低层ISP是较高层ISP的客户。近年来，主要的内容提供商已经开始创建自己的网络，直接在可能的地方与较低层ISP互联</p>
<h4 id="第一层ISP"><a href="#第一层ISP" class="headerlink" title="第一层ISP"></a>第一层ISP</h4><p>第一层ISP和其他ISP相同点：</p>
<p>有链路和路由器</p>
<p>不同之处：</p>
<ol>
<li>链路速度通常为622Mbps或更高。大型第一层ISP，其链路速率的范围为2.5~10Gbps。</li>
<li>直接和其他每个第一层ISP相连，和大量第二层ISP和其他客户网络相连。</li>
<li>覆盖国际范围。</li>
</ol>
<h4 id="第二层ISP"><a href="#第二层ISP" class="headerlink" title="第二层ISP"></a>第二层ISP</h4><p>第二层ISP：具有区域性或国家性覆盖范围；第一层ISP的客户。</p>
<p>许多大公司和机构将他们的企业网直接与第一层或第二层ISP相连，因而成为该ISP的客户。第一层ISP相对于该客户而言是提供商。一个提供商ISP向他的客户收费，费用通常根据连接两者的带宽而定。</p>
<p>一个第二层网络也可以选择与其他第二层网络直接相连。</p>
<h4 id="较低层ISP"><a href="#较低层ISP" class="headerlink" title="较低层ISP"></a>较低层ISP</h4><p>在第二层ISP之下是较低层的ISP，这些较低层ISP经过一个或多个第二层ISP和更的因特网相连。</p>
<p>当两个ISP彼此直接相连时，它们被称为彼此是对等的。</p>
<p>在一个ISP的网络中，某ISP和其他ISP的连接点被称为 <code>汇集点</code></p>
<p>（Point of Presence,POP）。POP就是某ISP网络中的一台或多台路由器组，通过它们能够和其他ISP的路由器连接。</p>
<pre class="line-numbers language-none"><code class="language-none">一个第一层提供商通常有许多POP，这些POP分桑在其网络中不同的地理位置。每个POP与多个客户网络和其他ISP相连。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>因特网的拓扑很复杂，他由几十个第一层ISP和第二层ISP和数以千计的较低层ISP组成。</p>
<h2 id="分组交换网中的时延，丢包和吞吐量"><a href="#分组交换网中的时延，丢包和吞吐量" class="headerlink" title="分组交换网中的时延，丢包和吞吐量"></a>分组交换网中的时延，丢包和吞吐量</h2><h3 id="分组交换网中的时延概述"><a href="#分组交换网中的时延概述" class="headerlink" title="分组交换网中的时延概述"></a>分组交换网中的时延概述</h3><p>时延是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间</p>
<p>时延分为节点处理时延（nodal processing delay），排队时延（queuing delay），传输时延（transmission delay）和传播时延（propagation delay），这些加起来就是节点总时延（total nodal delay），即<br>节点总时延 = 节点处理时延 + 排队时延 + 传输时延 + 传播时延</p>
<h4 id="时延的类型"><a href="#时延的类型" class="headerlink" title="时延的类型"></a>时延的类型</h4><p>处理时延：`检查分组首部和决定将分组导向哪一个队列。检查比特级差错所需要的时间。</p>
<p><code>排队时延</code>：分组在链路上等待传输的时间</p>
<p><code>传输时延</code>：将所有分组的比特推（传输）向链路所需要的时间。<br>用L比特表示分组的长度，用R bps(b/s)表示从路由器A到路由器B的链路传输速率。传输时延是L/R</p>
<p><code>传播时延：</code>从链路的起点到下一个路由器的时间，取决于链路的物理媒体和链路长度。</p>
<p>传播时延 = 两台路由器的距离d / 传播速率s</p>
<h3 id="排队时延和丢包"><a href="#排队时延和丢包" class="headerlink" title="排队时延和丢包"></a>排队时延和丢包</h3><p>a表示分组到达队列的平均速度（a的单位是分组每秒pkt/s）<br>R是传输速率，即从队列中推出比特的速率（bps即b/s为单位）<br>所有的分组都是由L比特组成的，比特的平均速率为La bps<br>比率La/R称为 <code>流量强度</code></p>
<p>如果La/R&gt;1,则比特到达队列的平均速率超过从该队列传输出去的速率<br>La/R&lt;=1,到达流量的性质影响排队延时<br>第n个分组具有（n-1）L/R秒的排队延时</p>
<p>La/R &gt; 1，则比特到达队列的平均速率超过从该队列传输出去的速率。在这种不幸的情况下，队列的增加将趋近于无界，并且排队时延将趋向无穷大。因此，流量工程中设计系统时流量强度不能大于1。在因特网中，接近1时将容易发生丢包</p>
<h3 id="端到端的时延"><a href="#端到端的时延" class="headerlink" title="端到端的时延"></a>端到端的时延</h3><p>假定在源主机和目的主机之间有N-1台路由器，并且该网络是无拥塞的（因此排队时延是微不足道的），处理时延为dproc，每台路由器和源主机的输出速率是 R bps，每条链路的传播时延是dprop，节点时延累加起来得到端到端时延</p>
<p>dend-end = N（dproc + dtrans + dprop）<br>dtrans= 分组长度L /R</p>
<h3 id="计算机网络的吞吐量"><a href="#计算机网络的吞吐量" class="headerlink" title="计算机网络的吞吐量"></a>计算机网络的吞吐量</h3><pre class="line-numbers language-none"><code class="language-none">吞吐量分为瞬时吞吐量（instancous throughput）和平均吞吐量（average throughput）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>瞬时吞吐量:</code>主机接收文件的速率是瞬时吞吐量。</p>
<p><code>平均吞吐量：</code>接收F比特用去T秒，平均吞吐量是F/T bps</p>
<h2 id="协议层次及其服务类型"><a href="#协议层次及其服务类型" class="headerlink" title="协议层次及其服务类型"></a>协议层次及其服务类型</h2><h3 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h3><p>各层的所有协议被称为协议栈（protocol stack）。</p>
<p><code>分层的优点：</code>改变服务的实验而不影响该系统其它部分的能力</p>
<pre class="line-numbers language-none"><code class="language-none">分层提供一种结构化方式来讨论系统组件，各层的所有协议被称为协议栈。因特网的协议栈分为5层：物理层、链路层、网络层、运输层和应用层。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="TCP-IP各层描述："><a href="#TCP-IP各层描述：" class="headerlink" title="TCP/IP各层描述："></a>TCP/IP各层描述：</h3><p>应用层：端到端，应用层的通信处于两个进程（该层正在运行的两个程序）之间，进程到进程的通信就是应用层的任务</p>
<p>HTTP:超级文本传输协议是访问万维网的载体</p>
<p>SMTP:简单邮件传输协议是电子邮件服务的主要协议</p>
<p>FTP:文件传输协议用于将文件从一台主机传输到另一台主机</p>
<p>TELNET:远程登陆 和SSH:安全外壳 用于访问远端的站点</p>
<p>SNMP:简单网络管理协议，用于对Internet全局或局部进行管理</p>
<p>DNS:域名系统：使其他的协议能够查询另一台计算机的网络层地址</p>
<p>IGMP:英特网组管理协议，用于管理一个组的成员资格</p>
<h3 id="分层的体系结构"><a href="#分层的体系结构" class="headerlink" title="分层的体系结构"></a>分层的体系结构</h3><p><code>应用层：</code> 是网络应用程序及其应用层协议存留的地方，包括HTTP，SMTP、FTP。报文</p>
<p><strong><code>运输层：</code></strong> 在应用程序端点之间传送应用层报文。TCP和UDP协议。TCP提供面向连接的服务，包括应用层报文向目的地的确保传递和流量控制；也将长报文分为短报文，提供拥塞控制。UDP提供无连接服务，没有可靠性、流量控制、拥塞控制。报文段</p>
<p><strong><code>网络层</code>：</strong><br>负责将运输层提交的报文段和目的地址传递到另一台主机。IP协议：定义了数据报中各个字段以及端系统和路由器如何作用于这些字段，也包括路由选择协议。数据报</p>
<p><strong><code>链路层</code>：</strong> 将网络层的数据报从一个结点（主机或路由器）移动到下一个结点。帧</p>
<p><strong><code>物理层：</code></strong> 将帧中的每一个比特从一个结点移动到下一个结点。</p>
<p><strong><code>osi模型：</code></strong> 物理层、链路层、网络层、运输层、会话层、表示层、应用层。</p>
<p><strong><code>表示层：</code></strong> 使通信的应用程序能够解释交换数据的含义。</p>
<p><strong><code>会话层：</code></strong> 提供了数据交换定界和同步功能。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>应用层报文和运输层首部信息一起构成了运输层报文段，附加的信息包括差错检测位信息。网络层增加了源和目的端地址等首部。每一层都对上一层的数据进行了封装。</p>
<p>因特网协议栈自顶向下传输时，各层会将上层信息包装，上层信息包装为有效载荷字段，本层信息包装为首部字段</p>
<p>在发送主机端，一个应用层报文被发送到运输层。运输层收取到报文并附上附加信息(运输层首部信息)，该首部将被接收端的运输层使用。应用层报文和运输层首部信息(差错检测信息等)一起构成了运输层报文段。运输层报文段因此封装了应用程报文。运输层则向网络层传递该报文段，网络层增加了网络层首部信息(源和目的端系统地址等)，产生了网络层数据报。该数据报接下来传递给链路层，链路层增加了自己的链路层首部信息并创建了链路层帧。所以，在一层，一个分组有两种类型字段:首部字段和有效载荷字段(通常来自上一个分组)。</p>
<h4 id="源主机的封装"><a href="#源主机的封装" class="headerlink" title="源主机的封装"></a>源主机的封装</h4><p>1.在应用层交换的数据称为消息。消息通常不包含任何头部和尾部，包含也统称为消息</p>
<p>2.传输层将传来的消息称为有效载荷，该载荷是传输层应该关注的负载。传输层在有效载荷基础上增加传输层头部，包含通信的源和目的应用程序的标识符等。其结果为一个传输层分组，该分组在TCP中称为段，在UDP中称为用户数据报</p>
<p>3.网络层把传输层分组作为数据或有效载荷，并且在该有效何在上添加自己的头部。头部包含源和目的主机的地址，以及用于头部差错检查、分片的信息等。其结果为一个称为数据报的网络层分组。</p>
<p>4.数据链路层把网络层分组作为数据或有效载荷，并且添加自己的头部。该头部包含主机或下一跳步（路由器）的链路层地址。其结果为一个称为帧的链路层分组。</p>
<h4 id="路由器的解封装与封装"><a href="#路由器的解封装与封装" class="headerlink" title="路由器的解封装与封装"></a>路由器的解封装与封装</h4><p>1.在比特集被投递到数据链路层后，从帧中解封装出数据报投递到网络层</p>
<p>2.网络层只检查数据报头部的源地址和目的地址，查阅它的转发表以寻找数据报投递的下一跳步。若数据报太大对其分片，内容不会被改变</p>
<p>3.数据链路层将数据报封装成一个帧，传递到物理层</p>
<h2 id="面对攻击的网络"><a href="#面对攻击的网络" class="headerlink" title="面对攻击的网络"></a>面对攻击的网络</h2><p>**<code>病毒：</code>**一种需要某种形式的用户交互来感染用户设备的恶意软件。<br>**<code>蠕虫：</code>**无需任何明显用户交互就能进入设备的恶意软件。</p>
<h3 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h3><p><strong><code>弱点攻击：</code></strong> 向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文</p>
<p><strong><code>带宽洪泛：</code></strong> 向目标主机发送大量的分组，分组过多使目标的接入链路变得拥塞，使得合法的分组无法到达服务器。</p>
<p><strong><code>连接洪泛:</code></strong> 攻击者在目标主机中创建大量的半开或全开TCP连接。该主机因这些连接陷入困境，并停止接受合法的连接。</p>
<h3 id="嗅探攻击："><a href="#嗅探攻击：" class="headerlink" title="嗅探攻击："></a>嗅探攻击：</h3><p>通过被动接收机接收数据，从而获取口令，商业秘密的私密信息，最好的防范方法是难以破解的密码。</p>
<h3 id="IP哄骗："><a href="#IP哄骗：" class="headerlink" title="IP哄骗："></a>IP哄骗：</h3><p>将具有虚假源地址的分组注入因特网</p>
<h3 id="中间人攻击："><a href="#中间人攻击：" class="headerlink" title="中间人攻击："></a>中间人攻击：</h3><p>处于信息传递着的中间，获取或修改数据。</p>
<h2 id="二、应用层"><a href="#二、应用层" class="headerlink" title="二、应用层"></a>二、应用层</h2><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162332837.png"></p>
<h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><h3 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h3><p><strong><code>应用体系结构</code></strong> 由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。在选择应用程序结构体系时，应用程序研发者很可能利用现代网络应用程序中所使用的两种主流体系结构之一，**<code>客户-服务器体系结构</code>** 或**<code>对等（P2P）体系结构</code>**</p>
<h4 id="客户-服务器体系结构-CS-："><a href="#客户-服务器体系结构-CS-：" class="headerlink" title="客户-服务器体系结构(CS)："></a>客户-服务器体系结构(CS)：</h4><p>1.有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。</p>
<p>2.特点的一对多，一台服务器对应多个客户机</p>
<p>3.客户之间不能直接通信，需要经过服务器</p>
<p>4.服务器是处理所有逻辑的中心，具有固定的ip地址，客户总能通过向该服务器的IP地址发送分组来与其联系</p>
<p>5.基础设施密集。虽然客户机/服务器体系结构的特征是“一对多”，但是服务器却并不总是一台，因为有的时候要处理海量的客户机的请求， 一台服务器很快就会不堪重负，所以这个时候常用服务器集群技术（server clustering）创建强大的虚拟服务器。所以此时这里“一对多”的一要理解为一组服务器组成的“一”个整体的意思</p>
<p>6.应用：WEB，FTP，电子邮件，Telnet</p>
<h4 id="P2P体系结构："><a href="#P2P体系结构：" class="headerlink" title="P2P体系结构："></a>P2P体系结构：</h4><p>1.对位于数据中心的专用服务器有最小（或者没有）依赖，应用程序在间断的主机对之间使用直接通信，对于这些主机称为对等方</p>
<p>2.特点：客户机间的直接通信使得P2P有了强大的自扩展性<br>（self-calability），比如下载文件时接收到文件的主机又可以直接把文件上载给其他的主机，因此对基础设施服务器依赖较小，并且可上载该文件的主机的数量是指数递增的，系统的服务能力只会越来越强。</p>
<p>3.应用：文件分发，因特网电话，文件搜索</p>
<p>4.任意的端系统直接通信</p>
<p>5.对等方间歇地连接，改变IP地址</p>
<p>6.P2P应用由于高度非集中式结构，面临安全性，性能和可靠性的挑战</p>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><p>应用程序体系结构（P2P, 客户-服务器）来自于应用设计者设定下更加宽泛的结构，而网络体系结构注重于通信进程的结构组织</p>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进行通信的实际是进程而不是程序，一个进程可以认为是运行在端系统中的一个程序。两个不同端系统上的进程，可以通过跨越计算机网络交换报文而相互通信。</p>
<h4 id="客户和服务器进程："><a href="#客户和服务器进程：" class="headerlink" title="客户和服务器进程："></a>客户和服务器进程：</h4><p>1.网络应用程序由成对的进程组成，这些进程通过网络相互发送报文</p>
<p>2.两个进程一个标识为客户，一个标识为服务器</p>
<p>3.在一对进程之间的通信绘画会话场景中，发起通信的进程被标识为客户，回话开始时等待联系的进程时服务器</p>
<h4 id="进程与计算机网络中的接口："><a href="#进程与计算机网络中的接口：" class="headerlink" title="进程与计算机网络中的接口："></a>进程与计算机网络中的接口：</h4><p>1.进程通过套接字的软件接口向网络发送和接收报文</p>
<p>2.套接字时同一台主机内应用层和运输层之间的接口，套接字是建立网络程序的可编程接口，因此套接字称为应用程序和网络之间的应用程序编程接口（api）</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162437807.png"></p>
<h4 id="进程寻址："><a href="#进程寻址：" class="headerlink" title="进程寻址："></a>进程寻址：</h4><p>一台主机的进程向另一台主机的进程发送分组，接收进程需要一个地址。为了标识该进程，需要定义两种信息：</p>
<p>**<code>主机的地址：</code>**用IP地址标识；</p>
<p>**<code>定义在目标主机中的接收进程的标识符：</code>**用目的地端口号标识。</p>
<h3 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h3><p>1.可靠数据传输。容忍丢失的应用。</p>
<p>2.吞吐量:带宽敏感应用。弹性应用。</p>
<p>3.定时</p>
<p>4.安全性</p>
<h3 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h3><p>因特网为应用程序提供了两个运输服务类型UDP和TCP</p>
<h4 id="TCP服务："><a href="#TCP服务：" class="headerlink" title="TCP服务："></a>TCP服务：</h4><p><strong><code>面向连接服务：</code></strong> 在应用层数据报文流动之前，TCP让客户和服务器互相交换运输层控制信息，握手阶段后，TCP连接就在两个进程的套接字之间建立了</p>
<p><strong><code>可靠的信息传送服务：</code></strong> 通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据</p>
<p><strong><code>拥塞控制机制：</code></strong> 发送方和接收方之间的网络出现拥塞时，TCP 的拥塞控制机制会抑制发送进程。 TCP 拥塞控制机制也试图限制每个 TCP 连接，使他们达到公平共享网络带宽的目的。 这种服务不一定为通信进程带来直接好处，但是能为因特网带来整体好处。</p>
<p><strong><code>安全套接字层（SSL）：</code></strong> 用SSL加强后的TCP不仅能够做TCP所做的一切，而且提供了关键的进程到进程的安全性服务。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162459350.png"></p>
<h4 id="UDP服务："><a href="#UDP服务：" class="headerlink" title="UDP服务："></a>UDP服务：</h4><p>1.UDP 是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。</p>
<p>2.UDP 是无连接的，因此在两个进程通信之前无握手。</p>
<p>3.UDP 协议提供一种不可靠数据传送服务，也就是说，当进程将一个报文发送<br>进</p>
<p>4.UDP 套接字时，UDP并不保证该报文到达接收进程。不仅如此，到达接收进程的报文也可能是乱序到达的。</p>
<p>5.UDP 没有包括拥塞控制机制，所以 UDP 的发送端可以用它选定的任何速率向其下层（网络层）注入数据</p>
<p>6.不抑制发送速率，实时应用通常选择UDP</p>
<h4 id="因特网运输协议不提供的服务："><a href="#因特网运输协议不提供的服务：" class="headerlink" title="因特网运输协议不提供的服务："></a>因特网运输协议不提供的服务：</h4><p>1.TCP 能提供可靠的数据传输服务，也能通过 SSL 来加强以提供安全服务。</p>
<p>2.今天的因特网通常能够为时间敏感应用提供满意的服务，但不能提供任何定时或带宽保证。</p>
<h4 id="TCP和UDP的应用："><a href="#TCP和UDP的应用：" class="headerlink" title="TCP和UDP的应用："></a>TCP和UDP的应用：</h4><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162519669.png"></p>
<h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>1.应用层协议定义了运行在不同端系统上的进程如何相互传递报文。</p>
<p>2.交换报文的类型，例如请求报文和响应报文。</p>
<p>3.各种报文类型的语法，如报文中各个字段及这些字段是如何描述的。</p>
<p>4.字段的语义，即这些字段中包含的信息的含义。</p>
<p>5.一个进程何时以及如何发送报文，对报文进行响应的规划。</p>
<h2 id="WEB和HTTP"><a href="#WEB和HTTP" class="headerlink" title="WEB和HTTP"></a>WEB和HTTP</h2><h3 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h3><p>1.web的应用层协议是超文本传输协议，它是web的核心</p>
<p>2.http由两个程序实现：客户程序和服务器程序</p>
<p>3.web页面是由对象组成的，一个对象只有一个文件，多数web页面含有一个<br>html基本文件以及几个引用对象</p>
<p>4.html基本文件通过对象的URL的地址引用页面中的其他对象，URL由两部分组成：存放对象的主机名和路径名</p>
<p>5.web浏览器实现了http的客户端，web服务器实现了http的服务器端。</p>
<p>6.http定义了web客户向web服务器请求web页面的方式，以及服务器向客户传送web页面的方式</p>
<p>7.服务器向客户发送被请求的文件，而不储存任何关于客户的状态信息，所以<br><strong><code>http是无状态协议</code></strong></p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162541334.png"></p>
<h3 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h3><h4 id="非持续连接的HTTP："><a href="#非持续连接的HTTP：" class="headerlink" title="非持续连接的HTTP："></a>非持续连接的HTTP：</h4><p><strong><code>每个请求/响应是经过一个单独的TCP连接发送。</code></strong></p>
<p>每个TCP连接只传输一个请求报文和一个响应报文。因此一次请求Web页面往往要产生多个TCP连接。</p>
<p>缺点：<br>必须为每个请求的对象建立和维护一个全新的连接；每个对象要经受两倍RTT的交付时延，一个RTT用于创建TCP，一个传输。总响应时间是两个RTT加上服务器传输HTML文件的时间。<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162615427.png"></p>
<h4 id="持续连接的HTTP："><a href="#持续连接的HTTP：" class="headerlink" title="持续连接的HTTP："></a>持续连接的HTTP：</h4><p><strong><code>所有的请求以及响应经相同的TCP连接发送。</code></strong></p>
<p>1.在采用持续连接的情况下，服务器再发送响应后保持该 TCP 连接打开。再相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传送。</p>
<p>2.一般来说，如果一条连接经过一定的时间间隔（一个可配置的时间间隔）仍未被使用，HTTP 服务器就关闭该连接。</p>
<p>3.HTTP 的默认模式是使用带流水线的持续连接。</p>
<h3 id="http报文格式"><a href="#http报文格式" class="headerlink" title="http报文格式"></a>http报文格式</h3><h4 id="http请求报文："><a href="#http请求报文：" class="headerlink" title="http请求报文："></a>http请求报文：</h4><p><em>plain</em></p>
<pre class="line-numbers language-none"><code class="language-none">GET /somedir/page.html HTTP/1.1      //请求行
Host: www.somechool.edu              //指明了对象所在的主机
Connection: close                    //要求服务器发送完请求的对象后就关闭该连接
User-agent: Mozilla/5.0              //用来指明用户代理，即向服务器发送请求的浏览器的类型
Accept-language: fr                  //指明了用户想要得到该对象的中文版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>请求行有三个字段：</code></strong></p>
<p>方法字段：包括 GET、POST、HEAD、PUT 和 DELETE。绝大部分报文使用 GET 方法。</p>
<p>URL 字段</p>
<p>HTTP 版本字段</p>
<p><strong><code>通用格式:</code></strong></p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162647992.png"></p>
<h4 id="http响应报文："><a href="#http响应报文：" class="headerlink" title="http响应报文："></a>http响应报文：</h4><pre class="line-numbers language-none"><code class="language-none">HTTP/1.1 200 OK                                  //状态行（3个字段：版本协议字段、状态码和相应状态信息）
Connection: close                                //发送完报文后关闭TCP连接 
Date: Tue, 18 Aug 2015 15:44:04 GMT              //服务器产生并发送该响应报文的日期和时间
Server: Apache/2.2.3 (CentOS)                    //改报文是Apache web服务器产生的
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT     //代理服务器
Content-Length: 6821                             //指示了被发送对象的字节数
Content-Type: text/html                          //指示了实体体中的对象是html文本
(data data data data data ......)                //实体体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>常见的状态码和相关短语：</code></strong></p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162706772.png"></p>
<p><strong><code>通用格式：</code></strong></p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162716590.png"></p>
<h3 id="用户和服务器的交互-cookie"><a href="#用户和服务器的交互-cookie" class="headerlink" title="用户和服务器的交互(cookie)"></a>用户和服务器的交互(cookie)</h3><p>http服务器是无状态的，Web 站点通常希望能够识别用户，为此，HTTP 使用了 cookie ，它允许站点对用户进行跟踪</p>
<p><strong><code>cookie 有 4 个技术组件：</code></strong></p>
<p>1.在 HTTP 响应报文中的一个 cookie 首部行；</p>
<p>2.在 HTTP 请求报文中的一个 cookie 首部行；</p>
<p>3.在用户端系统中保留有一个 cookie 文件，并由用户的浏览器进行管理；</p>
<p>4.位于 Web 站点的一个后端数据库。</p>
<p>在web站点后台有数据库。其工作原理是，用户第一次访问某服务器时，其响应报文中包含一个Set-cookie字段，该字段的值往往是服务器设定的唯一标识码，浏览器将该字段和服务器主机名等信息保存在本地，以后用户每次访问时，浏览器都会从cookies中找到该站点的标识码放在请求报文中发送，这样服务器就能通过这个唯一标识辨认这个用户，通过用户在网站上的浏览记录采取行为。</p>
<p><strong><code>cookie的工作过程：</code></strong></p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162738219.png"></p>
<h3 id="web缓存"><a href="#web缓存" class="headerlink" title="web缓存"></a>web缓存</h3><p>1.Web缓存器也叫 代理服务器，是能够代表 Web 服务器来满足 HTTP 请求的网络实体。</p>
<p>2.Web服务器有自己的磁盘存储空间，并在存储空间中保存着最近存储过的对象的副本。</p>
<p>3.可以配置用户的浏览器，使得用户所有的 HTTP 请求首先指向 Web 缓存器。</p>
<p>4.客户与 Web 缓存器之间的速度通常比较快，所以可以提高访问的速度，降低时延。</p>
<p>5.客户通过 Web 缓存器请求对象</p>
<p>6.当浏览器申请一个文件时，先建立一个到web缓存的TCP连接，如果缓存服务器上有这个文件就返回，否则，他就建立一个到原始服务器的TCP获得该文件并存储，之后将该文件发回客户端。web缓存可以大幅减少对客户端的响应时间，减少机构内部网络和internet之间的链路通信量并节约带宽。这样会带来的新的问题是，web缓存上的文件可能是陈旧的。为此HTTP引入了条件get，即web缓存在保存一个文件时会记录其最后修改时间，客户端每次请求文件时，web缓存会向原始服务器发送一个带有if-modified-since的报文，如果该文件没有改动就直接把缓存中的文件返回给用户，否则重新下载该文件。</p>
<h3 id="条件get的方法"><a href="#条件get的方法" class="headerlink" title="条件get的方法"></a>条件get的方法</h3><p>条件get方法用来解决 Web 缓存器中的对象拷贝可能是旧的的问题</p>
<p><strong><code>条件</code></strong></p>
<p>①请求报文使用 GET 方法。</p>
<p>②请求报文中包含一个 If-Modified-Since: 首部行</p>
<h2 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h2><p>因特网电子邮箱系统有三个重要的组成部分：</p>
<p><strong><code>①用户代理②邮件服务器③简单邮件传输协议（SMTP）</code></strong></p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162830790.png"></p>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>1.SMTP是因特网电子邮件应用的核心，用于从发送方的邮件服务器发送报文到接收方的邮件服务器</p>
<p>2.SMTP 是因特网中电子邮件中主要的应用层协议。它使用 TCP 可靠数据传输</p>
<p>3.SMTP 限制所有的邮件报文只能采用简单的 7 比特 ASCII 表示。</p>
<p>邮件发送过程是：从发送方的用户代理开始，传输到发送方的邮件服务器，再传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱上</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162844658.png"></p>
<ul>
<li>如果 Bob 的邮件服务器没有开机，该报文会保留在 Alice 的邮件服务器上并尝试进行新的尝试。这意味着邮件并不会在中间的某个邮件服务器存留。</li>
<li>SMTP 一般不使用中间服务器发送邮件，即使这两个邮件服务器位于地球的两端也一样。</li>
<li>SMTP 用的是 持续链接：如果发送邮件服务器有几个报文发往同一个接收邮件服务器，它可以通过同一个 TCP 连接发送所有的的报文。</li>
</ul>
<h3 id="与HTTP对比"><a href="#与HTTP对比" class="headerlink" title="与HTTP对比"></a>与HTTP对比</h3><p><strong><code>不同：</code></strong></p>
<ul>
<li>HTTP主要是一个拉协议，TCP连接由想要接收文件的机器发起。即在方便的时候，某些人在Web服务器上装载信息，用户使用HTTP从该服务器上拉取这些信息。</li>
<li>SMTP基本上是一个推协议，TCP连接由想要发送该文件的机器发起。即发送邮件服务器到接收邮件服务器</li>
<li>SMTP要求每个报文使用7比特ASCLL码形式。HTTP不受限制</li>
<li>处理一个既包含文本又包含图形的文档，HTTP把每个对象封装到自己的HTTP响应报文中，SMTP则把所有的报文对象放在一个报文之中。</li>
</ul>
<p><strong><code>相同：</code></strong></p>
<ul>
<li>都用于从一台主机向另一台主机传送文件。</li>
<li>都使用持续连接。</li>
</ul>
<h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><p>每个首部必须含有一个From：首部行和一个To：首部行；也许有Subject：首部行以及其他可选的首部行</p>
<h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><p>邮件访问使用**<code>客户-服务器体系结构</code>** ，用户通过用户端系统上运行的客户程序阅读电子邮件</p>
<p><strong><code>流行的邮件访问协议：</code></strong></p>
<p>①第三版邮局协议（POP3）</p>
<p>②因特网邮件访问协议(IMAP)</p>
<p>③HTTP(基于web的电子邮件)</p>
<h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><p>比较简单的邮件范文协议。</p>
<p>按三个阶段工作：</p>
<p>①特许阶段：特许、事物处理以及更新。第一阶段通过用户名和口令鉴别用户；</p>
<p>②事务处理阶段：第二阶段用户取回报文等操作；</p>
<p>③更新阶段：第三阶段退出，邮件服务器会删除那些被标记为删除的报文。</p>
<h4 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h4><p>POP3协议只在本地维持邮件的文件夹，不提供任何创建远程文件夹并为报文指派文件夹的方法。而IMAP服务器把每个报文与一个文件夹联系起来，为用户提供创建文件夹以及将邮件从一个文件夹移动到另一个文件夹的命令，允许用户<br>代理获取报文组件的命令。</p>
<h4 id="基于web的电子邮件"><a href="#基于web的电子邮件" class="headerlink" title="基于web的电子邮件"></a>基于web的电子邮件</h4><p>使用浏览器收发邮件时，从用户到邮件服务器之间用HTTP传输。</p>
<h2 id="DNS因特网的目录服务"><a href="#DNS因特网的目录服务" class="headerlink" title="DNS因特网的目录服务"></a>DNS因特网的目录服务</h2><p>主机的一种标识方式是用主机名，也可以用ip地址标识</p>
<p>①主机名：thriumph.top</p>
<p>②ip地址：xxx.xxx.xxx.xxx</p>
<h3 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h3><p>1.人们便于记忆主机名的方式，而路由器喜欢定长的具有层次结构的IP地址，所以需要一种能进行主机名到IP地址转换的服务，也就是域名系统(Domain Name System，DNS)</p>
<p>2.DNS 协议基于 UDP ，使用 53 端口</p>
<p>3.DNS也是应用层协议，它通常会被其他应用层协议所使用，包括HTTP、SMTP和FTP，将用户的主机名解析为 IP 地址</p>
<p><strong><code>DNS域名系统是</code></strong></p>
<p>①一个由分层的 DNS 服务器 实现的分布式数据库</p>
<p>②一个使得主机能够查询分布式数据库的应用层协议</p>
<p><strong><code>DNS的其他服务：</code></strong></p>
<p>①识别主机别名（用于HTTP、FTP）：有着复杂主机名的主机能拥有一个或者多个别名</p>
<p>②识别邮件服务器别名（用于SMTP）：便于记忆的电子邮件别名。</p>
<p>③负载分配：DNS可以用于冗余服务器之间进行负载分配。单个站点会有多台服务器，DNS数据中心会存储这些IP地址集合，因此多个服务器可以有相同的别名</p>
<h3 id="DNS工作机理的概述"><a href="#DNS工作机理的概述" class="headerlink" title="DNS工作机理的概述"></a>DNS工作机理的概述</h3><p>当主机上的DNS客户端收到一个转换请求时，客户端将向网络发送一个DNS查询报文，然后客户端将收到一个包含相关信息的DNS回答报文，这个报文里有客户端想要的内容，之后DNS客户端将IP地址返回给请求的提出者</p>
<h4 id="分布式，层次数据库："><a href="#分布式，层次数据库：" class="headerlink" title="分布式，层次数据库："></a>分布式，层次数据库：</h4><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162928465.png"></p>
<p>为了处理扩展性问题，DNS服务器采用层次式组织，并且分布在全世界范围内；大致来说，存在三种DNS服务器</p>
<p><strong><code>DNS服务器：</code></strong></p>
<p>①根 DNS 服务器：因特网上有13个根DNS服务器，大部分分布在北美洲，尽管我们可以将这13个根DNS服务器视为单个的服务器，但是每台服务器实际上是一个冗余的计算机网络以提供安全性和可靠性</p>
<p>②顶级域（DNS）服务器：负责顶级域名，如com，org，net，edu，gov以及各个国家的顶级域名的转换</p>
<p>③权威DNS服务器：因特网上，具有公共可访问主机的每个组织机构必须公共可访问的DNS记录，这些记录将主机名映射为IP地址。一个组织的权威DNS服务器收藏了这些DNS记录，多数大学和大公司实现和维护它们自己的基本和辅助（备份）权威DNS服务器；当然，也可以通过付费的方式，将相关的信息插入到其它权威服务器中</p>
<p>还有一种不在DNS层次结构之中，是本地DNS服务器。本地DNS服务器通常邻近其所在网络的其他主机。当主机发出DNS请求时，该请求被发往本地DNS服务器，它起着代理的作用，并将请求转发到DNS服务器层次结构中。DNS服务器的层次结构，每个ISP都有一台本地DNS服务器。</p>
<h4 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h4><p>①递归查询</p>
<p>②迭代查询</p>
<p>从请求主机到本地DNS服务器的查询是递归的，其他查询是迭代的，如果请求的接收者不知道所请求的内容，那么接收者将扮演请求者，发出有关请求，直到获得所需要的内容，然后将内容返回给最初的请求者。也就是说，在递归查询中，一定要给请求者想要的答案；迭代查询则是指，如果接收者没有请求者所需要的准确内容，接收者将告诉请求者，如何去获得，但是自己并不去发出请求</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920162943326.png"></p>
<h4 id="DNS缓存："><a href="#DNS缓存：" class="headerlink" title="DNS缓存："></a>DNS缓存：</h4><p>为了改善时延性能并减少在因特网上传输的DNS报文数量，DNS使用缓存技术。通常在本地服务器实现，可以缓存主机名/IP地址对，可以缓存TLD服务器地址，从而绕过根DNS服务器</p>
<h3 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h3><p>资源记录是一个4元组：（Name，Value，Type，TTL）</p>
<p>TTL为该记录的生存时间，决定了资源记录应当从缓存中删除的时间。</p>
<p>①Type=A，则Name是主机名，Value是该主机名对应的IP地址。</p>
<p>②Type=NS，则Name是域，Value是如何获取该域中主机IP地址的权威DNS服务<br>器的主机名。</p>
<p>③Type=CNAME，则Value是别名为Name的主机对应的规范主机名。</p>
<p>④Type=MX，则Value是别名为Name的邮件服务器对应的规范主机名。从而使得同一公司的邮件服务器和web服务器可以使用相同别名。</p>
<p>所以如果一条记录为type=A，则它直接包含了需要的信息；如果是NS，需要进一步得到权威DNS服务器的IP地址（不一定需要再次请求哦~），然后向其发出，请求希望得到一条A记录；而type=CNAME和MX的记录则实现了主机别名到主机规范名的转换，可以通过该规范名继续构建查询链条，直到获得希望的IP地址</p>
<h4 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h4><p>DNS报文有两种，即查询报文和回答报文，并且两种报文有着相同的结构：</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163014665.png"></p>
<p>①前12字节为首部区域。标识符是一个用来标记该查询的16比特数。该标志符会被复制到相应的回答报文里，以便匹配请求和回答；</p>
<p>②标志字段有若干标志，用来指出报文的类型（请求还是响应）、查询类型（递归还是迭代）、是否是所请求名字的权威DNS服务器、以及4个有关数量的字段，用来指示4类数据区域出现的数量。</p>
<p>③问题区域包含了正在进行的查询信息，包括名字字段、查询类型。</p>
<p>④回答区域包含了对最初请求的名字的资源记录，回答报文回答区域可以包含多条RR，因此一个主机名能有多个IP地址。</p>
<p>⑤权威区域包含了其他权威服务器的信息。</p>
<p>⑥附加区域包含了其它有帮助的记录，比如在对于一个MX类型的请求回答报文里，回答区域里指出了邮件服务器的规范主机名，而附加区域里就有可能包含一个类型为A的关于该规范主机名的的IP地址。</p>
<h4 id="向DNS数据库中插入记录"><a href="#向DNS数据库中插入记录" class="headerlink" title="向DNS数据库中插入记录"></a>向DNS数据库中插入记录</h4><p>需要在注册登记机构完成这一任务，当你注册一个域名时，需要向该机构提供你的基本和辅助DNS服务器的名字和IP地址，该注册机构将确保一个类型为NS和类型为A的记录输入对应的顶级域名服务器，这样就完成了插入数据。</p>
<h2 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h2><p>有两种典型因特网应用十分适合P2P体系结构，一种是文件分发，另一种是大型对等方社区中的数据库；P2P体系结构有着良好的自扩展性；</p>
<p>BitTorrent 是一种用于文件分发的流行P2P协议；用BitTorrent的术语来说，参与一个特定文件分发的所有对等方的集合被称为一个洪流；在一个洪流中的对等方彼此下载等长度的文件块；当一个对等方下载文件块的时候，也向其他对等方发送了多个块；一旦某对等方获得了完整文件，就可以自私地离开洪流或者大公无私地留下来继续向其他对等方发送文件</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163032533.png"></p>
<p>P2P的最小分发时间</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163041945.png"></p>
<h2 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h2><h3 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h3><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163100417.png"><strong><code>UDPClient.py</code></strong></p>
<pre class="line-numbers language-none"><code class="language-none">from socket import *
serverName = "127.0.0.1"
serverPort = 10021
clientSocket = socket(AF_INET,SOCK_DGRAM)
while True:
	message = raw_input('Input lowercase sentence:')
	if message=='quit':
		break
	clientSocket.sendto(message,(serverName,serverPort))
	modifiedMessage,serverAddress = clientSocket.recvfrom(2048)
	print modifiedMessage
clientSocket.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>UDPServer.py</code></strong></p>
<pre class="line-numbers language-none"><code class="language-none">from socket import *
serverName = "127.0.0.1"
serverPort = 10021
serverSocket = socket(AF_INET,SOCK_DGRAM)
serverSocket.bind((serverName,serverPort))
print ("The server is ready to receive")
while True:
	message,clientAddress = serverSocket.recvfrom(2048)
	modifiedMessage = message.upper()
	serverSocket.sendto(modifiedMessage,clientAddress)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h3><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163128785.png"></p>
<p><strong><code>TCPClient.py</code></strong></p>
<pre class="line-numbers language-none"><code class="language-none">from socket import *
serverName = "127.0.0.1"
serverPort = 10021
clientSocket = socket(AF_INET,SOCK_STREAM)
clientSocket.connect((serverName,serverPort))
while True:
	message = raw_input('Input lowercase sentence:')
	if message=='quit':
		break
	clientSocket.send(message)
	modifiedMessage,serverAddress = clientSocket.recvfrom(2048)
	print modifiedMessage
clientSocket.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>TCPServer.py</code></strong></p>
<pre class="line-numbers language-none"><code class="language-none">from socket import *
serverName = "127.0.0.1"
serverPort = 10021
serverSocket = socket(AF_INET,SOCK_STREAM)
serverSocket.bind((serverName,serverPort))
serverSocket.listen(1)
print ("The server is ready to receive")
while True:
	connectionSocket,addr = serverSocket.accept()
	message = connectionSocket.recv(2048)
	modifiedMessage = message.upper()
	connectionSocket.send(modifiedMessage)
	connectionSocket.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="三、运输层"><a href="#三、运输层" class="headerlink" title="三、运输层"></a>三、运输层</h2><h2 id="概述和运输层服务"><a href="#概述和运输层服务" class="headerlink" title="概述和运输层服务"></a>概述和运输层服务</h2><p>传输层位于应用层和网络层之间，是分层的网络体系结构中重要的部分，该层为运行在不同主机上的应用进程提供直接的通信服务起着至关重要的作用</p>
<p>1.网络层提供了主机之间的逻辑通信，运输层为在不同主机上的进程之间提供了逻辑通信。</p>
<p>2.运输层协议只在主机起作用，运输层能够提供的服务受制于网络层协议的服务模型</p>
<p>3.网络应用可以使用多种传输层协议，因特网有两种传输层协议，即TCP和UDP，不同的传输层协议提供不同的运输层服务</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163421589.png"></p>
<h3 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h3><p>1.网络层提供了**<code>主机</code>** 之间的逻辑通信。而运输层为运行在**<code>不同主机上的进程</code>** 提供逻辑通信。</p>
<p>2.运输层协议只工作在端系统上</p>
<p>3.运输协议能提供的服务受制于底层网络协议的服务模型，如果网络层协议无法为主机之间的通信提供时延和带宽保证的话，运输层协议也就无法为进程之间发送的应用程序报文提供时延或者带宽保证</p>
<p>4.网络层协议，即 IP 协议，其服务模型是 尽力而为交付服务 ，但不做任何的保证。是 不可靠服务</p>
<p><strong><code>解释运输层和网络层关系：</code></strong></p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163435663.png"></p>
<ul>
<li><strong><code>运输层服务受制于网络层服务:</code></strong> （邮政大哥若三天来一次，Ann和Bill就不可能两天收发一次信）</li>
<li><strong><code>多种运输层协议，多种服务模型:</code></strong> （Ann 和 Bill 外出，Susan 和 Harvey来收信发信，结果年龄太小，收发邮件次数少，也老丢信）</li>
<li>**<code>运输层协议能为应用程序提供可靠数据传输服务:</code>**（若邮政大哥把信弄脏弄丢弄混，Ann 和 Bill 可以清理整理信件，或者让对方下次重新发一次）</li>
<li>**<code>运输层协议能确保应用程序报文不受入侵读取:</code>**（尽管邮政大哥可能被别人骗或者强行看了信件，Ann 和 Bill 也能规定加密方式对信的内容进行加解密，弟弟妹妹们只需要看信的内容）</li>
<li><strong><code>多路分解:</code></strong> Bill 和 Ann从邮递大哥拿到信件，看收信人名字（端口号），然后分别交到他们手上</li>
<li><strong><code>多路复用:</code></strong> Bill 和 Ann从弟弟妹妹手里拿到信件，帮他们装填信封写上信息</li>
</ul>
<h3 id="因特网运输层概述"><a href="#因特网运输层概述" class="headerlink" title="因特网运输层概述"></a>因特网运输层概述</h3><p>1.UDP（用户数据报协议） 提供了一种不可靠、无连接的服务。</p>
<p>2.TCP（传输控制协议） 提供了一种可靠的、面向连接的服务。</p>
<p>3.进程到进程的数据交付和差错检测是两种最低限度的运输层服务，也是 UDP 能提供的仅有的两种服务</p>
<p>4.运输层分组也被称为报文段</p>
<p>5.UDP和TCP最基本的责任就是将IP提供的主机间交付服务扩展到不同端系统上两个个进程之间的服务。这也被称为传输层的多路分解和多路复用</p>
<h2 id="多路复用和多路复解"><a href="#多路复用和多路复解" class="headerlink" title="多路复用和多路复解"></a>多路复用和多路复解</h2><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163454154.png"></p>
<p><strong><code>多路分解：</code></strong> 将运输层报文段中的数据交付到正确的套接字。</p>
<p><strong><code>多路复用：</code></strong> 在源主机从不同的套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文传递到网络层。</p>
<p><strong>运输层多路复用要求：</strong></p>
<p>①套接字有唯一标识符。</p>
<p>②每个报文段有特殊字符（端口号）来指示该报文段所要交付到的套接字。</p>
<p><strong><code>端口号：</code></strong> 一个 16 比特的数，在 0 ~ 65535 之间。其中 0 ~ 1023 是周知端口号，是受限制的。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163507636.png"></p>
<h3 id="无连接的多路复用和多路分解："><a href="#无连接的多路复用和多路分解：" class="headerlink" title="无连接的多路复用和多路分解："></a>无连接的多路复用和多路分解：</h3><p><strong><code>创建UDP套接字：</code></strong></p>
<p>①用 <code>clientSocket = socket(socket.AF_INET, socket.SOCK_DGRAM)</code>创建一个 UDP 套接字时，系统会自动为该套接字分配一个未被其他 UDP 套接字使用的端口号。</p>
<p>②用<code>clientSocket.bind(('',23333))</code> 显式的分配一个端口号。</p>
<p>通常，应用程序的客户端让运输层自动地分配端口号，而服务器则分配一个特定的端口号</p>
<p>一个 UDP 套接字由（目的IP地址，目的端口号）标识。注意是用来标识，不是只有这两个相关字段，还有源端口号、源IP地址字段。源端口号和目的端口号按传递方向反转![image-20250920163531283](《计算机网络自顶向下方法》读书笔记/image-20250920163531283.png</p>
<h3 id="面向连接的多路复用和多路分解"><a href="#面向连接的多路复用和多路分解" class="headerlink" title="面向连接的多路复用和多路分解"></a>面向连接的多路复用和多路分解</h3><p>TCP 套接字是由一个四元组（源 IP 地址，源端口号，目的 IP 地址，目的端口号）来标识的</p>
<p>TCP服务器在12000端口listen，TCP客户创建一个套接字并发送一个连接建立请求报文段，当服务器接收到该请求时，服务器会定位12000端口等待的进程并为其创建一个套接字，用[源IP，源端口，目的IP，目的端口]来标识，则可以建立与源端口的连接。服务器主机可以支持很多并行的TCP套接字，每个套接字与一个进程连接，从而提供并行的服务。当今高性能的服务器通常只有一个进程，而是为每个新客户连接创建一个具有新套接字的线程。</p>
<h2 id="无连接运输UDP"><a href="#无连接运输UDP" class="headerlink" title="无连接运输UDP"></a>无连接运输UDP</h2><p><strong><code>选择UDP的原因：</code></strong></p>
<p><strong><code>①关于何时、发送什么数据的应用层控制更为精细。</code></strong></p>
<p><strong><code>②UDP无需建立连接。</code></strong> TCP数据传输之前会经过三次握手，UDP不需要准备就能传输数据，UDP不会引入建立连接的时延</p>
<p><strong><code>③无连接状态。</code></strong> TCP需要在端系统维护连接状态</p>
<p><strong><code>④分组首部开销小。</code></strong> 只有8个字节，比TCP的20个字节的首部要短</p>
<ul>
<li>UDP支持一对一、一对多、多对一、多对多的交互通信</li>
<li>UDP没有拥塞控制，对于实时应用很有效。</li>
<li>UDP是面向报文的，对应用程序交下来的报文，在添加首部之后直接交付给IP层。应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文</li>
<li>UDP使用最大努力交付，不保证可靠交付。</li>
</ul>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163822787.png">、</p>
<h3 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h3><ul>
<li>UDP首部只有4个字段，每个字段占用两个字节，分别是：源端口号、目的端口号、长度和校验和</li>
<li>长度表示包含首部在内的UDP报文段长度，以字节为单位</li>
</ul>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920174748505.png"></p>
<h3 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a>UDP检验和</h3><p>IP数据报的检验和只检验IP数据报的首部，但是UDP的检验和是把首部和数据部分一起都检验。</p>
<p><strong><code>检验方法：</code></strong></p>
<p>①将 UDP 报文按 16 比特进行分组。</p>
<p>②将两个 16 比特的数字相加得到一个 32 位的数。</p>
<p>③将 2 中得到的 32 比特数的 高 16 位和低 16 相加。</p>
<p>④重复第 2 步直到得到的和的高 16 位为 0。</p>
<p>⑤将得到的 16 比特的数按位取反即为 检验和。</p>
<p>注：计算之前的检验和为 0</p>
<p>如果传输没有出错，则在接收方处计算的的检验和将是 11111111111111。若不是，则数据有错。<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163849402.png"></p>
<h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><blockquote>
<p>可靠数据传输协议（reliable data transfer protocol）。由于可靠数据传输协议的下层协议也许是不可靠的，因此这是一项困难的任务。<br>单向数据传输（unidirectional data transfer）即数据传输是从发送端到接收端的。</p>
</blockquote>
<p>双向数据传输（bidirectional data transfer）（即全双工数据传输）</p>
<p>可靠数据传输协议往往建立在不可靠IP网络层协议之上。</p>
<p>TCP发送的报文段是交给IP层传送的。但IP层只能提供尽最大努力服务，也就是说TCP下面的网络所提供的是不可靠的传输。因此，TCP必须采用适当的措施才能使得两个传输层之间的通信变得可靠。</p>
<p>可靠数据传输为上层实体提供的服务抽象是：数据可以通过一套可靠的信道进行传输，借助于可靠信道，传输数据就不会受到损坏或者丢失；并且所有数据都可以按照其发送顺序进行交付。而这正是TCP向调用它的应用所提供的服务模型</p>
<p>单方向的可靠数据传输流程大概是这样的：可靠数据传输-&gt;不可靠数据传输-&gt;不可靠的传输信道-&gt;可靠数据接收-&gt;上传Data<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163904083.png"></p>
<h3 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h3><h4 id="经完全可靠信道的可靠数据传输：rdt1-0"><a href="#经完全可靠信道的可靠数据传输：rdt1-0" class="headerlink" title="经完全可靠信道的可靠数据传输：rdt1.0"></a>经完全可靠信道的可靠数据传输：<strong>rdt1.0</strong></h4><p>底层信号完全可靠，然而这在实际中不能实现</p>
<p><strong><code>有限状态机（FSM）：</code></strong></p>
<p>箭头指示了协议从一个状态变迁到另一个状态</p>
<p>引起变迁的事件显示在横线的上方。</p>
<p>事件发生时所采取的动作显示在横线的下方。</p>
<p>^ 表示什么都不做。</p>
<p>FSM初始状态用虚线表示</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163917081.png"></p>
<p>发送方：</p>
<p>rdt_send(data): 接收较高层的数据。</p>
<p>make_pkt(data): 将数据打包成分组。</p>
<p>udt_send(packet): 将分组发送到信道中。</p>
<p>接收方：</p>
<p>rdt_rcv(data): 从底层信道接收一个分组。</p>
<p>extract(packet,data): 从分组中取出数据。</p>
<p>deliver_data(data): 将数据传送给较高层</p>
<h4 id="经具有比特差错信道的可靠数据传输：rdt-2-0"><a href="#经具有比特差错信道的可靠数据传输：rdt-2-0" class="headerlink" title="经具有比特差错信道的可靠数据传输：rdt 2.0"></a>经具有比特差错信道的可靠数据传输：<strong>rdt 2.0</strong></h4><p>底层信道传输的数据可能会有比特差错。但是仍然不会丢包<br>自动重传请求协议（ARQ）当发送方处于等待 ACK 或 NAK 的状态时，它不能从上层获得数据</p>
<p><strong><code>三种协议功能来处理存在比特差错的情况</code></strong></p>
<p><strong><code>差错检测</code></strong></p>
<p><strong><code>接收方反馈</code></strong></p>
<p>肯定确认（ACK）</p>
<p>否定确认（NAK）</p>
<p><strong><code>重传</code></strong></p>
<p>接收到有差错的分组时，发送方重传该分组。</p>
<h4 id="停等协议"><a href="#停等协议" class="headerlink" title="停等协议"></a>停等协议</h4><p>所谓停等协议是指发送方发送完分组A后，需要等待接收方对分组A的反馈分组，如果收到肯定分组，那么就发送下一个分组；如果收到否定分组，那么就重新发送当前分组；值得注意的是，有些协议中只有肯定分组，肯定分组包含一个分组号K，表示标号为K的分组已经收到，发送方可以发送标号为K+1的分组；如果发送方此时等待的正好是对K的确认分组，那么发送方就会发送标号为K+1的分组；如果发送方接收到对K-1的确认，表示接收方并没有收到编号为K的分组，需要重发；另外，停等协议中只需要一个定时器用来监听超时事件<br>简单来说，停等协议就是要等到上一个分组得到正确接收的确认后才能处理下一个分组。它存在一个致命的缺陷。尤其是我们没有考虑到ACK或NAK分组受损的可能性。</p>
<pre class="line-numbers language-none"><code class="language-none">考虑处理受损ACK和NAK的3种可能性


    第一种：接收方对受损的ACK或NAK继续做错误反馈，由于发出的错误反馈可能再次受损，这样就有可能进入死循环。

    第二种：增加足够的检验和比特，使发送方不仅可以检测差错，还可以恢复差错。对于会产生差错但不丢失分组的信道，这就可以直接解决问题。

    第三种：当接收方收到含糊不清的ACK或NAK分组时，只需重传当前数据分组即可。这种方法在发送方到接收方的信道中引入了冗余分组（duplicate packet）。冗余分组的根本困难在于接收方不知道他上次所发送的ACK或NAK是否被发送方正确的收到。因此他无法事先知道接收到的分组是新的还是一次重传。

    对于第三种情况，解决这个新问题的的简单方法是在数据分组中添加一新字段，让发送方对其数据分组编号，即将发送数据分组的序号（sequence number）放在该字段。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="经具有比特差错的丢包信道的可靠数据传输：-rdt3-0-（比特交替协议）"><a href="#经具有比特差错的丢包信道的可靠数据传输：-rdt3-0-（比特交替协议）" class="headerlink" title="经具有比特差错的丢包信道的可靠数据传输：**rdt3.0**（比特交替协议）"></a>经具有比特差错的丢包信道的可靠数据传输：**<code>rdt3.0</code>**（比特交替协议）</h4><ul>
<li>发送方负责检测和回复丢包工作，对每一个分组维护一个定时器。如果在一个时间段内没收到ACK，则判定为丢包，重传分组，这也引入了冗余数据分组的可能性（时延很大的情况）</li>
<li>检测丢包的方法：倒计数定时器用于实现基于时间的重传机制</li>
<li>总结可靠传输需要的技术：检验和、序号、定时器、肯定和否定确认分组</li>
</ul>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920163957571.png"></p>
<h3 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h3><p>dt 3.0 是一个功能正确的协议，但是由于它是一个停等协议，大部分的时间都浪费在等待确认上面，所以性能不好。</p>
<p>解决这种特殊性能问题的一个简单的方法是：不使用停等方式运行，允许发送方发送多个分组而无需等待确认。这种技术被称为 流水线。<br>要使用流水线技术，则须：</p>
<p>①增加序号范围。因为要传送多个分组，而每个传输中的分组必须有一个单独的序号。</p>
<p>②协议的发送方和接收方两端必须能缓存多个分组。发送方至少得能缓存那些已发送但未确认的分组，而接收方或许也需要缓存那些已经正确接收的分组。<br>所需序号的范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。</p>
<p>③流水线的差错恢复有两种基本方法：</p>
<p>回退 N 步</p>
<p>选择重传<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164015200.png"></p>
<h3 id="回退n步"><a href="#回退n步" class="headerlink" title="回退n步"></a>回退n步</h3><p>回退N步（GBN）：允许发送端发送多个分组，但在流水线中未被确认的分组数不能大于N，N被称为窗口长度，GBN协议也被称为滑动窗口协议。如果出现超时，发送方会重传所有已发送但未被确认的分组，即回退N步，从而保证接收端可以按序将数据交付给上层。</p>
<ul>
<li>基序号（base）为最早的未确认分组的序号。</li>
<li>下一个序号（nextseqnum）为下一个待发分组的的序号。</li>
<li>N 常被称为 窗口长度，GBN 协议也常被称为 滑动窗口协议。</li>
<li>GBN 的发送方必须响应三种类型的事件：</li>
</ul>
<p>①上层的调用：若窗口未满，则产生一个分组将其发送</p>
<p>②收到一个 ACK：对序号为 n 的分组的确认采取 累积确认，表明接收方已正确接收到包括 n 的序号在内的 n 的以前的所有分组</p>
<p>③超时事件：只使用一个定时器，即最早的已发送但未被确认的分组所使用的定时器。如果出现超时，则发送方重传所有已发送但还未被确认的分组。如果收到一个 ACK，但仍有已发送但未被确认的分组，则重启定时器。如果没有已发送但未确认的分组，该定时器被终止</p>
<p><strong><code>GBN正常传输：</code></strong></p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164057607.png"></p>
<p><strong><code>GBN丢失帧</code></strong></p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164108765.png"></p>
<h2 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h2><p>选择重传（SR）：GBN中单个分组的错误会引起重传大量分组。选择重传协议通过让发送端仅重传那些它怀疑在接收方出错的分组。</p>
<p><strong><code>发送方需要响应的时间有三个</code>：</strong></p>
<ul>
<li>上层调用：基本上同GBN一致；</li>
<li>收到ACK：如果该分组号在base-next sequence-1之间，将其标记为已到；如果等于base，则移动窗口到最下的待确认的分组序号处；在GBN中，接收方根本不会收到非base的ACK，但是怎么收，还的看怎么发；</li>
<li>超时事件：同GBN不一样的是，选择重传需要为每一个分组建立一个定时器，如果某个已发送但未被确认的分组超时，发送方重发该分组；</li>
</ul>
<p><strong><code>SR 接收方的事件与动作：</code></strong></p>
<ul>
<li><p>序号在 [rcv_base, rcv_base + N -1] 内的分组被正确接收：在此情况下，收到的分组落在接收方的窗口内，一个选择 ACK 被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接收窗口的基序号，则该分组及以前缓存的序号连续的分组交付给上层。</p>
</li>
<li><p>序号在 [rcv_base - N, rcv_base - 1] 内的分组被正确接收： 产生一个 ACK，即使该分组是接收方以前已确认过的分组。</p>
</li>
<li><p>其他情况：忽略该分组。</p>
</li>
</ul>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164124483.png"></p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164133582.png"></p>
<h2 id="面向连接的运输TCP"><a href="#面向连接的运输TCP" class="headerlink" title="面向连接的运输TCP"></a>面向连接的运输TCP</h2><p>TCP是因特网运输层的面向连接的可靠的运输协议</p>
<ul>
<li>TCP是面向连接的</li>
</ul>
<p>通信前需要建立连接，通信结束需要释放连接。</p>
<ul>
<li>TCP提供全双工通信</li>
</ul>
<p>TCP的两端既可以作为发送端，也可以作为接收端</p>
<ul>
<li>TCP提供可靠交付服务</li>
</ul>
<p>TCP发送的数据无重复、无丢失、无错误、与发送端顺序一致。</p>
<ul>
<li>TCP是面向字节流的</li>
</ul>
<p>TCP以字节为单位。虽然传输的过程中数据被划分成一个个数据报，但这只是为了方便传输，接收端最终接受到的数据将与发送端的数据一模一样。</p>
<ul>
<li>一条TCP连接的两端只能有两个端点</li>
</ul>
<p>TCP只能提供点到点的通信，而UDP可以任意方式的通信。</p>
<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><ul>
<li>由于 TCP 协议只在端系统中运行，而不在中间的网络元素（路由器和链路层交换机）中运行，所以中间的网络元素不会维持 TCP 连接状态，不会为该连接分配任何缓存和变量。其连接状态完全保留在两个端系统中。</li>
<li>TCP 建立连接需要 三次握手，其中，前两次握手不承载”有效荷载“，第三次握手可以承载有效荷载。</li>
<li>通过套接字发送数据、</li>
</ul>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164201535.png"></p>
<ul>
<li>TCP 将数据引导到该连接的 发送缓存 里，接下来 TCP 就会不时地从发送缓存里取出一块数据。</li>
<li>TCP 可从缓存中取出并放入报文段的数据数量受限于 最大报文段长度（MSS）。该长度是指报文段里应用层数据的最大长度，而不是包括 TCP 首部的 TCP 报文段的最大长度</li>
</ul>
<h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164215432.png"></p>
<ul>
<li>16 比特的 <strong><code>源端口号</code></strong> 和 16 比特的目的 <strong><code>端口号</code></strong> 。用于多路分解和多路复用。</li>
<li>32 比特的 <strong><code>序号（sequence number）</code></strong> 字段。 <strong><code>一个报文段的序号</code></strong> 是该报文段数据字段首字节的序号。</li>
<li>32 比特的 <strong><code>确认号（Acknowledgement number）</code></strong> 字段。主机 A　填充进报文段的确认号是**<code>主机 A 期望从主机 B 收到的下一字节的序号</code>**</li>
<li>16 比特的 <strong><code>接收窗口（Receive window）</code></strong> 字段。用于指示接收方愿意接收的字节数量。</li>
<li>4 比特的 <strong><code>首部长度（header length）</code></strong> 字段。指示了以 32 比特的字为单位的 TCP 首部长度。</li>
</ul>
<p>可变与变长的 <strong><code>选项（options）</code></strong> 字段。用于发送方与接收方协商最大报文段长度时，或在高速网络环境下作用窗口调节因子时使用。</p>
<ul>
<li>6 比特的 <strong><code>标志（flag）</code></strong> 字段。<br>ACK 是对成功接收一个报文段的确认。<br>RST、SYN 和 FIN 用于连接的建立和拆除。<br>PSH 被设置时，指示接收方应立即将数据交给上层。<br>URG 比特用来指示报文段里存在着被发送端上层实体置为“紧急”的数据。紧急的最后一个字节由 16 比特的 紧急数据指针（Urgent data pointer）字段 指出。</li>
<li>检验和，2字节；紧急指针，2字节</li>
</ul>
<p><strong><code>序号和确认号：</code></strong> TCP把数据看做有序无结构的字节流，用序号对每个传输的字节进行编号。由于TCP是全双工服务，在主机A向主机B发送报文的同时A也会接收B发送的报文，确认号则是接收方希望发送方发送的下一字节的序号。例如A已收到B发送的序号为0-535的所有字节，则A会在发给B的报文段的确认号中填入536。如果A在收到536-899之前收到900-1000，则确认号仍为536，这叫TCP的累积确认。</p>
<h3 id="往返时间的估计和超时"><a href="#往返时间的估计和超时" class="headerlink" title="往返时间的估计和超时"></a>往返时间的估计和超时</h3><h4 id="估计往返时间："><a href="#估计往返时间：" class="headerlink" title="估计往返时间："></a>估计往返时间：</h4><p>报文段的样本RTT：SampleRTT</p>
<p>SampleRTT 均值：EstimatedRTT</p>
<blockquote>
<p>EstimatedRTT=0.875∗EstimeatedRTT+0.125∗SampleRTT</p>
</blockquote>
<h4 id="设置和管理超时重传时间"><a href="#设置和管理超时重传时间" class="headerlink" title="设置和管理超时重传时间 :"></a>设置和管理超时重传时间 :</h4><blockquote>
<p>TimeoutInterval=EstimatedRTT+4∗DevRTT</p>
</blockquote>
<p>超时间隔 = 估计RTT + 4*偏差RTT</p>
<p><strong><code>设置TCP超时值：</code></strong></p>
<p>应大于RTT：但RTT是变化的</p>
<p>太短: 过早超时，不必要的重传</p>
<p>太长: 对报文段的丢失响应太慢</p>
<p>TCP采用超时/重传机制处理报文段丢失</p>
<h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><p>网络层传输的数据单元为**<code>数据报</code>** ，传输层的数据单元为**<code>报文段</code>** ，为了方便起见可以统称为**<code>分组</code>**</p>
<p><strong><code>TCP 发送方</code></strong></p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164254661.png"></p>
<p><strong><code>TCP 发送方有三个与发送和重传有关的事件：</code></strong></p>
<p>①从上层应用程序接收数据</p>
<p>②定时器</p>
<p>③收到 ACK</p>
<p><strong><code>三种情况：</code></strong></p>
<p>①A向B发送一个报文段，序号92，包含8字节，交给IP后开始等待一个来自B的确认号为100的报文段。然而确认报文段丢失，超时，A又重发相同报文段。B收到后对比序号发现已经收到过该报文段的一些字节，于是B的TCP确认后，将报文段重复的字节丢弃</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164306089.png"></p>
<p>②A连续发了两个报文段，92，8和100，20（序号和字节）。B收到两个报文段并发送确认100和200。超时前没有一个确认到达A，超时后A重传92，8的报文，重启定时器。只要第二个报文的ACK在新的超时以前发生到达，第二个报文就不会重传。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164314724.png"></p>
<p>③和上面一种一样，A发送两个报文段，第一个报文段的确认在网络丢失，但是超时之前收到了第二个报文段的确认报文。因为累积确认机制，A知道B已经收到第二个以及之前的报文，不会重传了</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164323351.png"></p>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>超时间隔加倍会增加端到端时延。而由于接收端累积确认，在未收到期望序号报文段时会不断的发送相同的ACK确认号，此为冗余ACK。当接收端收到3个冗余ACK时，TCP就执行快速重传，在定时器过期前重传丢失的报文段。</p>
<ul>
<li>TCP 接收方的 ACK 接收策略</li>
</ul>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164336305.png"></p>
<h4 id="回退N步还是选择重传"><a href="#回退N步还是选择重传" class="headerlink" title="回退N步还是选择重传"></a>回退N步还是选择重传</h4><ul>
<li>TCP确认是累积式的，正确接收但失序的报文段是不会被接收方逐个确认的，像GBN风格，但是TCP和GBN有显著区别</li>
<li>许多TCP实现会将正确接收但失序的报文段缓存起来</li>
<li>GBN不仅重传未确认分组，还会重传之后所有分组，TCP只传一个或不传（若其后面的ACK超时前到来）</li>
<li>选择确认，允许接收方有选择地确认失序报文段，而不是累积确认最后一个正确接收的有序报文段。该机制与选择重传机制结合（跳过重传已确认报文段），TCP看起来像SR</li>
<li>TCP的差错恢复机制是GBN协议和SR协议的混合体</li>
</ul>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><ul>
<li>什么是流量控制？</li>
</ul>
<p>如果发送者发送过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。<br>流量控制是一个速度匹配服务，发送方发送速率与接收方程序读取速率相匹配</p>
<ul>
<li>流量控制的目的？</li>
</ul>
<p>流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。</p>
<ul>
<li>如何实现流量控制？</li>
</ul>
<p>由滑动窗口协议（连续ARQ协议，如GBN和SR）实现，TCP让发送方维护一个称为接收窗口rwnd的变量，用于给发送方指示接收方还有多少可用缓存。因为是全双工通信，双方都维护接收窗口变量。B把rwnd值放入给A的报文段接收窗口字段中，通知A自己还有多少缓存空间，A控制未确认的数据量小于rwnd，即发送方的发送窗口不可以大于接收方发回的窗口大小。</p>
<p>滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。</p>
<ul>
<li>流量控制引发的死锁</li>
</ul>
<p>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。</p>
<ul>
<li>持续计时器</li>
</ul>
<p>为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。</p>
<ul>
<li>一条TCP连接每一侧主机都设置了缓存，当TCP连接收到正确有序的字节后，将数据放入缓存，应用从缓存中读取。若应用较忙，发送方发送太快太多，可能会造成缓存溢出</li>
<li>TCP发送方因为IP网络的拥塞而降速（超时间隔加倍），属于拥塞控制，不属于流量控制，虽然都是降速</li>
<li>UDP无流量控制，缓存溢出就溢出了</li>
</ul>
<h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164427080.png"></p>
<p>TCP协议中，主动发起请求的一端称为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP连接建立完后都能发送和接收数据。起初，服务器和客户端都为CLOSED状态。在通信开始前，双方都得创建各自的传输控制块（TCB）。 服务器创建完TCB后遍进入LISTEN状态，此时准备接收客户端发来的连接请求。</p>
<p><strong><code>第一次握手：</code></strong></p>
<p>客户端向服务端发送连接请求报文段。该报文段的头部中SYN=1，ACK=0，seq=x。请求发送后，客户端便进入SYN-SENT状态<br>。<br>PS1：SYN=1，ACK=0表示该报文段为连接请求报文。</p>
<p>PS2：x为本次TCP通信的字节流的初始序号。</p>
<p>TCP规定：SYN=1的报文段不能有数据部分，但要消耗掉一个序号。</p>
<p><strong><code>第二次握手：</code></strong></p>
<p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。</p>
<p>该应答发送完成后便进入SYN-RCVD状态。</p>
<p>PS1：SYN=1，ACK=1表示该报文段为连接同意的应答报文。</p>
<p>PS2：seq=y表示服务端作为发送者时，发送字节流的初始序号。</p>
<p>PS3：ack=x+1表示服务端希望下一个数据报发送序号从x+1开始的字节</p>
<p><strong><code>第三次握手：</code></strong></p>
<p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。</p>
<p>该报文段的头部为：ACK=1，seq=x+1，ack=y+1。</p>
<p>客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！</p>
<p><strong><code>三次握手后：</code></strong></p>
<p>发送方通过套接字向TCP的发送缓存中传输数据，当数据达到最大报文段长（MSS）时TCP就将缓存加上一个TCP首部形成报文段发送给接收方的TCP接收缓存。</p>
<blockquote>
<p>为什么连接建立需要三次握手，而不是两次握手？<br>防止失效的连接请求报文段被服务端接收，从而产生错误。<br>失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是失效的。<br>若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。</p>
</blockquote>
<h4 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h4><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164444378.png"></p>
<p><strong><code>第一次挥手：</code></strong></p>
<p>若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为：</p>
<p>FIN=1，seq=u。此时，A将进入FIN-WAIT-1状态。</p>
<p>PS1：FIN=1表示该报文段是一个连接释放请求。</p>
<p>PS2：seq=u，u-1是A向B发送的最后一个字节的序号。</p>
<p><strong><code>第二次挥手：</code></strong></p>
<p>B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含：</p>
<p>ACK=1，seq=v，ack=u+1。</p>
<p>PS1：ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都<br>为1，表示应答。</p>
<p>PS2：seq=v，v-1是B向A发送的最后一个字节的序号。</p>
<p>PS3：ack=u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收<br>了前u个字节。</p>
<p>A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。</p>
<p>第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但B到A方向的连接仍然存在，B可以继续向A发送数据。</p>
<p><strong><code>第三次挥手：</code></strong></p>
<p>当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。B便进入LAST-ACK状态。</p>
<p><strong><code>第四次挥手:</code></strong></p>
<p>A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。</p>
<h4 id="拆除过程"><a href="#拆除过程" class="headerlink" title="拆除过程"></a>拆除过程</h4><p>①（客户端关闭）客户TCP发送一个特殊报文段到服务器，该报文段中FIN位被置1；</p>
<p>②服务器收到后向发送方回送一个ACK报文段；</p>
<p>③（服务器端关闭）服务器端发送FIN报文段给客户端；</p>
<p>④客户端发送ACK对该报文段进行确认；</p>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><p>在计算机网络中的链路量（即带宽）、交换结点中的缓存和处理机制等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。这种情况就叫做拥塞</p>
<h3 id="拥塞原因和代价"><a href="#拥塞原因和代价" class="headerlink" title="拥塞原因和代价"></a>拥塞原因和代价</h3><p>计算机网络拥塞的原因是因为网络中的分组太多，而链路带宽和路由器缓存容量都是有限的</p>
<ul>
<li>情况一：两个发送方和一台无穷大缓存的路由器</li>
</ul>
<p>容量为R的共享式输出链路上传输</p>
<p>当发送速率超过R/2时，路由器的排队分组就会无限增加，源和目的平均时延变成无穷大</p>
<ul>
<li>情况二：两个发送方和一台有限缓存的路由器</li>
</ul>
<p>分组到达一个已满的缓存时会被丢弃，发送方必须执行重传以补偿因为缓存溢出丢弃的分组</p>
<p>发送方遇到高时延时，进行的不必要重传引起路由器转发不必要的分组副本</p>
<ul>
<li>情况三：4个发送方和具有优先缓存的多台路由器及多条路径</li>
</ul>
<p>当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组使用的传输容量被浪费</p>
<p><strong><code>拥塞控制 和 流量控制 的区别</code></strong></p>
<p>拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；</p>
<p>流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收。</p>
<p><strong><code>拥塞控制的目的</code></strong></p>
<p>缓解网络压力</p>
<p>保证分组按时到达</p>
<h3 id="拥塞控制的方法"><a href="#拥塞控制的方法" class="headerlink" title="拥塞控制的方法"></a>拥塞控制的方法</h3><p>①端到端拥塞控制，网络层并没有为运输层的拥塞控制提供支持，TCP运用的方式，只能推断是否发生拥塞。</p>
<p>②网络辅助的拥塞控制，路由器可以向发送端反馈网络的拥塞情况，但还未被用于TCP中。</p>
<h2 id="TCP拥塞控制（加性增、乘性减（AIMD）拥塞控制方法）"><a href="#TCP拥塞控制（加性增、乘性减（AIMD）拥塞控制方法）" class="headerlink" title="TCP拥塞控制（加性增、乘性减（AIMD）拥塞控制方法）"></a>TCP拥塞控制（加性增、乘性减（AIMD）拥塞控制方法）</h2><p>TCP必须用端到端拥塞控制，因为IP层不向端系统提供显式网络拥塞反馈</p>
<p>TCP让每一个发送方根据感知到的拥塞程度限制其发送速率</p>
<p><strong><code>限制速率</code></strong></p>
<p>①维护拥塞窗口cwnd值（注意流量控制使用接收窗口rwnd值）</p>
<p>②发送方未确认数据量 &lt;= min { cwnd , rwnd }</p>
<p><strong><code>感知是否存在拥塞</code></strong></p>
<p>丢包：超时或收到3个冗余ACK</p>
<p><strong><code>TCP发送方如何确定发送速率</code></strong></p>
<p>1.一个丢失的报文意味着拥塞，当丢失报文段时应当降低速率（当前速度不能正常交付，得慢点）</p>
<p>2.先前未确认报文段的确认到达时，增加发送方速率（当前速度能够正常交付，说明可以再快点）</p>
<p>3.带宽探测（试探）：TCP发送方增加速率，丢包，从该速率后退，再往前探测….（因为拥塞情况是波动的，得尽力保持在最高速率）</p>
<h3 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h3><p><strong><code>慢启动算法</code></strong> 和 <strong><code>拥塞避免算法</code></strong></p>
<ul>
<li>发送方维护一个发送窗口，发送窗口的大小取决于网络的拥塞情况和接收窗口的大小，发送窗口是动态变化的。</li>
<li>发送方还维护一个慢启动门限</li>
</ul>
<p>发送窗口 &lt; 慢启动门限：使用慢启动算法</p>
<p>发送窗口 &gt; 慢启动门限：使用拥塞避免算法</p>
<p>发送窗口 = 慢启动门限：使用慢启动算法或拥塞避免算法</p>
<ul>
<li>TCP拥塞控制算法：慢启动，拥塞避免，快速恢复</li>
</ul>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><ul>
<li>一开始cwnd只设为一个MSS的较小值（这就是『慢』，不过瞬间指数级加速<br>）</li>
<li>收到一个确认，cwnd增加一个MSS ——&gt; 每过一个RTT，cwnd翻番，发送速率翻倍（1，2，4…每次发的也多一个）</li>
<li>丢包（拥塞）结束慢启动</li>
</ul>
<p>①将ssthresh（慢启动阈值）设置为cwnd/2，cwnd置为1重新开始慢启动</p>
<p>②当cwnd=ssthresh时，结束慢启动，TCP转移到拥塞避免模式</p>
<p>③收到3个冗余ACK，执行快速重传，进入快速恢复模式</p>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><ul>
<li>进入拥塞避免状态，cwnd值是上次遇到拥塞时的一半</li>
<li>每个RTT只将cwnd值增加一个MSS/cwnd字节</li>
<li>丢包，结束拥塞避免</li>
<li>超时：ssthresh更新为cwnd的一半，cwnd置为1个MSS，返回慢启动状态</li>
</ul>
<p>冗余ACK：ssthresh更新为cwnd的一半，cwnd值减半，进入快速恢复状态</p>
<h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><ul>
<li>快速恢复中，每个冗余ACK，cwnd 增加一个MSS，当丢失报文的ACK到达时，TCP降低cwnd，进入拥塞避免状态</li>
<li>超时：同慢启动和拥塞避免</li>
</ul>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920164519401.png"></p>
<h3 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h3><p>在K条TCP连接经过传输速率为R的链路时，如果每条连接的平均传输速率接近R/K，则认为该拥塞控制是公平的。在每条TCP连接的RTT相等的情况下，TCP拥塞控制是公平的，但实际中RTT小的连接会有更高的吞吐量。</p>
<h2 id="四、网络层数据平面"><a href="#四、网络层数据平面" class="headerlink" title="四、网络层数据平面"></a>四、网络层数据平面</h2><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170244616.png"></p>
<h2 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h2><p>1.每台路由器的**<code>数据平面</code>** 的主要作用是从其输入链路向其输出链路转发数据报。</p>
<p>2.**<code>控制平面</code>**的主要作用是协调这些本地的每路由器转发动作，使得数据报沿着源和目的地主机之间的路由器路径最终进行端到端传送。</p>
<p>3.**<code>路由器</code>**（不运行应用层网络层协议）的主要作用是将数据从入链路转发到出链路。</p>
<p>4.<strong><code>A,B两主机通信：</code></strong> A中网络层取得于A运输层的报文段，每个报文段封装成数据报，向相邻路由器发送。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170308181.png"></p>
<h3 id="转发和路由选择（数据平面和控制平面）"><a href="#转发和路由选择（数据平面和控制平面）" class="headerlink" title="转发和路由选择（数据平面和控制平面）"></a>转发和路由选择（数据平面和控制平面）</h3><p><strong><code>网络层作用：</code></strong> 将分组从一台发送主机发送到另一台接受主机。IP协议：编址规则，数据报格式，分组处理规则。</p>
<p><strong><code>需要两种功能：转发和路由选择</code></strong></p>
<ul>
<li><strong><code>转发：</code></strong> 分组从（路由器）输入链路接口转移到适当输出链路接口的路由器本地动作</li>
<li><strong><code>路由选择：</code></strong> 分组从发送方发往接收方时，网络层须决定分组采用的路由或路径</li>
</ul>
<p><strong><code>转发是路由器本地动作，路由选择是网络范围过程。</code></strong> 比如开车从北京到上海，转发相当于在某个路口选择某一条岔路，路由选择相当于规划从北京到上海所有线路的过程</p>
<p><strong><code>路由选择算法：</code></strong> 计算采用的路径的算法，决定了插入路由器的转发表中的值</p>
<p>每台路由都有一张 **<code>转发表</code>**。路由器检查分组首部字段值（可能是目的地址或所属连接，看网络层协议）来转发分组，使用该值在转发表索引查询。该值指出了该分组将被转发的路由器输出链路接口</p>
<h4 id="控制平面：传统的方法"><a href="#控制平面：传统的方法" class="headerlink" title="控制平面：传统的方法"></a>控制平面：传统的方法</h4><p><strong><code>路由选择算法决定了插入路由器转发表中的值(两种算法)</code></strong></p>
<ul>
<li><p>集中式</p>
</li>
<li><p>分布式</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170322634.png"></p>
</li>
</ul>
<h4 id="控制平面：SDN方法"><a href="#控制平面：SDN方法" class="headerlink" title="控制平面：SDN方法"></a>控制平面：SDN方法</h4><p>远程控制器计算和分发转发表以供每台路由器使用</p>
<p>控制平面路由 <strong><code>选择功能</code></strong> 和 <strong><code>物理路由器</code></strong> 是分开的，**<code>选择设备执行转发，远程控制器计算并分发转发表</code>** ，这种控制平面方法是 <strong><code>软件定义网络（Soft-ware-Defined Networking,SDN）</code></strong> 的本质</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170347356.png"></p>
<h3 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h3><p><strong><code>网络服务模型：</code></strong> 定义了分组在发送与接收端系统之间的端到端运输特性</p>
<p><strong><code>网络层提供的服务（IP没有的服务）：</code></strong></p>
<p>运输层向网络层传递分组时：</p>
<p><strong><code>①确保交付：</code></strong> 确保分组最终达到目的地</p>
<p><strong><code>②具有时延上界的确保交付：</code></strong> 确保分组交付和主机到主机时延上界内交付<br>为给定源和目的地之间的分组流提供服务时<br>：<br><strong><code>③有序分组交付</code></strong></p>
<p><strong><code>④确保最小带宽：</code></strong> 模仿发送方和接收方之间一条特定比特率传输链路的行为。发送速率低于该速率，分组不会丢失，且会在预定时延内到达</p>
<p><strong><code>⑤ 安全性：</code></strong> 使用仅由源和目的地主机知晓的密钥，加密数据报，源加密，目的主机解密。此外还有数据完整性和源鉴别服务</p>
<p>因特网的网络层IP协议提供单一服务，尽力而为服务，无带宽保证，无丢包保证，无顺序保证，不定时，无拥塞指示</p>
<p><strong><code>分组交换机</code></strong> 是指一台通用分组交换设备，它根据分组首部字段中的值，从输入链路接口到输出链路接口转移分组。某些分组交换机称为 <strong><code>链路层交换机</code></strong> ，基于链路层帧中的字段值做出转发决定，这些交换机因此被称为链路层设备。其他分组交换机称为 <strong><code>路由器</code></strong> ，基于网络层数据报中的首部字段值做出转发决定。路由器因此是网络层设备</p>
<p><strong><code>路由器是网络层设备</code></strong></p>
<h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><p><strong><code>路由器有4个主要组件：</code></strong></p>
<p><strong><code>①输入端口：</code></strong> 路由器中执行终结入物理链路的物理层功能。与位于入链路远端的数据链路层交互来执行数据链路层功能。执行查找功能。通过查询转发表决定路由器的输出端口，到达的分组通过路由器的交换结构转发到输出端口。控制分组从输入端口转发到路由选择处理器。</p>
<p><strong><code>②交换结构：</code></strong> 交换结构将路由器的输入端口连接到它的输出端口。这种交换结构完全包含在路由器之中</p>
<p><strong><code>③输出端口：</code></strong> 输出端口存储从交换结构接收的分组，并通过执行必要的链路层和物理层功能在输出链路上传输这些分组。</p>
<p><strong><code>④路由选择处理器：</code></strong> 路由选择处理器执行控制平面功能。它执行路由选择协议，维护路由选择表与关联链路状态信息，并为该路由器计算转发表。在软件定义网络（Software-Defined Networking, SDN）路由器中，路由选择处理器负责与远程控制器通信，目的是接收由远程控制器计算的转发表项，并在该路由器的输入端口安装这些表项。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170414409.png"></p>
<h3 id="输入端口处理和基于目的地的转发"><a href="#输入端口处理和基于目的地的转发" class="headerlink" title="输入端口处理和基于目的地的转发"></a>输入端口处理和基于目的地的转发</h3><p>路由器用分组目的地址的前缀与转发表中的表项进行匹配。如果存在一个匹配项，则路由器向与该匹配项相关联的链路转发该分组。当有多个匹配时，该路由器使用 <strong><code>最长前缀匹配规则</code></strong> ，即在表中寻找最长的匹配项，并向与最长前缀匹配相关项的链路接口转发分组。</p>
<h4 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h4><p>①线路端接</p>
<p>②数据链路处理（协议、拆封）</p>
<p>③查找</p>
<ul>
<li>查找必须在纳秒级别执行，不仅要用硬件执行查找，而且要对大型转发表使用快速查找算法，而且需要更快的内存访问速度（DRAM、SRAM）。</li>
<li>三态内容可寻址存储器TCAM常被用于查找。使用TCAM，一个32bit的IP地址放入内存，TCAM在基本常数时间内返回转发表项内容</li>
</ul>
<p>④转发</p>
<ul>
<li>转发表由路由选择处理器计算和更新，从路由选择处理器经过独立总线复制到（输入）线路卡</li>
<li>有了转发表副本，转发决策能在每个输入端口本地做出，无须调动路由选择处理器，避免集中式处理</li>
</ul>
<p>⑤排队</p>
<ul>
<li>查找确定了某分组输出端口，分组就能发送进入交换结构。一个被阻塞的分组必须在输入端口处排队</li>
</ul>
<h4 id="查找采取的动作"><a href="#查找采取的动作" class="headerlink" title="查找采取的动作"></a>查找采取的动作</h4><p>①物理层和链路层的处理</p>
<p>②检查分组的版本号，检验以及寿命字段，并重写后两个字段</p>
<p>③更新用于网络管理的计数器</p>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>交换结构位于路由器的核心部位。</p>
<h4 id="交换的三种方式"><a href="#交换的三种方式" class="headerlink" title="交换的三种方式"></a>交换的三种方式</h4><p><strong><code>①经内存交换</code></strong></p>
<ul>
<li>一个分组到达输入端口时，该端口会先通过中断方式向路由选择处理器发出信号</li>
<li>分组从输入端口复制到处理器内存中（现代路由器查找交换进内存，是由输入线路卡处理的）</li>
<li>早期路由选择处理器从首部提取目的地址，在转发表查找输出端口，将分组复制到输出端口</li>
</ul>
<p><strong><code>②经总线交换</code></strong></p>
<ul>
<li>输入端口经一根共享总线将分组直接传送到输出端口，无需路由选择处理器的干预</li>
<li>路由器的交换带宽受总线速率限制</li>
</ul>
<p><strong><code>③经互联网络交换</code></strong></p>
<ul>
<li><p>纵横式交换机，2N条总线组成网络，连接N各输入端口和N个输出端口<br>每条垂直的总线与每条水平的总线交叉，交叉点通过交换结构控制器开启闭合</p>
</li>
<li><p>某分组到达端口A，需要转发到Y，交换机控制器闭合总线A和Y的交叉点，A在其总线上发送分组，仅由Y接收；同时B也能发分组到X，因为没有公用总线。纵横式网络能并行转发多个分组</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170443471.png"></p>
</li>
</ul>
<h3 id="输出端口处理"><a href="#输出端口处理" class="headerlink" title="输出端口处理"></a>输出端口处理</h3><p>①排队（缓存管理）</p>
<p>②数据链路处理（协议、拆封）</p>
<p>③线路端接</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170511929.png"></p>
<h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><p>输入、输出端口都能形成分组队列，取决于流量负载、交换结构<br>随着队列增长，路由器缓存空间会耗尽，出现丢包</p>
<p>需要路由器缓存吸收流量负载波动，需要多少缓存？</p>
<ul>
<li>少量TCP流：RTT * C（链路容量）</li>
<li>大量TCP流：RTT* C/ (N^1/2)</li>
</ul>
<p>输出端口排队，需要分组调度程序选出一个分组发送。提供服务质量保证</p>
<p>主动队列管理：</p>
<ul>
<li>缓存填满前丢弃（或首部加个标记）一个分组，向发送方提供一个拥塞信号</li>
<li>随机早期检测算法：平均队列长度在某个范围内时，以某种概率被丢弃/标记</li>
</ul>
<h3 id="分组调度"><a href="#分组调度" class="headerlink" title="分组调度"></a>分组调度</h3><p><strong><code>先进先出（First-In-First-Out, FIFO）:</code></strong><br>链路调度规则按照到达输出链路队列的相同次序来选择分组在链路上传输。</p>
<p><strong><code>优先权排队：</code></strong> 到达输出链路的分组被分类放入输出队列中的优先权类。在非抢占式优先权排队规则下，一旦分组开始传输，就不能打断。</p>
<p><strong><code>循环排队：</code></strong> 分组像使用优先权排队那样被分类。然而，在类之间不存在严格的服务优先权，循环调度器在这些类之间轮流提供服务。保持工作排队规则在有分组排队等待传输时，不允许链路保持空闲。加权公平排队（Weighted Fair Queuing, WFQ）规则下，每个类在任何时间间隔内可能受到不同数量的服务。具体而言，每个类i被分配一个权wi。使用WFQ方式，在类i有分组要发送的任何时间间隔中，第i类将确保接受到的服务部分等于wi/(∑wj)，分母中的和是计算所有分组排队等待传输的类别得到的。对于一条传输速率为R的链路，第i类总能获得至少为R ∙ wi/(∑wj)的吞吐量。</p>
<h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p><strong><code>网络层三个组件 ：</code></strong></p>
<ul>
<li><strong><code>IP协议</code></strong></li>
<li><strong><code>路由选择协议</code></strong></li>
<li><strong><code>控制报文协议（ICMP）</code></strong> ：报告数据报中的差错、对某些网络层信息请求进行响应的设施</li>
</ul>
<h3 id="IPv4数据报格式"><a href="#IPv4数据报格式" class="headerlink" title="IPv4数据报格式"></a>IPv4数据报格式</h3><p>网络层分组被称为<code>数据报</code></p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170530669.png"></p>
<p><strong><code>版本号（IPv4、IPv6）：</code></strong> 不同版本对数据报不同解释，4比特规定了数据报的IP协议版本</p>
<p><strong><code>首部长度：</code></strong> 数据报可包含可变数量的选项。不过大部分没有，首部固定20字节</p>
<p><strong><code>服务类型：</code></strong> 区分不同类型的IP数据报</p>
<p><strong><code>数据报长度：</code></strong> 首部+数据的长度。该字段16bit，然而一般数据报很少超过1500字节</p>
<p><strong><code>标识、标志、片偏移:</code></strong> IP分片相关。不过IPv6不允许在路由器上对分组分片</p>
<p><strong><code>寿命TTL：</code></strong> 确保数据报不会永远在网络中循环。每被一个路由器处理时，值-1。若值减到0，丢弃数据报</p>
<p><strong><code>协议号：</code></strong> 到达最终目的地才有用，指示了IP数据报的数据部分应该交给哪个运输层协议。如6交给TCP，如17交给UDP</p>
<p>协议号是将网络层与运输层绑定到一起的粘合剂；端口号是将运输层和应用层绑定的粘合剂</p>
<p><strong><code>首部检验和：</code></strong> 帮忙路由器检测收到IP数据报中首部的比特错误，有错一般丢弃</p>
<p><strong><code>源和目的IP地址：</code></strong> 源主机通过DNS查找目的地址</p>
<p>选项：IPv6已抛弃选项字段</p>
<p><strong><code>数据（有效载荷）：</code></strong> 包含运输层报文段（TCP或UDP），或ICMP报文段</p>
<ul>
<li>一个IP数据报有长为20的首部，如果数据报承载一个TCP报文段，则每个无分片数据报承载总长40的首部（还有TCP的20）以及应用层报文</li>
</ul>
<h3 id="IPv4数据报分片"><a href="#IPv4数据报分片" class="headerlink" title="IPv4数据报分片"></a>IPv4数据报分片</h3><ul>
<li>并不是所有链路层协议都能承载相同长度的网络层分组，如以太网帧能承载不超过1500字节的数据，某些广域网链路帧不超过576字节</li>
<li>一个链路层帧承载的最大数据量：最大传送单元MTU</li>
<li>限制了IP数据报的长度，且发送方与目的路径上的每段链路可能使用不同的链路层协议，有不同的MTU</li>
<li>将IP数据报中的数据分片成多个较小的IP数据报，用单独的链路层帧封装这些小IP数据报，每个小数据报叫片</li>
<li>数据报的重新组装放在端系统中，而不是路由器中</li>
<li>标识、标志、片偏移字段，帮助主机执行重组任务</li>
<li>一个4000字节的数据报（20+3980）到达一台路由器，转发到一条MTU为1500子节的链路上。必须分配3个独立的片，假设初始数据报的标识号是777，则前两片字节都为20+1480，第三层为20+1020</li>
</ul>
<p><strong>安全性</strong></p>
<ul>
<li>分片被用于Dos攻击，如Jolt2，攻击者向目标主机发送小片的流，没有一个片的偏移量是0，目标试图重组时可能会崩溃</li>
<li>发送交迭偏移量的IP片，不能被适当排列，可能会崩溃</li>
<li>IPv6废除了分片，简化了IP分组的处理</li>
</ul>
<h3 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h3><p><strong>主机与路由器连入网络的方法</strong></p>
<p>①一台主机通常只有一条链路连接到网络，主机IP发送数据报从该链路发送</p>
<p>②主机与物理链路的边界叫接口，一台路由器有多个接口</p>
<p>③IP要求每台主机和路由器都有自己的IP地址，因此一个IP地址实际上是与每一个接口相关联的</p>
<p>每个IP地址长度32bit（4字节），总共2^32个可能的IP地址，约40亿个,用**<code>点分十进制记法</code>** ，如193.32.216.9</p>
<p><strong><code>一个接口的IP地址的一部分需要由其连接的子网决定</code></strong></p>
<ul>
<li>如互联3个主机接口与1个路由器接口的网络形成一个子网，IP编址为这个子网分配一个地址：223.1.1.0/24，/24记法称为子网掩码，指示了32bit中的最左侧24bit定义了子网地址</li>
<li>为了确定子网，分开主机和路由器的每个接口，产生几个隔离的网络岛，使用接口端接这些隔离的网络的端点，这些隔离的网络中每一个都叫做一个子网</li>
</ul>
<p><strong><code>因特网地址分配策略：</code></strong> 无类别域间路由选择CDIR</p>
<p>a.b.c.d/x的地址的x最高比特构成IP地址的网络部分，称为该地址的前缀，一个组织通常被分配一块连续的地址，即具有相同前缀的一段地址。BGP路由选择协议中，该组织网络外的路由器仅考虑x，减少了转发表的长度，因为形式为a.b.c.d/x单一表项足以将数据报转发到该组织内的任何目的地</p>
<p><strong><code>地址聚合（路由聚合）：</code></strong> 使用单个网络前缀通告多个网络的能力<br>一个ISP将8个组织连接到因特网。该ISP向外界通告：向我发送以200.23.16.0/20开始的任何内容。外部无需知道在该地址块内还有8个其他组织，每个组织有自己的子网</p>
<p>一个地址的剩余32-x比特可认为是用于区分该组织内部设备的。组织内部路由器转发分组时，才会考虑这些比特</p>
<p>在CDIR出现之前，采用分类编址，A、B、C类网络，分别具有8、16、24比特子网地址</p>
<p><strong><code>C类（/24）</code></strong> 仅能容纳2^8-2=254台主机（其中两个用于特殊用途）。 C类地址第1字节、第2字节和第3个字节为网络地址，第4个字节为主机地址。另外第1个字节的前三位固定为110。192.168.X.X是私有地址。</p>
<p>(192.168.0.0-192.168.255.255)</p>
<p>⑵ C类地址范围：192.0.0.0—223.255.255.255。</p>
<p><strong><code>B类（/16）</code></strong> 支持65534台主机，一个组织分配一个B类地址却只用2000个接口，造成巨大浪费。B类地址范围：128.0.0.0—191.255.255.255</p>
<p><strong><code>A类：</code></strong> A类地址第1字节为网络地址，其它3个字节为主机地址。，A类地址范围：1.0.0.0—127.255.255.255。A类地址中的私有地址和保留地址：</p>
<p>① 10.X.X.X是私有地址（所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址）。范围（10.0.0.0.0-10.255.255.255）</p>
<p>② 127.X.X.X是保留地址，用做循环测试用的</p>
<p><strong><code>IP广播地址</code></strong></p>
<p>当一台主机发出目的地址为255.255.255.255的数据报时，报文会交付给同一个网络的所有主机，可用于DHCP发现报文的发送，广播最小生成树</p>
<h4 id="获取一块地址"><a href="#获取一块地址" class="headerlink" title="获取一块地址"></a>获取一块地址</h4><ul>
<li>子网获取IP地址：由ISP从它大块地址中分配</li>
<li>ISP获取IP地址：IP地址由因特网名字和编号分配机构ICANN管理（也管理DNS根服务器、AS标识号）。ICANN向区域性因特网注册机构分配地址，处理本地域内的地址分配/管理</li>
</ul>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170557648.png"></p>
<h4 id="获取主机地址"><a href="#获取主机地址" class="headerlink" title="获取主机地址"></a>获取主机地址</h4><ul>
<li>组织获得一块地址，就可为组织内的主机、路由器接口逐个分配IP地址</li>
<li>主机地址能手动配置，也能自动配置，即动态主机配置协议DHCP</li>
</ul>
<h4 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h4><ul>
<li>DHCP允许主机自动获取一个IP地址</li>
<li>DHCP可配置，可以使主机每次连网获得相同IP地址，也可每次分配一个临时IP地址（比如ISP给你家分配了一个IP地址，你想多台主机同时连网时，需要配置路由器。一般电信这种会给你家分配临时IP地址，这样节省IP地址。也有的每次连接都是固定地址比如公寓的ISP，这时需要手动在路由器设置里输入，可以ipconfig查看）</li>
<li>DHCP还允许主机查看子网掩码、默认网关（第一跳路由器地址）、本地DNS服务器地址</li>
<li>DHCP能将主机连接进一个网络的自动能力，常被称为即插即用协议</li>
<li>DHCP是一个客户-服务器协议。新来的主机要获得自使用的IP地址等网络配置信息</li>
</ul>
<p>1.每个子网都有一台DHCP服务器</p>
<p>2.若子网没有DHCP服务器，则由一个路由器做DHCP中继代理，该代理知道该网络的DHCP服务器地址</p>
<h5 id="DHCP协议的四个步骤"><a href="#DHCP协议的四个步骤" class="headerlink" title="DHCP协议的四个步骤"></a>DHCP协议的四个步骤</h5><p><strong><code>DHCP服务器发现</code></strong></p>
<p>新到的客户通过广播DHCP发现报文，发现一个要与其交互的DHCP服务器<br>客户在UDP分组中向端口67发送该发现报文，此时必须用广播地址255.255.255.255，源地址是0.0.0.0</p>
<p><strong><code>DHCP服务器提供</code></strong></p>
<p>DHCP收到DHCP发现报文后，响应一个DHCP提供报文，仍然使用广播地址，因为此时新客户并没有IP地址</p>
<p>可能有多台DHCP服务器，每台服务器提供的报文中，有向客户主机推荐的IP地址、网络掩码以及IP地址租用期（一般几天或几小时）</p>
<p><strong><code>DHCP请求</code></strong></p>
<p>客户从提供中选一个，向选中的服务器提供一个DHCP请求报文进行响应，回显配置参数</p>
<p><strong><code>DHCP ACK</code></strong></p>
<p>收到DHCP请求报文后，用DHCP ACK报文对其记性响应，证实所传参数<br>客户收到ACK后，交互完成，在租期内使用DHCP分配的IP地址。DHCP提供了机制允许客户更新对一个IP地址的租用</p>
<h3 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h3><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170621318.png"></p>
<p>当ISP已经为SOHO网络当前地址范围分配过一块连续地址，而SOHO内主机越来也多时，需要用到NAT（比如电信给你家分配一个动态IP地址，家里要好几台手机电脑联网用一个IP地址，需要用NAT）</p>
<p>当ISP已经为SOHO网络当前地址范围分配过一块连续地址，而SOHO内主机越来也多时，需要用到NAT（比如电信给你家分配一个动态IP地址，家里要好几台手机电脑联网用一个IP地址，需要用NAT）</p>
<h4 id="UPnP"><a href="#UPnP" class="headerlink" title="UPnP"></a>UPnP</h4><ul>
<li>NAT穿越由通用即插即用（UPnP）提供</li>
<li>UPnP是一种允许主机发现并配置邻接NAT的协议，要求主机和NAT都是UPnP兼容</li>
<li>使用UPnP，在主机上运行的应用程序能为某些请求的公共端口号请求一个NAT映射（专用IP地址，专用端口号 — 公共IP地址，公共端口号）。如果某NAT接收请求并生成映射，来自外部的结点能发起到（公共IP地址，公共端口号）的TCP连接</li>
</ul>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>IPv4地址耗尽，IPv6也可强化IPv4某些方面</p>
<h4 id="IPv6数据报格式"><a href="#IPv6数据报格式" class="headerlink" title="IPv6数据报格式"></a>IPv6数据报格式</h4><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170645532.png"></p>
<p>①扩大的地址容量</p>
<p>32bit —&gt; 128bit</p>
<p>r除了单播多播地址，引入任播地址，使数据报交付给一组主机中的任意一个</p>
<p>②简化高效的40字节首部</p>
<p>③流标签与优先级</p>
<p>如音频流、视频流、高优先级用户承载的流量</p>
<p><strong><code>IPv6定义的字段：</code></strong></p>
<p>①版本</p>
<p>②流量类型</p>
<p>③流标签</p>
<p>④有效载荷长度</p>
<p>⑤下一个首部</p>
<p>⑥跳限制</p>
<p>⑦源地址和目的地址</p>
<p>⑧数据</p>
<p><strong><code>IPv6中不存在的IPv4数据报字段</code></strong></p>
<p>①分片/重新组装：只能在源与目的地进行</p>
<p>②首部检验和</p>
<p>③选项：放到了下一个首部位置，使得IP首部定长40字节</p>
<h4 id="IPv4到IPv6的迁移"><a href="#IPv4到IPv6的迁移" class="headerlink" title="IPv4到IPv6的迁移"></a>IPv4到IPv6的迁移</h4><p>4到v6的迁移，两种双栈（dual-stack）方法。</p>
<p>1.接受结点和发送节点如果都是IPv6，则使用v6，否则使用IPv4。</p>
<p>2.将IPv4路由器集合作为隧道（tunneling），将IPv6数据报放入IPv4的数<br>据字段</p>
<h2 id="通用转发和SDN"><a href="#通用转发和SDN" class="headerlink" title="通用转发和SDN"></a>通用转发和SDN</h2><p>将基于目的地转发的特征总结为两个步骤：查找目的IP地址（“匹配”），然后将分组发送到有特定输出端口的交换结构（“动作”）。现有一种更有意义的通用“匹配加动作”范式，其中能够对协议栈的多个首部字段进行“匹配”，这些首部字段是与不同层次的不同协议相关联的。</p>
<h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><p>匹配加动作转发表在OpenFlow中成为流表，它的每个表项包括：</p>
<p>1.首部字段值的集合。入分组将与之匹配。匹配不上流表项的分组将被丢弃或发送到远程控制器做更多处理。</p>
<p>2.计数器集合。这些计数器可以包括已经与该表项匹配的分组数量，以及自从该表项匹配的分组数量，以及自从该表项上次更新以来的时间。</p>
<p>当分组匹配流表项时所采取的动作集合。这些动作可能将分组转发到给定的3.输出端口，丢弃该分组、复制该分组和将它们发送到多个输出端口，和/或重写所选的首部字段。</p>
<h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>1.转发</p>
<p>2.丢弃。没有动作的流表项表明某个匹配的分组应当丢弃</p>
<p>3.修改字段</p>
<h2 id="五、网络层控制平面"><a href="#五、网络层控制平面" class="headerlink" title="五、网络层控制平面"></a>五、网络层控制平面</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>计算、维护和安装转发表和流表有两种可能的方法：</p>
<p>1.每路由器控制。每台路由器中都包含转发和路由选择功能。每台路由器有一个路由选择组件，用于与其他路由器中的路由选择组件通信，以计算转发表的值。</p>
<p>2.逻辑集中式控制。逻辑集中式控制器计算并分发转发表以供每台路由器使用。</p>
<h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><h3 id="根据路由算则算法是集中式还是分散式"><a href="#根据路由算则算法是集中式还是分散式" class="headerlink" title="根据路由算则算法是集中式还是分散式"></a>根据路由算则算法是集中式还是分散式</h3><h4 id="集中式路由选择算法"><a href="#集中式路由选择算法" class="headerlink" title="集中式路由选择算法"></a>集中式路由选择算法</h4><p>完整的、全局性的网络知识计算出从源到目的地之间的最低开销路径。也就是说，该算法以所有节点之间的连通性及所有链路的开销为输入。这就要求该算法在真正开始计算以前，要以某种方式获得这种信息。具有全局状态信息的算法常被称作 <code>链路状态（Link State, LS）算法</code>。</p>
<h4 id="分散式路由选择算法"><a href="#分散式路由选择算法" class="headerlink" title="分散式路由选择算法"></a>分散式路由选择算法</h4><p>路由器以迭代、分布式的方式计算出最低开销路径。没有节点拥有关于所有网络链路的开销的完整信息。相反，每个节点仅有与其之间相连链路的开销知识即可开始工作。然后，通过迭代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或一组目的节点的最低开销路径。</p>
<h3 id="根据算法是静态的还是动态"><a href="#根据算法是静态的还是动态" class="headerlink" title="根据算法是静态的还是动态"></a>根据算法是静态的还是动态</h3><h4 id="静态路由选择算法"><a href="#静态路由选择算法" class="headerlink" title="静态路由选择算法"></a>静态路由选择算法</h4><p>路由随时间的变化非常缓慢，通常是人工进行调整。</p>
<h4 id="动态路由选择算法"><a href="#动态路由选择算法" class="headerlink" title="动态路由选择算法"></a>动态路由选择算法</h4><p>随着网络流量负载或拓扑发生变化而改变路由选择路径。一个动态算法可周期性地运行或直接相应拓扑或链路开销的变化而运行。虽然动态算法易于对网络的变化做出反应，但也更容易受诸如路由选择循环、路由振荡之类问题的影响。</p>
<h3 id="根据是负载敏感还是负载迟钝"><a href="#根据是负载敏感还是负载迟钝" class="headerlink" title="根据是负载敏感还是负载迟钝"></a>根据是负载敏感还是负载迟钝</h3><h4 id="负载敏感算法"><a href="#负载敏感算法" class="headerlink" title="负载敏感算法"></a>负载敏感算法</h4><p>链路开销会动态地变化以反应出底层链路得到当前拥塞水平。如果当前拥塞的一条链路与高开销想联系，则路由选择算法趋向于绕开该拥塞链路来选择路由。</p>
<h4 id="负载迟钝算法"><a href="#负载迟钝算法" class="headerlink" title="负载迟钝算法"></a>负载迟钝算法</h4><p>某条链路的开销不明确地反应其当前的拥塞水平。</p>
<h3 id="链路状态路由选择算法（Dijkstra）"><a href="#链路状态路由选择算法（Dijkstra）" class="headerlink" title="链路状态路由选择算法（Dijkstra）"></a>链路状态路由选择算法（Dijkstra）</h3><p>在链路状态算法中，网络拓扑和所有的链路开销都是已知的，也就是说可用作LS算法的输入。实际上这是通过让每个节点向网络中所有其他节点广播链路状态分组来完成的，其中每个链路状态分组包含它所连接的链路的标识和开销。这经常有链路状态广播算法来完成。链路状态算法实际上是用Dijkstra算法实现的。</p>
<h3 id="距离向量路由选择算法"><a href="#距离向量路由选择算法" class="headerlink" title="距离向量路由选择算法"></a>距离向量路由选择算法</h3><p><code>距离向量（Distance-Vector, DV）算法</code> 是一种迭代的、异步的和分布式的算法。DV算法实际上是用Bellman-Ford算法实现的。在DV算法中，当节点x发现它的直接相连的链路开销变化或从某个邻居接收到一个距离向量的更新时，它就更新距离向量估计值。每个节点等待来自任何邻居的更新，当接收到一个更新时计算它的新距离向量并向它的邻居分布其新距离向量。</p>
<p><code>DV算法</code> 会遇到 <code>路由选择环路</code> 而变得缓慢。对于两个直接相连的节点，可以通过毒性逆转技术加以避免，但是对于3个或以上的节点就无法使用毒性逆转技术检测到。</p>
<h4 id="LS算法与DV算法的比较"><a href="#LS算法与DV算法的比较" class="headerlink" title="LS算法与DV算法的比较"></a>LS算法与DV算法的比较</h4><p><code>报文复杂性。</code> LS算法要求每个节点都知道网络中每条链路的开销。这就要求发送O(|N||E|)个报文。而且无论何时一条链路的开销改变时，必须向所有节点发送新的链路开销。DV算法要求在每次迭代时，在两个直接相连邻居之间交换报文。算法收敛所需时间依赖于许多因素。当链路开销改变时，DV算法仅当在新的链路开销导致与该链路相连节点的最低开销路径发生改变时，才传播已改变的链路开销。</p>
<p><code>收敛速度。</code>LS算法的实现是一个要求O(|N||E|)个报文的O(|N|2)算法。DV算法收敛较慢，且在收敛时会遇到路由选择环路。DV算法还会遇到无穷计数问题。</p>
<p><code>健壮性。</code> 如果一台路由器发生故障、行为错乱或收到蓄意破坏时，对于LS算法，路由器能够向其连接广播不正确的开销。作为LS广播的一部分，一个节点也可损坏或丢弃它收到的任何LS广播分组。但是一个LS节点仅计算自己的转发表；其他节点也自行执行类似的计算。这就意味着在LS算法下，路由计算在某种程度上是分离的，提供了一定程度的健壮性。在DV算法中，一个节点可向任意或所有目的节点通告其不正确的最低开销路径。在此情况下，DV算法中一个不正确的节点计算值会扩散到整个网络。</p>
<h2 id="因特网中自治系统内部的路由"><a href="#因特网中自治系统内部的路由" class="headerlink" title="因特网中自治系统内部的路由"></a>因特网中自治系统内部的路由</h2><h3 id="选择OSPF"><a href="#选择OSPF" class="headerlink" title="选择OSPF"></a>选择OSPF</h3><ul>
<li>随着路由器数目变得很大，涉及路由选择信息的通信、计算和存储的开销将高得不可实现。因特网是ISP的网络，其中每个ISP都有它自己的路由器网络。ISP通常希望按自己的意愿运行路由器，或对外部隐藏其网络的内部组织面貌。这两个问题都可以通过将路由器组织进 <code>自治系统（Autonomous System, AS）</code> 来解决。其中每个AS由一组通常处在相同管理控制下的路由器组成。通常在一个ISP中的路由器以及互联它们的链路构成一个AS，而其他ISP则将它们的ISP拆分为数十个互联的AS。一个自治系统由其全局唯一的AS号（ASN）所标识。</li>
<li>在相同的AS中的路由器都运行相同的路由选择算法并且有彼此的信息。在一个自治系统内运行得到路由选择算法叫做 <code>自治系统内部路由选择协议</code> 。</li>
</ul>
<h4 id="开放最短路优先（OSPF）"><a href="#开放最短路优先（OSPF）" class="headerlink" title="开放最短路优先（OSPF）"></a>开放最短路优先（OSPF）</h4><p><code>开放最短路优先（OSPF）</code> 是一种链路状态协议，它使用洪泛链路状态信息和Dijkstra最低开销路径算法。使用OSPF，一台路由器构建了一副关于整个自治系统的完整拓扑图。于是，每台路由器在本地运行Dijkstra的最短路径算法，以确定一个自身为根节点到所有子网的最短路径树。各条链路开销是由网络管理员配置的。</p>
<p>使用OSPF时，路由器向自治系统内所有其他路由器广播路由选择信息，而不仅仅是向其相邻路由器广播。每当一条链路的状态发生变化时，路由器就会广播链路状态信息。即使链路状态未发生变化，它也要周期性地（至少每隔30min一次）广播链路状态。</p>
<pre class="line-numbers language-none"><code class="language-none">OSPF的优点：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>①安全。</code> 能够鉴别OSPF路由器之间的交换。使用鉴别，仅有受信任的路由器能参与一个AS内的OSPF协议，因此可防止恶意入侵者将不正确的信息诸如路由器表内。</p>
<p><code>②多条相同开销路径。</code> 当到达某目的地的多条路路径具有相同的开销时，OSPF允许使用多条路径（这就是说，当存在多条相等开销的路径时，无须仅选择单一的路径来承载所有的流量）。</p>
<p><code>③对单播和多播路由选择的综合支持。</code> 多播OSPF（MOSPF）提供对OSPF的简单扩展，以便提供多播路由选择。MOSPF使用现有的OSPF链路数据库，并为现有的OSPF链路状态广播机制增加了一种新型的链路状态通告</p>
<p><code>④支持在单个AS中的层次结构。</code> 一个OSPF自治系统能够层次化地配置多个区域。每个区域都运行自己的OSPF链路状态路由选择算法，区域内的每台路由器都向该区域内的所有其他路由器广播其链路状态。</p>
<h2 id="ISP之间的路由选择（BGP）"><a href="#ISP之间的路由选择（BGP）" class="headerlink" title="ISP之间的路由选择（BGP）"></a>ISP之间的路由选择（BGP）</h2><p>在因特网中，所有的AS运行相同的AS间路由选择协议，称为 <code>边界网关协议（Broder Gateway Protocal, BGP）</code></p>
<h3 id="BGP的作用"><a href="#BGP的作用" class="headerlink" title="BGP的作用"></a>BGP的作用</h3><p><code>从邻居AS获得前缀的可达性信息。</code> BGP允许每个子网向因特网的其余部分通告他的存在。BGP确保在因特网中的的所有AS知道该子网。如果没有BGP的话，每个子网将是隔离的孤岛，即它们孤独地存在，不为其他因特网其余部分所知和所达。</p>
<p><code>确定到该前缀的“最好的”路由。</code> 一台路由器可能知道两条或更多条到特定前缀的不同路由。为了确定最好的路由，该路由器将本地运行一个BGP路由选择过程。该最好的路由将基于策略以及可达性信息来确定。</p>
<h3 id="通告BGP路由信息"><a href="#通告BGP路由信息" class="headerlink" title="通告BGP路由信息"></a>通告BGP路由信息</h3><p>对于每个AS，每台路由器要么是一台 <code>网关路由器</code> ，要么是一台内部路由器。网关路由器是一台位于 <code>AS边缘的路由器</code> ，它直接连接到在其他AS中的一台或多台路由器。内部路由器仅连接在它自己AS中主机和路由器。</p>
<ul>
<li>在BGP中，每对路由器通过使用179端口的半永久TCP连接交换路由选择信息。每条直接连接以及所有通过该连接发送的BGP报文，称为 <code>BGP连接</code> 。此外，跨越两个AS的BGP连接称为 <code>外部BGP（eBGP）连接</code> ，而在相同AS中的两台路由器之间的BGP会话称为 <code>内部BGP（iBGP）连接</code> 。通过使用eBGP和iBGP会话，路由器之间可以互相通告可达性信息。</li>
<li>对于每个AS，每台路由器要么是一台 <code>网关路由器</code> ，要么是一台内部路由器。网关路由器是一台位于AS边缘的路由器，它直接连接到在其他AS中的一台或 <code>多台路由器</code> 。内部路由器仅连接在它自己AS中主机和路由器。</li>
</ul>
<h3 id="确认最好的路由"><a href="#确认最好的路由" class="headerlink" title="确认最好的路由"></a>确认最好的路由</h3><p>当路由器通过 BGP连接通告前缀时，它在前缀中包括一些 <code>BDP属性</code> 。用BGP术语来说，前缀及其属性称为 <code>路由</code> 。两个较为重要的属性是 <code>AS-PATH</code> 和 <code>NEXT-HOP</code> 。AS-PATH属性包含了通告已经通过的AS列表。当一个前缀通过某AS时，该AS将其ASN加入AS-PATH中现有的列表。BGP路由器还使用AS-PATH属性来检测和防止通告环路，如果一台路由器在路径列表中看到包含了它自己的AS，它将拒绝该通告。NEXT-HOP是AS-PATH起始的路由器接口的IP地址。</p>
<h4 id="热土豆路由选择"><a href="#热土豆路由选择" class="headerlink" title="热土豆路由选择"></a>热土豆路由选择</h4><pre class="line-numbers language-none"><code class="language-none">在一台路由器转发表中对于热土豆路由器选择增加AS向外前缀的步骤：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>1.从AS间协议学到经过多个网关可达子网x。</p>
<p>2.使用来自AS内部协议的路由选择信息，以决定到达每个网关的最低开销路径的开销。</p>
<p>3.热土豆路由选择：选择具有最小最低开销的网关。</p>
<p>4.从转发表确定通往最低开销的网关的接口I。在转发表中加入表项（x, I）。</p>
<pre class="line-numbers language-none"><code class="language-none">路由选择特点：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>1.路由被指派一个本地偏好值作为其属性之一。一条路由的本地偏好可能由该路由器设置或可能在相同AS中的另一台路由器学习到。本地偏好属性的值是一种策略决定，它完全取决于该AS的网络管理员。具有最高本地偏好值的路由将被选择。</p>
<p>2.从余下的路由中（所有都具有相同的的最高本地偏好值），将选择具有最短AS-PATH的路由。</p>
<p>3.从余下的路由中（所有都具有相同的最高本地偏好值和相同的AS-PATH长度），使用热土豆路由选择，即选择具有最靠近NEXT-HOP路由器的路由。</p>
<p>4.如果仍留下多条路由，该路由器使用BGP标识符来选择路由。</p>
<h3 id="IP任意传播"><a href="#IP任意传播" class="headerlink" title="IP任意传播"></a>IP任意传播</h3><p>除了作为因特网的AS间路由选择协议外，BGP还常为用于实现IP任播服务，该服务通常同用于DNS中</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920170930087.png"></p>
<h2 id="SDN控制平面"><a href="#SDN控制平面" class="headerlink" title="SDN控制平面"></a>SDN控制平面</h2><h3 id="SDN体系结构有四个关键特征"><a href="#SDN体系结构有四个关键特征" class="headerlink" title="SDN体系结构有四个关键特征"></a>SDN体系结构有四个关键特征</h3><p><code>1.基于流的转发。</code>SDN的交换机分组转发工作，能够基于运输层、网络层或链路层首部中任意数量的首部字段值进行。</p>
<p><code>2.数据平面与控制平面分离。</code> 数据平面由网络交换机组成，交换机是相对简单（但快速）的设备，该设备在它们的流表中执行“匹配加动作”的规则。控制平面由服务器以及决定和管理交换机流表的软件组成。</p>
<p><code>3.网络控制功能。</code> 位于数据平面的交换机外部。软件在服务器上执行，该服务器与网络交换机截然分开且与之远离。控制平面自身由两个组件组成：一个SDN控制器，以及若干网络控制应用程序。控制器维护准确的网络状态信息；为运行在控制平面的中的网络控制应用程序提供这些信息；提供方法，这些应用程序通过这些方法能够监视、编程和控制下面的网络设备。</p>
<p><code>4.可编程的网络。</code> 通过运行在控制平面中的网络控制应用程序，该网络是可编程的。这些应用程序代表了SDN控制平面的“智力”，使用了由SDN控制器提供的API来定义和控制网络设备中的数据平面。</p>
<h3 id="SDN控制器的功能大体可组织为3个"><a href="#SDN控制器的功能大体可组织为3个" class="headerlink" title="SDN控制器的功能大体可组织为3个"></a>SDN控制器的功能大体可组织为3个</h3><p><code>通信层。</code> SDN控制器和受控网络设备之间的通信。显然，如果SDN控制器要控制远程SDN使能的交换机、主机或其他设备的运行，需要一个协议来传送控制器与这些设备之间的信息。此外，设备必须能够向可知其传递本地观察到的时间。这些时间向SDN控制器提供该网络状态的最新视图。这个协议构成了控制器体系结构的最底层。</p>
<p><code>网络范围状态管理层。</code> 由SDN控制平面所做出的最终控制决定，将要求控制器具有有关网络的主机、链路、交换机和其他SDN控制设备的最新状态信息。交换机的流表包含计数器，其值也可以由网络控制应用程序很好地使用；因此这些值应当为应用程序所用。</p>
<p><code>对于网络控制应用程序层的接口。</code> 控制器通过接口与网络控制应用程序交互。该API允许网络控制应用程序在状态管理层之间读/写网络状态和流表。当状态改变事件出现时，应用程序能够注册进行通告。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920171000739.png">OpenFlow协议</p>
<p>OpenFlow协议运行在TCP之上，使用6653的默认端口号。从控制器到受控交换机流动的重要报文有下列这些：</p>
<ul>
<li><code>配置。</code> 该报文允许控制器查询并设置交换机的配置参数。</li>
<li><code>修改状态。</code> 该报文由控制器所使用，以增加/删除或修改交换机流表中的表项，并且设置交换机端口特性。</li>
<li><code>读状态。</code> 该报文被控制器用于从交换机的流表和端口收集统计数据和计数器值。</li>
<li><code>发送分组。</code> 该报文被控制器用于在受控交换机从特定的端口发送出一个特定的报文。</li>
</ul>
<p>从受控交换机到控制器流动的重要报文有下列这些：</p>
<ul>
<li><code>流删除。</code> 该报文通知控制器已删除一个流表项，例如由于超时，或作为收到“修改状态”报文的结果。</li>
<li><code>端口状态。</code> 交换机用该报文向控制器通知端口状态的变化。</li>
<li><code>分组入。</code> 一个分组到达交换机端口，并且不能与任何流表项匹配，那么这个分组将被发送给控制器进行额外处理。匹配的分组也被发送给控制器，作为匹配是所采取的一个动作。“分组入”报文被用于将分组发送给控制器。</li>
</ul>
<h2 id="ICMP（因特网控制报文协议）"><a href="#ICMP（因特网控制报文协议）" class="headerlink" title="ICMP（因特网控制报文协议）"></a>ICMP（因特网控制报文协议）</h2><p>为了更有效的提高ip数据报的成功转发和交付的效率，在网际层使用了icmp网际控制报文协议，这个协议允许主机和路由器提供差错和异常情况的报告，icmp不是高层协议，而是网际层的协议，加在ip数据报中一起发出。</p>
<p>ICMP报文通过ip报文发送，ICMP报文当做是ip数据包的数据部分，而IP数据包又被放倒了以太网的数据帧中的数据区。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920171022334.png"></p>
<p>ICMP的报文种类有ICMP差错报文和ICMP询问报文：</p>
<p>差错报告报文有5种：</p>
<p>（1）终点不可以到达：当路由器和主机不能交付的时候：</p>
<p>（2）源点抑制：当路由器由于网络拥塞而丢弃的时候</p>
<p>（3）时间超过：当路由器收到生存时间为0的数据报的时候</p>
<p>（4）参数问题：当目的主机发现收到的数据报首部有问题的时候</p>
<p>（5）改变路由：路由器把改变你的路由交付主机，告诉下一次的主机</p>
<p>两种ICMP询问报文：</p>
<p>（1）ICMP请求与回答报文：主机和路由器向主机发送一个ICMP请求报文，目的主机发送一个ICMP回答报文，用来测试两方能否互相通信</p>
<p>（2）ICMP时间戳请求与回答报文：ICMP时间戳报文请某个主机和路由器回答当前的时间，ICMP回答时间戳是一个32位的字段，其中写入的整数表示从<br>1900/1/1到现在的秒数</p>
<p>ICMP报文有一个类型字段和一个编码字段，并且包含引起该ICMP报文首次生成的IP数据报的首部和前8个字节。表5-1列出了所选的ICMP报文类型</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920171034509.png"></p>
<h3 id="网络管理和SNMP"><a href="#网络管理和SNMP" class="headerlink" title="网络管理和SNMP"></a>网络管理和SNMP</h3><p>网络管理包括了硬件、软件和人类元素的设置、综合和协调，以监视、测试、轮询、配置、分析、评价和控制网网络及网元资源，用合理的成本满足实时性、运营性能和服务质量的要求。</p>
<h4 id="网络管理的关键组件"><a href="#网络管理的关键组件" class="headerlink" title="网络管理的关键组件"></a>网络管理的关键组件</h4><p>1.<code>管理服务器</code> 是一个应用程序，通常有人的参与，并运行在网络运营中心的集中式网络管理的工作站上。管理服务器是执行网络管理活动的地方，它控制网络管理信息的收集、处理、分析和/或显示。正是在这里，发起控制网络行为的动作，人类网络管理员与网络设备打交道。</p>
<p>2.<code>被管设备</code> 是网络装备的一部分，位于被管理的网络中。在一个被管设备中，有几个所谓<code>被管对象。</code> 这些被管对象是被管设备中硬件的实际部分和用于这些硬件及软件组件的配置参数。</p>
<p>3.一个被管设备中的每个被管对象的关联信息收集在<code>管理信息库（Management Information Base, MIB）</code> 中，这些信息的值可供管理服务器所用。MIB对象由称为SMI（Strcture of Management Information）的数据语言所定义。</p>
<p>4.在每个被管设备中还驻留有<code>网络管理代理。</code> 它是运行在被管设备中的一个进程，该进程与管理服务器通信，在管理服务器的命令和控制下载被管设备中采取本地动作。</p>
<p>网络管理框架的最后组件是<code>网络管理协议。</code> 该协议运行在管理服务器和被管设备之间，允许管理服务器查询被管设备的状态，并经过其代理间接地在这些设备上采取行动。代理能够使用网络管理协议向管理服务器通知异常事件。重要的是网络管理协议自己不能管理网络。恰恰相反，它为网络管理员提供了一种能力，使他们能够管理网络。</p>
<p><code>简单网络管理协议版本2（SNMPv2）是一个应用层协议,</code>用于在管理服务器和代表管理服务器执行的代理之间传递网络管理控制和信息报文。SNMP最常使用的是请求响应模式，其中SNMP管理服务器向SNMP代理发送一个请求，代理接收到该请求后，执行某些动作，然后对该请求发送一个回答。请求通常用于查询或修改与某被管设备关联的MIB对象值。SNMP第二个常被使用的是代理向管理服务器发送的一种非请求报文，该报文被称为陷阱报文。陷阱报文用于通知管理服务器，一个异常情况已经导致了MIB对象值的改变。表5-2中列出了SNMPv2定义的7种报文，这些报文一般称为协议数据单元（PDU）。SNMP PDU通常是作为UDP数据报的载荷进行传输的。<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920171053187.png"></p>
<h2 id="六、链路层和局域网"><a href="#六、链路层和局域网" class="headerlink" title="六、链路层和局域网"></a>六、链路层和局域网</h2><pre class="line-numbers language-none"><code class="language-none">链路层信道分为两种：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>广播信道</code>:局域网,无限LAN,卫星和混合光纤</p>
<pre class="line-numbers language-none"><code class="language-none">点对点的通信链路<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="链路层的概念"><a href="#链路层的概念" class="headerlink" title="链路层的概念"></a>链路层的概念</h2><p>运行链路层协议的任何设备称为<code>节点</code>。把沿着通信路径连接相邻节点的通信信道称为<code>链路</code></p>
<p>链路层采取的动作包括了差错检测,重传,流量控制以及随机接入</p>
<p><code>特点:</code>数据报在不同的链路可以使用不同的协议</p>
<h3 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h3><p><code>成帧:</code>在每个网络层数据报经链路传送之前，几乎所有的链路层协议都要将其用链路层帧封装起来。一个帧由一个数字字段和若干首部字段组成，其中网络层数据报就插在数据字段中。帧的结构由链路层协议规定。</p>
<p><code>链路接入:</code>媒体访问控制协议（Medium Access Control, MAC）协议规定了帧在链路上传输的规则。</p>
<p><code>可靠交付:</code>当链路层协议提供可靠交付服务时，它保证无差错地经链路层移动每个网络层数据报。</p>
<p><code>差错检测和纠正:</code>当帧中的一个比特作为1传输时，接收方节点中的链路层硬件可能不正确地将其判断为0，反之亦然。这种比特差错是由信号衰减和电磁噪声导致的。因为没有必要转发一个有差错的数据报，所以许多链路层协议提供一种机制来检测这样的比特差错。通过让发送节点在帧中包含差错检测比特，让接收节点进行差错检查，以此来完成这项工作。</p>
<h3 id="链路层在何处实现"><a href="#链路层在何处实现" class="headerlink" title="链路层在何处实现"></a>链路层在何处实现</h3><p>链路层的主体部分是在 <strong>网络适配器</strong> 中实现的，网络适配器有时也称为 <strong>网络接口卡</strong> ，位于适配器核心的是链路层控制器，这个控制器是实现许多链路层服务的专用芯片。链路层控制器的许多功能使用硬件是实现的。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920171439649.png"></p>
<h2 id="差错检测和纠正技术"><a href="#差错检测和纠正技术" class="headerlink" title="差错检测和纠正技术"></a>差错检测和纠正技术</h2><p>在发送节点，为了保护比特免受差错，使用 <strong>差错检测和纠正比特（Error-Detection and-Correction, EDC）</strong> 来增强数据D。通常，要保护的数据不仅包括从网络层传递下来需要通过链路传输的数据报，而且包括链路帧首部中的链路的寻址信息、序号和其他字段。链路级中的D和EDC都被发送到接收节点</p>
<h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p><code>奇偶校验</code>使用单个奇偶校验位。假设要发送的信息D有d比特。在偶校验方案中，发送方只需包含一个附加的比特，选择它的值，使得这d + 1比特中1的总数是偶数。对于奇校验方案，选择校验比特值使得有奇数个1。接收方只需要数一数接收的d + 1比特中1的数目即可。如果在采用偶校验方案中发现了奇数个值为1的比特，接收方知道出现了奇数个比特差错。</p>
<p><code>二维奇偶校验</code>方案中，D中的d个比特被划分为i行j列。对每行和每列计算奇偶值。产生的i + j + 1奇偶比特构成了链路层帧的差错检测比特。包含比特值改变的列和行的校验值都将会出现差错。因此接收方不仅可以检测到出现了单个比特差错的事实，而且还可以利用存在就校验差错的列和行的索引来实际识别发生差错的比特并纠正它。</p>
<h3 id="校验和方法"><a href="#校验和方法" class="headerlink" title="校验和方法"></a>校验和方法</h3><p><code>检验和</code> 技术中，数据的字节作为16比特的整数对待并求和。这个和的反码形成了携带在报文段首部的因特网检验和。接收方通过对接收的数据的和取反码，并且检测其结果是否全为1比特来检测检验和。如果这些比特中有任何比特是0，就可以指示出差错。</p>
<h3 id="循环冗余检测"><a href="#循环冗余检测" class="headerlink" title="循环冗余检测"></a>循环冗余检测</h3><p>现今的计算机网络中广泛应用的差错检测技术基于<code>循环冗余检测（Cyclic Redundancy Check, CRC）</code>。CRC编码也称为多项式编码，因为该编码能够将要发送的比特串看作为系数是0和1一个多项式，对比特串的操作被解释为多项式算术。</p>
<p>假设发送节点要发送一个d比特的数据D给接收节点。发送方和接收方首先必须协商一个r + 1比特模式，称为生成多项式，将其表示为G。要求G的最高有效比特是1。对于一个给定的数据段D，发送方要选择r个附加比特R，并将它们附加到D上，使得得到的d + r比特模式用模2算术恰好能被G整除。接收方用G去除接收到的d + r比特。如果余数非0，接收方知道出现了差错；否则认为数据正确而被接收。</p>
<pre class="line-numbers language-none"><code class="language-none">求附加比特R的公式:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920171510312.png"></p>
<p>其中remainder表示求余数。</p>
<p>国际标准定义的32比特生成多项式为</p>
<p>GCRC-32 = 100000100110000010001110110110111</p>
<p>每个CRC标准都能检测小于r + 1比特的突发差错。此外，在适当的假设下，长度大于r + 1比特的突发差错以概率1 – 0.5r被检测到。每个CRC标准也都能检测任何奇数个比特差错。</p>
<h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><p>有两种类型的网络链路：<code>点对点链路</code>和<code>广播链路</code>。点对点链路由链路一端的单个发送方和链路另一端的单个接收方组成。许多链路层协议都是为点对点链路设计的，如点对点协议（point-to-point protocol, PPP）和高级数据链路控制（high-level data link control, HDLC）就是两种这样的协议。广播链路能够让多个发送和接收节点都连接到相同的、单一的、共享的广播信道上。</p>
<pre class="line-numbers language-none"><code class="language-none">对于速率为R bps的广播信道，多路访问协议应该具有以下所希望的特性：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>当仅有一个节点发送数据时，该节点具有R bps的吞吐量；</li>
<li>当有M个节点发送数据时，每个节点吞吐量为R/M bps的平均传输速率；</li>
<li>协议是分散的，即不会因某节点故障而使整个系统崩溃；</li>
<li>协议是简单的，使实现不昂贵。</li>
</ul>
<h3 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h3><pre class="line-numbers language-none"><code class="language-none">多路访问协议有三种：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>信道划分协议</li>
<li>随机接入协议</li>
<li>轮流协议</li>
</ul>
<p>假设一个支持N个节点的信道且信道的传输速率为R bps。TDM将时间划分为时间帧，并进一步划分每个时间帧为N个时隙。然后把每个时隙分配给N个节点中的一个。无论何时某个节点在有分组要发送的时候，它在循环的TDM帧中指派给它的时隙内传输比特。TDM使每个节点在每个帧时间内得到了专用的传输速率，R/N bps。然而它由两个主要缺陷。首先，节点被限制于R/N bps的平均速率，即使当它是唯一有分组要发送的节点时。其次，节点必须总是等待它在传输序列中的轮次</p>
<p>FDM将R bps信道划分为不同的频段，并把每个频率分配给N个节点中的一个。因此FDM在较大的R bps信道中创建了N个较小的R/N bps信道。FDM避免了碰撞，在N个节点之间公平地划分了带宽。然而限制一个节点只能使用R/N的带宽，即使当它是唯一一个有分组要发送的节点时</p>
<p>CDMA对每个节点分配一种不同的编码。然后每个节点用它唯一的编码来对它发送的数据进行编码。如果精心选择这些编码，CDMA网络具有一种特性，即不同的节点能够同时传输，并且它们各自相应的接收方仍能正确接收发送方编码的数据比特，而不在乎其他节点的干扰传输。</p>
<h3 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h3><p>在随机接入协议中，一个传输节点总是以信道的全部速率进行发送。当有碰撞时，设计碰撞的每个节点反复地重发它的帧，到该帧无碰撞地通过为止。但是当一个节点经历一次碰撞时，它不必立即重发该帧。相反，它在重发该帧之前等待一个随机时延。涉及碰撞的每个节点独立地选择随机时延。因为该随机实验是独立地选择的，所以下述现象是有可能的：这些节点之一所选择的时延充分小于其他碰撞节点的时延，并因此能够无碰撞地将它的帧在信道中发出</p>
<h4 id="时隙ALOHA协议"><a href="#时隙ALOHA协议" class="headerlink" title="时隙ALOHA协议"></a>时隙ALOHA协议</h4><pre class="line-numbers language-none"><code class="language-none">时隙ALOHA假设:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>所有帧由L比特组成。</li>
<li>时间被划分成长度为L/R秒的时隙（这就是说，一个时隙等于传输一帧的时间）。</li>
<li>节点只是在时隙起点开始传输帧。</li>
<li>节点是同步的，每个节点都知道时隙何时开始。</li>
<li>如果在一个时隙中有两个或者更多个帧碰撞，则所有节点在该时隙结束之前检测到该碰撞事件。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">令p是一个概率，即一个在0和1之间的数。在每个节点中，时隙ALOHA的操作是<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>当节点有一个新帧要发送时，它等到下一个时隙开始并在该时隙传输整个帧。</li>
<li>如果没有碰撞，该节点成功地传输它的帧，从而不需要考虑重传该帧。</li>
<li>如果有碰撞，该节点在时隙结束之前检测到这次碰撞。该节点以概率p在后续的每个时隙中重传它的帧，直到该帧被无碰撞地传输出去。</li>
</ul>
<h5 id="时隙ALOHA的优点"><a href="#时隙ALOHA的优点" class="headerlink" title="时隙ALOHA的优点"></a>时隙ALOHA的优点</h5><ul>
<li>当某节点是唯一活跃的节点时，时隙ALOHA允许该节点以全速R连续传输。时隙ALOHA也是高度分散的，因为每个节点检测碰撞并独立地决定什么时候重传。但是，当有N个活跃节点时，时隙ALOHA的效率是Np(1 – p)N – 1，这个表达式的最大值仅为1/e = 0.37。也就是说，当有大量活跃用户时，时隙ALOHA的最大效率只有37%。</li>
<li>时隙ALOHA协议要求所有的节点同步它们的传输，以在每个时隙开始时开始传播。在纯ALOHA中，当一帧首次到达，节点将立即以概率p重传该帧，否则，该节点等待一个帧传输时间。在此等待之后，它则以概率p传输该帧，或者以概率1 – p在另一个帧时间等待。纯ALOHA的最大效率仅为1/(2e)，这刚好是时隙ALOHA的一半</li>
</ul>
<h4 id="载波监听多路访问（CSMA）"><a href="#载波监听多路访问（CSMA）" class="headerlink" title="载波监听多路访问（CSMA）"></a>载波监听多路访问（CSMA）</h4><p><code>载波侦听。</code>即一个节点在传输前先听信道。如果来自另一个节点的帧正向信道上发送，节点则等待直到检测到一小段时间没有传输，然后开始传输。（说话之前监听）</p>
<p><code>碰撞检测。</code>CSMA没有进行碰撞检测；即使已经出现了碰撞。而CSMA/CD进行碰撞检测。碰撞检测，即当一个传输节点在传输时一直在侦听此信道。如果它检测到另一个节点正在传输干扰帧，它就停止传输，在重复“侦听-当空闲时时传输”循环之前等待一段随机时间。（如果与他人同时说话，停止说话）</p>
<p>广播信道的端到端 <strong>信道传播时延</strong> 在决定性能的反面决定关键的作用，传播时延越长，载波监听节点不能侦听到网络到另一个节点已经传输的机会越大。</p>
<h4 id="具有碰撞的载波监听多路访问（CSMA-CD）"><a href="#具有碰撞的载波监听多路访问（CSMA-CD）" class="headerlink" title="具有碰撞的载波监听多路访问（CSMA/CD）"></a>具有碰撞的载波监听多路访问（CSMA/CD）</h4><h5 id="CSMA-CD的运行步骤"><a href="#CSMA-CD的运行步骤" class="headerlink" title="CSMA/CD的运行步骤"></a>CSMA/CD的运行步骤</h5><ul>
<li>适配器从网络层一条获得数据报，准备链路层帧，并将其放入帧适配器缓存中。</li>
<li>如果适配器侦听到信道空闲，它开始传输帧。在另一方面，如果适配器侦听到信道正在忙，它将等待，直到侦听到没有信号能量时才开始传输帧。</li>
<li>在传输过程中，适配器监视来自其他使用该广播信道的适配器的信号能量的存在。</li>
<li>如果适配器传输整个帧而未检测到来自其他适配器的信号能量，该适配器就完成了该帧。在另一方面，如果适配器在传输时检测到来自其他适配器的信号能量，它中止传输。</li>
<li>中止传输后，适配器等待一个随机时间量，然后返回步骤2。</li>
</ul>
<h5 id="CSMA-CD效率"><a href="#CSMA-CD效率" class="headerlink" title="CSMA/CD效率"></a>CSMA/CD效率</h5><p>CSMA/CD使用 <strong>二进制指数后退算法</strong> ，使得当碰撞节点数量较少时，节点等待的时间间隔较短；当碰撞节点数量较大时，时间间隔较长。当传输一个给定帧时，在该帧经历了一连串n此碰撞后，节点随机地从{0, 1, 2, …, 2n – 1}中选择一个K值。因此，一个帧经历的碰撞越多，K选择的间隔越大。对于以太网，一个节点等待实际时间量是K ∙ 512比特时间（即发送512比特进入以太网所需的时间量的K倍，n能够取的最大值为10。</p>
<p>CSMA/CD效率定义：当有大量的活跃节点，且每个节点有大量帧要发送时，帧在信道中无碰撞地传输的那部分时间在长期运行时间中所占的份额。令dprop表示信号能量在任意两个适配器之间传播所需的最大时间。令dtrans表示传输一个最大长度的以太网帧的时间。则CSMA/CD的效率为</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920171913258.png"></p>
<h3 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h3><pre class="line-numbers language-none"><code class="language-none">轮流协议主要有两种：轮询协议和令牌传递协议。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h4><p>轮询协议要求节点之一要被指定为主节点。主节点以循环的方式轮询每个节点。轮询协议消除了困扰随机接入协议的碰撞和空时隙，这使得轮询取得高得多的效率。但是它也有一些缺点。第一，该协议引入了轮询时延，即通知一个节点“它可以传输”所需的时间。第二，如果主节点有故障，整个信道都变得不可操作。</p>
<h4 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h4><p>令牌传递协议中没有主节点。一个成为令牌的小的特殊帧在节点之间以某种固定的次序进行交换。当一个节点收到令牌时，仅当它有一些帧要发送时，它才持有这个令牌，并发送最大数目的帧数，然后把令牌转发给下一个节点；否则它立即向下一个节点转发该令牌。令牌传递是分散的，并有很高的效率。但是一个节点的故障可能会使整个信道崩溃。或者如果一个节点偶然忘记了释放令牌，则必须调用某些恢复步骤使令牌返回到循环中来。</p>
<h3 id="DOCSIS：用于电缆因特网接入的链路层协议"><a href="#DOCSIS：用于电缆因特网接入的链路层协议" class="headerlink" title="DOCSIS：用于电缆因特网接入的链路层协议"></a>DOCSIS：用于电缆因特网接入的链路层协议</h3><p>一个电缆接入网通常在电缆网头端将几千个住宅电缆调制解调器与一个电缆调制解调器端接系统（Cable Modem Termination System, CMTS）连接。数据经电缆服务接口（Data-Over-Cable Service Interface, DOCSI）规范（DOCSIS）定义了电缆数据网络体系结构及其协议。</p>
<h3 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h3><p> <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920171932476.png"></p>
<h3 id="链路层寻址和ARP"><a href="#链路层寻址和ARP" class="headerlink" title="链路层寻址和ARP"></a>链路层寻址和ARP</h3><p><strong>地址解析协议（ARP）</strong> 提供了将IP地址转换为链路层地址的协议</p>
<h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>1.主机或路由器的适配器（即网络接口）具有链路层地址。链路层地址有各种不同的称呼：LAN地址、物理地址或MAC（Medium Access Control）地址。MAC地址是最为流行的术语。</p>
<p>2.没有两块适配器具有相同的地址。适配器的MAC地址具有扁平结构，而且不论适配器到哪里用都不会变化。</p>
<p>3.MAC地址的长度为6字节，共有6的48次方的可能的MAC地址，6个字节的地址常用16进制表示法，地址的每个字节表示一对十六进制数</p>
<h5 id="主机和路由器接口除了网络层地址之外还有MAC地址的原因"><a href="#主机和路由器接口除了网络层地址之外还有MAC地址的原因" class="headerlink" title="主机和路由器接口除了网络层地址之外还有MAC地址的原因"></a>主机和路由器接口除了网络层地址之外还有MAC地址的原因</h5><p>局域网是为任意网络层协议而设计的，而不只是用于IP和因特网。</p>
<p>如果适配器使用网络层地址而不是MAC地址的话，网络层地址必须存储在适配器的RAM中，并且在每次适配器移动时要重新配置。<img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172010656.png"></p>
<h4 id="地址解析协议"><a href="#地址解析协议" class="headerlink" title="地址解析协议"></a>地址解析协议</h4><p>1.<code>地址解析协议（Address Resolution Protocol, ARP）</code>用于在网络层地址（比如因特网的IP地址）和链路层地址(MAC地址)之间进行转换。ARP只为在同一个子网上的主机和路由器接口解析IP地址。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172054334.png"></p>
<p>2.每台主机或路由器在其内存中具有一个ARP表，这张表包含IP地址到MAC地址的映射关系。该ARP表也包含一个寿命值，它指示了从表中删除每个映射的时间。</p>
<p>3.假定主机A要向主机B发送一个数据报，该数据报要IP寻址到本子网上另一台主机或路由器。发送主机需要获得给定IP地址的目的主机的MAC地址。如果发送方的ARP表具有该目的节点的表项，则直接通过查询ARP表即可完成任务。如果ARP表中当前没有该目的主机的表项，发送方构造一个称为ARP分组的特殊分组。一个ARP分组有几个字段，包括发送和接收IP地址及MAC地址。ARP查询分组和响应分组都具有相同的格式。ARP查询分组的目的是询问子网上所有其他主机和路由器，以确定对应于要解析的IP地址的那个MAC地址</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172104982.png"></p>
<p>4.查询ARP报文是在广播帧中发送的，而响应ARP报文在一个标准帧中发送。ARP是即插即用的，即一个ARP表是自动建立的，它不需要系统管理员来配置。并且如果某主机与子网断开连接，它的表项最终会从留在子网中的节点的表中删除掉。</p>
<h5 id="ARP协议原理"><a href="#ARP协议原理" class="headerlink" title="ARP协议原理"></a>ARP协议原理</h5><p>1.如果要通过IP来得到同一子网上的主机MAC地址；过程是这样的：首先源主机会看看自己的ARP机制的内存里有没有对应的IP MAC项，有就直接输出目标MAC地址；没有的话就需要ARP发送一个查询分组，分组以广播的形式发送，也就是每一个主机都能收到这个查询分组，收到之后，各个被询问的主机会先看看 目标IP是不是与自己的IP对应，不对应就不用响应，对应的就应该返回一个响应分组。这样源主机的ARP机制就有了目的IP地址的MAC地址了。</p>
<p>2.通过目标IP获得子网以外的主机的MAC地址；首先，源主机有了目的主机的IP地址，假想我们通过某种手段已经得到了目的主机的MAC地址了，那现在是不是就可以直接放入数据帧里面呢，显然是不行的，因为目前看来，目的MAC地址与当前的任何一个路由的MAC地址都不匹配。任何路由都不会给与转发。事实上是这样的，我们有了目标IP地址，通过路由算法得到了最短路径的转发表，我们每一次转发不是直接用目标主机的IP地址的，而是用路由表中给出的每一跳的地址，这样，先得到通往外网的第一个路由的MAC地址，现在关键来了：由于在外网中路由器的一个IP对应一个MAC，他也是通过ARP查询得到与他匹配的IP再得到返回的MAC地址的。就这样得到外网路由的第二个MAC地址，这样直到终点</p>
<h4 id="发送数据报到子网以外"><a href="#发送数据报到子网以外" class="headerlink" title="发送数据报到子网以外"></a>发送数据报到子网以外</h4><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172124649.png"></p>
<p>每台主机仅有一个IP地址和一个适配器，一台路由器对它的每个接口都有一个IP地址，也有一个ARP模块和一个适配器，每个适配器都有自己的MAC地址</p>
<h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>1.如果某台主机要向子网外的另一台主机发送数据报，则发送主机必须首先发送给最终目的路径上的第一跳路由器</p>
<p>2.初始的以太网是使用总线拓扑的一种广播局域网，即所有的帧传送到与该总线连接的所有适配器并被其处理。</p>
<p>3.在20世纪90年代后期，大多数公司和大学使用一种基于集线器的星形拓扑以太网安装替代了它们的局域网。在这种安装中，主机和路由器直接用双绞对铜线与一台 <strong>集线器</strong> 相连。集线器是一种物理层设备，它作用于各个比特而不是作用于帧。当表示一个0或一个1的比特到达一个接口时，集线器只是重新生成这个比特，将其能量强度放大，并将该比特向其他所有接口传输出去。</p>
<p>4.在21世纪初，以太网又经历了一次重要的革命性变化。以太网安装继续使用星形拓扑，但是位于中心的集线器被 <strong>交换机</strong> 所替代。</p>
<h4 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h4><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172140701.png"></p>
<pre class="line-numbers language-none"><code class="language-none">太网帧有以下6个字段<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><code>数据字段（46~1500字节）。</code>这个字段承载了IP数据报。以太网的最大传输单元是1500字节。这意味着如果IP数据报超过了1500字节，则主机必须将该数据报分片。数据字段的最小长度是46字节。这意味着如果IP数据报小于46字节，数据报必须被填充到46字节。当采用填充时，传递到网络层的数据包括IP数据报和填充部分。网络层使用IP数据报首部中的长度字段来去除填充部分。</li>
<li><code>目的地址（6字节）。</code>这个字段包含目的适配器的MAC地址。当适配器收到一个以太网帧，帧的目的地址如果和该适配器MAC地址相同或为广播地址，则它都将该帧的数据字段的内容传递给网络层；如果它受到了具有任何其他MAC地址的帧，则丢弃之。</li>
<li><code>源地址（6字节）。</code>这个地段包含了传输该帧到局域网上的适配器的MAC地址。</li>
<li><code>类型字段（2字节）。</code>类型字段允许以太网复用多种网络层协议。</li>
<li><code>CRC（4字节）。</code>CRC字段的目的时使得接收器检测帧中是否引入了差错。</li>
<li><code>前同步码（8字节）。</code>以太网帧以一个8字节的钱同步码字段开始。该前同步码的前7个字节的值都是10101010；最后一个字节时10101011。前同步码字段的前7字节用于“唤醒”接收适配器，并且将它们的时钟和发送方的时钟同步。前同步码的第8个字节的最后两个比特警告接收适配器，“重要的内容“就要到来了。</li>
</ul>
<h4 id="以太网技术"><a href="#以太网技术" class="headerlink" title="以太网技术"></a>以太网技术</h4><p>所有的以太网技术都向网络层提供无连接服务和不可靠服务。</p>
<h3 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h3><p>交换机自身对子网中的主机和路由器是透明的，某主机/路由器向另一个主机/路由器寻址一个帧（而不是向交换机寻址该帧），顺利将该帧发送进局域网，并不知道某交换机将会接收该帧并将该帧转发到另一个节点</p>
<h4 id="交换机的转发和过滤"><a href="#交换机的转发和过滤" class="headerlink" title="交换机的转发和过滤"></a>交换机的转发和过滤</h4><p><code>过滤</code>是决定一个帧应该转发到某个接口还是应当将其丢弃的交换机功能。</p>
<p><code>转发</code>是决定一个帧应该被导向哪个接口，并把该帧移动到那些接口的交换机功能。交换机的过滤和转发借助于<code>交换机表</code>完成。</p>
<p>该交换机表发函某局域网上某些主机和路由器的但不必是全部的表项。交换机表中的一个表项包含：一个MAC地址；通向该MAC地址的交换机接口；表项放置在表中的时间。</p>
<pre class="line-numbers language-none"><code class="language-none">假定目的地址为A的帧从交换机接口x到达。交换机用地址A索引它的表。有3种可能的情况<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>表中没有对于A的表项。在这种情况下，交换机向除接口x外的所有接口前面的输出缓存转发该帧的副本。换言之，如果没有对于目的地址的表项，交换机广播该帧。</li>
<li>表中有一个表项将A与接口x联系起来。在这种情况下，该帧从包括适配器A的局域网网段到来。无须将该帧转发到任何其他接口，交换机将通过丢弃该帧执行过滤功能即可。</li>
<li>表中有一个表项将A与接口y ≠ x联系起来。在这种情况下，该帧需要被转发到与接口y相连的局域网网段。交换机通过将该帧放到接口y前面的输出缓存完成转发功能。</li>
</ul>
<h4 id="自学习"><a href="#自学习" class="headerlink" title="自学习"></a>自学习</h4><p>交换机的表是自动、动态和自治地建立的，即没有来自网络管理员或来自配置协议的任何干预。即交换机的<code>自学习</code>的。这种能力是以如下方式实现的：<br>交换机表初始为空。</p>
<ul>
<li>对于在每个接口接受到的每个入帧，该交换机在其表中存储：在该帧源地址字段中的MAC地址；该帧到达的接口；当前时间。交换机以这种方式在它的表中记录了发送节点所在的局域网网段。</li>
<li>如果在一段时间（称为老化期）后，交换机没有接收到以该地址作为源地址的帧，就在表中删除这个地址。</li>
</ul>
<h4 id="交换机的性质"><a href="#交换机的性质" class="headerlink" title="交换机的性质"></a>交换机的性质</h4><ol>
<li><strong>消除碰撞。</strong> 在使用交换机构建的局域网中，没有因碰撞而浪费的贷款。交换机缓存帧并且决定不会在网段上同时传输多余一个帧。因此，交换机提供了比使用广播链路的局域网高得多的性能改善。</li>
<li><strong>异质的链路。</strong> 交换机将链路彼此隔离，因此局域网中的不同链路能够以不同的速率并且能够在不同的媒体上运行。因此，对于原有的设备与新设备混用，交换机是理想的。</li>
<li><strong>管理。</strong> 除了提供强化的安全性，交换机也易于进行网络管理。</li>
</ol>
<h4 id="交换机和路由器比较"><a href="#交换机和路由器比较" class="headerlink" title="交换机和路由器比较"></a>交换机和路由器比较</h4><p>1.交换机是即插即用的；交换机能够具有相对高的分组过滤和转发速率；交换机必须处理高至第二层的帧，而路由器必须处理高至第三层的数据报；为了防止广播帧的循环，交换网络的活跃拓扑限制为一颗生成树。另外，一个大型交换网络将要求在主机和路由器中有大量的ARP表，这将生成客观的ARP流量和处理量。而且，交换机对于广播风暴并不提供任何保护措施。</p>
<p>2.因为网络殉职通常是分层次的，即使当网络中存在冗余路径时，分组通常也不会通过路由器循环。所以，分组不会被限制到一颗生成树上，并可以使用源和目的地之间的最佳路径。路由器对第二层的广播风暴提供了防火墙保护。路由器不是即插即用的，即路由器和连接到它们的主机都需要人为地配置IP地址。而且路由器对每个分组的处理时间通常比交换机更长，因为它们必须处理高达第三层的字段。</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172210459.png"></p>
<h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><p>现代机构的局域网配置为等级结构的，每个工作组都有自己的交换局域网，经过一个交换机等级与其他工作组交换局域网互联</p>
<p>三个缺点：</p>
<p>1.缺乏流量隔离</p>
<p>2.交换机的无效使用</p>
<p>3.管理用户</p>
<p><strong>可以用通过支持虚拟局域网（VLAN）的交换机来处理</strong></p>
<h2 id="链路虚拟化-网络作为链路层"><a href="#链路虚拟化-网络作为链路层" class="headerlink" title="链路虚拟化:网络作为链路层"></a>链路虚拟化:网络作为链路层</h2><h4 id="多协议标签交换（MPLS）"><a href="#多协议标签交换（MPLS）" class="headerlink" title="多协议标签交换（MPLS）"></a>多协议标签交换（MPLS）</h4><p>1.<code>多协议标签交换（Multiprotocol Label Switching, MPLS）</code>采用来自虚电路网络领域的一个关键概念：固定长度标签。其目标是：对于基于固定长度标签和虚电路的技术，在不放弃基于目的地IP数据报转发的基础设施的前提下，当可能时通过选择性地标识数据报并允许路由器基于固定长度的标签转发数据报来增强其功能。</p>
<p>2.在MPLS使能的路由器之间传输的一个链路层帧</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172231330.png"></p>
<p>包括在MPLS首部中的字段是：</p>
<p>标签；</p>
<p>预留的3比特实验字段；</p>
<p>1比特S字段，用于指示一系列“成栈”的MPLS首部的结束；</p>
<p>寿命字段</p>
<p>3.一个MPLS加强的帧仅能在两个均为MPLS使能的路由器之间发送。一个MPLS使能的路由器常被称为标签交换路由器，因为它通过在其转发表中查找MPLS标签，然后立即将数据报传递给适当的输出接口来转发MPLS帧。因此，MPLS使能的路由器不需要提取目的IP地址和在转发表中执行最长前缀匹配的查找</p>
<p>4.MPLS能够并且已经被用于实现所谓虚拟专用网（Virtual Private Network, VPN）</p>
<h2 id="数据中心网络"><a href="#数据中心网络" class="headerlink" title="数据中心网络"></a>数据中心网络</h2><p>1.每个数据中心都有自己的数据中心网络，这些数据中心网络将其内部主机彼此互联并与因特网中的数据中心互联。数据中心中的主机称为<code>刀片</code>，一般是包括CPU、内存和磁盘存储的商用主机。主机被堆迭在机架上，每个机架一般堆放20~40台刀片。在每一个机架顶部有一台交换机，这台交换机形象地被称为机架<code>顶部（Top of Rank, TOR）交换机</code>，它们与机架上的主机互联，并与数据中心中的其他交换机互联。具体来说，机架上的每台主机都有一块与TOR交换机连接的网卡，每台TOR交换机有额外的端口能够与其他TOR交换机连接。</p>
<p>2.数据中心网络支持两种类型的流量：在外部客户与内部主机之间流动的流量，以及内部主机之间流动的流量。为了处理外部客户与内部主机之间流动的流量，数据中心网络包括了一台或者多台<code>边界路由器</code>，它们将数据中心网络与公共因特网相连。数据中心网络因此需要将所有机架彼此互联，并将机架与边界路由器连接。</p>
<p>3.在数据中心内部，外部请求首先被定向到一个<code>负载均衡器</code>。负载均衡器的任务是向主机分发请求，以主机当前的负载作为函数来在主机之间均衡负载。一个大型数据中心通常会有几台负载均衡器，每台服务于一组特定的云引用。由于负载均衡器基于分组的目的端口号以及目的的IP地址做决策，因此它们常被称为“第四层交换机”。一旦接收到一个对于特定应用程序的请求，负载均衡器将该请求分发到处理该应用的某一台主机上。当主机处理完该请求后，向负载均衡器回送响应，再由负载均衡器将其中继发回给外部客户。负载均衡器不仅彭亨主机间的工作负载，而且还提供类似NAT的功能，将外部IP地址转换为内部适当主机的IP地址，然后将反方向流向客户的分组按照相反的转换进行处理。这防止客户直接接触主机，从而具有隐藏网络内部结构和防止客户直接与主机交互等安全益处。</p>
<p>4.数据中心网络的两个设计趋势是<code>全连接拓扑</code>和<code>模块化数据中心</code>。</p>
<h2 id="七、无线网络和移动网络"><a href="#七、无线网络和移动网络" class="headerlink" title="七、无线网络和移动网络"></a>七、无线网络和移动网络</h2><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ol>
<li><strong>基站</strong> 是无线网络基础设施的一个关键部分。基站在有线网络中没有明确的对应设备，它负责向与之关联的无线主机发送数据和从主机那里接收数据。基站通常负责协调与之相关联的多个无线主机的传输。当一台无线主机与某基站“相关联”时，表示该主机位于该基站的无线通信范围内；该主机使用该基站中继它和更大网络之间的数据。蜂窝网络中的 <code>蜂窝塔</code> 和802.11无线LAN中的 <code>接入点</code> 都属于基站。</li>
</ol>
<p>2.可以根据两个准则来对无线网络分类：</p>
<p>①在该无线网络中的分组是否跨越了一个无线跳或多个无线跳；</p>
<p>②网络中是否有诸如基站这样的基础设施。</p>
<ul>
<li>单跳，基于基础设施。 这些网络具有与较大的有线网络连接的基站。此外，该基站与无线主机之间的所有通信都经过一个无线跳。在教室、咖啡屋或图书馆中使用的802.11网络以及4G LTE数据网络都属于这种类型。</li>
<li>单跳，无基础设施。 在这些网络中，不存在与无线网络相连的基站。在这种单跳网络中的一个节点可以协调其他节点的传输。蓝牙网络和具有自组织模式的802.11网络属于这种类型。</li>
<li>多跳，基于基础设施。 在这些网络中，一个基站表现为以有线方式与较大网络相连。然而，某种无线节点为了经该基站通信，可能不得不通过其他无线节点中继它们的通信。某些无线传感网络和所谓的无线网状网络就属于这种类型。</li>
<li>多跳。无基础设施。 在这些网络中没有基站，并且节点为了到达目的地可能必须在几个其他无线节点之间中继报文。节点也可能是移动的，在多个节点中改变连接关系，一类网络被称为移动自组织网络（mobile ad hoc network, MANET）。如果该移动节点是车载的，该网络是车载自组织网络（vehicular ad hoc network, VANET）。</li>
</ul>
<h2 id="无线链路和网络特征"><a href="#无线链路和网络特征" class="headerlink" title="无线链路和网络特征"></a>无线链路和网络特征</h2><h4 id="无线链路和有线链路间重要的区别"><a href="#无线链路和有线链路间重要的区别" class="headerlink" title="无线链路和有线链路间重要的区别"></a>无线链路和有线链路间重要的区别</h4><ol>
<li><strong>递减的信号强度。</strong> 电磁波在穿过物体时强度将减弱。即使在自由空间中，信号仍将扩散，这使得信号强度随着发送方和接收方距离的增加而减弱（有时称其为路径损耗）。</li>
<li><strong>来自其他源的干扰。</strong> 在同一个频段发送信号的电波源将相互干扰。除了来自发送源的干扰，环境中的电磁噪声也能形成干扰。</li>
<li><strong>多径传播。</strong> 当电磁波的一部分受物体和地面反射，在发送方和接收方之间走了不同长度的路径，则会出现多径传播。这使得接收方收到的信号变得模糊。位于发送方和接收方之间的移动物体可导致多径传播随时间而改变。</li>
</ol>
<h4 id="信噪比（Signal-to-Noise-Ratio-SNR）"><a href="#信噪比（Signal-to-Noise-Ratio-SNR）" class="headerlink" title="信噪比（Signal-to-Noise Ratio, SNR）"></a>信噪比（Signal-to-Noise Ratio, SNR）</h4><p><strong>信噪比</strong> 是所受到的信号和噪声强度的相对测量。SNR的度量单位通常是分贝（dB）。以dB度量的SNR是这个比值的20倍，即接收到的信号的振幅与噪声的振幅的以10为底的对数的比值。比特差错率（BER）是在接收方收到的有错传输比特的概率。</p>
<p>1.对于给定的调制方案，SNR越高，BER越低。由于发送方通过增加它的传输功率就能够增加SNR，因此发送方能够通过增加它的传输功率来降低接收到差错帧的概率。然而，增加传输功率也会伴随着一些缺点：发送方必须消耗更多的能量，并且发送方的传输更可能干扰另一个发送方的传输。</p>
<p>2.对于给定的SNR，具有较高比特传输率的调制技术将具有较高的BER。</p>
<p>3.物理层调制技术的动态选择能用于适配对信道条件的调制技术。</p>
<h4 id="CMDA"><a href="#CMDA" class="headerlink" title="CMDA"></a>CMDA</h4><p>这个信号的变化速率（称为码片速率）比初始数据比特序列的变化速率快得多。假设初始数据比特到达CDMA编码其的速率定义了时间单元；也就是说，每个要发送的初始数据比特需要1比特时隙时间。</p>
<p>设di为第i个比特时隙中的数据比特值。为计算便利，把具有0值的数据比特表示为-1。每个比特时隙又进一步细分为M个微时隙。发送方使用的CDMA编码由M个值的一个序列cm组成，m = 1, …, M，每个取值为+1或-1。</p>
<p>对于第i个数据比特di。对于di比特传输时间的第m个微时隙，CDMA编码器的输出Zi,m是di乘以分配的CDMA编码的第m比特cm</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172347374.png"></p>
<p>对没有干扰的发送方，接收方将收到编码的比特Zi,m，并且恢复初始的数据比特di，计算如下：</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172357268.png"></p>
<p>然而，实际上的CDMA必须在存在干扰发送方的情况下工作，这些发送方用分配的不同编码来编码和传输它们的数据。但是当一个发送方的数据比特和其他发送方发送的比特混在一起时，CDMA发送方就需要其他的方法来恢复该发送方的初始数据比特。</p>
<p>CDMA的工作有一种假设，即对干扰的传输比特信号是加性的，这意味着，例如在同一个微时隙中，如果3个发送段都发送1，第4个发送端发送-1，那么在那个微时隙中所有的接收方接收的信号都是2。在存在多个发送方时，发送方s计算它编码后的传输计算方式与上面完全相同</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172409781.png"></p>
<p>然而在第i个比特时隙的第m个微时隙期间，接收方现在收到的值是那个微时隙中从所有N个发送方传输的比特总和：</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172429143.png" alt="image-20250920172429143"></p>
<p>如果仔细地选择发送方的编码，每个接收方只通过式*中的同样方式使用发送方的编码，就能从聚合的信号中恢复一个给定的发送方发送的数据：</p>
<p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172439656.png"></p>
<h2 id="Wife-802-11和无线Lan"><a href="#Wife-802-11和无线Lan" class="headerlink" title="Wife:802.11和无线Lan"></a>Wife:802.11和无线Lan</h2><p>IEEE 802.11 无限LAN，也成为wife</p>
<h3 id="802-11结构体系"><a href="#802-11结构体系" class="headerlink" title="802.11结构体系"></a>802.11结构体系</h3><p>1.802.11体系结构的基本构建模块是<code>基本服务集（Basic Service Set, BSS）</code>。一个BSS包含一个或多个无线站点和一个在802.11术语中成为<code>接入点（Access Point, AP）</code>的中央基站。</p>
<p>2.配置AP的无线LAN经常被称作基础设施无线LAN，其中的“基础设施”是指AP联通互联AP和一台路由器的有线以太网</p>
<h4 id="信道与关联"><a href="#信道与关联" class="headerlink" title="信道与关联"></a>信道与关联</h4><p>1.当网络管理员安装一个AP时，管理员为该接入点分配一个单字或双字的<code>服务器集标识符（Service Set Identifier, SSID）</code>。管理员还必须为该AP分配一个信道号。在802.11运行的85MHz的频段内，802.11定义了11个部分重迭的信道。当且仅当两个信道由4个或更多信道隔开时它们才无重迭。特别是信道1、6和11的集合是唯一的3个非重迭信道的集合。</p>
<p>2.<code>WiFi丛林</code>是一个任意物理位置，在这里无线站点能从两个或多个AP中收到很强的信号。为了获得因特网的接入，无线站点需要加入其中一个子网并因此需要与与其中的一个AP相<code>关联</code>。关联意味着这一无线站点在自身和该AP之间船舰一个虚拟线路。特别是，仅有关联的AP才向无线站点发送数据帧，并且该无线站点也仅仅通过该关联AP向因特网发送数据帧。</p>
<p>3.802.11标准要求每个AP周期性地发送<code>信标帧</code>，每个信标帧包括该AP的SSID和MAC地址。无线站点为了得知正在发送信标帧的AP，扫描11个信道，找出来自可能位于该区域的AP所发送的信标帧。通过信标帧了解到可用AP后，无线站点选择一个AP用于关联。</p>
<p>4.扫描信道和监听信标帧的过程被称为<code>被动扫描</code>。无线主机也能够执行<code>主动扫描</code>，这是通过向位于无线主机范围内的所有AP广播探测帧完成的。AP用一个探测响应帧应答探测请求帧。无线主机则能够在响应的AP中选择某AP与之相关联。选定与之相关联的AP后，无线主机向AP发送一个关联请求帧，并且该AP以一个关联响应帧进行响应。注意到对于主动扫描需要这种第二次请求/响应握手，因为一个对初始探测请求帧进行响应的AP并不知道主机选择哪个响应的AP进行关联。一旦与一个AP关联，该主机希望加入该AP所属的子网中。因此，该主机通常将通过关联的AP向该子网发送一个DHCP发现报文，以获取在该AP子网中的一个IP地址。一旦获得地址，网络的其他部分将直接视该主机为该子网中的另一台主机。</p>
<h3 id="802-11-MAC协议"><a href="#802-11-MAC协议" class="headerlink" title="802.11 MAC协议"></a>802.11 MAC协议</h3><p>802.11的设计者为802.11无线LAN选择了一种随机访问协议。这个随机访问协议称作带碰撞避免的CSMA（CSMA/CA）。尽管以太网和802.11都使用载波侦听随机接入，但这两种MAC协议有着重要的区别。首先，802.11使用碰撞避免而非碰撞检测。其次，由于无线信道相对较高的比特率，802.11使用链路层确认/重传方案</p>
<pre class="line-numbers language-none"><code class="language-none">802.11 MAC协议并未实现碰撞检测的原因：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>检测碰撞的能力要求站点具有同时发送和接收的能力。因为在802.11适配器上，接收信号的强度通常远远小于发送信号的强度，制造具有检测碰撞能力的硬件代价较大。</li>
<li>即使适配器可以同时发送和监听信号，适配器也会由于隐藏终端问题和衰减问题而无法检测到所有的碰撞。</li>
</ul>
<p>当无线LAN中某站点发送一个帧时，该帧会由于多种原因不能无损地到达目的站点。为了处理这种不可忽视的故障情况，802.11 MAC使用链路层确认。目的站点收到一个通过CRC校验的帧后，它等待一个被称作<code>短帧时间间隔（Short Inter-Frame Spacing, SIFS）</code>的一小段时间，然后发回一个确认帧，如果发送站点在给定的时间内未收到确认帧，它假定出现了错误并重传该帧，使用CSMA/CA协议访问该信道。如果在若干固定次重传后仍未收到确认，发送站点将放弃发送并丢弃该帧。</p>
<p><code>10.802.11的CSMA/CA协议的内容：</code><br>假设一个站点有一个帧要发送。</p>
<ul>
<li>如果某站带你最初监听到某信道空闲，它将在一个被称作分布式帧间间隔（Distributed Inter-Frame Space, DIFS）的短时间段后发送该帧。</li>
<li>否则，该站点选取一个随机回退值并且在侦听信道空闲时递减该值。当侦听到信道忙时，计数值保持不变。</li>
<li>当计数值减为0时，该站点发送整个数据帧并等待确认。</li>
<li>如果收到确认，发送站站点知道它的帧以被目的站正确接收了。如果该站点要发送另一帧，它将从第二步开始CSMA/CA协议。如果未收到确认，发送站点将重新进入第二步中的回退阶段，并从一个更大范围内选取随机值。</li>
</ul>
<h4 id="处理隐藏终端-RTS和CTS"><a href="#处理隐藏终端-RTS和CTS" class="headerlink" title="处理隐藏终端:RTS和CTS"></a>处理隐藏终端:RTS和CTS</h4><p>为了避免隐藏终端导致的碰撞，IEEE 802.11协议允许站点使用一个短<code>请求发送（Request to Send, RTS）</code>控制帧和一个短<code>允许发送（Clear to Send, CTS）</code>控制帧来预约对信道的访问。当发送方要发送一个DATA帧时，它能够首先向AP发送一个RTS帧，只是传输DATA帧和确认帧需要的总时间。当AP收到RTS帧后，它广播一个CTS帧作为响应。该CTS帧有两个目的：给发送方明确的发送许可，也指示其他站点在预约其内不要发送。RTS和CTS帧的使用能够在两个重要方面提高性能：</p>
<ul>
<li>隐藏终端问题被缓解了，因为长DATA帧只有在信道预约后才被传输。</li>
<li>因为RTS和CTS帧较短，涉及RTS和CTS帧的碰撞将仅持续短RTS和CTS帧的持续期。一旦RTS和CTS帧被正确传输，后续的DATA和ACK帧应当能无碰撞地发送。</li>
</ul>
<p>尽管RTS/CTS交换有助于降低碰撞，但它同样引入了时延以及小号了信道资源。因此，RTS/CTS交换仅仅用于长数据帧预约信道。在实际中，每个无线站点可以设置一个RTS门限值，仅当帧长超过门限值时，才使用RTS/CTS序列。</p>
<h3 id="IEEE-802-11帧"><a href="#IEEE-802-11帧" class="headerlink" title="IEEE 802.11帧"></a>IEEE 802.11帧</h3><h4 id="有效载荷与CRC字段"><a href="#有效载荷与CRC字段" class="headerlink" title="有效载荷与CRC字段"></a>有效载荷与CRC字段</h4><p>帧的核心是有效载荷，它通产是由一个IP数据报或者ARP分组组成。尽管这一字段允许的最大长度为2312字节，但它通常小于1500字节，放置一个IP数据报或一个ARP分组。如同以太网帧一样，802.11包括一个CRC码，从而接收方可以检测所收到帧中的比特错误。比特错误在无线局域网中比在有线局域网中更加普遍，因此CRC在这里更加有用。</p>
<h4 id="地址字段"><a href="#地址字段" class="headerlink" title="地址字段"></a>地址字段</h4><p>802.11帧具有4个地址字段，其中每个都可以包含一个6字节的MAC地址。地址2是传输该帧的站点的MAC地址。地址1是要接收该帧的无线站点的MAC地址。BSS是一个子网的一部分，并且这个子网经一些路由器接口与其他子网相连，地址3包含这个路由器接口的MAC地址。</p>
<h4 id="序号、持续期和帧控制字段"><a href="#序号、持续期和帧控制字段" class="headerlink" title="序号、持续期和帧控制字段"></a>序号、持续期和帧控制字段</h4><p>在802.11网络中，无论何时一个站点正确地收到一个来自其他站点的帧，它就回发一个确认。因为确认可能会丢失，发送站点可能会发送一个给定帧的多个副本。使用序号可以使接收方区分新传输的帧和以前的帧的重传。802.11协议允许传输节点预约信道一段时间，包括传输其数据帧的时间和传输确认的时间，这个持续期值被包括在该帧的持续期字段中。控制字段包括许多子字段，比较重要的是，类型和子类型字段用于区分关联、RTS、CTS、ACK和数据帧。到和从字段用于定义不同地址字段的含义。WEP字段指示了是否使用加密</p>
<h3 id="在相同的IP子网中的移动性"><a href="#在相同的IP子网中的移动性" class="headerlink" title="在相同的IP子网中的移动性"></a>在相同的IP子网中的移动性</h3><p><img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/image-20250920172510538.png"></p>
<h3 id="802-11-中的高级特色"><a href="#802-11-中的高级特色" class="headerlink" title="802.11 中的高级特色"></a>802.11 中的高级特色</h3><h4 id="效率适应"><a href="#效率适应" class="headerlink" title="效率适应"></a>效率适应</h4><p>802.11实现具有一种速率自适应能力，该能力自适应地根据当前和近期信道特点来选择下面的物理层调职技术。如果一个节点连续发送两个帧而没有收到确认，该传输速率降低到前一个较低的速率。如果10个帧连续得到确认，或如果用来跟踪自上次降速以来时间的定时器超时，该传输速率提高到上一个较高的速率。</p>
<h4 id="功率管理"><a href="#功率管理" class="headerlink" title="功率管理"></a>功率管理</h4><p>802.11标准提供了功率管理能力，以使802.11节点的侦听、传输和接收功能以及其他需要“打开”电路的时间最小化。802.11功率管理按下列方式运行。一个节点能够明显地在睡眠和唤醒状态之间交替。通过将802.11帧首部的功率管理比特设置为1，某节点向接入点指示它将打算睡眠。设置节点中的一个定时器，使得正好在AP计划发送它的信标帧前唤醒节点。因为AP从设置的功率传输比特知道哪个节点打算睡眠，所以该AP知道它不应当向这个节点发送任何帧，先缓存目的地为睡眠主机的任何帧，待以后再传输。</p>
<h3 id="个人域网络-蓝牙和ZigBee"><a href="#个人域网络-蓝牙和ZigBee" class="headerlink" title="个人域网络:蓝牙和ZigBee"></a>个人域网络:蓝牙和ZigBee</h3><h4 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h4><p>IEEE 802.15.1网络以低功率和低成本在小范围内运行。它本质上是一个低功率、小范围、低速率的“电缆替代”技术，用于计算机与其无线键盘、鼠标或其他外部设备的互联。802.15.1网络有时被称为无线个人网络（Wireless Personal Area Network, WPAN）。802.15.1的链路层和物理层基于早期用于个人域网络的蓝牙规范。</p>
<h4 id="ZigBee"><a href="#ZigBee" class="headerlink" title="ZigBee"></a>ZigBee</h4><p>IEEE标准化的第二个个人域网络是802.14.5，它被称为ZigBee，其服务目标是低功率、低数据率、低工作周期的应用。ZigBee定义了20kbps、40kbps、100kbps和250kbps的信道速率，这取决于信道的频率。</p>
<h2 id="蜂窝因特网的接入"><a href="#蜂窝因特网的接入" class="headerlink" title="蜂窝因特网的接入"></a>蜂窝因特网的接入</h2><p>1.蜂窝是指这样的事实，即由一个蜂窝网覆盖的区域被分成许多称作<code>小区</code>的地理覆盖区域。每个小于包含一个<code>收发基站（Base Transceiver Station, BTS）</code>，负责向位于其小区内的移动站点发送或接收信号。一个小区的覆盖区域取决于许多因素，包括BTS的发射功率、用户设备的传输功率、小区中的障碍建筑物以及基站天线的高度。</p>
<p>2.2G蜂窝系统的<code>全球移动通信系统（GSM）</code>标准对空中接口使用了组合的FDM/TDM。在组合的FDM/TDM系统中，信道被划分为若干频率子带；对于每个子带，时间又被划分为帧和时隙。因此，对于一个组合的FDM/TDM系统，如果信道被划分为F个子带，并且时间被划分为T个时隙，那么该信道将能够支持FT个并发的呼叫。</p>
<p>3.一个GSM网络的<code>基站控制器（Base Station Controller, BSC）</code>通常服务于几十个收发基站。BSC的责任是为移动用户分配BTS无线信道，执行寻呼，执行移动用户的切换。基站控制器及其控制的收发基站共同构成了<code>GSM基站系统（Base Station System, BSS）</code>。</p>
<p>4.在用户鉴别和账户管理中以及呼叫建立和切换中，<code>移动交换中心（Mobile sWitching Center, MSC）</code>起着决定性的租用。单个MSC通常包含多达5个BSC，因此每个MSC有大约200 000个用户。一个蜂窝提供商的网络将有若干MSC，使用称为网关MSC的特殊MSC将提供商的蜂窝网络于更大的公共电话网相连。</p>
<p>5.在3G核心网中有两类节点：<code>服务通用分组无线服务支持节点（Serving Generalized packet radio service Support Node, SGSN）和网关GPRS支持节点（Gateway GPRS Support Node, GGSN）</code>。SGSN负责向位于其连接的无线电接入网中的移动节点交付数据报。SGSM于该区域蜂窝语音网的MSC进行交互，提供用户认证和切换，维护活跃移动节点的位置信息，执行位于无线接入网中的移动节点和GGSN之间的数据报转发。GGSN起着网关的作用，将多个SGSN连接到更大的因特网。GGSN因此是源于移动节点的一个数据报在进入更大因特网之前遇到的3G基础设施的最后一部分。</p>
<p>6.4G系统体系结构中：</p>
<ul>
<li>eNode是2G基站和3G无线电网络控制器的逻辑后代，并且此时还起这关键作用。它的数据报平面作用是在UE和P-GW之间（经过LTE无线电接入网）转发数据报。UE数据报在eNodeB被封装，并且通过4G网络的全IP强化分组核（EPC）以隧道形式传输到P-GW。这些隧道可能于保证服务质量（QoS）相关。</li>
<li>分组数据网络网关（Packet Data Network Gateway, P-GW）给UE分配IP地址，并且保证QoS实施。作为隧道端点，当向或从UE转发数据报时，它也执行数据报封装/解封装。</li>
<li>服务网关（S-GW）是数据平面移动性锚点，即所有UE流量将通过S-GW传递。该S-GW也执行收费/记账功能以及法定的流量拦截。</li>
<li>移动性管理实体（Mobility Management Entity, MME）代表位于它所控制单元中的UE，执行连接和移动性管理。它从HHS接收UE订购信息。</li>
<li>归属用户服务（Home Subscriber Server, HSS）包含了包括漫游接入能力、服务质量配置文件和鉴别信息的UE信息。</li>
</ul>
<p>7.LTE在下行信道采用频分复用和时分复用结合的方法，称之为正交频分复用（Orthogonal Frequency Division Multiplexing, OFDM）技术。</p>
<h2 id="移动管理"><a href="#移动管理" class="headerlink" title="移动管理"></a>移动管理</h2><p>在一个网络环境中，一个移动节点的永久居所被称为归属网络，在归属网络中代表移动节点执行移动挂历功能的实体叫归属代理。移动节点当前所在的网络叫作外部网络或被访网络，在外部网络中帮助移动节点做移动管理功能的实体称为外部代理。通信者就是希望与该移动节点通信的实体。</p>
<h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>外部代理的作用之一是为移动节点创建一个所谓的<code>转交地址（Care-Of Address, COA）</code>，该COA的网络部分与外部网络的网络部分相匹配。因此一个移动节点可与两个地址相关联，即其<code>永久地址</code>与其COA，该COA有时又称为<code>外部地址</code>。外部代理的第二个作用是告诉归属代理，该移动节点在它的网络中且具有给定的COA。</p>
<h4 id="两种方法"><a href="#两种方法" class="headerlink" title="两种方法"></a>两种方法</h4><p><code>间接路由选择方法。</code>通信者指示将数据报寻址到移动节点的固定地址，并将数据报发送到网络中去，完全不知道移动节点是在归属网络中还是正在访问某个外部网络，因此移动性对于通信者来说是完全透明的。这些数据报就像平常一样首先导向移动节点的归属网络。</p>
<p>归属代理监视到达的数据报，这些数据报寻址的节点的归属网络与该归属代理所在网络相同，但这些节点当前却在某个外部网络中。归属代理截获这些数据报，然后转发它们。通过使用移动节点的COA，该数据报先转发给外部代理，然后再从外部代理转发给移动节点。</p>
<p>归属代理将通信者的原始完整数据报封装在一个新的较大的数据报中，这个较大的数据报被导向并交付到移动节点的COA。“拥有”该COA的外部代理将接收并拆封该数据报，即从较大的封装数据报中取出通信者的原始数据报，然后再向移动节点转发该原始数据报。</p>
<p>移动节点向通信者发送数据报时，只要直接将其数据报寻址到通信者（使用自己的永久地址作为源地址，通信者的地址作为目的地址）即可。</p>
<p> 间接路由选择方法存在一个低效的问题，即三角路由选择问题。该问题是指即使在通信者与移动节点之间存在一条更有效的路由，发往移动节点的数据报也要先发给归属代理，然后再发送到外部网络。</p>
<p><code>直接路由选择</code>克服了路由选择的低效问题，但却是以增加复杂性为代价的。在直接路由选择方法中，通信者所在网络中的一个通信者代理先知道该移动节点的COA。这可以让通信者向归属代理询问得知，假设移动节点具有一个在归属代理注册过的最新的COA。通信者本身也可能执行通信者代理的功能。</p>
<h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2><p>支持移动性的因特网体系结构与协议合起来称为移动IP。移动IP标准有三部分组成：</p>
<ul>
<li>代理发现。移动IP定义了一个归属代理或外部代理用来向移动节点通告其服务的协议，以及移动节点请求一个外部代理或归属代理的服务所使用的协议。</li>
<li>向归属代理注册。移动IP定义了移动节点和/或外部代理向一个移动节点归属代理注册或注销COA所使用的协议。</li>
<li>数据报的间接路由选择。该标准也定义了数据报被一个归属代理转发给移动节点的方式，包括转发数据报使用的规则、处理差错情况的规则和集中不同的封装形式。</li>
</ul>
<p>到达一个新网络的某移动IP节点，不管是连到一个外部网络还是返回其归属网络，它都必须知道响应的外部代理或归属代理的身份。这个过程被称为代理发现。代理发现可以通过下列两种方式之一实现：<code>代理通过或代理请求。</code></p>
<p>借助<code>代理通告</code>，外部代理或归属代理使用一种现有路由器发现协议的扩展新协议来通告其服务。该代理周期性地在所有连接的链路上广播一个类型字段为9的ICMP报文。路由器发现报文也包含路由器的IP地址，因此允许一个移动节点知道该代理的IP地址。路由器发现报文还包括了一个移动性代理通告扩展，其中包含了该移动节点所需的附加信息。在这种扩展中又如下一些较重要的字段：</p>
<ul>
<li>归属代理比特（H）。指出该代理是它所在网络的一个归属代理。</li>
<li>外部代理比特（F）。指出该代理是它所在网络的一个外部代理。</li>
<li>注册要求比特（R）。指出在该网络中的某个移动用户必须向某个外部代理注册。特别是，一个移动用户不能在外部网络中获得一个转交地址，并假定由它自己承担外部代理的功能，无须向外部代理注册。</li>
<li>M、G封装比特。指出除了IP-in-IP封装形式外，是否还要用其他的封装形式。</li>
<li>转交地址（COA）字段。由外部代理提供的一个或多个转交地址的列表。移动用户在向其归属代理注册时将选择这些地址中的一个作为其COA。</li>
</ul>
<p><code>使用代理请求</code>，一个想知道代理的移动节点不必等待接收代理通告，就能广播一个代理请求报文，该报文只是一个类型值为10的ICMP报文。收到该请求的代理将直接向该移动节点单播一个代理通告，于是该移动节点将继续处理，就好像刚收到一个未经请求的通告一样。</p>
<p>1.一旦某个移动IP节点收到一个COA，则该地址必须要向归属代理注册。这可通过外部代理或直接通过移动IP节点自己来完成。共涉及4个步骤：</p>
<p>2.当收到一个外部代理通告后，一个移动节点立即向外部代理发送一个移动IP注册报文。注册报文承载在一个UDP数据报中并通过端口434发送。注册报文携带以下内容：一个由外部代理通告的COA、归属代理的地址（HA）、移动节点的永久地址（MA）、请求的注册寿命和一个64比特的注册标识。请求的注册寿命指示了注册有效的秒数。如果注册没有在规定的时间内在归属代理上更新，则该注册将变得无效。注册标识就像一个序号，用于收到的注册回答与注册请求的匹配。</p>
<p>3.外部代理收到注册报文并记录节点的永久IP地址。外部代理知道现在它应该查找这样的数据报，即它封装的数据报的目的地址与该移动节点的永久地址相匹配。外部代理然后向归属代理的434端口发送一个移动IP注册报文。这一报文包括COA、HA、MA、封装格式要求、请求的注册寿命以及注册标识。</p>
<p>4.归属代理接收注册请求并检查真实性和正确性，归属代理把移动节点的永久IP地址与COA绑定在一起。以后，到达该归属代理的数据报与发往移动节点的数据报将被封装并以隧道方式给COA。归属代理发送一个移动IP注册回答，该响应报文中含有HA、MA、实际注册寿命和被认可的请求报文注册标识。</p>
<p>5.外部代理接收注册响应，然后将其转发给移动节点。</p>
<p>6.当某个移动节点离开其网络时，外部代理无须显式地取消某个COA的注册。当移动节点移动到一个新网并注册一个新COA时，上述情况将自动发生。</p>
<h2 id="管理蜂窝网中的移动性"><a href="#管理蜂窝网中的移动性" class="headerlink" title="管理蜂窝网中的移动性"></a>管理蜂窝网中的移动性</h2><p>在GSM术语中，移动用户的归属网络被称作该移动用户的归属公<code>共地域网络（home Public Land Mobile Network, home PLMN）</code>。为简便起见，直接将GSM归属PLMN称为<code>归属网络</code>。移动用户向某个蜂窝网提供商订购了服务，该蜂窝网就称为了这些用户的归属网络。被访问的PLMN直接称为<code>被访网络</code>。归属网络与被访网络的指责有很大的差别。</p>
<p>归属网络维护一个称作<code>归属位置注册器（Home Location Register, HLR）</code>的数据库，其中包括它每个用户的永久蜂窝电话号码以及用户个人概要信息。重要的是，HLR也包括这些用户当前的位置信息。这就是说，如果一个移动用户当前漫游到另一个提供商的蜂窝网络中，HLR中将包含足够多的信息来获取被访网络中对移动用户的呼叫应该路由选择到的地址。当一个呼叫定位到一个移动用户后，通信者将与归属网络中一个被称作<code>网关移动服务交换中心（Gateway Mobile services Switching Center, GMSC）</code>的特殊交换机联系，用<code>归属MSC</code>简称。</p>
<p>被访网络维护一个称作<code>访问者位置注册（Visitor Location Register, VLR）</code>的数据库。VLR为每一个当前在其服务网络中的移动用户包含一个表项，VLR表项因此随着移动用户进入和离开网络而出现或消失。VLR通常与移动交换中心在一起，该中心协调到达或离开被访网络的呼叫建立。</p>
<h3 id="对移动用户呼叫的路由选择"><a href="#对移动用户呼叫的路由选择" class="headerlink" title="对移动用户呼叫的路由选择"></a>对移动用户呼叫的路由选择</h3><pre class="line-numbers language-none"><code class="language-none">呼叫定位到被访网络中的移动GSM用户的步骤：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>通信者拨打移动用户的电话号码。该号码本身并不设计一个特定的电话线路或位置，号码中的前几位数字足以全局地判别移动用户的归属网络。呼叫从通信者通过公共交换电话网到达移动用户归属网络中的归属MSC。这是呼叫的第一步。</li>
<li>归属MSC收到该呼叫并查询HLR来确定移动用户的位置。在最简单的情况下，HLR返回移动站点漫游号码（Moblie Station Roaming Number, MSRN），简称漫游号。这个号码与移动用户的永久电话号码不同，后者是与移动用户的归属网络相关联的，而漫游号码是短暂的：当移动用户进入一个被访网络后，会给移动用户临时分配一个漫游号码。漫游号码的作用就相当于移动IP中转交地址的作用。如果HLR不具有该漫游号码，它返回被访网络中的VLR地址。在这种情况下，归属MSC需要查询VLR以便获取移动节点的漫游号码。HLR是如何获得有关移动用户位置信息的？当一个移动电话切换或进入一个由新的VLR所覆盖的被访网络中以后，移动用户必须向被访网络注册，这是通过在移动用户和VLR之间交换信令报文来实现的。被访VLR随后又向移动用户的HLR发送一个位置更新请求报文。这一报文告知HLR可以用来联系移动用户的漫游号码，或者VLR地址。作为这个交换的一部分，VLR同样从HLR那里获取移动用户的信息，以及确定被访网络应该基于移动用户什么样的服务。</li>
<li>给定一个漫游号码，归属MSC通过网络到达被访网络的MSC建立呼叫的第二步。至此，该呼叫已完成。</li>
</ul>
<h3 id="GSM中的切换"><a href="#GSM中的切换" class="headerlink" title="GSM中的切换"></a>GSM中的切换</h3><pre class="line-numbers language-none"><code class="language-none">当一个基站决定切换一个移动用户时所包括的步骤：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>旧基站（BS）通知被访问MSC即将要进行一个切换，通知移动用户将要切换到的BS（或可能的BS集）。</li>
<li>被访问MSC发起建立到新BS的路径，分配承载重路由选择的呼叫所需的资源，以及用信令告知新BS一个切换即将出现。</li>
<li>新BS分配并激活一个无线信道供移动用户使用。</li>
<li>新BS发出信令返回被访问MSC和旧BS，即已经建立了被访问MSC到新BS的路径并且移动用户应当被告知即将发生的切换。新BS提供移动用户与新的BS相关联所需要的所有信息。</li>
<li>移动用户被告知它应当进行一个切换。到此时为止，移动用户完全不知道网络已经为切换做好所有底层工作。</li>
<li>移动用户和新BS交换一个或多个报文，以完全激活新BS中新的信道。</li>
<li>移动用户向新BS发送一个切换完成报文，该报文随后向上转发给被访问MSC。该被访问MSC然后重路由选择到移动用户的正在进行的呼叫，使其经过新BS。</li>
<li>沿着到旧BS的路径分配的资源随后被释放</li>
</ul>
<h2 id="无限和移动性（对高层协议的影响）"><a href="#无限和移动性（对高层协议的影响）" class="headerlink" title="无限和移动性（对高层协议的影响）"></a>无限和移动性（对高层协议的影响）</h2><p>由于无线信道的高比特差错率和切换丢失的可能性，TCP的拥塞控制反应在无限情况下可能会有问题。有三大类可能的方法用于处理这一问题：</p>
<ul>
<li>本地恢复。本地恢复的方法的目标是在比特差错出现的当时和当地将其恢复。</li>
<li>TCP发送方知晓无线链路。让TCP发送方和接收方知道无线链路的存在，从而将在有线网络中发生的拥塞性丢包和在无线网络中发生的差错/丢包区分开，并且仅对有线网络中的拥塞性丢包采用拥塞控制。</li>
<li>分离连接方法。在分离连接方法中，移动用户和其他断电之间的端到端连接被打断为两个运输层连接：一个从移动主机到无线接入点，一个从无线接入点到其他通信端点。该端到端连接因此是由一个无线部分和一个有线部分分级连形成的。经无线段的运输层能够是一个标准的TCP连接，或是一个特别定制运行在UDP上的差错恢复协议。</li>
</ul>
<h2 id="八、什么是网络安全"><a href="#八、什么是网络安全" class="headerlink" title="八、什么是网络安全"></a>八、什么是网络安全</h2><p>安全通信具有下列所需要的特性：</p>
<p><code>机密性。</code>仅有发送方和希望的接收方能够理解传输报文的内容。因为窃听者可以截获报文，这必须要求报文在一定程度上进行加密，是截取的报文无法被截获者所理解。</p>
<p><code>报文完整性。</code>发送方和希望的接收方希望确保其通信的内容在传输过程中未被改变——或者恶意篡改或者意外活动。</p>
<p><code>端点鉴别。</code>发送方和接收方都应该能证实通信过程所涉及的另一方，以确信通信的另一方确实具有其所生成的身份。</p>
<p><code>运行安全性。</code>几乎所有的机构几天都有了于公共因特网连接的网络。这些网络因此潜在地能够被危及安全。攻击者能够试图在网络主机中安放蠕虫，获取公司秘密，勘察内部网络配置并发起DoS攻击。</p>
<h2 id="密码学的原则"><a href="#密码学的原则" class="headerlink" title="密码学的原则"></a>密码学的原则</h2><p>发送者报文的最初形式被称为<code>明文</code>。发送者使用<code>加密算法</code>加密其明文报文，生成的加密报文被称为<code>密文</code>，该密文对任何入侵者看起来是不可懂的。发送方提供了一个<code>密钥</code>KA，它是一串数字或字符，作为加密算法的输入。加密算法以密钥和明文报文m为输入，生成的密文作为输出。用符号KA(m)表示使用密钥KA加密的明文报文m的密文形式。类似地，接收方将为<code>解密算法</code>提供密钥KB，将密文和接收方的密钥作为输入，输出初始明文。也就是说，如果接收方接收到一个加密的报文KA(m)，他可通过计算KB(KA(m)) = m进行解密。在<code>对称密钥系统</code>中，发送方和接收方的密钥是相同并且是秘密的。在<code>公开密钥系统</code>中，使用一对密钥：一个密钥为发送方和接收方两人所知，另一个密钥只有发送方或接收方知道</p>
<h3 id="对称密钥密码体制"><a href="#对称密钥密码体制" class="headerlink" title="对称密钥密码体制"></a>对称密钥密码体制</h3><p><code>凯撒密码</code>用于英语文本时，将明文报文中的每个字母用字母表中该字母后第k个字母进行替换。</p>
<p>凯撒密码的一种改进方法是单码代替密码，也是使用自字母表中的一个字母替换该字母表中的另一个字母。然而，并非按照规则的模式进行替换，只要每个字母都有一个唯一的替换字母，任一字母都可用另一字母替换，反之亦然。</p>
<pre class="line-numbers language-none"><code class="language-none">当考虑入侵者破解加密方案的难易程度时，可以根据入侵者所拥有的信息分为三种不同的情况：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>1.唯密文攻击。</code>有些情况下，入侵者只能得到截取的密文，也不了解明文报文的内容。</p>
<p><code>2.已知明文攻击。</code>如果入侵者以某种方式确信在密文报文中会出现的信息，就可以破解部分匹配关系。</p>
<p><code>3.选择明文攻击。</code>在选择明文攻击中，入侵者能够选择某一明文报文并得到该明文报文对应的密文形式。</p>
<p><code>4.多码代替密码</code>是对单码代替密码的改进。多码代替密码的基本思想是使用多个单码代替密码，一个单码代替密码用于加密某明文中一个特定位置的字母。因此，在某明文报文中不同位置出现的相同字母可能以不同方式编码。</p>
<h4 id="块密码"><a href="#块密码" class="headerlink" title="块密码"></a>块密码</h4><p>块密码中，要加密的报文被处理为k比特的块。为了加密一个块，该密码采用了一对一映射，将k比特块的明文映射为k比特块的密文。块密码通常使用函数模拟随机排列表。例如当k = 64时，该函数首先将64比特块划分为8个块，每个块由8比特组成。每个8比特块由一个“8比特到8比特”表处理，这是个可管理的长度。接下来，这8个输出块被重新装配成一个64比特的块。该输出被回馈到64比特的输入，开始了第二次循环。经n此这样的循环后，该函数提供了一个64比特的密文块。</p>
<h4 id="密码块链接"><a href="#密码块链接" class="headerlink" title="密码块链接"></a>密码块链接</h4><p> 如果使用上述的块密码，会出现一个微妙而重要的问题，即相同铭文块对应的密文块可能是相同的。为了解决这个问题，可以在密文中混合某些随机性，使得相同的明文块产生不同的密文块。令m(i)表示第i个明文块，c(i)表示第i个密文块，并且a⊕b表示两个比特串a和b的异或。将具有密钥S的块密码加密算法表示为KS。其基本思想如下：发送方为第i块生成一个随机的k比特数r(i)，并且计算c(i) = KS(m(i)⊕r(i))。接收方收到c(i)和r(i)，它能够通过计算m(i) = KS(c(i)⊕r(i))而恢复每个明文块。</p>
<ul>
<li>引入随机性产生了另一个问题：发送方必须传输一千两倍的比特。为了有效利用该技术，块密码通常使用了一种称为<code>密码块链接（Cipher Block Chaining, CBC）</code>的技术。其基本思想是仅随第一个报文发送一个随机值，然后让发送方和接收方使用计算的编码块代替后继的随机数。集体而言，CBC运行过程如下：</li>
<li>在加密报文之前，发送方生成一个随机的k比特穿，称为初始向量（Initialization Vector, IV）。将该初始向量表示为c(0)。发送方以明文方式将IV发送给接收方。</li>
<li>对第一个块，发送方计算m(1)⊕c(0)，即计算第一块明文与IV的异或。然后通过块密码算法运行得到的结果以得到对应的密文块，即c(1) = KS(m(1)⊕c(0))。发送方向接收方发送加密块c(1)。</li>
<li>对于第i个块，发送方根据c(i) = KS(m(i)⊕c(i – 1))生成第i个密文块。</li>
</ul>
<h3 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h3><p>在公开密钥密码中，发送方和接收方并未共享一个密钥，而接收方则由两个密钥，一个世界上任何人都可得到的公钥，另一个是只有接收方知道的私钥。使用符号$ K^+_B 和 和和 K^-_B 来分别表示接收方的公钥和私钥。<br>为了与接收方通信，发送方首先取得接收方的公钥，然后用这个公钥和一个众所周知的加密算法，加密他要传递给发送方的报文m；即发送方计算 来分别表示接收方的公钥和私钥。为了与接收方通信，发送方首先取得接收方的公钥，然后用这个公钥和一个众所周知的加密算法，加密他要传递给发送方的报文m；即发送方计算来分别表示接收方的公钥和私钥。为了与接收方通信，发送方首先取得接收方的公钥，然后用这个公钥和一个众所周知的加密算法，加密他要传递给发送方的报文m；即发送方计算 K^+_B (m)。接收方接收到发送方的加密报文后，用其私钥和一个众所周知的解密算法解密发送方的加密报文，即接收方计算 (m)。接收方接收到发送方的加密报文后，用其私钥和一个众所周知的解密算法解密发送方的加密报文，即接收方计算(m)。接收方接收到发送方的加密报文后，用其私钥和一个众所周知的解密算法解密发送方的加密报文，即接收方计算 K^-_B ( (( K^+_B (m))。存在着可以选择公钥和私钥的加密/解密算法和技术，使得 (m))。存在着可以选择公钥和私钥的加密/解密算法和技术，使得(m))。存在着可以选择公钥和私钥的加密/解密算法和技术，使得 K^-_B ( (( K^+_B (m))；也就是说，用接收方的公钥 (m))；也就是说，用接收方的公钥(m))；也就是说，用接收方的公钥 K^+_B 加密报文m，然后再用接收方的私钥解密报文密文形式就能得到最初得到明文m。公钥和私钥加密相互交换同样能够得到结果，即 加密报文m，然后再用接收方的私钥 解密报文密文形式就能得到最初得到明文m。公钥和私钥加密相互交换同样能够得到结果，即加密报文m，然后再用接收方的私钥解密报文密文形式就能得到最初得到明文m。公钥和私钥加密相互交换同样能够得到结果，即 K^-_B ( (( K^+_B $(m)) = $ K^+_B ( (( K^-_B $(m)) = m。</p>
<h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><p>RSA算法广泛地使用模n算术运算。RSA由两个互相关联的部分：</p>
<ul>
<li>公钥和私钥的选择。</li>
<li>解密和解密算法。</li>
</ul>
<p>为了生成RSA的公钥和私钥，接收方执行如下步骤：</p>
<ul>
<li>选择两个大素数p和q。该值越大，破解RSA越困难，而执行加密和解密所用的时间也越长。</li>
<li>计算n = pq和z = (p – 1)(q – 1)。</li>
<li>选择小于n的一个数e，且使e和z互素。</li>
<li>求一个数d，使得ed – 1可以被z整除。即给定e，求d，使得ed mod z = 1。</li>
<li>接收方使外界可用的公钥 是一对数(n, e)，其私钥是 是一对数(n, d)。</li>
</ul>
<p>发送方执行的加密和接收方执行的解密过程如下：</p>
<ul>
<li>假设发送方要给接收方发送一个由整数m表示的比特组合，且m &lt; n。为了进行编码，接受当执行指数运算me，然后计算me被n除的整数余数。换言之，发送方的明文m的加密值c就是：c = me mod n。对于这个密文c的比特模式发送给接收方。</li>
<li>为了对收到的密文报文c解密，接收方计算：m = cd mod n。</li>
</ul>
<p>在实际应用中，RSA通常与对称密钥密码结合起来使用。例如，如果发送方要向接收方发送大量的加密数据，他可以用下述方式做。首先，发送方选择一个用于加密数据本身的密钥，这个密钥称为<code>会话密钥</code>，该会话密钥表示为KS。发送方必须把这个会话密钥告知接收方，因为这是他们在对称密钥密码中所使用的共享对称密钥。发送方可以使用接收方的RSA公钥来加密该会话密钥，即计算c = (KS)e mod n。接收方收到了该RSA加密的会话密钥c后，解密得到会话密钥KS。接收方此时已经知道将要用于加密数据传输的会话密钥了</p>
<h2 id="报文完整性和数字签名"><a href="#报文完整性和数字签名" class="headerlink" title="报文完整性和数字签名"></a>报文完整性和数字签名</h2><p>报文完整性是指，接收方为了鉴别收到的报文，需要证实：</p>
<ul>
<li>该报文确实源自希望的发送方。</li>
<li>该报文在到达的途中没有被篡改。</li>
</ul>
<h3 id="密码散列函数"><a href="#密码散列函数" class="headerlink" title="密码散列函数"></a>密码散列函数</h3><p>散列函数以m为输入，并计算得到一个称为散列的固定长度的字符串H(m)。<code>密码散列函数</code>要求具有下列附加的性质：找到任意两个不同的报文x和y使得H(x) = H(y)，在计算上是不可能的。这种性质就意味着入侵者在计算上不可能用其他报文替换由散列函数保护的报文。这就是说，如果(m, H(m))是报文和由发送方生成的报文散列的话，则入侵者不可能伪造另一个报文y的内容，使得该报文具有与原报文相同的散列值</p>
<h3 id="报文鉴别码"><a href="#报文鉴别码" class="headerlink" title="报文鉴别码"></a>报文鉴别码</h3><p>为了鉴别报文完整性，除了使用密码散列函数外，发送方和接收方需要共享秘密s。这个共享的秘密只不过是一个比特串，它被称为鉴别密钥。使用这个共享秘密，报文完整性能够执行如下：</p>
<ul>
<li>发送方生成报文m，用s级联m以生成m + s，并计算散列H(m + s)。H(m + s)被称为报文鉴别码（Message Authentication Code, MAC）。</li>
<li>然后发送方将MAC附加到报文m上，生成扩展报文(m, H(m + s))，并将报文发送给接受方。</li>
<li>接收方接收到一个扩展报文(m, h)，由于知道s，计算出报文鉴别码H(m + s)。如果H(m + s) = h，接受方得到结论：一切正常。</li>
</ul>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名是一种在数字领域实现的密码技术。</p>
<p>使用数字签名的发送方的步骤：发送方让他的初始长报文通过一个散列函数。然后他用自己的私钥对得到的散列进行数字签名。明文形式的初始报文连同已经数字签名的报文摘要一道被发送给接收方。</p>
<p>接收方的步骤：接收方先把发送方的公钥应用于报文获得一个散列结果。然后再把该散列函数应用于明文报文以得到第二个散列结果。若果这两个散列匹配，则接收方可以确信报文的完整性及其发送方。</p>
<h4 id="公钥认证"><a href="#公钥认证" class="headerlink" title="公钥认证"></a>公钥认证</h4><p>将公钥于特定实体绑定通常是由认证中心（Certification Authority, CA）完成的，CA的职责就是使识别和发行证书合法化。CA具有下列作用：</p>
<ul>
<li>CA认证一个实体的真实身份。</li>
<li>一旦CA验证了某个实体的身份，这个CA会生成一个将其身份和实体的公钥绑定起来的证书。这个证书包含这个公钥和公钥所有者全局唯一的身份标识信息。由CA对这个证书进行数字签名。</li>
</ul>
<h2 id="端点鉴别"><a href="#端点鉴别" class="headerlink" title="端点鉴别"></a>端点鉴别</h2><p>1.端点鉴别就是一个实体经过计算机网络向另一个实体证明其身份的过程</p>
<ol>
<li>不重数是在一个协议的生存期中只使用一次的数。也就是说，一旦某协议使用了一个不重数，就永远不会再使用那个数字了。</li>
</ol>
<p>3.端点鉴别的步骤：</p>
<ul>
<li>发送方向接收方发送报文“我是xxx”。</li>
<li>接收方选择一个不重数R，然后把这个值发给发送方。</li>
<li>发送方使用他与接收方共享的对称秘密密钥K来加密这个不重数，然后把加密的不重数K®发回给接收方。由于发送方知道K并用它加密一个值，就使得接收方知道收到的报文是由希望的发送方产生的。这个不重数用于确定希望的发送方是活跃的。</li>
<li>接收方解密收到的报文，如果解密得到的不重数等于他发送给发送方的那个不重数，则可鉴别发送方的身份。</li>
</ul>
<h2 id="安全电子邮件"><a href="#安全电子邮件" class="headerlink" title="安全电子邮件"></a>安全电子邮件</h2><h3 id="安全电子邮件-1"><a href="#安全电子邮件-1" class="headerlink" title="安全电子邮件"></a>安全电子邮件</h3><p>如果要设计一个提供机密性、发送方鉴别和报文完整性的电子邮件系统，可以通过把会话密钥和数字签名结合起来实现：发送方首先生成一个预备包，该预备包是通过会话密钥生成的，包括了发送方的初始报文和该报文数字签名过的散列。然后发送方把这个预备包看作一个报文，再经过数字签名后发送给接收方。接收方收到这个包后，通过与发送方相反的步骤获得初始报文。</p>
<h3 id="PGP"><a href="#PGP" class="headerlink" title="PGP"></a>PGP</h3><p>PGR是安全电子邮件加密方案的一个范例，在公共领域中有各个版本的PGR可以使用</p>
<h2 id="TCP安全连接-SSL"><a href="#TCP安全连接-SSL" class="headerlink" title="TCP安全连接 SSL"></a>TCP安全连接 SSL</h2><p>TCP的强化版本<code>安全套接字层（Secure Socket Layer, SSL）</code>用安全性服务加强TCP，该安全性服务包括机密性、数据完整性和端点鉴别。SSL版本3的一个稍加修改的版本被称为<code>运输层安全性（Transport Layer Security, TLS）。</code></p>
<h3 id="宏观描述"><a href="#宏观描述" class="headerlink" title="宏观描述"></a>宏观描述</h3><p>SSL具有三个阶段：握手、密钥导出和数据传输</p>
<p>一个客户B和一个服务器A之间的通信会话的这三个阶段</p>
<h4 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h4><p>①与A创建一条TCP连接；</p>
<p>②验证A是真实的，而不是入侵者假冒的；</p>
<p>③发送给A一个主密钥，B和A持用该主密钥生成SSL会话所需的所有对称密钥。具体过程：一旦创建了TCP连接，B就向A发送一个hello报文。A用它得到证书进行响应，证书中包含了它的公钥。因为该证书已被某CA证实过，B明白无误地知道该公钥属于A。然后，B产生一个主密钥（EMS），并将该EMS发送给A。A用它的私钥解密该EMS从而得到MS。在这个阶段后，B和A均知道了用于这次SSL会话的主密钥。</p>
<h4 id="密钥导出"><a href="#密钥导出" class="headerlink" title="密钥导出"></a>密钥导出</h4><p>在密钥导出阶段，MS已由B和A共享，它能够用作所有后继加密和数据完整性检查的对称会话密钥。然而，对于A和B每人而言，使用不同的密码密钥，并且对于加密和完整性检查也使用不同的密钥，通常认为更为安全。因此，A和B都使用MS生成4个密钥：</p>
<ul>
<li>EB，用于从B发送到A的数据的会话加密密钥。</li>
<li>MB，用于从B发送到A的数据的会话MAC密钥。</li>
<li>EA，用于从A发送到B的数据的会话加密密钥。</li>
<li>MA，用于从A发送到B的数据的会话MAC密钥。</li>
</ul>
<p>这通过直接将MS分为4个密钥来实现。</p>
<h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p>在数据传输阶段，SSL将数据流分割成记录，对每个记录附加一个MAC用于完整性检查，然后加密该“记录+MAC”。为了产生这个MAC，B将数据连同密钥MB，一起放入一个散列函数中。B维护一个序号计数器，计数器开始为0，B每发送的一个SSL记录它都增加1。B计算MAC时，他把该序列号包括在MAC的计算中。所以，MAC现在是数据加MAC密钥MB加当前序列号的散列。为了加密“记录+MAC”这个包，B使用他的会话加密密钥EB。然后这个加密的包将传递给TCP经因特网传输。</p>
<h3 id="完整描述"><a href="#完整描述" class="headerlink" title="完整描述"></a>完整描述</h3><p>前三个字段是不加密的。类型字段指出了该字段是握手报文还是包含应用数据的报文。它也用于关闭SSL连接。在接收端SSL使用长度字段以从到达的TCP字节流中提取SSL记录。</p>
<h4 id="SSL握手"><a href="#SSL握手" class="headerlink" title="SSL握手"></a>SSL握手</h4><p>详细的SSL握手步骤：</p>
<ul>
<li>客户发送它支持的密码算法的列表，连同一个客户的不重数。</li>
<li>从该列表中，服务器选择一种对称算法、一种公钥算法和一种MAC算法。它把它的选择以及证书和一个服务器不重数返回给客户。</li>
<li>客户验证该证书，提取服务器的公钥，生成一个前主密钥（Pre-Master Secret, PMS），用服务器的公钥加密该PMS，并将加密的PMS发送给服务器。</li>
<li>使用相同的密钥导出函数，客户和服务器独立地从PMS和不重数中计算出主密钥（MS）。然后该MS被切片以生成两个密码和两个MAC密钥。此外，当选择的对称密码应用于CBC，则两个初始化向量（IV）也从该MS获得，这两个IV分别用于该连接的两端。自此以后，客户和服务器之间发送的所有报文均被加密和鉴别。</li>
<li>客户发送所有握手报文的一个MAC。</li>
<li>服务器发送所有握手报文的一个MAC。</li>
</ul>
<h2 id="网络安全性（IPsec和虚拟专用网）"><a href="#网络安全性（IPsec和虚拟专用网）" class="headerlink" title="网络安全性（IPsec和虚拟专用网）"></a>网络安全性（IPsec和虚拟专用网）</h2><p>IP安全（IP Security）协议更常被称为IPsec，它为网络层提供了安全性。IPsec为任意两个网络层实体（包括主机和路由器）之间的IP数据报提供了安全</p>
<h3 id="IPsec和虚拟专用网"><a href="#IPsec和虚拟专用网" class="headerlink" title="IPsec和虚拟专用网"></a>IPsec和虚拟专用网</h3><p>跨越在多个地理区域上的某机构常常希望有自己的IP网络，使它的主机和服务器能够以一种安全和机密的方式彼此发送数据。为了达到这个目标，该机构能够实际部署一个单独的物理网络，该网络包括路由器、链路和DNS基础设施且与公共因特网完全分析。这样一种为特定的机构专用的分立网络被称为<code>专用网络</code>。专用网络可能耗资巨大，因为该机构需要购买、安装和维护它自己的物理网络基础设施。而使用<code>虚拟专用网（Virtual Private Network, VPN）</code>，机构和办公室之间的流量经公共因特网而不是经物理上独立的网络发送。而为了提供机密性，办公室之间的流量在进入公共因特网之前进行加密。</p>
<h3 id="AH协议和ESP协议"><a href="#AH协议和ESP协议" class="headerlink" title="AH协议和ESP协议"></a>AH协议和ESP协议</h3><p>在IPsec协议族中，有两个主要协议：鉴别首部（Authentication Header, AH）协议和封装安全性协议（Encapsulation Security Payload, ESP）协议。AH协议提供源鉴别和数据完整性服务，但不提供机密性服务。ESP提供了源鉴别、数据完整性和机密性服务</p>
<h3 id="安全关联"><a href="#安全关联" class="headerlink" title="安全关联"></a>安全关联</h3><p>IPsec数据报在网络实体对之间发送。在从源实体向目的实体发送IPsec数据报之前，源和目的实体创建了一个网络层的逻辑连接。这个逻辑连接称为<code>安全关联（Security Association, SA）。</code></p>
<p>在SA内部，路由器将维护有关该SA的状态信息，这包括：</p>
<ul>
<li>SA的32比特的标识符，称为安全参数索引（Security Parameter Index, SPI）。</li>
<li>SA的初始接口和SA的目的接口。</li>
<li>将使用的加密类型。</li>
<li>加密密钥。</li>
<li>整性检查的类型。</li>
<li>鉴别密钥。</li>
</ul>
<p>一个IPsec协议在它的<code>安全关联数据库（Security Association Database, SAD）</code>中存储其所有SA的状态信息，SAD是实体操作系统内核中得到一个数据结构</p>
<h3 id="IPsec数据报"><a href="#IPsec数据报" class="headerlink" title="IPsec数据报"></a>IPsec数据报</h3><p>IPsec有两种不同的分组形式，一种用于所谓的<code>隧道模式</code>，另一种用于所谓的<code>运输模式</code>。</p>
<p>将一个IPv4数据报转换成一个IPsec数据报的步骤：</p>
<ul>
<li>在初始IPv4数据报后面附上一个“ESP尾部”字段。</li>
<li>使用算法和由SA规定的密钥加密该结果。</li>
<li>在这个加密量的前面附加上一个称为“ESP首部”的字段，得到的包称为“enchilada”。</li>
<li>使用算法和由SA规定的密钥生成一个覆盖整个enchilada的鉴别MAC。</li>
<li>该MAC附加到enchilada的后面形成载荷。</li>
<li>最后，生成一个就有经典IPv4首部字段的全新IP首部，该新首部附加到载荷之前。</li>
</ul>
<p>IPsec数据报中的新IP首部的源地址和目的地址分别设置为位于隧道两个端点的源和目的地路由器接口。同时，整个新IPv4首部字段中的协议号不被设置为TCP、UDP或SMTP，而是设置为50，指示这是一个使用ESP协议的IPsec数据报。</p>
<p>ESP尾部由三个字段组成：填充、填充长度和下一个首部。块密码要求被加密的报文必须为块长度的整数倍。使用填充（由无意义的字节组成），使得当其加上初始数据报（连同长度字段和下一个首部字段）形成的“报文”是块的整数倍。填充长度字段指示接收实体插入的填充是多少（并且需要被删除）。下一个首部字段指示包含在载荷数据字段中数据的类型。载荷数据和ESP尾部级联起来并被加密。</p>
<p>ESP首部以明文发送，它由两个字段组成：SPI字段和序号字段。SPI字段指示接收实体该数据属于哪个SA；接收实体则能够用该SPI索引其SAD以确定适当的鉴别/解密算法和密钥。序号字段用于防御重放攻击。</p>
<p>发送实体也附加一个鉴别MAC。发送实体跨越整个enchilada计算一个MAC。</p>
<ul>
<li>当接收路由器收到IPsec数据报时，首先判断数据报的目的IP地址是否为自己本身。是则进行以下步骤：</li>
<li>针对enchilada，使用SPI以确定该数据报属于哪个SA。</li>
<li>计算该enchilada的MAC并且验证该MAC与在ESP MAC字段中<br>的值一致。如果两者一致，它知道该enchilada未被篡改。</li>
<li>检查序列号字段以验证该数据报是新的（并且不是重放的数据报）。</li>
<li>使用与SA关联的解密算法和密钥解密该加密单元。</li>
<li>删除填充并抽取初始的普通IP报文。</li>
<li>朝着最终目的地将该初始数据报转发进分支机构网络。</li>
</ul>
<p><code>安全策略库（Security Policy Database, SPD）</code>。该SPD指示哪些类型的数据报将被IPsec处理；并且对这些将被IPsec处理的数据报应当使用哪个SA。</p>
<h3 id="IKE-IPsec中的密钥管理"><a href="#IKE-IPsec中的密钥管理" class="headerlink" title="IKE:IPsec中的密钥管理"></a>IKE:IPsec中的密钥管理</h3><p>大型的、地理上分散的部署要求一个自动的机制来生成SA。IPsec使用<code>因特网密钥交换（Internet Key Exchange, IKE）</code>协议来从事这项工作。</p>
<h2 id="使无限LAN安全"><a href="#使无限LAN安全" class="headerlink" title="使无限LAN安全"></a>使无限LAN安全</h2><h3 id="有限等效保密"><a href="#有限等效保密" class="headerlink" title="有限等效保密"></a>有限等效保密</h3><p>有线等效保密（Wired Qeuivalent Privacy, WEP）协议为在主机和无线接入点之间提供鉴别和数据的加密。鉴别以下列方式进行：</p>
<ul>
<li>无线主机通过接入点请求鉴别。</li>
<li>接入点以一个128字节的不重数响应该鉴别请求。</li>
<li>无线主机用它与这个接入点共享的密钥加密这个不重数值。</li>
<li>加入点解密主机加密的不重数值。</li>
</ul>
<h3 id="IEEE-802-11i"><a href="#IEEE-802-11i" class="headerlink" title="IEEE 802.11i"></a>IEEE 802.11i</h3><p>802.11i是具有更强安全性机制的802.11的新型、改进版本。802.11i运行分为4个阶段：</p>
<ul>
<li>发现。在发现阶段，AP通告它的存在以及它能够向无线客户节点提供的鉴别和加密的形式。客户则请求它希望的特定鉴别和加密形式。</li>
<li>相互鉴别和主密钥（MK）生成。鉴别发生在无线客户和鉴别服务器之间。在这个阶段，接入点基本是其中继的作用，在客户和鉴别服务器之间转发报文。可扩展鉴别协议（Extensible Authentication Protocol, EAP）定义了客户和鉴别服务器之间交互时的请求/响应模式中使用的端到端报文格式。</li>
<li>成对主密钥（Pairwise Master Key, PMK）生成。MK是一个仅为客户和鉴别服务器所知的共享密钥，它们都使用MK来生成一个次密钥，即成对主密钥（PMK）。鉴别服务器则向AP发送该PMK。客户和AP现在具有一个共享的密钥，并彼此相互鉴别。</li>
<li>临时密钥（Tamporal Key, TK）生成。使用PMK，无线客户和AP现在能够生成附加的、将用于通信的密钥。其中的关键是临时密钥，TK将被用于执行经无线链路向任意远程主机发送数据的链路级的加密。</li>
</ul>
<h2 id="运行安全性-防火墙和入侵检测系统"><a href="#运行安全性-防火墙和入侵检测系统" class="headerlink" title="运行安全性:防火墙和入侵检测系统"></a>运行安全性:防火墙和入侵检测系统</h2><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>防火墙是一个硬件和软件的结合体，它将一个机构的内部网络与整个因特网隔离开，允许一些数据分组通过而组织另一些分组通过。防火墙具有3个目标：</p>
<ul>
<li>从外部到内部和从内部到外部的所有流量都通过防火墙。</li>
<li>仅被授权的流量允许通过。</li>
<li>防火墙自身免于渗透。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">防火墙能够分为3类：传统分组过滤器、状态过滤器和应用程序网关。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>传统分组过滤器独立地检查每个数据报，然后基于管理员特定的规则决定该数据报应当允许通过还是应当丢弃。过滤决定通常基于下列因素：</p>
<ul>
<li>IP源或目的地址。</li>
<li>在IP数据报中的协议类型字段：TCP、UDP、ICMP、OSPF等。</li>
<li>TCP或UCP的源和目的端口。</li>
<li>TCP标志比特：SYN、ACK等。</li>
<li>ICMP报文类型。</li>
<li>数据报离开和进入网络的不同规则。</li>
<li>对不同路由器接口的不同规则。</li>
</ul>
<h3 id="入侵检测系统"><a href="#入侵检测系统" class="headerlink" title="入侵检测系统"></a>入侵检测系统</h3><p>状态过滤器通过用一张连接表来跟踪所有进行中的TCP连接</p>
<p>应用程序网关是一个应用程序特定的服务器，所有应用程序数据都必须通过它。</p>
<p>当观察到潜在恶意流量时产生告警的设备称为<code>入侵检测系统（Intrusion Detection System, IDS）</code>。滤除可疑流量的设备称为<code>入侵防止系统（Intrusion Prevention System, IPS）</code>。IDS系统大致可分为基于特征的系统和基于异常的系统。基于特征的IDS维护了一个范围广泛的攻击特征数据库。每个特征与一个入侵活动相关联的规则集。一个特征可能只是有关单个分组的特性列表，或者可能与一系列分组有关。基于异常的IDS系统最大的特点是它们不依赖现有攻击的以前知识。</p>
<h2 id="九、多媒体网络应用"><a href="#九、多媒体网络应用" class="headerlink" title="九、多媒体网络应用"></a>九、多媒体网络应用</h2><h3 id="视频的性质"><a href="#视频的性质" class="headerlink" title="视频的性质"></a>视频的性质</h3><p>视频的显著特点是高比特率</p>
<h3 id="音频的性质"><a href="#音频的性质" class="headerlink" title="音频的性质"></a>音频的性质</h3><p><code>脉冲编码调制（Pulse Code Modulation, PCM）</code>将模拟音频转换为数字信号：</p>
<ul>
<li>模拟音频信号首先以某种固定速率采样。每个采样值是一个任意的实数。</li>
<li>然后每个采样值被“四舍五入”为有限个数值中的一个。这种操作被称为量化。这些有限个数值通常是2的幂。</li>
<li>每个量化值由固定数量的比特表示。通过音频扬声器播放，这个数字信号则能够转换回来（也就是解码），形成一个模拟信号。然而，解码后的模拟信号仅是初始信号的近似，并且声音质量也许有明显的下降。通过增加采样速率和量化值的数量，解码信号能够更好地接近初始的模拟信号。因此，在解码信号的质量和比特率与数字信号存储空间存在一种折中。</li>
</ul>
<p>一种接近CD质量立体声音乐的流行压缩技术是MPEG 1第3层，更通常的叫法是MP3。MP3编码器通常能够压缩为许多不同的速率；128kbps是最常用的编码速率，并且能够产生非常小的声音失真。一种相关的标准是高级音频编码（Advanced Audio Coding, AAC）。</p>
<h3 id="多媒体网络应用的类型"><a href="#多媒体网络应用的类型" class="headerlink" title="多媒体网络应用的类型"></a>多媒体网络应用的类型</h3><p>多媒体应用可以分为三大类: <strong>流式存储音频/视频；会话式IP语音/视频；流式实况音频/视频。</strong></p>
<h4 id="流式储存音频和视频"><a href="#流式储存音频和视频" class="headerlink" title="流式储存音频和视频"></a>流式储存音频和视频</h4><p>流式存储视频具有三个关键的不同特色：</p>
<ul>
<li>流。在流式存储视频应用中，客户开始从服务器接收文件几秒之后，通常就开始播放视频。这意味着当客户正在从视频的一个位置开始播放时，与此同时正在从服务器接收该视频的后续部分。这种技术被称为流，它避免了在开始播放之前必须下载整个视频。</li>
<li>相互作用。因为媒体是预先录制的，用户可以对多媒体内容进行暂停、重新配置前进、重新配置倒退、快进等操作。从一个客户提出这种请求到该动作在客户端表现出来，可接收的响应时间应该小于几秒。</li>
<li>连续播放。一旦视频开始播放，它应该根据初始记录的时序进行。因此，为了在客户端播放，必须从服务器中及时接收数据；否则，用户经历视频帧停滞或帧跳过。</li>
</ul>
<h4 id="会话式IP语音和视频"><a href="#会话式IP语音和视频" class="headerlink" title="会话式IP语音和视频"></a>会话式IP语音和视频</h4><p>在因特网上的实时会话式语音通常称为因特网电话。也常被称为IP语音（Voice-over-IP, VoIP）</p>
<h4 id="流式实况音频和视频"><a href="#流式实况音频和视频" class="headerlink" title="流式实况音频和视频"></a>流式实况音频和视频</h4><p>流式实况音频和视频类似于传统的电台广播和电视，只是它通过因特网来传输而已。</p>
<h2 id="流式存储视频"><a href="#流式存储视频" class="headerlink" title="流式存储视频"></a>流式存储视频</h2><p>流式视频系统可分为三种类型：UDP流、HTTP流和适应性HTTP流</p>
<p>当视频开始到达客户时，客户不必立即开始播放，反而能够在应用程序缓存中建立该视频的储备。一旦客户建立起几秒“已缓存但尚未播放”的视频储备，客户就可以开始视频播放了。这种客户缓存具有两种重要的优点。第一，客户缓存能够吸收服务器到客户时延中的波动。第二，如果服务器到客户带宽暂时低于视频消耗速率，用户能够继续享受连续的播放，只要客户应用缓存仍没有完全排尽</p>
<h3 id="UDP流"><a href="#UDP流" class="headerlink" title="UDP流"></a>UDP流</h3><p>使用UDP流，服务器通过UDP以一种稳定的速率记录下视频块，用于哭护的视频消耗速率向匹配的速率传输视频。在将视频块传递给UDP之前，服务器将视频块封装在运输分组中，该运输分组是专门为传输音频和视频而设计的，使用了实时传输协议（Real-Time Transport Protocal, RTP）或某种类似的方案。UDP流的另一种不同的性质是，除了服务器到客户的视频流外，两者间还并行地维护一个单独的控制连接，通过该连接，客户可发送有关会话状态变化的命令。</p>
<p>UDP流有三个重大不足。首先，由于服务器和控制之间的可用带宽无法预测并且是变化的，恒定速率UDP流不能够提供连续的播放。第二个缺点是它要求如RTSP服务器这样的媒体控制服务器，以对每个进行中的客户会话处理客户到服务器的交互请求和跟踪客户状态。这增加了部署大规模的按需视频系统的总体成本和复杂性。第三个缺点是许多防火前配置为阻塞UDP流量，防止这些防火墙后面的用户接收UDP视频</p>
<h3 id="HTTP流"><a href="#HTTP流" class="headerlink" title="HTTP流"></a>HTTP流</h3><p>在HTTP流中，视频直接作为具有一个特定URL的普通文件存储在HTTP服务器上。当用户要看视频时，客户和服务器之间建立一个TCP连接，并且发送一个对该URL的HTTP GET请求。服务器则尽可能快地在HTTP响应报文中发送该视频文件。在客户端上，字节收集在一个客户应用缓存中。一旦在缓存中字节数量超过了预先设定的阈值，该客户应用程序开始播放，具体而言，它周期性地从客户应用缓存中抓取视频帧，对帧解压缩并在用户屏幕上显示它们。</p>
<p>在TCP上使用HTTP也使得视频穿越防火墙和NAT更为容易。HTTP流消除了因需要媒体服务器带来的不便，减少了在因特网上大规模部署的成本。</p>
<p>对于流式存储视频，客户能够尝试以高于消耗速率的速率下载视频，因此预取将来会被消耗的视频帧。该预取的视频当然存储在客户应用缓存中。</p>
<p>当网络中可用速率小于视频速率时，播放将在连续播放期和停滞播放期之间进行变动。当网络中的可用速率大于视频速率时，在初始缓存时延后，用户将享受连续的播放直到视频结束。</p>
<h2 id="IP语音"><a href="#IP语音" class="headerlink" title="IP语音"></a>IP语音</h2><p>经因特网的实时会话式语音经常被称为因特网电话，通常称为IP语音（VoIP）</p>
<h3 id="尽力而为服务限制"><a href="#尽力而为服务限制" class="headerlink" title="尽力而为服务限制"></a>尽力而为服务限制</h3><p>因特网的网络层协议提供尽力而为的服务</p>
<h4 id="端到端延时"><a href="#端到端延时" class="headerlink" title="端到端延时"></a>端到端延时</h4><p>端到端时延得到一个关键成分是一个分组在网络路由器中经历的变化的排队时延。由于这些可变的时延，从在源中产生分组到它在接收方收到的这段时间，对于不同的分组可能会有波动。这个现象称为时延抖动。</p>
<h3 id="在接收方消除音频的时延抖动"><a href="#在接收方消除音频的时延抖动" class="headerlink" title="在接收方消除音频的时延抖动"></a>在接收方消除音频的时延抖动</h3><h4 id="分组时延抖动"><a href="#分组时延抖动" class="headerlink" title="分组时延抖动"></a>分组时延抖动</h4><p>对于VoIP应用，周期性地产生分组，接收方应该在存在随机网络时延抖动的情况下尝试提供播放语音块。这经常通过结合下面两种机制来实现：</p>
<ul>
<li>为每个块预先计划一个时间戳。发送方用每个块产生的时刻为它加上时间印记。</li>
<li>在接收方延迟播放块。接收的音频块的播放时延必须足够长，以便大多数分组在它们的预定播放时间之前被接收到。这个播放时延可能在整个音频会话期间是固定的，或者在音频会话生命期中适应性地变化。</li>
</ul>
<h5 id="固定播放时延"><a href="#固定播放时延" class="headerlink" title="固定播放时延"></a>固定播放时延</h5><p>使用固定播放时延策略，接收方试图在块产生正好q ms后播放它。因此如果一个块在时刻t打上时间戳，接收方在时刻t + q播放这个块，假设这个块在那个时间已经到达。在预定播放时间之后到达的分组将被丢弃，并被认为已经丢失。</p>
<h5 id="适应性播放时延"><a href="#适应性播放时延" class="headerlink" title="适应性播放时延"></a>适应性播放时延</h5><p>ti = 第i个分组的时间戳 = 该分组在发送方产生的时间</p>
<p> ri = 分组i被接收方接收的时间</p>
<p> pi = 分组i在接收方播放的时间</p>
<p>第i个分组的端到端网络时延是ri – ti。由于网络时延抖动，这个时延在不同的分组之间会发送变化。令di表设计接收到第i个分组时的平均网络时延的估计值。这个估计值根据如下的时间戳来构造：</p>
<p>式中u是一个固定的常数。这样di是观察到的网络时延r1 – t1, …, ri - ti的一个平滑均值。这个估计值为最近观察到的网络时延设置了比过去一段时间观察到的网络时延有更大的权重。令vi表示于估计平均时延的平均时延绝对偏差的估计值。这个估计值也可从这些时间戳构建：</p>
<p> 为每个接收的分组计算估计值di和vi，尽管它们仅能用于为任何话音突峰期的第一个分组确定播放点。</p>
<p> 一旦计算完了这些估计值，接收方为分组播放应用下列的算法。如果分组i是一个话音突峰期的第一个分组，它的播放时间pi计算如下：</p>
<p>这里K是一个正的常数。Kvi项的目的是给将来设置足够大的播放时间，以便话音突峰期中只有一小部分到达的分组由于迟到而丢失。在一个话音突峰期中任何后续分组的播放点被计算为对于这个话音突峰期的第一个分组播放时间点的偏移。</p>
<p>表示从话音突峰期的第一个分组产生到它播放的时间长度。如果分组j也属于这个话音突峰期，它播放的时刻是</p>
<h3 id="从丢包中恢复"><a href="#从丢包中恢复" class="headerlink" title="从丢包中恢复"></a>从丢包中恢复</h3><p>丢包恢复方案有前向纠错（Forward Error Correction, FEC）与交织。</p>
<h4 id="向前纠错"><a href="#向前纠错" class="headerlink" title="向前纠错"></a>向前纠错</h4><p>FEC的基本思想是给初始的分组流增加冗余信息。以稍微增加传输速率为代价，这些冗余信息可用用来重建一些丢失分组的近似或者准确版本。第一种机制是每发送n个块之后发送一个冗余编码的块。这个冗余块通过异或n个初始块来获得。以想和中方式，在这n + 1个分组的组中，如果任何一个分组丢失，接收方能够完全重建丢失的分组。但是如果这一组中有两个或更多分组丢失，接收方则无法重建丢失的分组。通过让组的长度n + 1比较小，当丢失不是很多时，大部分丢失分组都可以恢复。然而组的长度越小，相对增加的传输速率就越大。</p>
<p>第二个FEC机制是发送一个较低分辨率的音频流作为冗余信息。发送方可能创建一个标称的音频流和一个相应的低分辨率、低比特率的音频流。这个低比特率流被认为是冗余信息。发送方通过从流中取出第n个块并附加上第n – 1个块的冗余信息，以构建第n个分组。以这种方式，只要没有连续分组的丢失，接收方都可以通过播放和后续分组一起到达的低比特率编码来隐藏丢失。当然，低比特率块比标称块的质量要低。然而，在一个流主要是由高质量块组成、偶尔出现低质量块并且没有丢失块的情况下，其整体的音频质量良好。在这种方案中，接收方在播放前只需接收两个分组，因此增加的时延小。此外，如果低比特率编码比标称编码少得多，那么传输速率的额外增加并不大。</p>
<h4 id="交织"><a href="#交织" class="headerlink" title="交织"></a>交织</h4><p>作为冗余传输的另一种替代方案，VoIP应用可以发送交织的音频。发送方在传输之前对音频数据单元重新排序，使得最初相邻的单元在传输流中以一定距离分离开来。交织可以减轻丢包的影响。一个交织流的单个丢包导致重建流中的多个小间隙，这与在非交织流中将会导致单个大间隙形成对照。</p>
<p>交织能够明显地提高音频流可感觉到的质量。它的开销也较低。交织明显的缺点是增加了时延。这限制了它在如VoIP这样的会话式应用中的使用，然而它能够很好地处理流式存储音频。交织的一个主要优点是它不增加流的带宽要求。</p>
<h4 id="差错掩盖"><a href="#差错掩盖" class="headerlink" title="差错掩盖"></a>差错掩盖</h4><p>差错掩盖方案试图为丢失的分组产生一个与初始分组类似的替代物。因为音频信号（特别是语音）呈现出大量的短期自相似性，故该方案是可行的。这些技术适合于工作在相对小的丢包率和小分组的情况。基于接收方的恢复的最简单方式是分组重复。即用在丢失之前刚到达的分组的副本来代替丢失的分组。这种方法的计算复杂度低，并且工作得相当好。基于接收方恢复的另一种形式的内插法，它使用在丢失之前和之后的音频内插形成一个合适分组来隐藏丢失。内插法比分组重复稍微好一些，但是显然需要更高的计算强度。</p>
<h2 id="实时会话式应用的协议"><a href="#实时会话式应用的协议" class="headerlink" title="实时会话式应用的协议"></a>实时会话式应用的协议</h2><h3 id="RTP"><a href="#RTP" class="headerlink" title="RTP"></a>RTP</h3><p><code>实时传输协议（Real-Time Transport Protocol, RTP）</code>通常运行在UDP之上。发送端在RTP分组中封装媒体块，然后再UDP报文段中封装该分组，然后将该报文段递交给IP。接收端从UDP报文段中提取出这个RTP分组，然后从RTP分组中提取出媒体块，并将这个块传递给媒体播放器来解码和呈现。</p>
<h4 id="RTP基础"><a href="#RTP基础" class="headerlink" title="RTP基础"></a>RTP基础</h4><p>发送端在每个语音数据块的前面加上一个RTP首部，这个首部包括音频编码的类型、序号和时间戳。RTP首部通常是12字节。音频块和RTP首部一起形成RTP分组。然后向UDP套接字接口发送该RTP分组。在接收端，应用程序从它的套接字接口收到该RTP分组，从RTP分组中提取出该音频块，并且使用RTP分组的额首部字段来适当地解码和播放该音频块</p>
<h4 id="RTP分组首部字段"><a href="#RTP分组首部字段" class="headerlink" title="RTP分组首部字段"></a>RTP分组首部字段</h4><p>RTP分组中的有效载荷类型字段的长度是7比特。对于音频流，有效载荷类型字段用于指示所使用的音频编码类型。如果发送方在会话过程中决定改变编码，发送方可以通过该有效载荷类型字段来通知接收方这种变化。发送方可能要通过改变该编码来提高语音质量或者减小RTP流比特率。</p>
<p>当前RTP支持的一些音频有效载荷类型。</p>
<p>对于一个视频流，有效载荷类型用于指示视频编码类型。发送方也可以在会话期间动态改变视频编码。</p>
<h3 id="SIP"><a href="#SIP" class="headerlink" title="SIP"></a>SIP</h3><p>会话发起协议（Session Initiation Protocol, SIP）是一个开放和轻型的协议，其功能如下：</p>
<ul>
<li>提供了在主叫者和被叫者之间经IP网络创建呼叫的机制。它允许主叫者通知被叫者它要开始一个呼叫。它允许参与者约定媒体编码，也允许参与者结束呼叫。</li>
<li>提供了主叫者确定被叫者的当前IP地址的机制。因为用户可能动态地分配到地址，而且因为它们可能有多个IP设备，每个都有一个不同的IP地址，所以用户不具有单一的、固定的IP地址。</li>
<li>提供二零用于呼叫管理的机制，这些机制包括在呼叫期间增加新媒体流、在呼叫期间改变编码、在呼叫期间邀请新的参与者、呼叫转移和呼叫保持等。</li>
</ul>
<p>SIP的特性</p>
<ul>
<li>SIP是一个带外协议，即发送和接收SIP报文使用了一个不同于发送和接收媒体数据的套接字。</li>
<li>SIP报文本身是可读的ASCII，这于HTTP报文类似。</li>
<li>SIP要求所有的报文都要确认，因此它能够在UDP或者TCP上运行。</li>
</ul>
<p>SIP注册器把固定的人识别标志翻译为一个动态的IP地址。</p>
<h2 id="支持多媒体的网络"><a href="#支持多媒体的网络" class="headerlink" title="支持多媒体的网络"></a>支持多媒体的网络</h2><p><strong>三种网络层方法：</strong></p>
<ul>
<li>区分服务。使用区分服务，当两类流量在一台路由器中排队时，一种类型的流量可以给定严格的优于另一种类型的流量的优先权。</li>
<li>每连接服务质量（QoS）保证。使用每连接QoS保证，每个应用的实例显式地预约端到端带宽，并因此具有确保的端到端性能。硬保证意味着应用将必定接收到它所请求的服务质量。软保证意味着应用将以高概率接收到它所请求的服务质量。</li>
<li>尽可能利用尽力而为的服务</li>
</ul>
<h3 id="定制尽力而为网络"><a href="#定制尽力而为网络" class="headerlink" title="定制尽力而为网络"></a>定制尽力而为网络</h3><p>对需要提供多种类型流量机制的见解：</p>
<ul>
<li>标记分组使得路由器区分属于不同类型流量的分组。</li>
<li>希望在流量类型之间的提供流量隔离的度，以便一类流量不会收到另一类流量的负面影响。</li>
<li>当为流量类型或流之间提供隔离时，希望尽可能有效地使用资源。</li>
</ul>
<h3 id="提供多种类型的服务"><a href="#提供多种类型的服务" class="headerlink" title="提供多种类型的服务"></a>提供多种类型的服务</h3><p>3个重要的监管准则：</p>
<ul>
<li>平均速率。网络可能希望限制一个流的分组能够发送到网络中的长期平均速率。这里一个关键的问题是监管平均速率的时间间隔。一个平均速率被限制为美妙100个分组的流要比一个每分钟6000个分组的源收到的约束更严格，即使在一个足够长的时间间隔上它们有相同的平均速率。</li>
<li>峰值速率。平均速率约束限制了一个相对长的时间内能够发送到网络中的流量，而峰值约束限制了一个较短时间内能够发送的最大分组数。</li>
<li>突发长度。网络也许还希望限制极端的时间间隔内能够发送到网络中的最大分组数。</li>
</ul>
<p><strong>漏桶机制</strong> 是一个能够用来表征这些监管限制的抽象。漏桶由一个能够容纳b个令牌的桶组成。令牌加进桶的过程如下。可能潜在地加入桶中的新令牌总是以每秒r个令牌的速率产生。当产生一个令牌时，如果桶填充得少于b个令牌，新产生的令牌加入到该桶中；否则忽略该新产生的令牌，令牌桶保持具有b个令牌的满状态。假设在一个分组流向网络传输之前，必须首先从令牌桶中去除一个令牌。。如果令牌桶是空的，分组必须等待一个令牌。因为在桶中最多能由b个令牌，所以漏桶监管的流的最大突发长度是b个分组。此外，因为令牌产生的速率是r，所以在任何长度为t的时间间隔内能够进入网络中的最大分组数目为rt + b。因此，令牌产生速率r用于限制分组能够进入网络的长期平均速率。</p>
<p>在加权公平排队（WFQ）规则中，每个流i保证收到至少等于R ∙ wi / (∑wj)的共享链路带宽，其中R是以分组/秒为单位的链路传输速率。当将漏桶机制于WFQ结合时，假设流i的令牌桶最初是满的。然后b个分组的突发到达流i的漏桶监管器。这些分组取出了漏桶中的所有令牌，然后加入了流i的WFQ等待区域。因为这b个分组以至少R ∙ wi / (∑wj)分组/秒的速度得到服务，直到这些分组的最后一个传输完成，所以将由最大时延dmax</p>
<h3 id="区分服务"><a href="#区分服务" class="headerlink" title="区分服务"></a>区分服务</h3><p>因特网区分服务（Diffserv）体系结构提供服务区分，也就是在因特网中以一种可扩展性方式用不同的方法处理不同类型流量的能力。区分服务体系结构由两个功能元素的集合所组成：</p>
<ul>
<li>边界功能：分组分类和流量调节。在网络的入边缘，到达的分组被标记。更具体地说，在IPv4或者IPv6分组首部中的区分服务（DS）字段被设置为某个值。分组得到的标记标识了该分组所属的流量类型。然后不同类型的流量将在核心网络得到不同的服务。</li>
<li>核心功能：转发。当一个DS标记的分组到达一个Diffserv使能的服务器时，根据与分组类型相关的所谓的每跳行为（Per-Hop Behavior, PHB），该分组被转发到它的下一跳。每跳行为影响在竞争的流量类型之间共享路由器缓存和链路带宽的方式。Diffserv体系结构的一个关键原则是路由器的每跳行为只基于分组标记，即分组所属的流量类型。</li>
</ul>
<h3 id="资源预约和呼叫准入"><a href="#资源预约和呼叫准入" class="headerlink" title="资源预约和呼叫准入"></a>资源预约和呼叫准入</h3><p>已经定义了两种PHB：加速转发（Expedited Forwarding, EF）PHB规定了一类流量离开路由器的速率必须等于或者大于某个已配置的速率。确保转发（Assured Forwarding, AF）PHB将流量分为4类，其中每个AF类都确保提供某种最小数量的带宽和缓存。</p>
<p>让流申告它的QoS需求，然后让网络接收该流或者阻塞该流的过程称为呼叫准入过程。如果不总是能够提供充分的资源，并且要确保QoS，则需要一个呼叫准入过程，在这个过程中流申告其QoS需求，然后要么被网络准入，要么被网络阻塞。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">大茗茗のblog</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://12ule.top/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">https://12ule.top/2019/10/20/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">大茗茗のblog</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                                    <span class="chip bg-color">计算机网络</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/10/21/PE%E6%96%87%E4%BB%B6/">
                    <div class="card-image">
                        
                        
                        <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/medias/featureimages/5.jpg" class="responsive-img" alt="PE文件">
                        
                        <span class="card-title">PE文件</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-10-21
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/windows/" class="post-category">
                                    windows
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/PE%E6%96%87%E4%BB%B6/">
                        <span class="chip bg-color">PE文件</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/08/22/windows%E6%B6%88%E6%81%AF%E9%92%A9%E5%8F%96/">
                    <div class="card-image">
                        
                        
                        <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="/medias/featureimages/10.jpg" class="responsive-img" alt="windows消息钩取">
                        
                        <span class="card-title">windows消息钩取</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-08-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/windows/" class="post-category">
                                    windows
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/hook/">
                        <span class="chip bg-color">hook</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number(''),
            headingSelector: 'h2, h3, h4, h5'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="12676036352"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2024-2025</span>
            
            <a href="/about" target="_blank">大茗茗のblog</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
                <span id="translate">|&nbsp;繁/简：</span><a id="translateLink" href="javascript:translatePage();">繁</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">227k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:sp1ritus@outlook.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        <script type="text/javascript" src="/js/tw_cn.js"></script>
        <script type="text/javascript">
          var defaultEncoding = 2; //网站编写字体是否繁体，1-繁体，2-简体
          var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0
          var cookieDomain = "https://12ule.top"; //Cookie地址, 一定要设定, 通常为你的网址
          var msgToTraditionalChinese = "繁"; //此处可以更改为你想要显示的文字
          var msgToSimplifiedChinese = "简"; //同上，但两处均不建议更改
          var translateButtonId = "translateLink"; //默认互换id
          translateInitilization();
        </script>
    
    
    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    
    

    <!-- 弹出文字 -->
    
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write(
                    '<script type="text/javascript" src="/libs/others/popupText.js"><\/script>'
                );
            }
        </script>
    


    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    


    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

    <script type="text/javascript"> var OriginTitile = document.title, st; 
        document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) }) </script>        


        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,d=(r.imageLazyLoadSetting.preloadRatio,o());function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight+240||document.documentElement.clientHeight+240)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body>

</html>
